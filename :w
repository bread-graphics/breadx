// MIT/Apache2 License

use crate::{
    auto::{
        render::{
            Pictvisual, Pictformat, Pictforminfo, Pictscreen, QueryPictFormatsReply, QueryPictFormatsRequest,
            QueryVersionReply, QueryVersionRequest,
        },
        xproto::Visualtype,
    },
    display::{Connection, Display, DisplayLike},
    send_request, sr_request,
};

#[cfg(feature = "async")]
use crate::display::AsyncConnection;

/// A wrapper around the `Display` that contains XRender-specific data.
#[derive(Debug)]
pub struct RenderDisplay<Dpy> {
    inner: Dpy,
    formats: Vec<Pictforminfo>,
    screens: Vec<Pictscreen>,
    subpixels: Vec<u32>,
    major_version: u32,
    minor_version: u32,
}

impl<Dpy: DisplayLike> DisplayLike for RenderDisplay<Dpy> {
    type Connection = Dpy::Connection;

    #[inline]
    fn display(&self) -> &Display<Conn> {
        self.inner.display()
    }

    #[inline]
    fn display_mut(&mut self) -> &mut Display<Conn> {
        self.inner.display_mut()
    }
}

impl<Dpy> RenderDisplay<Dpy> {
    /// Get a reference to the inner object.
    #[inline]
    pub fn inner(&self) -> &Dpy {
        &self.inner
    }

    /// Get a mutable reference to the inner object.
    #[inline]
    pub fn inner_mut(&mut self) -> &mut Dpy {
        &mut self.inner
    }

    /// Destroy this objet and return the inner display.
    #[inline]
    pub fn into_inner(self) -> Dpy {
        self.inner
    }

    #[inline]
    fn fold_for_visformat<F: FnMut(&Pictvisual) -> bool>(&self, f: F) -> Option<&Pictformat> {
        self.screens
            .iter()
            .flat_map(|s| s.depths.iter())
            .flat_map(|d| d.visuals.iter())
            .find_map(|v| {
                if f(v) {
                    Some(&v.format)
                } else {
                    None
                }
            })
    }

    /// Get a `Pictformat` object that matches the given `Visualtype`.
    #[inline]
    pub fn find_visual_format(&self, visual: &Visualtype) -> Option<&Pictformat> {
self.fold_for_visformat(|v| v.visual == visual.visual_id)
    }
}

impl<Dpy: DisplayLike> RenderDisplay<Dpy>
where
    Dpy::Connection: Connection,
{
    /// Initialize a RenderDisplay with the appropriate information.
    #[inline]
    pub fn new(
        mut dpy: Dpy,
        client_major_version: u32,
        client_minor_version: u32,
    ) -> crate::Result<Self> {
        // run QueryVersion and QueryPictFormats simultaneously
        let qvtok = send_request!(
            dpy,
            QueryVersionRequest {
                client_major_version,
                client_minor_version,
                ..Default::default()
            }
        )?;
        let qpftok = send_request!(dpy, QueryPictFormatsRequest::default())?;

        let QueryVersionReply {
            major_version,
            minor_version,
            ..
        } = dpy.resolve_request(qvtok)?;
        let QueryPictFormatsReply {
            formats,
            screens,
            subpixels,
            ..
        } = dpy.resolve_request(qpftok)?;

        Ok(Self {
            inner: dpy,
            major_version,
            minor_version,
            formats,
            screens,
            subpixels,
        })
    }
}

#[cfg(feature = "async")]
impl<Dpy: DisplayLike> RenderDisplay<Dpy>
where
    Dpy::Connection: AsyncConnection + Send,
{
    /// Initialize a RenderDisplay with the appropriate information, async redox.
    #[inline]
    pub async fn new_async(
        mut dpy: Dpy,
        client_major_version: u32,
        client_minor_version: u32,
    ) -> crate::Result<Self> {
        let qvtok = send_request!(
            dpy,
            QueryVersionRequest {
                client_major_version,
                client_minor_version,
                ..Default::default()
            },
            async
        )
        .await?;
        let qpftok = send_request!(dpy, QueryPictFormatsRequest::default(), async).await?;

        let QueryVersionReply {
            major_version,
            minor_version,
            ..
        } = dpy.resolve_request_async(qvtok).await?;
        let QueryPictFormatsReply {
            formats,
            screens,
            subpixels,
            ..
        } = dpy.resolve_request_async(qpftok).await?;

        Ok(Self {
            inner: dpy,
            major_version,
            minor_version,
            formats,
            screens,
            subpixels,
        })
    }
}
