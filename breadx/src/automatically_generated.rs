
// This file is automatically generated by the `breadx-generator` crate.
// Do not edit this file directly.

//! Contains automatically generated items.

#![rustfmt::skip]

use crate::{Result, display::{Cookie, Display, DisplayExt}};
use alloc::borrow::Cow;
#[allow(unused_imports)]
use alloc::vec::Vec;
use core::borrow::Borrow;
use __private::Sealed;

cfg_async! {
    use crate::{display::{AsyncDisplay, AsyncDisplayExt}, futures};
    use __private::Sealed2;
}

pub trait DisplayFunctionsExt : Display + Sealed {
    fn bigreq_enable(&mut self, ) -> Result<Cookie<types::bigreq::EnableReply>> {
        let span = tracing::info_span!(
            "bigreq_enable",
        );
        let _enter = span.enter();
        let request = types::bigreq::EnableRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn bigreq_enable_immediate(&mut self, ) -> Result<types::bigreq::EnableReply> {
        let request = types::bigreq::EnableRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "composite")]
    fn composite_query_version(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::composite::QueryVersionReply>> {
        let span = tracing::info_span!(
            "composite_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::composite::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_query_version_immediate(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<types::composite::QueryVersionReply> {
        let request = types::composite::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_window(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_redirect_window",
            window = ?window,
            update = ?update,
        );
        let _enter = span.enter();
        let request = types::composite::RedirectWindowRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_window_checked(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<()> {
        let request = types::composite::RedirectWindowRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_subwindows(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_redirect_subwindows",
            window = ?window,
            update = ?update,
        );
        let _enter = span.enter();
        let request = types::composite::RedirectSubwindowsRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_subwindows_checked(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<()> {
        let request = types::composite::RedirectSubwindowsRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_window(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_unredirect_window",
            window = ?window,
            update = ?update,
        );
        let _enter = span.enter();
        let request = types::composite::UnredirectWindowRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_window_checked(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<()> {
        let request = types::composite::UnredirectWindowRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_subwindows(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_unredirect_subwindows",
            window = ?window,
            update = ?update,
        );
        let _enter = span.enter();
        let request = types::composite::UnredirectSubwindowsRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_subwindows_checked(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<()> {
        let request = types::composite::UnredirectSubwindowsRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_create_region_from_border_clip(&mut self, region: types::Region, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_create_region_from_border_clip",
            region = ?region,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::composite::CreateRegionFromBorderClipRequest {
            region,
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_create_region_from_border_clip_checked(&mut self, region: types::Region, window: types::xproto::Window) -> Result<()> {
        let request = types::composite::CreateRegionFromBorderClipRequest {
            region,
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_name_window_pixmap(&mut self, window: types::xproto::Window, pixmap: types::xproto::Pixmap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_name_window_pixmap",
            window = ?window,
            pixmap = ?pixmap,
        );
        let _enter = span.enter();
        let request = types::composite::NameWindowPixmapRequest {
            window,
            pixmap,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_name_window_pixmap_checked(&mut self, window: types::xproto::Window, pixmap: types::xproto::Pixmap) -> Result<()> {
        let request = types::composite::NameWindowPixmapRequest {
            window,
            pixmap,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_get_overlay_window(&mut self, window: types::xproto::Window) -> Result<Cookie<types::composite::GetOverlayWindowReply>> {
        let span = tracing::info_span!(
            "composite_get_overlay_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::composite::GetOverlayWindowRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_get_overlay_window_immediate(&mut self, window: types::xproto::Window) -> Result<types::composite::GetOverlayWindowReply> {
        let request = types::composite::GetOverlayWindowRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_release_overlay_window(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_release_overlay_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::composite::ReleaseOverlayWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_release_overlay_window_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let request = types::composite::ReleaseOverlayWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "damage")]
    fn damage_query_version(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::damage::QueryVersionReply>> {
        let span = tracing::info_span!(
            "damage_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::damage::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "damage")]
    fn damage_query_version_immediate(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<types::damage::QueryVersionReply> {
        let request = types::damage::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "damage")]
    fn damage_create(&mut self, damage: types::Damage, drawable: types::xproto::Drawable, level: types::ReportLevel) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "damage_create",
            damage = ?damage,
            drawable = ?drawable,
            level = ?level,
        );
        let _enter = span.enter();
        let request = types::damage::CreateRequest {
            damage,
            drawable,
            level,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "damage")]
    fn damage_create_checked(&mut self, damage: types::Damage, drawable: types::xproto::Drawable, level: types::ReportLevel) -> Result<()> {
        let request = types::damage::CreateRequest {
            damage,
            drawable,
            level,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "damage")]
    fn damage_destroy(&mut self, damage: types::Damage) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "damage_destroy",
            damage = ?damage,
        );
        let _enter = span.enter();
        let request = types::damage::DestroyRequest {
            damage,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "damage")]
    fn damage_destroy_checked(&mut self, damage: types::Damage) -> Result<()> {
        let request = types::damage::DestroyRequest {
            damage,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "damage")]
    fn damage_subtract(&mut self, damage: types::Damage, repair: impl Into<types::Region>, parts: impl Into<types::Region>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "damage_subtract",
            damage = ?damage,
        );
        let _enter = span.enter();
        let request = types::damage::SubtractRequest {
            damage,
            repair: Into::<u32>::into(repair.into()) as _,
            parts: Into::<u32>::into(parts.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "damage")]
    fn damage_subtract_checked(&mut self, damage: types::Damage, repair: impl Into<types::Region>, parts: impl Into<types::Region>) -> Result<()> {
        let request = types::damage::SubtractRequest {
            damage,
            repair: Into::<u32>::into(repair.into()) as _,
            parts: Into::<u32>::into(parts.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "damage")]
    fn damage_add(&mut self, drawable: types::xproto::Drawable, region: types::Region) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "damage_add",
            drawable = ?drawable,
            region = ?region,
        );
        let _enter = span.enter();
        let request = types::damage::AddRequest {
            drawable,
            region,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "damage")]
    fn damage_add_checked(&mut self, drawable: types::xproto::Drawable, region: types::Region) -> Result<()> {
        let request = types::damage::AddRequest {
            drawable,
            region,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "dpms")]
    fn dpms_get_version(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::dpms::GetVersionReply>> {
        let span = tracing::info_span!(
            "dpms_get_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::dpms::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_version_immediate(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<types::dpms::GetVersionReply> {
        let request = types::dpms::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_capable(&mut self, ) -> Result<Cookie<types::dpms::CapableReply>> {
        let span = tracing::info_span!(
            "dpms_capable",
        );
        let _enter = span.enter();
        let request = types::dpms::CapableRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_capable_immediate(&mut self, ) -> Result<types::dpms::CapableReply> {
        let request = types::dpms::CapableRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_timeouts(&mut self, ) -> Result<Cookie<types::dpms::GetTimeoutsReply>> {
        let span = tracing::info_span!(
            "dpms_get_timeouts",
        );
        let _enter = span.enter();
        let request = types::dpms::GetTimeoutsRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_timeouts_immediate(&mut self, ) -> Result<types::dpms::GetTimeoutsReply> {
        let request = types::dpms::GetTimeoutsRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_set_timeouts(&mut self, standby_timeout: types::Card16, suspend_timeout: types::Card16, off_timeout: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dpms_set_timeouts",
            standby_timeout = ?standby_timeout,
            suspend_timeout = ?suspend_timeout,
            off_timeout = ?off_timeout,
        );
        let _enter = span.enter();
        let request = types::dpms::SetTimeoutsRequest {
            standby_timeout,
            suspend_timeout,
            off_timeout,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_set_timeouts_checked(&mut self, standby_timeout: types::Card16, suspend_timeout: types::Card16, off_timeout: types::Card16) -> Result<()> {
        let request = types::dpms::SetTimeoutsRequest {
            standby_timeout,
            suspend_timeout,
            off_timeout,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_enable(&mut self, ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dpms_enable",
        );
        let _enter = span.enter();
        let request = types::dpms::EnableRequest {
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_enable_checked(&mut self, ) -> Result<()> {
        let request = types::dpms::EnableRequest {
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_disable(&mut self, ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dpms_disable",
        );
        let _enter = span.enter();
        let request = types::dpms::DisableRequest {
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_disable_checked(&mut self, ) -> Result<()> {
        let request = types::dpms::DisableRequest {
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_force_level(&mut self, power_level: types::DPMSMode) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dpms_force_level",
            power_level = ?power_level,
        );
        let _enter = span.enter();
        let request = types::dpms::ForceLevelRequest {
            power_level,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_force_level_checked(&mut self, power_level: types::DPMSMode) -> Result<()> {
        let request = types::dpms::ForceLevelRequest {
            power_level,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_info(&mut self, ) -> Result<Cookie<types::dpms::InfoReply>> {
        let span = tracing::info_span!(
            "dpms_info",
        );
        let _enter = span.enter();
        let request = types::dpms::InfoRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_info_immediate(&mut self, ) -> Result<types::dpms::InfoReply> {
        let request = types::dpms::InfoRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "dri2")]
    fn dri2_query_version(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::dri2::QueryVersionReply>> {
        let span = tracing::info_span!(
            "dri2_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::dri2::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_query_version_immediate(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<types::dri2::QueryVersionReply> {
        let request = types::dri2::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_connect(&mut self, window: types::xproto::Window, driver_type: types::DriverType) -> Result<Cookie<types::dri2::ConnectReply>> {
        let span = tracing::info_span!(
            "dri2_connect",
            window = ?window,
            driver_type = ?driver_type,
        );
        let _enter = span.enter();
        let request = types::dri2::ConnectRequest {
            window,
            driver_type,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_connect_immediate(&mut self, window: types::xproto::Window, driver_type: types::DriverType) -> Result<types::dri2::ConnectReply> {
        let request = types::dri2::ConnectRequest {
            window,
            driver_type,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_authenticate(&mut self, window: types::xproto::Window, magic: types::Card32) -> Result<Cookie<types::dri2::AuthenticateReply>> {
        let span = tracing::info_span!(
            "dri2_authenticate",
            window = ?window,
            magic = ?magic,
        );
        let _enter = span.enter();
        let request = types::dri2::AuthenticateRequest {
            window,
            magic,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_authenticate_immediate(&mut self, window: types::xproto::Window, magic: types::Card32) -> Result<types::dri2::AuthenticateReply> {
        let request = types::dri2::AuthenticateRequest {
            window,
            magic,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_create_drawable(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri2_create_drawable",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::dri2::CreateDrawableRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_create_drawable_checked(&mut self, drawable: types::xproto::Drawable) -> Result<()> {
        let request = types::dri2::CreateDrawableRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_destroy_drawable(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri2_destroy_drawable",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::dri2::DestroyDrawableRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_destroy_drawable_checked(&mut self, drawable: types::xproto::Drawable) -> Result<()> {
        let request = types::dri2::DestroyDrawableRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_copy_region(&mut self, drawable: types::xproto::Drawable, region: types::Card32, dest: types::Card32, src: types::Card32) -> Result<Cookie<types::dri2::CopyRegionReply>> {
        let span = tracing::info_span!(
            "dri2_copy_region",
            drawable = ?drawable,
            region = ?region,
            dest = ?dest,
            src = ?src,
        );
        let _enter = span.enter();
        let request = types::dri2::CopyRegionRequest {
            drawable,
            region,
            dest,
            src,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_copy_region_immediate(&mut self, drawable: types::xproto::Drawable, region: types::Card32, dest: types::Card32, src: types::Card32) -> Result<types::dri2::CopyRegionReply> {
        let request = types::dri2::CopyRegionRequest {
            drawable,
            region,
            dest,
            src,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_buffers(&mut self, drawable: types::xproto::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> Result<Cookie<types::dri2::SwapBuffersReply>> {
        let span = tracing::info_span!(
            "dri2_swap_buffers",
            drawable = ?drawable,
            target_msc_hi = ?target_msc_hi,
            target_msc_lo = ?target_msc_lo,
            divisor_hi = ?divisor_hi,
            divisor_lo = ?divisor_lo,
            remainder_hi = ?remainder_hi,
            remainder_lo = ?remainder_lo,
        );
        let _enter = span.enter();
        let request = types::dri2::SwapBuffersRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_buffers_immediate(&mut self, drawable: types::xproto::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> Result<types::dri2::SwapBuffersReply> {
        let request = types::dri2::SwapBuffersRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_msc(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<types::dri2::GetMSCReply>> {
        let span = tracing::info_span!(
            "dri2_get_msc",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::dri2::GetMSCRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_msc_immediate(&mut self, drawable: types::xproto::Drawable) -> Result<types::dri2::GetMSCReply> {
        let request = types::dri2::GetMSCRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_msc(&mut self, drawable: types::xproto::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> Result<Cookie<types::dri2::WaitMSCReply>> {
        let span = tracing::info_span!(
            "dri2_wait_msc",
            drawable = ?drawable,
            target_msc_hi = ?target_msc_hi,
            target_msc_lo = ?target_msc_lo,
            divisor_hi = ?divisor_hi,
            divisor_lo = ?divisor_lo,
            remainder_hi = ?remainder_hi,
            remainder_lo = ?remainder_lo,
        );
        let _enter = span.enter();
        let request = types::dri2::WaitMSCRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_msc_immediate(&mut self, drawable: types::xproto::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> Result<types::dri2::WaitMSCReply> {
        let request = types::dri2::WaitMSCRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_sbc(&mut self, drawable: types::xproto::Drawable, target_sbc_hi: types::Card32, target_sbc_lo: types::Card32) -> Result<Cookie<types::dri2::WaitSBCReply>> {
        let span = tracing::info_span!(
            "dri2_wait_sbc",
            drawable = ?drawable,
            target_sbc_hi = ?target_sbc_hi,
            target_sbc_lo = ?target_sbc_lo,
        );
        let _enter = span.enter();
        let request = types::dri2::WaitSBCRequest {
            drawable,
            target_sbc_hi,
            target_sbc_lo,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_sbc_immediate(&mut self, drawable: types::xproto::Drawable, target_sbc_hi: types::Card32, target_sbc_lo: types::Card32) -> Result<types::dri2::WaitSBCReply> {
        let request = types::dri2::WaitSBCRequest {
            drawable,
            target_sbc_hi,
            target_sbc_lo,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_interval(&mut self, drawable: types::xproto::Drawable, interval: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri2_swap_interval",
            drawable = ?drawable,
            interval = ?interval,
        );
        let _enter = span.enter();
        let request = types::dri2::SwapIntervalRequest {
            drawable,
            interval,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_interval_checked(&mut self, drawable: types::xproto::Drawable, interval: types::Card32) -> Result<()> {
        let request = types::dri2::SwapIntervalRequest {
            drawable,
            interval,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_param(&mut self, drawable: types::xproto::Drawable, param: types::Card32) -> Result<Cookie<types::dri2::GetParamReply>> {
        let span = tracing::info_span!(
            "dri2_get_param",
            drawable = ?drawable,
            param = ?param,
        );
        let _enter = span.enter();
        let request = types::dri2::GetParamRequest {
            drawable,
            param,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_param_immediate(&mut self, drawable: types::xproto::Drawable, param: types::Card32) -> Result<types::dri2::GetParamReply> {
        let request = types::dri2::GetParamRequest {
            drawable,
            param,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "dri3")]
    fn dri3_query_version(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::dri3::QueryVersionReply>> {
        let span = tracing::info_span!(
            "dri3_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::dri3::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_query_version_immediate(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<types::dri3::QueryVersionReply> {
        let request = types::dri3::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_open(&mut self, drawable: types::xproto::Drawable, provider: types::Card32) -> Result<Cookie<types::dri3::OpenReply>> {
        let span = tracing::info_span!(
            "dri3_open",
            drawable = ?drawable,
            provider = ?provider,
        );
        let _enter = span.enter();
        let request = types::dri3::OpenRequest {
            drawable,
            provider,
        };
        let cookie = self.send_reply_fd_request(request);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_open_immediate(&mut self, drawable: types::xproto::Drawable, provider: types::Card32) -> Result<types::dri3::OpenReply> {
        let request = types::dri3::OpenRequest {
            drawable,
            provider,
        };
        let cookie = self.send_reply_fd_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffer(&mut self, pixmap: types::xproto::Pixmap, drawable: types::xproto::Drawable, size: types::Card32, width: types::Card16, height: types::Card16, stride: types::Card16, depth: types::Card8, bpp: types::Card8, pixmap_fd: types::Fd) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri3_pixmap_from_buffer",
            pixmap = ?pixmap,
            drawable = ?drawable,
            size = ?size,
            width = ?width,
            height = ?height,
            stride = ?stride,
            depth = ?depth,
            bpp = ?bpp,
            pixmap_fd = ?pixmap_fd,
        );
        let _enter = span.enter();
        let request = types::dri3::PixmapFromBufferRequest {
            pixmap,
            drawable,
            size,
            width,
            height,
            stride,
            depth,
            bpp,
            pixmap_fd,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffer_checked(&mut self, pixmap: types::xproto::Pixmap, drawable: types::xproto::Drawable, size: types::Card32, width: types::Card16, height: types::Card16, stride: types::Card16, depth: types::Card8, bpp: types::Card8, pixmap_fd: types::Fd) -> Result<()> {
        let request = types::dri3::PixmapFromBufferRequest {
            pixmap,
            drawable,
            size,
            width,
            height,
            stride,
            depth,
            bpp,
            pixmap_fd,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffer_from_pixmap(&mut self, pixmap: types::xproto::Pixmap) -> Result<Cookie<types::dri3::BufferFromPixmapReply>> {
        let span = tracing::info_span!(
            "dri3_buffer_from_pixmap",
            pixmap = ?pixmap,
        );
        let _enter = span.enter();
        let request = types::dri3::BufferFromPixmapRequest {
            pixmap,
        };
        let cookie = self.send_reply_fd_request(request);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffer_from_pixmap_immediate(&mut self, pixmap: types::xproto::Pixmap) -> Result<types::dri3::BufferFromPixmapReply> {
        let request = types::dri3::BufferFromPixmapRequest {
            pixmap,
        };
        let cookie = self.send_reply_fd_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fence_from_fd(&mut self, drawable: types::xproto::Drawable, fence: types::Card32, initially_triggered: types::Bool, fence_fd: types::Fd) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri3_fence_from_fd",
            drawable = ?drawable,
            fence = ?fence,
            initially_triggered = ?initially_triggered,
            fence_fd = ?fence_fd,
        );
        let _enter = span.enter();
        let request = types::dri3::FenceFromFDRequest {
            drawable,
            fence,
            initially_triggered,
            fence_fd,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_fence_from_fd_checked(&mut self, drawable: types::xproto::Drawable, fence: types::Card32, initially_triggered: types::Bool, fence_fd: types::Fd) -> Result<()> {
        let request = types::dri3::FenceFromFDRequest {
            drawable,
            fence,
            initially_triggered,
            fence_fd,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fd_from_fence(&mut self, drawable: types::xproto::Drawable, fence: types::Card32) -> Result<Cookie<types::dri3::FDFromFenceReply>> {
        let span = tracing::info_span!(
            "dri3_fd_from_fence",
            drawable = ?drawable,
            fence = ?fence,
        );
        let _enter = span.enter();
        let request = types::dri3::FDFromFenceRequest {
            drawable,
            fence,
        };
        let cookie = self.send_reply_fd_request(request);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_fd_from_fence_immediate(&mut self, drawable: types::xproto::Drawable, fence: types::Card32) -> Result<types::dri3::FDFromFenceReply> {
        let request = types::dri3::FDFromFenceRequest {
            drawable,
            fence,
        };
        let cookie = self.send_reply_fd_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_get_supported_modifiers(&mut self, window: types::Card32, depth: types::Card8, bpp: types::Card8) -> Result<Cookie<types::dri3::GetSupportedModifiersReply>> {
        let span = tracing::info_span!(
            "dri3_get_supported_modifiers",
            window = ?window,
            depth = ?depth,
            bpp = ?bpp,
        );
        let _enter = span.enter();
        let request = types::dri3::GetSupportedModifiersRequest {
            window,
            depth,
            bpp,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_get_supported_modifiers_immediate(&mut self, window: types::Card32, depth: types::Card8, bpp: types::Card8) -> Result<types::dri3::GetSupportedModifiersReply> {
        let request = types::dri3::GetSupportedModifiersRequest {
            window,
            depth,
            bpp,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffers(&mut self, pixmap: types::xproto::Pixmap, window: types::xproto::Window, width: types::Card16, height: types::Card16, stride0: types::Card32, offset0: types::Card32, stride1: types::Card32, offset1: types::Card32, stride2: types::Card32, offset2: types::Card32, stride3: types::Card32, offset3: types::Card32, depth: types::Card8, bpp: types::Card8, modifier: types::Card64, buffers: Vec<types::Fd>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri3_pixmap_from_buffers",
            pixmap = ?pixmap,
            window = ?window,
            width = ?width,
            height = ?height,
            stride0 = ?stride0,
            offset0 = ?offset0,
            stride1 = ?stride1,
            offset1 = ?offset1,
            stride2 = ?stride2,
            offset2 = ?offset2,
            stride3 = ?stride3,
            offset3 = ?offset3,
            depth = ?depth,
            bpp = ?bpp,
            modifier = ?modifier,
        );
        let _enter = span.enter();
        let request = types::dri3::PixmapFromBuffersRequest {
            pixmap,
            window,
            width,
            height,
            stride0,
            offset0,
            stride1,
            offset1,
            stride2,
            offset2,
            stride3,
            offset3,
            depth,
            bpp,
            modifier,
            buffers,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffers_checked(&mut self, pixmap: types::xproto::Pixmap, window: types::xproto::Window, width: types::Card16, height: types::Card16, stride0: types::Card32, offset0: types::Card32, stride1: types::Card32, offset1: types::Card32, stride2: types::Card32, offset2: types::Card32, stride3: types::Card32, offset3: types::Card32, depth: types::Card8, bpp: types::Card8, modifier: types::Card64, buffers: Vec<types::Fd>) -> Result<()> {
        let request = types::dri3::PixmapFromBuffersRequest {
            pixmap,
            window,
            width,
            height,
            stride0,
            offset0,
            stride1,
            offset1,
            stride2,
            offset2,
            stride3,
            offset3,
            depth,
            bpp,
            modifier,
            buffers,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffers_from_pixmap(&mut self, pixmap: types::xproto::Pixmap) -> Result<Cookie<types::dri3::BuffersFromPixmapReply>> {
        let span = tracing::info_span!(
            "dri3_buffers_from_pixmap",
            pixmap = ?pixmap,
        );
        let _enter = span.enter();
        let request = types::dri3::BuffersFromPixmapRequest {
            pixmap,
        };
        let cookie = self.send_reply_fd_request(request);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffers_from_pixmap_immediate(&mut self, pixmap: types::xproto::Pixmap) -> Result<types::dri3::BuffersFromPixmapReply> {
        let request = types::dri3::BuffersFromPixmapRequest {
            pixmap,
        };
        let cookie = self.send_reply_fd_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    fn ge_query_version(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::ge::QueryVersionReply>> {
        let span = tracing::info_span!(
            "ge_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::ge::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn ge_query_version_immediate(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<types::ge::QueryVersionReply> {
        let request = types::ge::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "glx")]
    fn glx_render(&mut self, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_render",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::RenderRequest {
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_render_checked(&mut self, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<()> {
        let request = types::glx::RenderRequest {
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_render_large(&mut self, context_tag: types::ContextTag, request_num: types::Card16, request_total: types::Card16, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_render_large",
            context_tag = ?context_tag,
            request_num = ?request_num,
            request_total = ?request_total,
        );
        let _enter = span.enter();
        let request = types::glx::RenderLargeRequest {
            context_tag,
            request_num,
            request_total,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_render_large_checked(&mut self, context_tag: types::ContextTag, request_num: types::Card16, request_total: types::Card16, data: impl AsRef<[types::Byte]>) -> Result<()> {
        let request = types::glx::RenderLargeRequest {
            context_tag,
            request_num,
            request_total,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context(&mut self, context: types::glx::Context, visual: types::Visualid, screen: types::Card32, share_list: types::glx::Context, is_direct: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_context",
            context = ?context,
            visual = ?visual,
            screen = ?screen,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let _enter = span.enter();
        let request = types::glx::CreateContextRequest {
            context,
            visual,
            screen,
            share_list,
            is_direct,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_checked(&mut self, context: types::glx::Context, visual: types::Visualid, screen: types::Card32, share_list: types::glx::Context, is_direct: types::Bool) -> Result<()> {
        let request = types::glx::CreateContextRequest {
            context,
            visual,
            screen,
            share_list,
            is_direct,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_context(&mut self, context: types::glx::Context) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_destroy_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::glx::DestroyContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_context_checked(&mut self, context: types::glx::Context) -> Result<()> {
        let request = types::glx::DestroyContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_make_current(&mut self, drawable: types::glx::Drawable, context: types::glx::Context, old_context_tag: types::ContextTag) -> Result<Cookie<types::glx::MakeCurrentReply>> {
        let span = tracing::info_span!(
            "glx_make_current",
            drawable = ?drawable,
            context = ?context,
            old_context_tag = ?old_context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::MakeCurrentRequest {
            drawable,
            context,
            old_context_tag,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_make_current_immediate(&mut self, drawable: types::glx::Drawable, context: types::glx::Context, old_context_tag: types::ContextTag) -> Result<types::glx::MakeCurrentReply> {
        let request = types::glx::MakeCurrentRequest {
            drawable,
            context,
            old_context_tag,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_is_direct(&mut self, context: types::glx::Context) -> Result<Cookie<types::glx::IsDirectReply>> {
        let span = tracing::info_span!(
            "glx_is_direct",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::glx::IsDirectRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_is_direct_immediate(&mut self, context: types::glx::Context) -> Result<types::glx::IsDirectReply> {
        let request = types::glx::IsDirectRequest {
            context,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_query_version(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::glx::QueryVersionReply>> {
        let span = tracing::info_span!(
            "glx_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::glx::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_query_version_immediate(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<types::glx::QueryVersionReply> {
        let request = types::glx::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_gl(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_wait_gl",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::WaitGLRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_wait_gl_checked(&mut self, context_tag: types::ContextTag) -> Result<()> {
        let request = types::glx::WaitGLRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_x(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_wait_x",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::WaitXRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_wait_x_checked(&mut self, context_tag: types::ContextTag) -> Result<()> {
        let request = types::glx::WaitXRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_copy_context(&mut self, src: types::glx::Context, dest: types::glx::Context, mask: types::Card32, src_context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_copy_context",
            src = ?src,
            dest = ?dest,
            mask = ?mask,
            src_context_tag = ?src_context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::CopyContextRequest {
            src,
            dest,
            mask,
            src_context_tag,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_copy_context_checked(&mut self, src: types::glx::Context, dest: types::glx::Context, mask: types::Card32, src_context_tag: types::ContextTag) -> Result<()> {
        let request = types::glx::CopyContextRequest {
            src,
            dest,
            mask,
            src_context_tag,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_swap_buffers(&mut self, context_tag: types::ContextTag, drawable: types::glx::Drawable) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_swap_buffers",
            context_tag = ?context_tag,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::glx::SwapBuffersRequest {
            context_tag,
            drawable,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_swap_buffers_checked(&mut self, context_tag: types::ContextTag, drawable: types::glx::Drawable) -> Result<()> {
        let request = types::glx::SwapBuffersRequest {
            context_tag,
            drawable,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_use_x_font(&mut self, context_tag: types::ContextTag, font: types::Font, first: types::Card32, count: types::Card32, list_base: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_use_x_font",
            context_tag = ?context_tag,
            font = ?font,
            first = ?first,
            count = ?count,
            list_base = ?list_base,
        );
        let _enter = span.enter();
        let request = types::glx::UseXFontRequest {
            context_tag,
            font,
            first,
            count,
            list_base,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_use_x_font_checked(&mut self, context_tag: types::ContextTag, font: types::Font, first: types::Card32, count: types::Card32, list_base: types::Card32) -> Result<()> {
        let request = types::glx::UseXFontRequest {
            context_tag,
            font,
            first,
            count,
            list_base,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_glx_pixmap(&mut self, screen: types::Card32, visual: types::Visualid, pixmap: types::xproto::Pixmap, glx_pixmap: types::glx::Pixmap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_glx_pixmap",
            screen = ?screen,
            visual = ?visual,
            pixmap = ?pixmap,
            glx_pixmap = ?glx_pixmap,
        );
        let _enter = span.enter();
        let request = types::glx::CreateGLXPixmapRequest {
            screen,
            visual,
            pixmap,
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_glx_pixmap_checked(&mut self, screen: types::Card32, visual: types::Visualid, pixmap: types::xproto::Pixmap, glx_pixmap: types::glx::Pixmap) -> Result<()> {
        let request = types::glx::CreateGLXPixmapRequest {
            screen,
            visual,
            pixmap,
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_visual_configs(&mut self, screen: types::Card32) -> Result<Cookie<types::glx::GetVisualConfigsReply>> {
        let span = tracing::info_span!(
            "glx_get_visual_configs",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::glx::GetVisualConfigsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_visual_configs_immediate(&mut self, screen: types::Card32) -> Result<types::glx::GetVisualConfigsReply> {
        let request = types::glx::GetVisualConfigsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_glx_pixmap(&mut self, glx_pixmap: types::glx::Pixmap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_destroy_glx_pixmap",
            glx_pixmap = ?glx_pixmap,
        );
        let _enter = span.enter();
        let request = types::glx::DestroyGLXPixmapRequest {
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_glx_pixmap_checked(&mut self, glx_pixmap: types::glx::Pixmap) -> Result<()> {
        let request = types::glx::DestroyGLXPixmapRequest {
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private(&mut self, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_vendor_private",
            vendor_code = ?vendor_code,
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::VendorPrivateRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_checked(&mut self, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<()> {
        let request = types::glx::VendorPrivateRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_with_reply(&mut self, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<Cookie<types::glx::VendorPrivateWithReplyReply>> {
        let span = tracing::info_span!(
            "glx_vendor_private_with_reply",
            vendor_code = ?vendor_code,
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::VendorPrivateWithReplyRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_with_reply_immediate(&mut self, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<types::glx::VendorPrivateWithReplyReply> {
        let request = types::glx::VendorPrivateWithReplyRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_query_extensions_string(&mut self, screen: types::Card32) -> Result<Cookie<types::glx::QueryExtensionsStringReply>> {
        let span = tracing::info_span!(
            "glx_query_extensions_string",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::glx::QueryExtensionsStringRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_query_extensions_string_immediate(&mut self, screen: types::Card32) -> Result<types::glx::QueryExtensionsStringReply> {
        let request = types::glx::QueryExtensionsStringRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_query_server_string(&mut self, screen: types::Card32, name: types::Card32) -> Result<Cookie<types::glx::QueryServerStringReply>> {
        let span = tracing::info_span!(
            "glx_query_server_string",
            screen = ?screen,
            name = ?name,
        );
        let _enter = span.enter();
        let request = types::glx::QueryServerStringRequest {
            screen,
            name,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_query_server_string_immediate(&mut self, screen: types::Card32, name: types::Card32) -> Result<types::glx::QueryServerStringReply> {
        let request = types::glx::QueryServerStringRequest {
            screen,
            name,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_client_info(&mut self, major_version: types::Card32, minor_version: types::Card32, string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_client_info",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::glx::ClientInfoRequest {
            major_version,
            minor_version,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_client_info_checked(&mut self, major_version: types::Card32, minor_version: types::Card32, string: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::glx::ClientInfoRequest {
            major_version,
            minor_version,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_fb_configs(&mut self, screen: types::Card32) -> Result<Cookie<types::glx::GetFBConfigsReply>> {
        let span = tracing::info_span!(
            "glx_get_fb_configs",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::glx::GetFBConfigsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_fb_configs_immediate(&mut self, screen: types::Card32) -> Result<types::glx::GetFBConfigsReply> {
        let request = types::glx::GetFBConfigsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pixmap(&mut self, screen: types::Card32, fbconfig: types::Fbconfig, pixmap: types::xproto::Pixmap, glx_pixmap: types::glx::Pixmap, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_pixmap",
            screen = ?screen,
            fbconfig = ?fbconfig,
            pixmap = ?pixmap,
            glx_pixmap = ?glx_pixmap,
        );
        let _enter = span.enter();
        let request = types::glx::CreatePixmapRequest {
            screen,
            fbconfig,
            pixmap,
            glx_pixmap,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_pixmap_checked(&mut self, screen: types::Card32, fbconfig: types::Fbconfig, pixmap: types::xproto::Pixmap, glx_pixmap: types::glx::Pixmap, attribs: impl AsRef<[types::Card32]>) -> Result<()> {
        let request = types::glx::CreatePixmapRequest {
            screen,
            fbconfig,
            pixmap,
            glx_pixmap,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pixmap(&mut self, glx_pixmap: types::glx::Pixmap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_destroy_pixmap",
            glx_pixmap = ?glx_pixmap,
        );
        let _enter = span.enter();
        let request = types::glx::DestroyPixmapRequest {
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pixmap_checked(&mut self, glx_pixmap: types::glx::Pixmap) -> Result<()> {
        let request = types::glx::DestroyPixmapRequest {
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_new_context(&mut self, context: types::glx::Context, fbconfig: types::Fbconfig, screen: types::Card32, render_type: types::Card32, share_list: types::glx::Context, is_direct: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_new_context",
            context = ?context,
            fbconfig = ?fbconfig,
            screen = ?screen,
            render_type = ?render_type,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let _enter = span.enter();
        let request = types::glx::CreateNewContextRequest {
            context,
            fbconfig,
            screen,
            render_type,
            share_list,
            is_direct,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_new_context_checked(&mut self, context: types::glx::Context, fbconfig: types::Fbconfig, screen: types::Card32, render_type: types::Card32, share_list: types::glx::Context, is_direct: types::Bool) -> Result<()> {
        let request = types::glx::CreateNewContextRequest {
            context,
            fbconfig,
            screen,
            render_type,
            share_list,
            is_direct,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_query_context(&mut self, context: types::glx::Context) -> Result<Cookie<types::glx::QueryContextReply>> {
        let span = tracing::info_span!(
            "glx_query_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::glx::QueryContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_query_context_immediate(&mut self, context: types::glx::Context) -> Result<types::glx::QueryContextReply> {
        let request = types::glx::QueryContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_make_context_current(&mut self, old_context_tag: types::ContextTag, drawable: types::glx::Drawable, read_drawable: types::glx::Drawable, context: types::glx::Context) -> Result<Cookie<types::glx::MakeContextCurrentReply>> {
        let span = tracing::info_span!(
            "glx_make_context_current",
            old_context_tag = ?old_context_tag,
            drawable = ?drawable,
            read_drawable = ?read_drawable,
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::glx::MakeContextCurrentRequest {
            old_context_tag,
            drawable,
            read_drawable,
            context,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_make_context_current_immediate(&mut self, old_context_tag: types::ContextTag, drawable: types::glx::Drawable, read_drawable: types::glx::Drawable, context: types::glx::Context) -> Result<types::glx::MakeContextCurrentReply> {
        let request = types::glx::MakeContextCurrentRequest {
            old_context_tag,
            drawable,
            read_drawable,
            context,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pbuffer(&mut self, screen: types::Card32, fbconfig: types::Fbconfig, pbuffer: types::Pbuffer, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_pbuffer",
            screen = ?screen,
            fbconfig = ?fbconfig,
            pbuffer = ?pbuffer,
        );
        let _enter = span.enter();
        let request = types::glx::CreatePbufferRequest {
            screen,
            fbconfig,
            pbuffer,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_pbuffer_checked(&mut self, screen: types::Card32, fbconfig: types::Fbconfig, pbuffer: types::Pbuffer, attribs: impl AsRef<[types::Card32]>) -> Result<()> {
        let request = types::glx::CreatePbufferRequest {
            screen,
            fbconfig,
            pbuffer,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pbuffer(&mut self, pbuffer: types::Pbuffer) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_destroy_pbuffer",
            pbuffer = ?pbuffer,
        );
        let _enter = span.enter();
        let request = types::glx::DestroyPbufferRequest {
            pbuffer,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pbuffer_checked(&mut self, pbuffer: types::Pbuffer) -> Result<()> {
        let request = types::glx::DestroyPbufferRequest {
            pbuffer,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_drawable_attributes(&mut self, drawable: types::glx::Drawable) -> Result<Cookie<types::glx::GetDrawableAttributesReply>> {
        let span = tracing::info_span!(
            "glx_get_drawable_attributes",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::glx::GetDrawableAttributesRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_drawable_attributes_immediate(&mut self, drawable: types::glx::Drawable) -> Result<types::glx::GetDrawableAttributesReply> {
        let request = types::glx::GetDrawableAttributesRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_change_drawable_attributes(&mut self, drawable: types::glx::Drawable, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_change_drawable_attributes",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::glx::ChangeDrawableAttributesRequest {
            drawable,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_change_drawable_attributes_checked(&mut self, drawable: types::glx::Drawable, attribs: impl AsRef<[types::Card32]>) -> Result<()> {
        let request = types::glx::ChangeDrawableAttributesRequest {
            drawable,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_window(&mut self, screen: types::Card32, fbconfig: types::Fbconfig, window: types::xproto::Window, glx_window: types::glx::Window, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_window",
            screen = ?screen,
            fbconfig = ?fbconfig,
            window = ?window,
            glx_window = ?glx_window,
        );
        let _enter = span.enter();
        let request = types::glx::CreateWindowRequest {
            screen,
            fbconfig,
            window,
            glx_window,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_window_checked(&mut self, screen: types::Card32, fbconfig: types::Fbconfig, window: types::xproto::Window, glx_window: types::glx::Window, attribs: impl AsRef<[types::Card32]>) -> Result<()> {
        let request = types::glx::CreateWindowRequest {
            screen,
            fbconfig,
            window,
            glx_window,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_window(&mut self, glxwindow: types::glx::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_delete_window",
            glxwindow = ?glxwindow,
        );
        let _enter = span.enter();
        let request = types::glx::DeleteWindowRequest {
            glxwindow,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_delete_window_checked(&mut self, glxwindow: types::glx::Window) -> Result<()> {
        let request = types::glx::DeleteWindowRequest {
            glxwindow,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info_arb(&mut self, major_version: types::Card32, minor_version: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_set_client_info_arb",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::glx::SetClientInfoARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info_arb_checked(&mut self, major_version: types::Card32, minor_version: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::glx::SetClientInfoARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_attribs_arb(&mut self, context: types::glx::Context, fbconfig: types::Fbconfig, screen: types::Card32, share_list: types::glx::Context, is_direct: types::Bool, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_context_attribs_arb",
            context = ?context,
            fbconfig = ?fbconfig,
            screen = ?screen,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let _enter = span.enter();
        let request = types::glx::CreateContextAttribsARBRequest {
            context,
            fbconfig,
            screen,
            share_list,
            is_direct,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_attribs_arb_checked(&mut self, context: types::glx::Context, fbconfig: types::Fbconfig, screen: types::Card32, share_list: types::glx::Context, is_direct: types::Bool, attribs: impl AsRef<[types::Card32]>) -> Result<()> {
        let request = types::glx::CreateContextAttribsARBRequest {
            context,
            fbconfig,
            screen,
            share_list,
            is_direct,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info2_arb(&mut self, major_version: types::Card32, minor_version: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_set_client_info2_arb",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::glx::SetClientInfo2ARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info2_arb_checked(&mut self, major_version: types::Card32, minor_version: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::glx::SetClientInfo2ARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_new_list(&mut self, context_tag: types::ContextTag, list: types::Card32, mode: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_new_list",
            context_tag = ?context_tag,
            list = ?list,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::glx::NewListRequest {
            context_tag,
            list,
            mode,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_new_list_checked(&mut self, context_tag: types::ContextTag, list: types::Card32, mode: types::Card32) -> Result<()> {
        let request = types::glx::NewListRequest {
            context_tag,
            list,
            mode,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_end_list(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_end_list",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::EndListRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_end_list_checked(&mut self, context_tag: types::ContextTag) -> Result<()> {
        let request = types::glx::EndListRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_lists(&mut self, context_tag: types::ContextTag, list: types::Card32, range: types::Int32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_delete_lists",
            context_tag = ?context_tag,
            list = ?list,
            range = ?range,
        );
        let _enter = span.enter();
        let request = types::glx::DeleteListsRequest {
            context_tag,
            list,
            range,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_delete_lists_checked(&mut self, context_tag: types::ContextTag, list: types::Card32, range: types::Int32) -> Result<()> {
        let request = types::glx::DeleteListsRequest {
            context_tag,
            list,
            range,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_lists(&mut self, context_tag: types::ContextTag, range: types::Int32) -> Result<Cookie<types::glx::GenListsReply>> {
        let span = tracing::info_span!(
            "glx_gen_lists",
            context_tag = ?context_tag,
            range = ?range,
        );
        let _enter = span.enter();
        let request = types::glx::GenListsRequest {
            context_tag,
            range,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_gen_lists_immediate(&mut self, context_tag: types::ContextTag, range: types::Int32) -> Result<types::glx::GenListsReply> {
        let request = types::glx::GenListsRequest {
            context_tag,
            range,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_feedback_buffer(&mut self, context_tag: types::ContextTag, size: types::Int32, type_: types::Int32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_feedback_buffer",
            context_tag = ?context_tag,
            size = ?size,
            type_ = ?type_,
        );
        let _enter = span.enter();
        let request = types::glx::FeedbackBufferRequest {
            context_tag,
            size,
            type_,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_feedback_buffer_checked(&mut self, context_tag: types::ContextTag, size: types::Int32, type_: types::Int32) -> Result<()> {
        let request = types::glx::FeedbackBufferRequest {
            context_tag,
            size,
            type_,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_select_buffer(&mut self, context_tag: types::ContextTag, size: types::Int32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_select_buffer",
            context_tag = ?context_tag,
            size = ?size,
        );
        let _enter = span.enter();
        let request = types::glx::SelectBufferRequest {
            context_tag,
            size,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_select_buffer_checked(&mut self, context_tag: types::ContextTag, size: types::Int32) -> Result<()> {
        let request = types::glx::SelectBufferRequest {
            context_tag,
            size,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_render_mode(&mut self, context_tag: types::ContextTag, mode: types::Card32) -> Result<Cookie<types::glx::RenderModeReply>> {
        let span = tracing::info_span!(
            "glx_render_mode",
            context_tag = ?context_tag,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::glx::RenderModeRequest {
            context_tag,
            mode,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_render_mode_immediate(&mut self, context_tag: types::ContextTag, mode: types::Card32) -> Result<types::glx::RenderModeReply> {
        let request = types::glx::RenderModeRequest {
            context_tag,
            mode,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_finish(&mut self, context_tag: types::ContextTag) -> Result<Cookie<types::glx::FinishReply>> {
        let span = tracing::info_span!(
            "glx_finish",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::FinishRequest {
            context_tag,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_finish_immediate(&mut self, context_tag: types::ContextTag) -> Result<types::glx::FinishReply> {
        let request = types::glx::FinishRequest {
            context_tag,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storef(&mut self, context_tag: types::ContextTag, pname: types::Card32, datum: types::Float32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_pixel_storef",
            context_tag = ?context_tag,
            pname = ?pname,
            datum = ?datum,
        );
        let _enter = span.enter();
        let request = types::glx::PixelStorefRequest {
            context_tag,
            pname,
            datum,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storef_checked(&mut self, context_tag: types::ContextTag, pname: types::Card32, datum: types::Float32) -> Result<()> {
        let request = types::glx::PixelStorefRequest {
            context_tag,
            pname,
            datum,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storei(&mut self, context_tag: types::ContextTag, pname: types::Card32, datum: types::Int32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_pixel_storei",
            context_tag = ?context_tag,
            pname = ?pname,
            datum = ?datum,
        );
        let _enter = span.enter();
        let request = types::glx::PixelStoreiRequest {
            context_tag,
            pname,
            datum,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storei_checked(&mut self, context_tag: types::ContextTag, pname: types::Card32, datum: types::Int32) -> Result<()> {
        let request = types::glx::PixelStoreiRequest {
            context_tag,
            pname,
            datum,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_read_pixels(&mut self, context_tag: types::ContextTag, x: types::Int32, y: types::Int32, width: types::Int32, height: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, lsb_first: types::Bool) -> Result<Cookie<types::glx::ReadPixelsReply>> {
        let span = tracing::info_span!(
            "glx_read_pixels",
            context_tag = ?context_tag,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            lsb_first = ?lsb_first,
        );
        let _enter = span.enter();
        let request = types::glx::ReadPixelsRequest {
            context_tag,
            x,
            y,
            width,
            height,
            format,
            type_,
            swap_bytes,
            lsb_first,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_read_pixels_immediate(&mut self, context_tag: types::ContextTag, x: types::Int32, y: types::Int32, width: types::Int32, height: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, lsb_first: types::Bool) -> Result<types::glx::ReadPixelsReply> {
        let request = types::glx::ReadPixelsRequest {
            context_tag,
            x,
            y,
            width,
            height,
            format,
            type_,
            swap_bytes,
            lsb_first,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_booleanv(&mut self, context_tag: types::ContextTag, pname: types::Int32) -> Result<Cookie<types::glx::GetBooleanvReply>> {
        let span = tracing::info_span!(
            "glx_get_booleanv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetBooleanvRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_booleanv_immediate(&mut self, context_tag: types::ContextTag, pname: types::Int32) -> Result<types::glx::GetBooleanvReply> {
        let request = types::glx::GetBooleanvRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_clip_plane(&mut self, context_tag: types::ContextTag, plane: types::Int32) -> Result<Cookie<types::glx::GetClipPlaneReply>> {
        let span = tracing::info_span!(
            "glx_get_clip_plane",
            context_tag = ?context_tag,
            plane = ?plane,
        );
        let _enter = span.enter();
        let request = types::glx::GetClipPlaneRequest {
            context_tag,
            plane,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_clip_plane_immediate(&mut self, context_tag: types::ContextTag, plane: types::Int32) -> Result<types::glx::GetClipPlaneReply> {
        let request = types::glx::GetClipPlaneRequest {
            context_tag,
            plane,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_doublev(&mut self, context_tag: types::ContextTag, pname: types::Card32) -> Result<Cookie<types::glx::GetDoublevReply>> {
        let span = tracing::info_span!(
            "glx_get_doublev",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetDoublevRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_doublev_immediate(&mut self, context_tag: types::ContextTag, pname: types::Card32) -> Result<types::glx::GetDoublevReply> {
        let request = types::glx::GetDoublevRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_error(&mut self, context_tag: types::ContextTag) -> Result<Cookie<types::glx::GetErrorReply>> {
        let span = tracing::info_span!(
            "glx_get_error",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::GetErrorRequest {
            context_tag,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_error_immediate(&mut self, context_tag: types::ContextTag) -> Result<types::glx::GetErrorReply> {
        let request = types::glx::GetErrorRequest {
            context_tag,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_floatv(&mut self, context_tag: types::ContextTag, pname: types::Card32) -> Result<Cookie<types::glx::GetFloatvReply>> {
        let span = tracing::info_span!(
            "glx_get_floatv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetFloatvRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_floatv_immediate(&mut self, context_tag: types::ContextTag, pname: types::Card32) -> Result<types::glx::GetFloatvReply> {
        let request = types::glx::GetFloatvRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_integerv(&mut self, context_tag: types::ContextTag, pname: types::Card32) -> Result<Cookie<types::glx::GetIntegervReply>> {
        let span = tracing::info_span!(
            "glx_get_integerv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetIntegervRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_integerv_immediate(&mut self, context_tag: types::ContextTag, pname: types::Card32) -> Result<types::glx::GetIntegervReply> {
        let request = types::glx::GetIntegervRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightfv(&mut self, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetLightfvReply>> {
        let span = tracing::info_span!(
            "glx_get_lightfv",
            context_tag = ?context_tag,
            light = ?light,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetLightfvRequest {
            context_tag,
            light,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightfv_immediate(&mut self, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> Result<types::glx::GetLightfvReply> {
        let request = types::glx::GetLightfvRequest {
            context_tag,
            light,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightiv(&mut self, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetLightivReply>> {
        let span = tracing::info_span!(
            "glx_get_lightiv",
            context_tag = ?context_tag,
            light = ?light,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetLightivRequest {
            context_tag,
            light,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightiv_immediate(&mut self, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> Result<types::glx::GetLightivReply> {
        let request = types::glx::GetLightivRequest {
            context_tag,
            light,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapdv(&mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<Cookie<types::glx::GetMapdvReply>> {
        let span = tracing::info_span!(
            "glx_get_mapdv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let _enter = span.enter();
        let request = types::glx::GetMapdvRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapdv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<types::glx::GetMapdvReply> {
        let request = types::glx::GetMapdvRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapfv(&mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<Cookie<types::glx::GetMapfvReply>> {
        let span = tracing::info_span!(
            "glx_get_mapfv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let _enter = span.enter();
        let request = types::glx::GetMapfvRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapfv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<types::glx::GetMapfvReply> {
        let request = types::glx::GetMapfvRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapiv(&mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<Cookie<types::glx::GetMapivReply>> {
        let span = tracing::info_span!(
            "glx_get_mapiv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let _enter = span.enter();
        let request = types::glx::GetMapivRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapiv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<types::glx::GetMapivReply> {
        let request = types::glx::GetMapivRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialfv(&mut self, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetMaterialfvReply>> {
        let span = tracing::info_span!(
            "glx_get_materialfv",
            context_tag = ?context_tag,
            face = ?face,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetMaterialfvRequest {
            context_tag,
            face,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialfv_immediate(&mut self, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> Result<types::glx::GetMaterialfvReply> {
        let request = types::glx::GetMaterialfvRequest {
            context_tag,
            face,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialiv(&mut self, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetMaterialivReply>> {
        let span = tracing::info_span!(
            "glx_get_materialiv",
            context_tag = ?context_tag,
            face = ?face,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetMaterialivRequest {
            context_tag,
            face,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialiv_immediate(&mut self, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> Result<types::glx::GetMaterialivReply> {
        let request = types::glx::GetMaterialivRequest {
            context_tag,
            face,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapfv(&mut self, context_tag: types::ContextTag, map: types::Card32) -> Result<Cookie<types::glx::GetPixelMapfvReply>> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapfv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let _enter = span.enter();
        let request = types::glx::GetPixelMapfvRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapfv_immediate(&mut self, context_tag: types::ContextTag, map: types::Card32) -> Result<types::glx::GetPixelMapfvReply> {
        let request = types::glx::GetPixelMapfvRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapuiv(&mut self, context_tag: types::ContextTag, map: types::Card32) -> Result<Cookie<types::glx::GetPixelMapuivReply>> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapuiv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let _enter = span.enter();
        let request = types::glx::GetPixelMapuivRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapuiv_immediate(&mut self, context_tag: types::ContextTag, map: types::Card32) -> Result<types::glx::GetPixelMapuivReply> {
        let request = types::glx::GetPixelMapuivRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapusv(&mut self, context_tag: types::ContextTag, map: types::Card32) -> Result<Cookie<types::glx::GetPixelMapusvReply>> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapusv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let _enter = span.enter();
        let request = types::glx::GetPixelMapusvRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapusv_immediate(&mut self, context_tag: types::ContextTag, map: types::Card32) -> Result<types::glx::GetPixelMapusvReply> {
        let request = types::glx::GetPixelMapusvRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_polygon_stipple(&mut self, context_tag: types::ContextTag, lsb_first: types::Bool) -> Result<Cookie<types::glx::GetPolygonStippleReply>> {
        let span = tracing::info_span!(
            "glx_get_polygon_stipple",
            context_tag = ?context_tag,
            lsb_first = ?lsb_first,
        );
        let _enter = span.enter();
        let request = types::glx::GetPolygonStippleRequest {
            context_tag,
            lsb_first,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_polygon_stipple_immediate(&mut self, context_tag: types::ContextTag, lsb_first: types::Bool) -> Result<types::glx::GetPolygonStippleReply> {
        let request = types::glx::GetPolygonStippleRequest {
            context_tag,
            lsb_first,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_string(&mut self, context_tag: types::ContextTag, name: types::Card32) -> Result<Cookie<types::glx::GetStringReply>> {
        let span = tracing::info_span!(
            "glx_get_string",
            context_tag = ?context_tag,
            name = ?name,
        );
        let _enter = span.enter();
        let request = types::glx::GetStringRequest {
            context_tag,
            name,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_string_immediate(&mut self, context_tag: types::ContextTag, name: types::Card32) -> Result<types::glx::GetStringReply> {
        let request = types::glx::GetStringRequest {
            context_tag,
            name,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_envfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexEnvfvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_envfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexEnvfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_envfv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetTexEnvfvReply> {
        let request = types::glx::GetTexEnvfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_enviv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexEnvivReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_enviv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexEnvivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_enviv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetTexEnvivReply> {
        let request = types::glx::GetTexEnvivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_gendv(&mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexGendvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_gendv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexGendvRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_gendv_immediate(&mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<types::glx::GetTexGendvReply> {
        let request = types::glx::GetTexGendvRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_genfv(&mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexGenfvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_genfv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexGenfvRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_genfv_immediate(&mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<types::glx::GetTexGenfvReply> {
        let request = types::glx::GetTexGenfvRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_geniv(&mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexGenivReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_geniv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexGenivRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_geniv_immediate(&mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<types::glx::GetTexGenivReply> {
        let request = types::glx::GetTexGenivRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_image(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::glx::GetTexImageReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_image",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexImageRequest {
            context_tag,
            target,
            level,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_image_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<types::glx::GetTexImageReply> {
        let request = types::glx::GetTexImageRequest {
            context_tag,
            target,
            level,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameterfv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetTexParameterfvReply> {
        let request = types::glx::GetTexParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameteriv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetTexParameterivReply> {
        let request = types::glx::GetTexParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexLevelParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_level_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexLevelParameterfvRequest {
            context_tag,
            target,
            level,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameterfv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> Result<types::glx::GetTexLevelParameterfvReply> {
        let request = types::glx::GetTexLevelParameterfvRequest {
            context_tag,
            target,
            level,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexLevelParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_level_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexLevelParameterivRequest {
            context_tag,
            target,
            level,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameteriv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> Result<types::glx::GetTexLevelParameterivReply> {
        let request = types::glx::GetTexLevelParameterivRequest {
            context_tag,
            target,
            level,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_is_enabled(&mut self, context_tag: types::ContextTag, capability: types::Card32) -> Result<Cookie<types::glx::IsEnabledReply>> {
        let span = tracing::info_span!(
            "glx_is_enabled",
            context_tag = ?context_tag,
            capability = ?capability,
        );
        let _enter = span.enter();
        let request = types::glx::IsEnabledRequest {
            context_tag,
            capability,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_is_enabled_immediate(&mut self, context_tag: types::ContextTag, capability: types::Card32) -> Result<types::glx::IsEnabledReply> {
        let request = types::glx::IsEnabledRequest {
            context_tag,
            capability,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_is_list(&mut self, context_tag: types::ContextTag, list: types::Card32) -> Result<Cookie<types::glx::IsListReply>> {
        let span = tracing::info_span!(
            "glx_is_list",
            context_tag = ?context_tag,
            list = ?list,
        );
        let _enter = span.enter();
        let request = types::glx::IsListRequest {
            context_tag,
            list,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_is_list_immediate(&mut self, context_tag: types::ContextTag, list: types::Card32) -> Result<types::glx::IsListReply> {
        let request = types::glx::IsListRequest {
            context_tag,
            list,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_flush(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_flush",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::FlushRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_flush_checked(&mut self, context_tag: types::ContextTag) -> Result<()> {
        let request = types::glx::FlushRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_are_textures_resident(&mut self, context_tag: types::ContextTag, textures: impl AsRef<[types::Card32]>) -> Result<Cookie<types::glx::AreTexturesResidentReply>> {
        let span = tracing::info_span!(
            "glx_are_textures_resident",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::AreTexturesResidentRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_are_textures_resident_immediate(&mut self, context_tag: types::ContextTag, textures: impl AsRef<[types::Card32]>) -> Result<types::glx::AreTexturesResidentReply> {
        let request = types::glx::AreTexturesResidentRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_textures(&mut self, context_tag: types::ContextTag, textures: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_delete_textures",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::DeleteTexturesRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_delete_textures_checked(&mut self, context_tag: types::ContextTag, textures: impl AsRef<[types::Card32]>) -> Result<()> {
        let request = types::glx::DeleteTexturesRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_textures(&mut self, context_tag: types::ContextTag, n: types::Int32) -> Result<Cookie<types::glx::GenTexturesReply>> {
        let span = tracing::info_span!(
            "glx_gen_textures",
            context_tag = ?context_tag,
            n = ?n,
        );
        let _enter = span.enter();
        let request = types::glx::GenTexturesRequest {
            context_tag,
            n,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_gen_textures_immediate(&mut self, context_tag: types::ContextTag, n: types::Int32) -> Result<types::glx::GenTexturesReply> {
        let request = types::glx::GenTexturesRequest {
            context_tag,
            n,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_is_texture(&mut self, context_tag: types::ContextTag, texture: types::Card32) -> Result<Cookie<types::glx::IsTextureReply>> {
        let span = tracing::info_span!(
            "glx_is_texture",
            context_tag = ?context_tag,
            texture = ?texture,
        );
        let _enter = span.enter();
        let request = types::glx::IsTextureRequest {
            context_tag,
            texture,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_is_texture_immediate(&mut self, context_tag: types::ContextTag, texture: types::Card32) -> Result<types::glx::IsTextureReply> {
        let request = types::glx::IsTextureRequest {
            context_tag,
            texture,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::glx::GetColorTableReply>> {
        let span = tracing::info_span!(
            "glx_get_color_table",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let _enter = span.enter();
        let request = types::glx::GetColorTableRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<types::glx::GetColorTableReply> {
        let request = types::glx::GetColorTableRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetColorTableParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_color_table_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetColorTableParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameterfv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetColorTableParameterfvReply> {
        let request = types::glx::GetColorTableParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetColorTableParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_color_table_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetColorTableParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameteriv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetColorTableParameterivReply> {
        let request = types::glx::GetColorTableParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_filter(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::glx::GetConvolutionFilterReply>> {
        let span = tracing::info_span!(
            "glx_get_convolution_filter",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let _enter = span.enter();
        let request = types::glx::GetConvolutionFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_filter_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<types::glx::GetConvolutionFilterReply> {
        let request = types::glx::GetConvolutionFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetConvolutionParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_convolution_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetConvolutionParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameterfv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetConvolutionParameterfvReply> {
        let request = types::glx::GetConvolutionParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetConvolutionParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_convolution_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetConvolutionParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameteriv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetConvolutionParameterivReply> {
        let request = types::glx::GetConvolutionParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_separable_filter(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::glx::GetSeparableFilterReply>> {
        let span = tracing::info_span!(
            "glx_get_separable_filter",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let _enter = span.enter();
        let request = types::glx::GetSeparableFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_separable_filter_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<types::glx::GetSeparableFilterReply> {
        let request = types::glx::GetSeparableFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> Result<Cookie<types::glx::GetHistogramReply>> {
        let span = tracing::info_span!(
            "glx_get_histogram",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            reset = ?reset,
        );
        let _enter = span.enter();
        let request = types::glx::GetHistogramRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> Result<types::glx::GetHistogramReply> {
        let request = types::glx::GetHistogramRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetHistogramParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_histogram_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetHistogramParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameterfv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetHistogramParameterfvReply> {
        let request = types::glx::GetHistogramParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetHistogramParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_histogram_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetHistogramParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameteriv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetHistogramParameterivReply> {
        let request = types::glx::GetHistogramParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> Result<Cookie<types::glx::GetMinmaxReply>> {
        let span = tracing::info_span!(
            "glx_get_minmax",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            reset = ?reset,
        );
        let _enter = span.enter();
        let request = types::glx::GetMinmaxRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> Result<types::glx::GetMinmaxReply> {
        let request = types::glx::GetMinmaxRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetMinmaxParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_minmax_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetMinmaxParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameterfv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetMinmaxParameterfvReply> {
        let request = types::glx::GetMinmaxParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetMinmaxParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_minmax_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetMinmaxParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameteriv_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetMinmaxParameterivReply> {
        let request = types::glx::GetMinmaxParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_compressed_tex_image_arb(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32) -> Result<Cookie<types::glx::GetCompressedTexImageARBReply>> {
        let span = tracing::info_span!(
            "glx_get_compressed_tex_image_arb",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
        );
        let _enter = span.enter();
        let request = types::glx::GetCompressedTexImageARBRequest {
            context_tag,
            target,
            level,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_compressed_tex_image_arb_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32) -> Result<types::glx::GetCompressedTexImageARBReply> {
        let request = types::glx::GetCompressedTexImageARBRequest {
            context_tag,
            target,
            level,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_queries_arb(&mut self, context_tag: types::ContextTag, ids: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_delete_queries_arb",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::DeleteQueriesARBRequest {
            context_tag,
            ids: Cow::Borrowed(ids.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_delete_queries_arb_checked(&mut self, context_tag: types::ContextTag, ids: impl AsRef<[types::Card32]>) -> Result<()> {
        let request = types::glx::DeleteQueriesARBRequest {
            context_tag,
            ids: Cow::Borrowed(ids.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_queries_arb(&mut self, context_tag: types::ContextTag, n: types::Int32) -> Result<Cookie<types::glx::GenQueriesARBReply>> {
        let span = tracing::info_span!(
            "glx_gen_queries_arb",
            context_tag = ?context_tag,
            n = ?n,
        );
        let _enter = span.enter();
        let request = types::glx::GenQueriesARBRequest {
            context_tag,
            n,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_gen_queries_arb_immediate(&mut self, context_tag: types::ContextTag, n: types::Int32) -> Result<types::glx::GenQueriesARBReply> {
        let request = types::glx::GenQueriesARBRequest {
            context_tag,
            n,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_is_query_arb(&mut self, context_tag: types::ContextTag, id: types::Card32) -> Result<Cookie<types::glx::IsQueryARBReply>> {
        let span = tracing::info_span!(
            "glx_is_query_arb",
            context_tag = ?context_tag,
            id = ?id,
        );
        let _enter = span.enter();
        let request = types::glx::IsQueryARBRequest {
            context_tag,
            id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_is_query_arb_immediate(&mut self, context_tag: types::ContextTag, id: types::Card32) -> Result<types::glx::IsQueryARBReply> {
        let request = types::glx::IsQueryARBRequest {
            context_tag,
            id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_queryiv_arb(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetQueryivARBReply>> {
        let span = tracing::info_span!(
            "glx_get_queryiv_arb",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetQueryivARBRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_queryiv_arb_immediate(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<types::glx::GetQueryivARBReply> {
        let request = types::glx::GetQueryivARBRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectiv_arb(&mut self, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetQueryObjectivARBReply>> {
        let span = tracing::info_span!(
            "glx_get_query_objectiv_arb",
            context_tag = ?context_tag,
            id = ?id,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetQueryObjectivARBRequest {
            context_tag,
            id,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectiv_arb_immediate(&mut self, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> Result<types::glx::GetQueryObjectivARBReply> {
        let request = types::glx::GetQueryObjectivARBRequest {
            context_tag,
            id,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectuiv_arb(&mut self, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetQueryObjectuivARBReply>> {
        let span = tracing::info_span!(
            "glx_get_query_objectuiv_arb",
            context_tag = ?context_tag,
            id = ?id,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetQueryObjectuivARBRequest {
            context_tag,
            id,
            pname,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectuiv_arb_immediate(&mut self, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> Result<types::glx::GetQueryObjectuivARBReply> {
        let request = types::glx::GetQueryObjectuivARBRequest {
            context_tag,
            id,
            pname,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "present")]
    fn present_query_version(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::present::QueryVersionReply>> {
        let span = tracing::info_span!(
            "present_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::present::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "present")]
    fn present_query_version_immediate(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<types::present::QueryVersionReply> {
        let request = types::present::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "present")]
    fn present_pixmap(&mut self, window: types::xproto::Window, pixmap: types::xproto::Pixmap, serial: types::Card32, valid: types::Region, update: types::Region, x_off: types::Int16, y_off: types::Int16, target_crtc: types::Crtc, wait_fence: types::Fence, idle_fence: types::Fence, options: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64, notifies: impl AsRef<[types::present::Notify]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "present_pixmap",
            window = ?window,
            pixmap = ?pixmap,
            serial = ?serial,
            valid = ?valid,
            update = ?update,
            x_off = ?x_off,
            y_off = ?y_off,
            target_crtc = ?target_crtc,
            wait_fence = ?wait_fence,
            idle_fence = ?idle_fence,
            options = ?options,
            target_msc = ?target_msc,
            divisor = ?divisor,
            remainder = ?remainder,
        );
        let _enter = span.enter();
        let request = types::present::PixmapRequest {
            window,
            pixmap,
            serial,
            valid,
            update,
            x_off,
            y_off,
            target_crtc,
            wait_fence,
            idle_fence,
            options,
            target_msc,
            divisor,
            remainder,
            notifies: Cow::Borrowed(notifies.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "present")]
    fn present_pixmap_checked(&mut self, window: types::xproto::Window, pixmap: types::xproto::Pixmap, serial: types::Card32, valid: types::Region, update: types::Region, x_off: types::Int16, y_off: types::Int16, target_crtc: types::Crtc, wait_fence: types::Fence, idle_fence: types::Fence, options: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64, notifies: impl AsRef<[types::present::Notify]>) -> Result<()> {
        let request = types::present::PixmapRequest {
            window,
            pixmap,
            serial,
            valid,
            update,
            x_off,
            y_off,
            target_crtc,
            wait_fence,
            idle_fence,
            options,
            target_msc,
            divisor,
            remainder,
            notifies: Cow::Borrowed(notifies.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "present")]
    fn present_notify_msc(&mut self, window: types::xproto::Window, serial: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "present_notify_msc",
            window = ?window,
            serial = ?serial,
            target_msc = ?target_msc,
            divisor = ?divisor,
            remainder = ?remainder,
        );
        let _enter = span.enter();
        let request = types::present::NotifyMSCRequest {
            window,
            serial,
            target_msc,
            divisor,
            remainder,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "present")]
    fn present_notify_msc_checked(&mut self, window: types::xproto::Window, serial: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64) -> Result<()> {
        let request = types::present::NotifyMSCRequest {
            window,
            serial,
            target_msc,
            divisor,
            remainder,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "present")]
    fn present_select_input(&mut self, eid: types::present::Event, window: types::xproto::Window, event_mask: impl Into<types::present::EventMask>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "present_select_input",
            eid = ?eid,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::present::SelectInputRequest {
            eid,
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "present")]
    fn present_select_input_checked(&mut self, eid: types::present::Event, window: types::xproto::Window, event_mask: impl Into<types::present::EventMask>) -> Result<()> {
        let request = types::present::SelectInputRequest {
            eid,
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "present")]
    fn present_query_capabilities(&mut self, target: types::Card32) -> Result<Cookie<types::present::QueryCapabilitiesReply>> {
        let span = tracing::info_span!(
            "present_query_capabilities",
            target = ?target,
        );
        let _enter = span.enter();
        let request = types::present::QueryCapabilitiesRequest {
            target,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "present")]
    fn present_query_capabilities_immediate(&mut self, target: types::Card32) -> Result<types::present::QueryCapabilitiesReply> {
        let request = types::present::QueryCapabilitiesRequest {
            target,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "randr")]
    fn randr_query_version(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::randr::QueryVersionReply>> {
        let span = tracing::info_span!(
            "randr_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::randr::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_query_version_immediate(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<types::randr::QueryVersionReply> {
        let request = types::randr::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_config(&mut self, window: types::xproto::Window, timestamp: types::Timestamp, config_timestamp: types::Timestamp, size_id: types::Card16, rotation: impl Into<types::Rotation>, rate: types::Card16) -> Result<Cookie<types::randr::SetScreenConfigReply>> {
        let span = tracing::info_span!(
            "randr_set_screen_config",
            window = ?window,
            timestamp = ?timestamp,
            config_timestamp = ?config_timestamp,
            size_id = ?size_id,
            rate = ?rate,
        );
        let _enter = span.enter();
        let request = types::randr::SetScreenConfigRequest {
            window,
            timestamp,
            config_timestamp,
            size_id,
            rotation: Into::<u32>::into(rotation.into()) as _,
            rate,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_config_immediate(&mut self, window: types::xproto::Window, timestamp: types::Timestamp, config_timestamp: types::Timestamp, size_id: types::Card16, rotation: impl Into<types::Rotation>, rate: types::Card16) -> Result<types::randr::SetScreenConfigReply> {
        let request = types::randr::SetScreenConfigRequest {
            window,
            timestamp,
            config_timestamp,
            size_id,
            rotation: Into::<u32>::into(rotation.into()) as _,
            rate,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_select_input(&mut self, window: types::xproto::Window, enable: impl Into<types::NotifyMask>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_select_input",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::SelectInputRequest {
            window,
            enable: Into::<u32>::into(enable.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_select_input_checked(&mut self, window: types::xproto::Window, enable: impl Into<types::NotifyMask>) -> Result<()> {
        let request = types::randr::SelectInputRequest {
            window,
            enable: Into::<u32>::into(enable.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_info(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetScreenInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_screen_info",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetScreenInfoRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_info_immediate(&mut self, window: types::xproto::Window) -> Result<types::randr::GetScreenInfoReply> {
        let request = types::randr::GetScreenInfoRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_size_range(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetScreenSizeRangeReply>> {
        let span = tracing::info_span!(
            "randr_get_screen_size_range",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetScreenSizeRangeRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_size_range_immediate(&mut self, window: types::xproto::Window) -> Result<types::randr::GetScreenSizeRangeReply> {
        let request = types::randr::GetScreenSizeRangeRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_size(&mut self, window: types::xproto::Window, width: types::Card16, height: types::Card16, mm_width: types::Card32, mm_height: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_screen_size",
            window = ?window,
            width = ?width,
            height = ?height,
            mm_width = ?mm_width,
            mm_height = ?mm_height,
        );
        let _enter = span.enter();
        let request = types::randr::SetScreenSizeRequest {
            window,
            width,
            height,
            mm_width,
            mm_height,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_size_checked(&mut self, window: types::xproto::Window, width: types::Card16, height: types::Card16, mm_width: types::Card32, mm_height: types::Card32) -> Result<()> {
        let request = types::randr::SetScreenSizeRequest {
            window,
            width,
            height,
            mm_width,
            mm_height,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetScreenResourcesReply>> {
        let span = tracing::info_span!(
            "randr_get_screen_resources",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetScreenResourcesRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_immediate(&mut self, window: types::xproto::Window) -> Result<types::randr::GetScreenResourcesReply> {
        let request = types::randr::GetScreenResourcesRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_info(&mut self, output: types::Output, config_timestamp: types::Timestamp) -> Result<Cookie<types::randr::GetOutputInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_output_info",
            output = ?output,
            config_timestamp = ?config_timestamp,
        );
        let _enter = span.enter();
        let request = types::randr::GetOutputInfoRequest {
            output,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_info_immediate(&mut self, output: types::Output, config_timestamp: types::Timestamp) -> Result<types::randr::GetOutputInfoReply> {
        let request = types::randr::GetOutputInfoRequest {
            output,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_list_output_properties(&mut self, output: types::Output) -> Result<Cookie<types::randr::ListOutputPropertiesReply>> {
        let span = tracing::info_span!(
            "randr_list_output_properties",
            output = ?output,
        );
        let _enter = span.enter();
        let request = types::randr::ListOutputPropertiesRequest {
            output,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_list_output_properties_immediate(&mut self, output: types::Output) -> Result<types::randr::ListOutputPropertiesReply> {
        let request = types::randr::ListOutputPropertiesRequest {
            output,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_query_output_property(&mut self, output: types::Output, property: types::Atom) -> Result<Cookie<types::randr::QueryOutputPropertyReply>> {
        let span = tracing::info_span!(
            "randr_query_output_property",
            output = ?output,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::randr::QueryOutputPropertyRequest {
            output,
            property,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_query_output_property_immediate(&mut self, output: types::Output, property: types::Atom) -> Result<types::randr::QueryOutputPropertyReply> {
        let request = types::randr::QueryOutputPropertyRequest {
            output,
            property,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_output_property(&mut self, output: types::Output, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_configure_output_property",
            output = ?output,
            property = ?property,
            pending = ?pending,
            range = ?range,
        );
        let _enter = span.enter();
        let request = types::randr::ConfigureOutputPropertyRequest {
            output,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_configure_output_property_checked(&mut self, output: types::Output, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> Result<()> {
        let request = types::randr::ConfigureOutputPropertyRequest {
            output,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_change_output_property(&mut self, output: types::Output, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::PropMode, num_units: types::Card32, data: &(impl crate::Void + ?Sized)) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_change_output_property",
            output = ?output,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            mode = ?mode,
            num_units = ?num_units,
        );
        let _enter = span.enter();
        let request = types::randr::ChangeOutputPropertyRequest {
            output,
            property,
            type_,
            format,
            mode,
            num_units,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_change_output_property_checked(&mut self, output: types::Output, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::PropMode, num_units: types::Card32, data: &(impl crate::Void + ?Sized)) -> Result<()> {
        let request = types::randr::ChangeOutputPropertyRequest {
            output,
            property,
            type_,
            format,
            mode,
            num_units,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_property(&mut self, output: types::Output, property: types::Atom) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_delete_output_property",
            output = ?output,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::randr::DeleteOutputPropertyRequest {
            output,
            property,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_property_checked(&mut self, output: types::Output, property: types::Atom) -> Result<()> {
        let request = types::randr::DeleteOutputPropertyRequest {
            output,
            property,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_property(&mut self, output: types::Output, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> Result<Cookie<types::randr::GetOutputPropertyReply>> {
        let span = tracing::info_span!(
            "randr_get_output_property",
            output = ?output,
            property = ?property,
            long_offset = ?long_offset,
            long_length = ?long_length,
            delete = ?delete,
            pending = ?pending,
        );
        let _enter = span.enter();
        let request = types::randr::GetOutputPropertyRequest {
            output,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
            delete,
            pending,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_property_immediate(&mut self, output: types::Output, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> Result<types::randr::GetOutputPropertyReply> {
        let request = types::randr::GetOutputPropertyRequest {
            output,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
            delete,
            pending,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_create_mode(&mut self, window: types::xproto::Window, mode_info: types::randr::ModeInfo, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::randr::CreateModeReply>> {
        let span = tracing::info_span!(
            "randr_create_mode",
            window = ?window,
            mode_info = ?mode_info,
        );
        let _enter = span.enter();
        let request = types::randr::CreateModeRequest {
            window,
            mode_info,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_create_mode_immediate(&mut self, window: types::xproto::Window, mode_info: types::randr::ModeInfo, name: impl AsRef<[types::Char]>) -> Result<types::randr::CreateModeReply> {
        let request = types::randr::CreateModeRequest {
            window,
            mode_info,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_destroy_mode(&mut self, mode: types::Mode) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_destroy_mode",
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::randr::DestroyModeRequest {
            mode,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_destroy_mode_checked(&mut self, mode: types::Mode) -> Result<()> {
        let request = types::randr::DestroyModeRequest {
            mode,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_add_output_mode(&mut self, output: types::Output, mode: types::Mode) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_add_output_mode",
            output = ?output,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::randr::AddOutputModeRequest {
            output,
            mode,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_add_output_mode_checked(&mut self, output: types::Output, mode: types::Mode) -> Result<()> {
        let request = types::randr::AddOutputModeRequest {
            output,
            mode,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_mode(&mut self, output: types::Output, mode: types::Mode) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_delete_output_mode",
            output = ?output,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::randr::DeleteOutputModeRequest {
            output,
            mode,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_mode_checked(&mut self, output: types::Output, mode: types::Mode) -> Result<()> {
        let request = types::randr::DeleteOutputModeRequest {
            output,
            mode,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_info(&mut self, crtc: types::Crtc, config_timestamp: types::Timestamp) -> Result<Cookie<types::randr::GetCrtcInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_info",
            crtc = ?crtc,
            config_timestamp = ?config_timestamp,
        );
        let _enter = span.enter();
        let request = types::randr::GetCrtcInfoRequest {
            crtc,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_info_immediate(&mut self, crtc: types::Crtc, config_timestamp: types::Timestamp) -> Result<types::randr::GetCrtcInfoReply> {
        let request = types::randr::GetCrtcInfoRequest {
            crtc,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_config(&mut self, crtc: types::Crtc, timestamp: types::Timestamp, config_timestamp: types::Timestamp, x: types::Int16, y: types::Int16, mode: types::Mode, rotation: impl Into<types::Rotation>, outputs: impl AsRef<[types::Output]>) -> Result<Cookie<types::randr::SetCrtcConfigReply>> {
        let span = tracing::info_span!(
            "randr_set_crtc_config",
            crtc = ?crtc,
            timestamp = ?timestamp,
            config_timestamp = ?config_timestamp,
            x = ?x,
            y = ?y,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::randr::SetCrtcConfigRequest {
            crtc,
            timestamp,
            config_timestamp,
            x,
            y,
            mode,
            rotation: Into::<u32>::into(rotation.into()) as _,
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_config_immediate(&mut self, crtc: types::Crtc, timestamp: types::Timestamp, config_timestamp: types::Timestamp, x: types::Int16, y: types::Int16, mode: types::Mode, rotation: impl Into<types::Rotation>, outputs: impl AsRef<[types::Output]>) -> Result<types::randr::SetCrtcConfigReply> {
        let request = types::randr::SetCrtcConfigRequest {
            crtc,
            timestamp,
            config_timestamp,
            x,
            y,
            mode,
            rotation: Into::<u32>::into(rotation.into()) as _,
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_size(&mut self, crtc: types::Crtc) -> Result<Cookie<types::randr::GetCrtcGammaSizeReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_gamma_size",
            crtc = ?crtc,
        );
        let _enter = span.enter();
        let request = types::randr::GetCrtcGammaSizeRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_size_immediate(&mut self, crtc: types::Crtc) -> Result<types::randr::GetCrtcGammaSizeReply> {
        let request = types::randr::GetCrtcGammaSizeRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma(&mut self, crtc: types::Crtc) -> Result<Cookie<types::randr::GetCrtcGammaReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_gamma",
            crtc = ?crtc,
        );
        let _enter = span.enter();
        let request = types::randr::GetCrtcGammaRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_immediate(&mut self, crtc: types::Crtc) -> Result<types::randr::GetCrtcGammaReply> {
        let request = types::randr::GetCrtcGammaRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_gamma(&mut self, crtc: types::Crtc, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_crtc_gamma",
            crtc = ?crtc,
        );
        let _enter = span.enter();
        let request = types::randr::SetCrtcGammaRequest {
            crtc,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_gamma_checked(&mut self, crtc: types::Crtc, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> Result<()> {
        let request = types::randr::SetCrtcGammaRequest {
            crtc,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_current(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetScreenResourcesCurrentReply>> {
        let span = tracing::info_span!(
            "randr_get_screen_resources_current",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetScreenResourcesCurrentRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_current_immediate(&mut self, window: types::xproto::Window) -> Result<types::randr::GetScreenResourcesCurrentReply> {
        let request = types::randr::GetScreenResourcesCurrentRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_transform(&mut self, crtc: types::Crtc, transform: types::render::Transform, filter_name: impl AsRef<[types::Char]>, filter_params: impl AsRef<[types::Fixed]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_crtc_transform",
            crtc = ?crtc,
            transform = ?transform,
        );
        let _enter = span.enter();
        let request = types::randr::SetCrtcTransformRequest {
            crtc,
            transform,
            filter_name: Cow::Borrowed(filter_name.as_ref()),
            filter_params: Cow::Borrowed(filter_params.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_transform_checked(&mut self, crtc: types::Crtc, transform: types::render::Transform, filter_name: impl AsRef<[types::Char]>, filter_params: impl AsRef<[types::Fixed]>) -> Result<()> {
        let request = types::randr::SetCrtcTransformRequest {
            crtc,
            transform,
            filter_name: Cow::Borrowed(filter_name.as_ref()),
            filter_params: Cow::Borrowed(filter_params.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_transform(&mut self, crtc: types::Crtc) -> Result<Cookie<types::randr::GetCrtcTransformReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_transform",
            crtc = ?crtc,
        );
        let _enter = span.enter();
        let request = types::randr::GetCrtcTransformRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_transform_immediate(&mut self, crtc: types::Crtc) -> Result<types::randr::GetCrtcTransformReply> {
        let request = types::randr::GetCrtcTransformRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_panning(&mut self, crtc: types::Crtc) -> Result<Cookie<types::randr::GetPanningReply>> {
        let span = tracing::info_span!(
            "randr_get_panning",
            crtc = ?crtc,
        );
        let _enter = span.enter();
        let request = types::randr::GetPanningRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_panning_immediate(&mut self, crtc: types::Crtc) -> Result<types::randr::GetPanningReply> {
        let request = types::randr::GetPanningRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_panning(&mut self, crtc: types::Crtc, timestamp: types::Timestamp, left: types::Card16, top: types::Card16, width: types::Card16, height: types::Card16, track_left: types::Card16, track_top: types::Card16, track_width: types::Card16, track_height: types::Card16, border_left: types::Int16, border_top: types::Int16, border_right: types::Int16, border_bottom: types::Int16) -> Result<Cookie<types::randr::SetPanningReply>> {
        let span = tracing::info_span!(
            "randr_set_panning",
            crtc = ?crtc,
            timestamp = ?timestamp,
            left = ?left,
            top = ?top,
            width = ?width,
            height = ?height,
            track_left = ?track_left,
            track_top = ?track_top,
            track_width = ?track_width,
            track_height = ?track_height,
            border_left = ?border_left,
            border_top = ?border_top,
            border_right = ?border_right,
            border_bottom = ?border_bottom,
        );
        let _enter = span.enter();
        let request = types::randr::SetPanningRequest {
            crtc,
            timestamp,
            left,
            top,
            width,
            height,
            track_left,
            track_top,
            track_width,
            track_height,
            border_left,
            border_top,
            border_right,
            border_bottom,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_panning_immediate(&mut self, crtc: types::Crtc, timestamp: types::Timestamp, left: types::Card16, top: types::Card16, width: types::Card16, height: types::Card16, track_left: types::Card16, track_top: types::Card16, track_width: types::Card16, track_height: types::Card16, border_left: types::Int16, border_top: types::Int16, border_right: types::Int16, border_bottom: types::Int16) -> Result<types::randr::SetPanningReply> {
        let request = types::randr::SetPanningRequest {
            crtc,
            timestamp,
            left,
            top,
            width,
            height,
            track_left,
            track_top,
            track_width,
            track_height,
            border_left,
            border_top,
            border_right,
            border_bottom,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_output_primary(&mut self, window: types::xproto::Window, output: types::Output) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_output_primary",
            window = ?window,
            output = ?output,
        );
        let _enter = span.enter();
        let request = types::randr::SetOutputPrimaryRequest {
            window,
            output,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_output_primary_checked(&mut self, window: types::xproto::Window, output: types::Output) -> Result<()> {
        let request = types::randr::SetOutputPrimaryRequest {
            window,
            output,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_primary(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetOutputPrimaryReply>> {
        let span = tracing::info_span!(
            "randr_get_output_primary",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetOutputPrimaryRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_primary_immediate(&mut self, window: types::xproto::Window) -> Result<types::randr::GetOutputPrimaryReply> {
        let request = types::randr::GetOutputPrimaryRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_providers(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetProvidersReply>> {
        let span = tracing::info_span!(
            "randr_get_providers",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetProvidersRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_providers_immediate(&mut self, window: types::xproto::Window) -> Result<types::randr::GetProvidersReply> {
        let request = types::randr::GetProvidersRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_info(&mut self, provider: types::Provider, config_timestamp: types::Timestamp) -> Result<Cookie<types::randr::GetProviderInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_provider_info",
            provider = ?provider,
            config_timestamp = ?config_timestamp,
        );
        let _enter = span.enter();
        let request = types::randr::GetProviderInfoRequest {
            provider,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_info_immediate(&mut self, provider: types::Provider, config_timestamp: types::Timestamp) -> Result<types::randr::GetProviderInfoReply> {
        let request = types::randr::GetProviderInfoRequest {
            provider,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_offload_sink(&mut self, provider: types::Provider, sink_provider: types::Provider, config_timestamp: types::Timestamp) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_provider_offload_sink",
            provider = ?provider,
            sink_provider = ?sink_provider,
            config_timestamp = ?config_timestamp,
        );
        let _enter = span.enter();
        let request = types::randr::SetProviderOffloadSinkRequest {
            provider,
            sink_provider,
            config_timestamp,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_offload_sink_checked(&mut self, provider: types::Provider, sink_provider: types::Provider, config_timestamp: types::Timestamp) -> Result<()> {
        let request = types::randr::SetProviderOffloadSinkRequest {
            provider,
            sink_provider,
            config_timestamp,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_output_source(&mut self, provider: types::Provider, source_provider: types::Provider, config_timestamp: types::Timestamp) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_provider_output_source",
            provider = ?provider,
            source_provider = ?source_provider,
            config_timestamp = ?config_timestamp,
        );
        let _enter = span.enter();
        let request = types::randr::SetProviderOutputSourceRequest {
            provider,
            source_provider,
            config_timestamp,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_output_source_checked(&mut self, provider: types::Provider, source_provider: types::Provider, config_timestamp: types::Timestamp) -> Result<()> {
        let request = types::randr::SetProviderOutputSourceRequest {
            provider,
            source_provider,
            config_timestamp,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_list_provider_properties(&mut self, provider: types::Provider) -> Result<Cookie<types::randr::ListProviderPropertiesReply>> {
        let span = tracing::info_span!(
            "randr_list_provider_properties",
            provider = ?provider,
        );
        let _enter = span.enter();
        let request = types::randr::ListProviderPropertiesRequest {
            provider,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_list_provider_properties_immediate(&mut self, provider: types::Provider) -> Result<types::randr::ListProviderPropertiesReply> {
        let request = types::randr::ListProviderPropertiesRequest {
            provider,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_query_provider_property(&mut self, provider: types::Provider, property: types::Atom) -> Result<Cookie<types::randr::QueryProviderPropertyReply>> {
        let span = tracing::info_span!(
            "randr_query_provider_property",
            provider = ?provider,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::randr::QueryProviderPropertyRequest {
            provider,
            property,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_query_provider_property_immediate(&mut self, provider: types::Provider, property: types::Atom) -> Result<types::randr::QueryProviderPropertyReply> {
        let request = types::randr::QueryProviderPropertyRequest {
            provider,
            property,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_provider_property(&mut self, provider: types::Provider, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_configure_provider_property",
            provider = ?provider,
            property = ?property,
            pending = ?pending,
            range = ?range,
        );
        let _enter = span.enter();
        let request = types::randr::ConfigureProviderPropertyRequest {
            provider,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_configure_provider_property_checked(&mut self, provider: types::Provider, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> Result<()> {
        let request = types::randr::ConfigureProviderPropertyRequest {
            provider,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_change_provider_property(&mut self, provider: types::Provider, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::Card8, num_items: types::Card32, data: &(impl crate::Void + ?Sized)) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_change_provider_property",
            provider = ?provider,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            mode = ?mode,
            num_items = ?num_items,
        );
        let _enter = span.enter();
        let request = types::randr::ChangeProviderPropertyRequest {
            provider,
            property,
            type_,
            format,
            mode,
            num_items,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_change_provider_property_checked(&mut self, provider: types::Provider, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::Card8, num_items: types::Card32, data: &(impl crate::Void + ?Sized)) -> Result<()> {
        let request = types::randr::ChangeProviderPropertyRequest {
            provider,
            property,
            type_,
            format,
            mode,
            num_items,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_provider_property(&mut self, provider: types::Provider, property: types::Atom) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_delete_provider_property",
            provider = ?provider,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::randr::DeleteProviderPropertyRequest {
            provider,
            property,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_delete_provider_property_checked(&mut self, provider: types::Provider, property: types::Atom) -> Result<()> {
        let request = types::randr::DeleteProviderPropertyRequest {
            provider,
            property,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_property(&mut self, provider: types::Provider, property: types::Atom, type_: types::Atom, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> Result<Cookie<types::randr::GetProviderPropertyReply>> {
        let span = tracing::info_span!(
            "randr_get_provider_property",
            provider = ?provider,
            property = ?property,
            type_ = ?type_,
            long_offset = ?long_offset,
            long_length = ?long_length,
            delete = ?delete,
            pending = ?pending,
        );
        let _enter = span.enter();
        let request = types::randr::GetProviderPropertyRequest {
            provider,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_property_immediate(&mut self, provider: types::Provider, property: types::Atom, type_: types::Atom, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> Result<types::randr::GetProviderPropertyReply> {
        let request = types::randr::GetProviderPropertyRequest {
            provider,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_monitors(&mut self, window: types::xproto::Window, get_active: types::Bool) -> Result<Cookie<types::randr::GetMonitorsReply>> {
        let span = tracing::info_span!(
            "randr_get_monitors",
            window = ?window,
            get_active = ?get_active,
        );
        let _enter = span.enter();
        let request = types::randr::GetMonitorsRequest {
            window,
            get_active,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_monitors_immediate(&mut self, window: types::xproto::Window, get_active: types::Bool) -> Result<types::randr::GetMonitorsReply> {
        let request = types::randr::GetMonitorsRequest {
            window,
            get_active,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_monitor(&mut self, window: types::xproto::Window, monitorinfo: types::MonitorInfo) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_monitor",
            window = ?window,
            monitorinfo = ?monitorinfo,
        );
        let _enter = span.enter();
        let request = types::randr::SetMonitorRequest {
            window,
            monitorinfo,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_monitor_checked(&mut self, window: types::xproto::Window, monitorinfo: types::MonitorInfo) -> Result<()> {
        let request = types::randr::SetMonitorRequest {
            window,
            monitorinfo,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_monitor(&mut self, window: types::xproto::Window, name: types::Atom) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_delete_monitor",
            window = ?window,
            name = ?name,
        );
        let _enter = span.enter();
        let request = types::randr::DeleteMonitorRequest {
            window,
            name,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_delete_monitor_checked(&mut self, window: types::xproto::Window, name: types::Atom) -> Result<()> {
        let request = types::randr::DeleteMonitorRequest {
            window,
            name,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_create_lease(&mut self, window: types::xproto::Window, lid: types::Lease, crtcs: impl AsRef<[types::Crtc]>, outputs: impl AsRef<[types::Output]>) -> Result<Cookie<types::randr::CreateLeaseReply>> {
        let span = tracing::info_span!(
            "randr_create_lease",
            window = ?window,
            lid = ?lid,
        );
        let _enter = span.enter();
        let request = types::randr::CreateLeaseRequest {
            window,
            lid,
            crtcs: Cow::Borrowed(crtcs.as_ref()),
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        let cookie = self.send_reply_fd_request(request);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_create_lease_immediate(&mut self, window: types::xproto::Window, lid: types::Lease, crtcs: impl AsRef<[types::Crtc]>, outputs: impl AsRef<[types::Output]>) -> Result<types::randr::CreateLeaseReply> {
        let request = types::randr::CreateLeaseRequest {
            window,
            lid,
            crtcs: Cow::Borrowed(crtcs.as_ref()),
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        let cookie = self.send_reply_fd_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_free_lease(&mut self, lid: types::Lease, terminate: types::Byte) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_free_lease",
            lid = ?lid,
            terminate = ?terminate,
        );
        let _enter = span.enter();
        let request = types::randr::FreeLeaseRequest {
            lid,
            terminate,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_free_lease_checked(&mut self, lid: types::Lease, terminate: types::Byte) -> Result<()> {
        let request = types::randr::FreeLeaseRequest {
            lid,
            terminate,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "record")]
    fn record_query_version(&mut self, major_version: types::Card16, minor_version: types::Card16) -> Result<Cookie<types::record::QueryVersionReply>> {
        let span = tracing::info_span!(
            "record_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::record::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_query_version_immediate(&mut self, major_version: types::Card16, minor_version: types::Card16) -> Result<types::record::QueryVersionReply> {
        let request = types::record::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_create_context(&mut self, context: types::record::Context, element_header: types::ElementHeader, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "record_create_context",
            context = ?context,
            element_header = ?element_header,
        );
        let _enter = span.enter();
        let request = types::record::CreateContextRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_create_context_checked(&mut self, context: types::record::Context, element_header: types::ElementHeader, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> Result<()> {
        let request = types::record::CreateContextRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_register_clients(&mut self, context: types::record::Context, element_header: types::ElementHeader, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "record_register_clients",
            context = ?context,
            element_header = ?element_header,
        );
        let _enter = span.enter();
        let request = types::record::RegisterClientsRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_register_clients_checked(&mut self, context: types::record::Context, element_header: types::ElementHeader, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> Result<()> {
        let request = types::record::RegisterClientsRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_unregister_clients(&mut self, context: types::record::Context, client_specs: impl AsRef<[types::ClientSpec]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "record_unregister_clients",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::record::UnregisterClientsRequest {
            context,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_unregister_clients_checked(&mut self, context: types::record::Context, client_specs: impl AsRef<[types::ClientSpec]>) -> Result<()> {
        let request = types::record::UnregisterClientsRequest {
            context,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_get_context(&mut self, context: types::record::Context) -> Result<Cookie<types::record::GetContextReply>> {
        let span = tracing::info_span!(
            "record_get_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::record::GetContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_get_context_immediate(&mut self, context: types::record::Context) -> Result<types::record::GetContextReply> {
        let request = types::record::GetContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_enable_context(&mut self, context: types::record::Context) -> Result<Cookie<types::record::EnableContextReply>> {
        let span = tracing::info_span!(
            "record_enable_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::record::EnableContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_enable_context_immediate(&mut self, context: types::record::Context) -> Result<types::record::EnableContextReply> {
        let request = types::record::EnableContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_disable_context(&mut self, context: types::record::Context) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "record_disable_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::record::DisableContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_disable_context_checked(&mut self, context: types::record::Context) -> Result<()> {
        let request = types::record::DisableContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_free_context(&mut self, context: types::record::Context) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "record_free_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::record::FreeContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_free_context_checked(&mut self, context: types::record::Context) -> Result<()> {
        let request = types::record::FreeContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "render")]
    fn render_query_version(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::render::QueryVersionReply>> {
        let span = tracing::info_span!(
            "render_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::render::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_query_version_immediate(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<types::render::QueryVersionReply> {
        let request = types::render::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_formats(&mut self, ) -> Result<Cookie<types::render::QueryPictFormatsReply>> {
        let span = tracing::info_span!(
            "render_query_pict_formats",
        );
        let _enter = span.enter();
        let request = types::render::QueryPictFormatsRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_query_pict_formats_immediate(&mut self, ) -> Result<types::render::QueryPictFormatsReply> {
        let request = types::render::QueryPictFormatsRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_index_values(&mut self, format: types::Pictformat) -> Result<Cookie<types::render::QueryPictIndexValuesReply>> {
        let span = tracing::info_span!(
            "render_query_pict_index_values",
            format = ?format,
        );
        let _enter = span.enter();
        let request = types::render::QueryPictIndexValuesRequest {
            format,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_query_pict_index_values_immediate(&mut self, format: types::Pictformat) -> Result<types::render::QueryPictIndexValuesReply> {
        let request = types::render::QueryPictIndexValuesRequest {
            format,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_picture(&mut self, pid: types::Picture, drawable: types::xproto::Drawable, format: types::Pictformat, value_list: impl Borrow<types::render::CreatePictureAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_picture",
            pid = ?pid,
            drawable = ?drawable,
            format = ?format,
        );
        let _enter = span.enter();
        let request = types::render::CreatePictureRequest {
            pid,
            drawable,
            format,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_picture_checked(&mut self, pid: types::Picture, drawable: types::xproto::Drawable, format: types::Pictformat, value_list: impl Borrow<types::render::CreatePictureAux>) -> Result<()> {
        let request = types::render::CreatePictureRequest {
            pid,
            drawable,
            format,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_change_picture(&mut self, picture: types::Picture, value_list: impl Borrow<types::render::ChangePictureAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_change_picture",
            picture = ?picture,
        );
        let _enter = span.enter();
        let request = types::render::ChangePictureRequest {
            picture,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_change_picture_checked(&mut self, picture: types::Picture, value_list: impl Borrow<types::render::ChangePictureAux>) -> Result<()> {
        let request = types::render::ChangePictureRequest {
            picture,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_clip_rectangles(&mut self, picture: types::Picture, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_set_picture_clip_rectangles",
            picture = ?picture,
            clip_x_origin = ?clip_x_origin,
            clip_y_origin = ?clip_y_origin,
        );
        let _enter = span.enter();
        let request = types::render::SetPictureClipRectanglesRequest {
            picture,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_set_picture_clip_rectangles_checked(&mut self, picture: types::Picture, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<()> {
        let request = types::render::SetPictureClipRectanglesRequest {
            picture,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_free_picture(&mut self, picture: types::Picture) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_free_picture",
            picture = ?picture,
        );
        let _enter = span.enter();
        let request = types::render::FreePictureRequest {
            picture,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_free_picture_checked(&mut self, picture: types::Picture) -> Result<()> {
        let request = types::render::FreePictureRequest {
            picture,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_composite(&mut self, op: types::PictOp, src: types::Picture, mask: impl Into<types::Picture>, dst: types::Picture, src_x: types::Int16, src_y: types::Int16, mask_x: types::Int16, mask_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_composite",
            op = ?op,
            src = ?src,
            dst = ?dst,
            src_x = ?src_x,
            src_y = ?src_y,
            mask_x = ?mask_x,
            mask_y = ?mask_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::render::CompositeRequest {
            op,
            src,
            mask: Into::<u32>::into(mask.into()) as _,
            dst,
            src_x,
            src_y,
            mask_x,
            mask_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_composite_checked(&mut self, op: types::PictOp, src: types::Picture, mask: impl Into<types::Picture>, dst: types::Picture, src_x: types::Int16, src_y: types::Int16, mask_x: types::Int16, mask_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> Result<()> {
        let request = types::render::CompositeRequest {
            op,
            src,
            mask: Into::<u32>::into(mask.into()) as _,
            dst,
            src_x,
            src_y,
            mask_x,
            mask_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_trapezoids(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, traps: impl AsRef<[types::Trapezoid]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_trapezoids",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::TrapezoidsRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_trapezoids_checked(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, traps: impl AsRef<[types::Trapezoid]>) -> Result<()> {
        let request = types::render::TrapezoidsRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_triangles(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, triangles: impl AsRef<[types::Triangle]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_triangles",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::TrianglesRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            triangles: Cow::Borrowed(triangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_triangles_checked(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, triangles: impl AsRef<[types::Triangle]>) -> Result<()> {
        let request = types::render::TrianglesRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            triangles: Cow::Borrowed(triangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_tri_strip(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_tri_strip",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::TriStripRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_tri_strip_checked(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> Result<()> {
        let request = types::render::TriStripRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_tri_fan(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_tri_fan",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::TriFanRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_tri_fan_checked(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> Result<()> {
        let request = types::render::TriFanRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_glyph_set(&mut self, gsid: types::Glyphset, format: types::Pictformat) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_glyph_set",
            gsid = ?gsid,
            format = ?format,
        );
        let _enter = span.enter();
        let request = types::render::CreateGlyphSetRequest {
            gsid,
            format,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_glyph_set_checked(&mut self, gsid: types::Glyphset, format: types::Pictformat) -> Result<()> {
        let request = types::render::CreateGlyphSetRequest {
            gsid,
            format,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_reference_glyph_set(&mut self, gsid: types::Glyphset, existing: types::Glyphset) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_reference_glyph_set",
            gsid = ?gsid,
            existing = ?existing,
        );
        let _enter = span.enter();
        let request = types::render::ReferenceGlyphSetRequest {
            gsid,
            existing,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_reference_glyph_set_checked(&mut self, gsid: types::Glyphset, existing: types::Glyphset) -> Result<()> {
        let request = types::render::ReferenceGlyphSetRequest {
            gsid,
            existing,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_free_glyph_set(&mut self, glyphset: types::Glyphset) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_free_glyph_set",
            glyphset = ?glyphset,
        );
        let _enter = span.enter();
        let request = types::render::FreeGlyphSetRequest {
            glyphset,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_free_glyph_set_checked(&mut self, glyphset: types::Glyphset) -> Result<()> {
        let request = types::render::FreeGlyphSetRequest {
            glyphset,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_add_glyphs(&mut self, glyphset: types::Glyphset, glyphids: impl AsRef<[types::Card32]>, glyphs: impl AsRef<[types::Glyphinfo]>, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_add_glyphs",
            glyphset = ?glyphset,
        );
        let _enter = span.enter();
        let request = types::render::AddGlyphsRequest {
            glyphset,
            glyphids: Cow::Borrowed(glyphids.as_ref()),
            glyphs: Cow::Borrowed(glyphs.as_ref()),
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_add_glyphs_checked(&mut self, glyphset: types::Glyphset, glyphids: impl AsRef<[types::Card32]>, glyphs: impl AsRef<[types::Glyphinfo]>, data: impl AsRef<[types::Byte]>) -> Result<()> {
        let request = types::render::AddGlyphsRequest {
            glyphset,
            glyphids: Cow::Borrowed(glyphids.as_ref()),
            glyphs: Cow::Borrowed(glyphs.as_ref()),
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_free_glyphs(&mut self, glyphset: types::Glyphset, glyphs: impl AsRef<[types::Glyph]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_free_glyphs",
            glyphset = ?glyphset,
        );
        let _enter = span.enter();
        let request = types::render::FreeGlyphsRequest {
            glyphset,
            glyphs: Cow::Borrowed(glyphs.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_free_glyphs_checked(&mut self, glyphset: types::Glyphset, glyphs: impl AsRef<[types::Glyph]>) -> Result<()> {
        let request = types::render::FreeGlyphsRequest {
            glyphset,
            glyphs: Cow::Borrowed(glyphs.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs8(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_composite_glyphs8",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::CompositeGlyphs8Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs8_checked(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<()> {
        let request = types::render::CompositeGlyphs8Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs16(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_composite_glyphs16",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::CompositeGlyphs16Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs16_checked(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<()> {
        let request = types::render::CompositeGlyphs16Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs32(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_composite_glyphs32",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::CompositeGlyphs32Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs32_checked(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<()> {
        let request = types::render::CompositeGlyphs32Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_fill_rectangles(&mut self, op: types::PictOp, dst: types::Picture, color: types::Color, rects: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_fill_rectangles",
            op = ?op,
            dst = ?dst,
            color = ?color,
        );
        let _enter = span.enter();
        let request = types::render::FillRectanglesRequest {
            op,
            dst,
            color,
            rects: Cow::Borrowed(rects.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_fill_rectangles_checked(&mut self, op: types::PictOp, dst: types::Picture, color: types::Color, rects: impl AsRef<[types::Rectangle]>) -> Result<()> {
        let request = types::render::FillRectanglesRequest {
            op,
            dst,
            color,
            rects: Cow::Borrowed(rects.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_cursor(&mut self, cid: types::xproto::Cursor, source: types::Picture, x: types::Card16, y: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_cursor",
            cid = ?cid,
            source = ?source,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::render::CreateCursorRequest {
            cid,
            source,
            x,
            y,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_cursor_checked(&mut self, cid: types::xproto::Cursor, source: types::Picture, x: types::Card16, y: types::Card16) -> Result<()> {
        let request = types::render::CreateCursorRequest {
            cid,
            source,
            x,
            y,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_transform(&mut self, picture: types::Picture, transform: types::render::Transform) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_set_picture_transform",
            picture = ?picture,
            transform = ?transform,
        );
        let _enter = span.enter();
        let request = types::render::SetPictureTransformRequest {
            picture,
            transform,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_set_picture_transform_checked(&mut self, picture: types::Picture, transform: types::render::Transform) -> Result<()> {
        let request = types::render::SetPictureTransformRequest {
            picture,
            transform,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_query_filters(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<types::render::QueryFiltersReply>> {
        let span = tracing::info_span!(
            "render_query_filters",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::render::QueryFiltersRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_query_filters_immediate(&mut self, drawable: types::xproto::Drawable) -> Result<types::render::QueryFiltersReply> {
        let request = types::render::QueryFiltersRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_filter(&mut self, picture: types::Picture, filter: impl AsRef<[types::Char]>, values: impl AsRef<[types::Fixed]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_set_picture_filter",
            picture = ?picture,
        );
        let _enter = span.enter();
        let request = types::render::SetPictureFilterRequest {
            picture,
            filter: Cow::Borrowed(filter.as_ref()),
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_set_picture_filter_checked(&mut self, picture: types::Picture, filter: impl AsRef<[types::Char]>, values: impl AsRef<[types::Fixed]>) -> Result<()> {
        let request = types::render::SetPictureFilterRequest {
            picture,
            filter: Cow::Borrowed(filter.as_ref()),
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_anim_cursor(&mut self, cid: types::xproto::Cursor, cursors: impl AsRef<[types::Animcursorelt]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_anim_cursor",
            cid = ?cid,
        );
        let _enter = span.enter();
        let request = types::render::CreateAnimCursorRequest {
            cid,
            cursors: Cow::Borrowed(cursors.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_anim_cursor_checked(&mut self, cid: types::xproto::Cursor, cursors: impl AsRef<[types::Animcursorelt]>) -> Result<()> {
        let request = types::render::CreateAnimCursorRequest {
            cid,
            cursors: Cow::Borrowed(cursors.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_add_traps(&mut self, picture: types::Picture, x_off: types::Int16, y_off: types::Int16, traps: impl AsRef<[types::Trap]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_add_traps",
            picture = ?picture,
            x_off = ?x_off,
            y_off = ?y_off,
        );
        let _enter = span.enter();
        let request = types::render::AddTrapsRequest {
            picture,
            x_off,
            y_off,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_add_traps_checked(&mut self, picture: types::Picture, x_off: types::Int16, y_off: types::Int16, traps: impl AsRef<[types::Trap]>) -> Result<()> {
        let request = types::render::AddTrapsRequest {
            picture,
            x_off,
            y_off,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_solid_fill(&mut self, picture: types::Picture, color: types::Color) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_solid_fill",
            picture = ?picture,
            color = ?color,
        );
        let _enter = span.enter();
        let request = types::render::CreateSolidFillRequest {
            picture,
            color,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_solid_fill_checked(&mut self, picture: types::Picture, color: types::Color) -> Result<()> {
        let request = types::render::CreateSolidFillRequest {
            picture,
            color,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_linear_gradient(&mut self, picture: types::Picture, p1: types::Pointfix, p2: types::Pointfix, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_linear_gradient",
            picture = ?picture,
            p1 = ?p1,
            p2 = ?p2,
        );
        let _enter = span.enter();
        let request = types::render::CreateLinearGradientRequest {
            picture,
            p1,
            p2,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_linear_gradient_checked(&mut self, picture: types::Picture, p1: types::Pointfix, p2: types::Pointfix, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<()> {
        let request = types::render::CreateLinearGradientRequest {
            picture,
            p1,
            p2,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_radial_gradient(&mut self, picture: types::Picture, inner: types::Pointfix, outer: types::Pointfix, inner_radius: types::Fixed, outer_radius: types::Fixed, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_radial_gradient",
            picture = ?picture,
            inner = ?inner,
            outer = ?outer,
            inner_radius = ?inner_radius,
            outer_radius = ?outer_radius,
        );
        let _enter = span.enter();
        let request = types::render::CreateRadialGradientRequest {
            picture,
            inner,
            outer,
            inner_radius,
            outer_radius,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_radial_gradient_checked(&mut self, picture: types::Picture, inner: types::Pointfix, outer: types::Pointfix, inner_radius: types::Fixed, outer_radius: types::Fixed, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<()> {
        let request = types::render::CreateRadialGradientRequest {
            picture,
            inner,
            outer,
            inner_radius,
            outer_radius,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_conical_gradient(&mut self, picture: types::Picture, center: types::Pointfix, angle: types::Fixed, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_conical_gradient",
            picture = ?picture,
            center = ?center,
            angle = ?angle,
        );
        let _enter = span.enter();
        let request = types::render::CreateConicalGradientRequest {
            picture,
            center,
            angle,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_conical_gradient_checked(&mut self, picture: types::Picture, center: types::Pointfix, angle: types::Fixed, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<()> {
        let request = types::render::CreateConicalGradientRequest {
            picture,
            center,
            angle,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "res")]
    fn res_query_version(&mut self, client_major: types::Card8, client_minor: types::Card8) -> Result<Cookie<types::res::QueryVersionReply>> {
        let span = tracing::info_span!(
            "res_query_version",
            client_major = ?client_major,
            client_minor = ?client_minor,
        );
        let _enter = span.enter();
        let request = types::res::QueryVersionRequest {
            client_major,
            client_minor,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_version_immediate(&mut self, client_major: types::Card8, client_minor: types::Card8) -> Result<types::res::QueryVersionReply> {
        let request = types::res::QueryVersionRequest {
            client_major,
            client_minor,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "res")]
    fn res_query_clients(&mut self, ) -> Result<Cookie<types::res::QueryClientsReply>> {
        let span = tracing::info_span!(
            "res_query_clients",
        );
        let _enter = span.enter();
        let request = types::res::QueryClientsRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_clients_immediate(&mut self, ) -> Result<types::res::QueryClientsReply> {
        let request = types::res::QueryClientsRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "res")]
    fn res_query_client_resources(&mut self, xid: types::Card32) -> Result<Cookie<types::res::QueryClientResourcesReply>> {
        let span = tracing::info_span!(
            "res_query_client_resources",
            xid = ?xid,
        );
        let _enter = span.enter();
        let request = types::res::QueryClientResourcesRequest {
            xid,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_client_resources_immediate(&mut self, xid: types::Card32) -> Result<types::res::QueryClientResourcesReply> {
        let request = types::res::QueryClientResourcesRequest {
            xid,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "res")]
    fn res_query_client_pixmap_bytes(&mut self, xid: types::Card32) -> Result<Cookie<types::res::QueryClientPixmapBytesReply>> {
        let span = tracing::info_span!(
            "res_query_client_pixmap_bytes",
            xid = ?xid,
        );
        let _enter = span.enter();
        let request = types::res::QueryClientPixmapBytesRequest {
            xid,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_client_pixmap_bytes_immediate(&mut self, xid: types::Card32) -> Result<types::res::QueryClientPixmapBytesReply> {
        let request = types::res::QueryClientPixmapBytesRequest {
            xid,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "res")]
    fn res_query_client_ids(&mut self, specs: impl AsRef<[types::ClientIdSpec]>) -> Result<Cookie<types::res::QueryClientIdsReply>> {
        let span = tracing::info_span!(
            "res_query_client_ids",
        );
        let _enter = span.enter();
        let request = types::res::QueryClientIdsRequest {
            specs: Cow::Borrowed(specs.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_client_ids_immediate(&mut self, specs: impl AsRef<[types::ClientIdSpec]>) -> Result<types::res::QueryClientIdsReply> {
        let request = types::res::QueryClientIdsRequest {
            specs: Cow::Borrowed(specs.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "res")]
    fn res_query_resource_bytes(&mut self, client: types::Card32, specs: impl AsRef<[types::ResourceIdSpec]>) -> Result<Cookie<types::res::QueryResourceBytesReply>> {
        let span = tracing::info_span!(
            "res_query_resource_bytes",
            client = ?client,
        );
        let _enter = span.enter();
        let request = types::res::QueryResourceBytesRequest {
            client,
            specs: Cow::Borrowed(specs.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_resource_bytes_immediate(&mut self, client: types::Card32, specs: impl AsRef<[types::ResourceIdSpec]>) -> Result<types::res::QueryResourceBytesReply> {
        let request = types::res::QueryResourceBytesRequest {
            client,
            specs: Cow::Borrowed(specs.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "screensaver")]
    fn screensaver_query_version(&mut self, client_major_version: types::Card8, client_minor_version: types::Card8) -> Result<Cookie<types::screensaver::QueryVersionReply>> {
        let span = tracing::info_span!(
            "screensaver_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::screensaver::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_version_immediate(&mut self, client_major_version: types::Card8, client_minor_version: types::Card8) -> Result<types::screensaver::QueryVersionReply> {
        let request = types::screensaver::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_info(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<types::screensaver::QueryInfoReply>> {
        let span = tracing::info_span!(
            "screensaver_query_info",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::screensaver::QueryInfoRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_info_immediate(&mut self, drawable: types::xproto::Drawable) -> Result<types::screensaver::QueryInfoReply> {
        let request = types::screensaver::QueryInfoRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_select_input(&mut self, drawable: types::xproto::Drawable, event_mask: impl Into<types::screensaver::Event>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "screensaver_select_input",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::screensaver::SelectInputRequest {
            drawable,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_select_input_checked(&mut self, drawable: types::xproto::Drawable, event_mask: impl Into<types::screensaver::Event>) -> Result<()> {
        let request = types::screensaver::SelectInputRequest {
            drawable,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_set_attributes(&mut self, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, depth: types::Card8, visual: types::Visualid, value_list: impl Borrow<types::screensaver::SetAttributesAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "screensaver_set_attributes",
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            border_width = ?border_width,
            class = ?class,
            depth = ?depth,
            visual = ?visual,
        );
        let _enter = span.enter();
        let request = types::screensaver::SetAttributesRequest {
            drawable,
            x,
            y,
            width,
            height,
            border_width,
            class,
            depth,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_set_attributes_checked(&mut self, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, depth: types::Card8, visual: types::Visualid, value_list: impl Borrow<types::screensaver::SetAttributesAux>) -> Result<()> {
        let request = types::screensaver::SetAttributesRequest {
            drawable,
            x,
            y,
            width,
            height,
            border_width,
            class,
            depth,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_unset_attributes(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "screensaver_unset_attributes",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::screensaver::UnsetAttributesRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_unset_attributes_checked(&mut self, drawable: types::xproto::Drawable) -> Result<()> {
        let request = types::screensaver::UnsetAttributesRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_suspend(&mut self, suspend: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "screensaver_suspend",
            suspend = ?suspend,
        );
        let _enter = span.enter();
        let request = types::screensaver::SuspendRequest {
            suspend,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_suspend_checked(&mut self, suspend: types::Card32) -> Result<()> {
        let request = types::screensaver::SuspendRequest {
            suspend,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "shape")]
    fn shape_query_version(&mut self, ) -> Result<Cookie<types::shape::QueryVersionReply>> {
        let span = tracing::info_span!(
            "shape_query_version",
        );
        let _enter = span.enter();
        let request = types::shape::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_query_version_immediate(&mut self, ) -> Result<types::shape::QueryVersionReply> {
        let request = types::shape::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_rectangles(&mut self, operation: types::SO, destination_kind: types::SK, ordering: types::ClipOrdering, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shape_rectangles",
            operation = ?operation,
            destination_kind = ?destination_kind,
            ordering = ?ordering,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let _enter = span.enter();
        let request = types::shape::RectanglesRequest {
            operation,
            destination_kind,
            ordering,
            destination_window,
            x_offset,
            y_offset,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_rectangles_checked(&mut self, operation: types::SO, destination_kind: types::SK, ordering: types::ClipOrdering, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<()> {
        let request = types::shape::RectanglesRequest {
            operation,
            destination_kind,
            ordering,
            destination_window,
            x_offset,
            y_offset,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_mask(&mut self, operation: types::SO, destination_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, source_bitmap: impl Into<types::xproto::Pixmap>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shape_mask",
            operation = ?operation,
            destination_kind = ?destination_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let _enter = span.enter();
        let request = types::shape::MaskRequest {
            operation,
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
            source_bitmap: Into::<u32>::into(source_bitmap.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_mask_checked(&mut self, operation: types::SO, destination_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, source_bitmap: impl Into<types::xproto::Pixmap>) -> Result<()> {
        let request = types::shape::MaskRequest {
            operation,
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
            source_bitmap: Into::<u32>::into(source_bitmap.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_combine(&mut self, operation: types::SO, destination_kind: types::SK, source_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, source_window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shape_combine",
            operation = ?operation,
            destination_kind = ?destination_kind,
            source_kind = ?source_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
            source_window = ?source_window,
        );
        let _enter = span.enter();
        let request = types::shape::CombineRequest {
            operation,
            destination_kind,
            source_kind,
            destination_window,
            x_offset,
            y_offset,
            source_window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_combine_checked(&mut self, operation: types::SO, destination_kind: types::SK, source_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, source_window: types::xproto::Window) -> Result<()> {
        let request = types::shape::CombineRequest {
            operation,
            destination_kind,
            source_kind,
            destination_window,
            x_offset,
            y_offset,
            source_window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_offset(&mut self, destination_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shape_offset",
            destination_kind = ?destination_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let _enter = span.enter();
        let request = types::shape::OffsetRequest {
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_offset_checked(&mut self, destination_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16) -> Result<()> {
        let request = types::shape::OffsetRequest {
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_query_extents(&mut self, destination_window: types::xproto::Window) -> Result<Cookie<types::shape::QueryExtentsReply>> {
        let span = tracing::info_span!(
            "shape_query_extents",
            destination_window = ?destination_window,
        );
        let _enter = span.enter();
        let request = types::shape::QueryExtentsRequest {
            destination_window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_query_extents_immediate(&mut self, destination_window: types::xproto::Window) -> Result<types::shape::QueryExtentsReply> {
        let request = types::shape::QueryExtentsRequest {
            destination_window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_select_input(&mut self, destination_window: types::xproto::Window, enable: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shape_select_input",
            destination_window = ?destination_window,
            enable = ?enable,
        );
        let _enter = span.enter();
        let request = types::shape::SelectInputRequest {
            destination_window,
            enable,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_select_input_checked(&mut self, destination_window: types::xproto::Window, enable: types::Bool) -> Result<()> {
        let request = types::shape::SelectInputRequest {
            destination_window,
            enable,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_input_selected(&mut self, destination_window: types::xproto::Window) -> Result<Cookie<types::shape::InputSelectedReply>> {
        let span = tracing::info_span!(
            "shape_input_selected",
            destination_window = ?destination_window,
        );
        let _enter = span.enter();
        let request = types::shape::InputSelectedRequest {
            destination_window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_input_selected_immediate(&mut self, destination_window: types::xproto::Window) -> Result<types::shape::InputSelectedReply> {
        let request = types::shape::InputSelectedRequest {
            destination_window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_get_rectangles(&mut self, window: types::xproto::Window, source_kind: types::SK) -> Result<Cookie<types::shape::GetRectanglesReply>> {
        let span = tracing::info_span!(
            "shape_get_rectangles",
            window = ?window,
            source_kind = ?source_kind,
        );
        let _enter = span.enter();
        let request = types::shape::GetRectanglesRequest {
            window,
            source_kind,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_get_rectangles_immediate(&mut self, window: types::xproto::Window, source_kind: types::SK) -> Result<types::shape::GetRectanglesReply> {
        let request = types::shape::GetRectanglesRequest {
            window,
            source_kind,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "shm")]
    fn shm_query_version(&mut self, ) -> Result<Cookie<types::shm::QueryVersionReply>> {
        let span = tracing::info_span!(
            "shm_query_version",
        );
        let _enter = span.enter();
        let request = types::shm::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_query_version_immediate(&mut self, ) -> Result<types::shm::QueryVersionReply> {
        let request = types::shm::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_attach(&mut self, shmseg: types::Seg, shmid: types::Card32, read_only: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shm_attach",
            shmseg = ?shmseg,
            shmid = ?shmid,
            read_only = ?read_only,
        );
        let _enter = span.enter();
        let request = types::shm::AttachRequest {
            shmseg,
            shmid,
            read_only,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_attach_checked(&mut self, shmseg: types::Seg, shmid: types::Card32, read_only: types::Bool) -> Result<()> {
        let request = types::shm::AttachRequest {
            shmseg,
            shmid,
            read_only,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_detach(&mut self, shmseg: types::Seg) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shm_detach",
            shmseg = ?shmseg,
        );
        let _enter = span.enter();
        let request = types::shm::DetachRequest {
            shmseg,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_detach_checked(&mut self, shmseg: types::Seg) -> Result<()> {
        let request = types::shm::DetachRequest {
            shmseg,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_put_image(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, total_width: types::Card16, total_height: types::Card16, src_x: types::Card16, src_y: types::Card16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, depth: types::Card8, format: types::Card8, send_event: types::Bool, shmseg: types::Seg, offset: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shm_put_image",
            drawable = ?drawable,
            gc = ?gc,
            total_width = ?total_width,
            total_height = ?total_height,
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            depth = ?depth,
            format = ?format,
            send_event = ?send_event,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let _enter = span.enter();
        let request = types::shm::PutImageRequest {
            drawable,
            gc,
            total_width,
            total_height,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            depth,
            format,
            send_event,
            shmseg,
            offset,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_put_image_checked(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, total_width: types::Card16, total_height: types::Card16, src_x: types::Card16, src_y: types::Card16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, depth: types::Card8, format: types::Card8, send_event: types::Bool, shmseg: types::Seg, offset: types::Card32) -> Result<()> {
        let request = types::shm::PutImageRequest {
            drawable,
            gc,
            total_width,
            total_height,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            depth,
            format,
            send_event,
            shmseg,
            offset,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_get_image(&mut self, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32, format: types::Card8, shmseg: types::Seg, offset: types::Card32) -> Result<Cookie<types::shm::GetImageReply>> {
        let span = tracing::info_span!(
            "shm_get_image",
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            plane_mask = ?plane_mask,
            format = ?format,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let _enter = span.enter();
        let request = types::shm::GetImageRequest {
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
            format,
            shmseg,
            offset,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_get_image_immediate(&mut self, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32, format: types::Card8, shmseg: types::Seg, offset: types::Card32) -> Result<types::shm::GetImageReply> {
        let request = types::shm::GetImageRequest {
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
            format,
            shmseg,
            offset,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_create_pixmap(&mut self, pid: types::xproto::Pixmap, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16, depth: types::Card8, shmseg: types::Seg, offset: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shm_create_pixmap",
            pid = ?pid,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
            depth = ?depth,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let _enter = span.enter();
        let request = types::shm::CreatePixmapRequest {
            pid,
            drawable,
            width,
            height,
            depth,
            shmseg,
            offset,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_create_pixmap_checked(&mut self, pid: types::xproto::Pixmap, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16, depth: types::Card8, shmseg: types::Seg, offset: types::Card32) -> Result<()> {
        let request = types::shm::CreatePixmapRequest {
            pid,
            drawable,
            width,
            height,
            depth,
            shmseg,
            offset,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_attach_fd(&mut self, shmseg: types::Seg, shm_fd: types::Fd, read_only: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shm_attach_fd",
            shmseg = ?shmseg,
            shm_fd = ?shm_fd,
            read_only = ?read_only,
        );
        let _enter = span.enter();
        let request = types::shm::AttachFdRequest {
            shmseg,
            shm_fd,
            read_only,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_attach_fd_checked(&mut self, shmseg: types::Seg, shm_fd: types::Fd, read_only: types::Bool) -> Result<()> {
        let request = types::shm::AttachFdRequest {
            shmseg,
            shm_fd,
            read_only,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_create_segment(&mut self, shmseg: types::Seg, size: types::Card32, read_only: types::Bool) -> Result<Cookie<types::shm::CreateSegmentReply>> {
        let span = tracing::info_span!(
            "shm_create_segment",
            shmseg = ?shmseg,
            size = ?size,
            read_only = ?read_only,
        );
        let _enter = span.enter();
        let request = types::shm::CreateSegmentRequest {
            shmseg,
            size,
            read_only,
        };
        let cookie = self.send_reply_fd_request(request);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_create_segment_immediate(&mut self, shmseg: types::Seg, size: types::Card32, read_only: types::Bool) -> Result<types::shm::CreateSegmentReply> {
        let request = types::shm::CreateSegmentRequest {
            shmseg,
            size,
            read_only,
        };
        let cookie = self.send_reply_fd_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "sync")]
    fn sync_initialize(&mut self, desired_major_version: types::Card8, desired_minor_version: types::Card8) -> Result<Cookie<types::sync::InitializeReply>> {
        let span = tracing::info_span!(
            "sync_initialize",
            desired_major_version = ?desired_major_version,
            desired_minor_version = ?desired_minor_version,
        );
        let _enter = span.enter();
        let request = types::sync::InitializeRequest {
            desired_major_version,
            desired_minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_initialize_immediate(&mut self, desired_major_version: types::Card8, desired_minor_version: types::Card8) -> Result<types::sync::InitializeReply> {
        let request = types::sync::InitializeRequest {
            desired_major_version,
            desired_minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_list_system_counters(&mut self, ) -> Result<Cookie<types::sync::ListSystemCountersReply>> {
        let span = tracing::info_span!(
            "sync_list_system_counters",
        );
        let _enter = span.enter();
        let request = types::sync::ListSystemCountersRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_list_system_counters_immediate(&mut self, ) -> Result<types::sync::ListSystemCountersReply> {
        let request = types::sync::ListSystemCountersRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_create_counter(&mut self, id: types::Counter, initial_value: types::sync::Int64) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_create_counter",
            id = ?id,
            initial_value = ?initial_value,
        );
        let _enter = span.enter();
        let request = types::sync::CreateCounterRequest {
            id,
            initial_value,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_create_counter_checked(&mut self, id: types::Counter, initial_value: types::sync::Int64) -> Result<()> {
        let request = types::sync::CreateCounterRequest {
            id,
            initial_value,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_counter(&mut self, counter: types::Counter) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_destroy_counter",
            counter = ?counter,
        );
        let _enter = span.enter();
        let request = types::sync::DestroyCounterRequest {
            counter,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_counter_checked(&mut self, counter: types::Counter) -> Result<()> {
        let request = types::sync::DestroyCounterRequest {
            counter,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_query_counter(&mut self, counter: types::Counter) -> Result<Cookie<types::sync::QueryCounterReply>> {
        let span = tracing::info_span!(
            "sync_query_counter",
            counter = ?counter,
        );
        let _enter = span.enter();
        let request = types::sync::QueryCounterRequest {
            counter,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_query_counter_immediate(&mut self, counter: types::Counter) -> Result<types::sync::QueryCounterReply> {
        let request = types::sync::QueryCounterRequest {
            counter,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_await(&mut self, wait_list: impl AsRef<[types::Waitcondition]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_await",
        );
        let _enter = span.enter();
        let request = types::sync::AwaitRequest {
            wait_list: Cow::Borrowed(wait_list.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_await_checked(&mut self, wait_list: impl AsRef<[types::Waitcondition]>) -> Result<()> {
        let request = types::sync::AwaitRequest {
            wait_list: Cow::Borrowed(wait_list.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_change_counter(&mut self, counter: types::Counter, amount: types::sync::Int64) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_change_counter",
            counter = ?counter,
            amount = ?amount,
        );
        let _enter = span.enter();
        let request = types::sync::ChangeCounterRequest {
            counter,
            amount,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_change_counter_checked(&mut self, counter: types::Counter, amount: types::sync::Int64) -> Result<()> {
        let request = types::sync::ChangeCounterRequest {
            counter,
            amount,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_set_counter(&mut self, counter: types::Counter, value: types::sync::Int64) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_set_counter",
            counter = ?counter,
            value = ?value,
        );
        let _enter = span.enter();
        let request = types::sync::SetCounterRequest {
            counter,
            value,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_set_counter_checked(&mut self, counter: types::Counter, value: types::sync::Int64) -> Result<()> {
        let request = types::sync::SetCounterRequest {
            counter,
            value,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_create_alarm(&mut self, id: types::Alarm, value_list: impl Borrow<types::sync::CreateAlarmAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_create_alarm",
            id = ?id,
        );
        let _enter = span.enter();
        let request = types::sync::CreateAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_create_alarm_checked(&mut self, id: types::Alarm, value_list: impl Borrow<types::sync::CreateAlarmAux>) -> Result<()> {
        let request = types::sync::CreateAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_change_alarm(&mut self, id: types::Alarm, value_list: impl Borrow<types::sync::ChangeAlarmAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_change_alarm",
            id = ?id,
        );
        let _enter = span.enter();
        let request = types::sync::ChangeAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_change_alarm_checked(&mut self, id: types::Alarm, value_list: impl Borrow<types::sync::ChangeAlarmAux>) -> Result<()> {
        let request = types::sync::ChangeAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_alarm(&mut self, alarm: types::Alarm) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_destroy_alarm",
            alarm = ?alarm,
        );
        let _enter = span.enter();
        let request = types::sync::DestroyAlarmRequest {
            alarm,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_alarm_checked(&mut self, alarm: types::Alarm) -> Result<()> {
        let request = types::sync::DestroyAlarmRequest {
            alarm,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_query_alarm(&mut self, alarm: types::Alarm) -> Result<Cookie<types::sync::QueryAlarmReply>> {
        let span = tracing::info_span!(
            "sync_query_alarm",
            alarm = ?alarm,
        );
        let _enter = span.enter();
        let request = types::sync::QueryAlarmRequest {
            alarm,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_query_alarm_immediate(&mut self, alarm: types::Alarm) -> Result<types::sync::QueryAlarmReply> {
        let request = types::sync::QueryAlarmRequest {
            alarm,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_set_priority(&mut self, id: types::Card32, priority: types::Int32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_set_priority",
            id = ?id,
            priority = ?priority,
        );
        let _enter = span.enter();
        let request = types::sync::SetPriorityRequest {
            id,
            priority,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_set_priority_checked(&mut self, id: types::Card32, priority: types::Int32) -> Result<()> {
        let request = types::sync::SetPriorityRequest {
            id,
            priority,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_get_priority(&mut self, id: types::Card32) -> Result<Cookie<types::sync::GetPriorityReply>> {
        let span = tracing::info_span!(
            "sync_get_priority",
            id = ?id,
        );
        let _enter = span.enter();
        let request = types::sync::GetPriorityRequest {
            id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_get_priority_immediate(&mut self, id: types::Card32) -> Result<types::sync::GetPriorityReply> {
        let request = types::sync::GetPriorityRequest {
            id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_create_fence(&mut self, drawable: types::xproto::Drawable, fence: types::Fence, initially_triggered: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_create_fence",
            drawable = ?drawable,
            fence = ?fence,
            initially_triggered = ?initially_triggered,
        );
        let _enter = span.enter();
        let request = types::sync::CreateFenceRequest {
            drawable,
            fence,
            initially_triggered,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_create_fence_checked(&mut self, drawable: types::xproto::Drawable, fence: types::Fence, initially_triggered: types::Bool) -> Result<()> {
        let request = types::sync::CreateFenceRequest {
            drawable,
            fence,
            initially_triggered,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_trigger_fence(&mut self, fence: types::Fence) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_trigger_fence",
            fence = ?fence,
        );
        let _enter = span.enter();
        let request = types::sync::TriggerFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_trigger_fence_checked(&mut self, fence: types::Fence) -> Result<()> {
        let request = types::sync::TriggerFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_reset_fence(&mut self, fence: types::Fence) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_reset_fence",
            fence = ?fence,
        );
        let _enter = span.enter();
        let request = types::sync::ResetFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_reset_fence_checked(&mut self, fence: types::Fence) -> Result<()> {
        let request = types::sync::ResetFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_fence(&mut self, fence: types::Fence) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_destroy_fence",
            fence = ?fence,
        );
        let _enter = span.enter();
        let request = types::sync::DestroyFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_fence_checked(&mut self, fence: types::Fence) -> Result<()> {
        let request = types::sync::DestroyFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_query_fence(&mut self, fence: types::Fence) -> Result<Cookie<types::sync::QueryFenceReply>> {
        let span = tracing::info_span!(
            "sync_query_fence",
            fence = ?fence,
        );
        let _enter = span.enter();
        let request = types::sync::QueryFenceRequest {
            fence,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_query_fence_immediate(&mut self, fence: types::Fence) -> Result<types::sync::QueryFenceReply> {
        let request = types::sync::QueryFenceRequest {
            fence,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_await_fence(&mut self, fence_list: impl AsRef<[types::Fence]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_await_fence",
        );
        let _enter = span.enter();
        let request = types::sync::AwaitFenceRequest {
            fence_list: Cow::Borrowed(fence_list.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_await_fence_checked(&mut self, fence_list: impl AsRef<[types::Fence]>) -> Result<()> {
        let request = types::sync::AwaitFenceRequest {
            fence_list: Cow::Borrowed(fence_list.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    fn xc_misc_get_version(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::xc_misc::GetVersionReply>> {
        let span = tracing::info_span!(
            "xc_misc_get_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::xc_misc::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn xc_misc_get_version_immediate(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<types::xc_misc::GetVersionReply> {
        let request = types::xc_misc::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn xc_misc_get_xid_range(&mut self, ) -> Result<Cookie<types::xc_misc::GetXIDRangeReply>> {
        let span = tracing::info_span!(
            "xc_misc_get_xid_range",
        );
        let _enter = span.enter();
        let request = types::xc_misc::GetXIDRangeRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn xc_misc_get_xid_range_immediate(&mut self, ) -> Result<types::xc_misc::GetXIDRangeReply> {
        let request = types::xc_misc::GetXIDRangeRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn xc_misc_get_xid_list(&mut self, count: types::Card32) -> Result<Cookie<types::xc_misc::GetXIDListReply>> {
        let span = tracing::info_span!(
            "xc_misc_get_xid_list",
            count = ?count,
        );
        let _enter = span.enter();
        let request = types::xc_misc::GetXIDListRequest {
            count,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn xc_misc_get_xid_list_immediate(&mut self, count: types::Card32) -> Result<types::xc_misc::GetXIDListReply> {
        let request = types::xc_misc::GetXIDListRequest {
            count,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xevie")]
    fn xevie_query_version(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::xevie::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xevie_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::xevie::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xevie")]
    fn xevie_query_version_immediate(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<types::xevie::QueryVersionReply> {
        let request = types::xevie::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xevie")]
    fn xevie_start(&mut self, screen: types::Card32) -> Result<Cookie<types::xevie::StartReply>> {
        let span = tracing::info_span!(
            "xevie_start",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xevie::StartRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xevie")]
    fn xevie_start_immediate(&mut self, screen: types::Card32) -> Result<types::xevie::StartReply> {
        let request = types::xevie::StartRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xevie")]
    fn xevie_end(&mut self, cmap: types::Card32) -> Result<Cookie<types::xevie::EndReply>> {
        let span = tracing::info_span!(
            "xevie_end",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xevie::EndRequest {
            cmap,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xevie")]
    fn xevie_end_immediate(&mut self, cmap: types::Card32) -> Result<types::xevie::EndReply> {
        let request = types::xevie::EndRequest {
            cmap,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xevie")]
    fn xevie_send(&mut self, event: types::xevie::Event, data_type: types::Card32) -> Result<Cookie<types::xevie::SendReply>> {
        let span = tracing::info_span!(
            "xevie_send",
            event = ?event,
            data_type = ?data_type,
        );
        let _enter = span.enter();
        let request = types::xevie::SendRequest {
            event,
            data_type,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xevie")]
    fn xevie_send_immediate(&mut self, event: types::xevie::Event, data_type: types::Card32) -> Result<types::xevie::SendReply> {
        let request = types::xevie::SendRequest {
            event,
            data_type,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xevie")]
    fn xevie_select_input(&mut self, event_mask: types::Card32) -> Result<Cookie<types::xevie::SelectInputReply>> {
        let span = tracing::info_span!(
            "xevie_select_input",
            event_mask = ?event_mask,
        );
        let _enter = span.enter();
        let request = types::xevie::SelectInputRequest {
            event_mask,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xevie")]
    fn xevie_select_input_immediate(&mut self, event_mask: types::Card32) -> Result<types::xevie::SelectInputReply> {
        let request = types::xevie::SelectInputRequest {
            event_mask,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_version(&mut self, ) -> Result<Cookie<types::xf86dri::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xf86dri_query_version",
        );
        let _enter = span.enter();
        let request = types::xf86dri::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_version_immediate(&mut self, ) -> Result<types::xf86dri::QueryVersionReply> {
        let request = types::xf86dri::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_direct_rendering_capable(&mut self, screen: types::Card32) -> Result<Cookie<types::xf86dri::QueryDirectRenderingCapableReply>> {
        let span = tracing::info_span!(
            "xf86dri_query_direct_rendering_capable",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86dri::QueryDirectRenderingCapableRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_direct_rendering_capable_immediate(&mut self, screen: types::Card32) -> Result<types::xf86dri::QueryDirectRenderingCapableReply> {
        let request = types::xf86dri::QueryDirectRenderingCapableRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_open_connection(&mut self, screen: types::Card32) -> Result<Cookie<types::xf86dri::OpenConnectionReply>> {
        let span = tracing::info_span!(
            "xf86dri_open_connection",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86dri::OpenConnectionRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_open_connection_immediate(&mut self, screen: types::Card32) -> Result<types::xf86dri::OpenConnectionReply> {
        let request = types::xf86dri::OpenConnectionRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_close_connection(&mut self, screen: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86dri_close_connection",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86dri::CloseConnectionRequest {
            screen,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_close_connection_checked(&mut self, screen: types::Card32) -> Result<()> {
        let request = types::xf86dri::CloseConnectionRequest {
            screen,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_client_driver_name(&mut self, screen: types::Card32) -> Result<Cookie<types::xf86dri::GetClientDriverNameReply>> {
        let span = tracing::info_span!(
            "xf86dri_get_client_driver_name",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86dri::GetClientDriverNameRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_client_driver_name_immediate(&mut self, screen: types::Card32) -> Result<types::xf86dri::GetClientDriverNameReply> {
        let request = types::xf86dri::GetClientDriverNameRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_context(&mut self, screen: types::Card32, visual: types::Card32, context: types::Card32) -> Result<Cookie<types::xf86dri::CreateContextReply>> {
        let span = tracing::info_span!(
            "xf86dri_create_context",
            screen = ?screen,
            visual = ?visual,
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xf86dri::CreateContextRequest {
            screen,
            visual,
            context,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_context_immediate(&mut self, screen: types::Card32, visual: types::Card32, context: types::Card32) -> Result<types::xf86dri::CreateContextReply> {
        let request = types::xf86dri::CreateContextRequest {
            screen,
            visual,
            context,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_context(&mut self, screen: types::Card32, context: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86dri_destroy_context",
            screen = ?screen,
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xf86dri::DestroyContextRequest {
            screen,
            context,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_context_checked(&mut self, screen: types::Card32, context: types::Card32) -> Result<()> {
        let request = types::xf86dri::DestroyContextRequest {
            screen,
            context,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_drawable(&mut self, screen: types::Card32, drawable: types::Card32) -> Result<Cookie<types::xf86dri::CreateDrawableReply>> {
        let span = tracing::info_span!(
            "xf86dri_create_drawable",
            screen = ?screen,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xf86dri::CreateDrawableRequest {
            screen,
            drawable,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_drawable_immediate(&mut self, screen: types::Card32, drawable: types::Card32) -> Result<types::xf86dri::CreateDrawableReply> {
        let request = types::xf86dri::CreateDrawableRequest {
            screen,
            drawable,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_drawable(&mut self, screen: types::Card32, drawable: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86dri_destroy_drawable",
            screen = ?screen,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xf86dri::DestroyDrawableRequest {
            screen,
            drawable,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_drawable_checked(&mut self, screen: types::Card32, drawable: types::Card32) -> Result<()> {
        let request = types::xf86dri::DestroyDrawableRequest {
            screen,
            drawable,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_drawable_info(&mut self, screen: types::Card32, drawable: types::Card32) -> Result<Cookie<types::xf86dri::GetDrawableInfoReply>> {
        let span = tracing::info_span!(
            "xf86dri_get_drawable_info",
            screen = ?screen,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xf86dri::GetDrawableInfoRequest {
            screen,
            drawable,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_drawable_info_immediate(&mut self, screen: types::Card32, drawable: types::Card32) -> Result<types::xf86dri::GetDrawableInfoReply> {
        let request = types::xf86dri::GetDrawableInfoRequest {
            screen,
            drawable,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_device_info(&mut self, screen: types::Card32) -> Result<Cookie<types::xf86dri::GetDeviceInfoReply>> {
        let span = tracing::info_span!(
            "xf86dri_get_device_info",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86dri::GetDeviceInfoRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_device_info_immediate(&mut self, screen: types::Card32) -> Result<types::xf86dri::GetDeviceInfoReply> {
        let request = types::xf86dri::GetDeviceInfoRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_auth_connection(&mut self, screen: types::Card32, magic: types::Card32) -> Result<Cookie<types::xf86dri::AuthConnectionReply>> {
        let span = tracing::info_span!(
            "xf86dri_auth_connection",
            screen = ?screen,
            magic = ?magic,
        );
        let _enter = span.enter();
        let request = types::xf86dri::AuthConnectionRequest {
            screen,
            magic,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_auth_connection_immediate(&mut self, screen: types::Card32, magic: types::Card32) -> Result<types::xf86dri::AuthConnectionReply> {
        let request = types::xf86dri::AuthConnectionRequest {
            screen,
            magic,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_query_version(&mut self, ) -> Result<Cookie<types::xf86vidmode::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_query_version",
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_query_version_immediate(&mut self, ) -> Result<types::xf86vidmode::QueryVersionReply> {
        let request = types::xf86vidmode::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_mode_line(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetModeLineReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_mode_line",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetModeLineRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_mode_line_immediate(&mut self, screen: types::Card16) -> Result<types::xf86vidmode::GetModeLineReply> {
        let request = types::xf86vidmode::GetModeLineRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_mod_mode_line(&mut self, screen: types::Card32, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_mod_mode_line",
            screen = ?screen,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::ModModeLineRequest {
            screen,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_mod_mode_line_checked(&mut self, screen: types::Card32, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<()> {
        let request = types::xf86vidmode::ModModeLineRequest {
            screen,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_mode(&mut self, screen: types::Card16, zoom: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_switch_mode",
            screen = ?screen,
            zoom = ?zoom,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SwitchModeRequest {
            screen,
            zoom,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_mode_checked(&mut self, screen: types::Card16, zoom: types::Card16) -> Result<()> {
        let request = types::xf86vidmode::SwitchModeRequest {
            screen,
            zoom,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_monitor(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetMonitorReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_monitor",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetMonitorRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_monitor_immediate(&mut self, screen: types::Card16) -> Result<types::xf86vidmode::GetMonitorReply> {
        let request = types::xf86vidmode::GetMonitorRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_lock_mode_switch(&mut self, screen: types::Card16, lock: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_lock_mode_switch",
            screen = ?screen,
            lock = ?lock,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::LockModeSwitchRequest {
            screen,
            lock,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_lock_mode_switch_checked(&mut self, screen: types::Card16, lock: types::Card16) -> Result<()> {
        let request = types::xf86vidmode::LockModeSwitchRequest {
            screen,
            lock,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_all_mode_lines(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetAllModeLinesReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_all_mode_lines",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetAllModeLinesRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_all_mode_lines_immediate(&mut self, screen: types::Card16) -> Result<types::xf86vidmode::GetAllModeLinesReply> {
        let request = types::xf86vidmode::GetAllModeLinesRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_add_mode_line(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, after_dotclock: types::Dotclock, after_hdisplay: types::Card16, after_hsyncstart: types::Card16, after_hsyncend: types::Card16, after_htotal: types::Card16, after_hskew: types::Card16, after_vdisplay: types::Card16, after_vsyncstart: types::Card16, after_vsyncend: types::Card16, after_vtotal: types::Card16, after_flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_add_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
            after_dotclock = ?after_dotclock,
            after_hdisplay = ?after_hdisplay,
            after_hsyncstart = ?after_hsyncstart,
            after_hsyncend = ?after_hsyncend,
            after_htotal = ?after_htotal,
            after_hskew = ?after_hskew,
            after_vdisplay = ?after_vdisplay,
            after_vsyncstart = ?after_vsyncstart,
            after_vsyncend = ?after_vsyncend,
            after_vtotal = ?after_vtotal,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::AddModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            after_dotclock,
            after_hdisplay,
            after_hsyncstart,
            after_hsyncend,
            after_htotal,
            after_hskew,
            after_vdisplay,
            after_vsyncstart,
            after_vsyncend,
            after_vtotal,
            after_flags: Into::<u32>::into(after_flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_add_mode_line_checked(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, after_dotclock: types::Dotclock, after_hdisplay: types::Card16, after_hsyncstart: types::Card16, after_hsyncend: types::Card16, after_htotal: types::Card16, after_hskew: types::Card16, after_vdisplay: types::Card16, after_vsyncstart: types::Card16, after_vsyncend: types::Card16, after_vtotal: types::Card16, after_flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<()> {
        let request = types::xf86vidmode::AddModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            after_dotclock,
            after_hdisplay,
            after_hsyncstart,
            after_hsyncend,
            after_htotal,
            after_hskew,
            after_vdisplay,
            after_vsyncstart,
            after_vsyncend,
            after_vtotal,
            after_flags: Into::<u32>::into(after_flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_delete_mode_line(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_delete_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::DeleteModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_delete_mode_line_checked(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<()> {
        let request = types::xf86vidmode::DeleteModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_validate_mode_line(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<Cookie<types::xf86vidmode::ValidateModeLineReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_validate_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::ValidateModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_validate_mode_line_immediate(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<types::xf86vidmode::ValidateModeLineReply> {
        let request = types::xf86vidmode::ValidateModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_to_mode(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_switch_to_mode",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SwitchToModeRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_to_mode_checked(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<()> {
        let request = types::xf86vidmode::SwitchToModeRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_view_port(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetViewPortReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_view_port",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetViewPortRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_view_port_immediate(&mut self, screen: types::Card16) -> Result<types::xf86vidmode::GetViewPortReply> {
        let request = types::xf86vidmode::GetViewPortRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_view_port(&mut self, screen: types::Card16, x: types::Card32, y: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_view_port",
            screen = ?screen,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SetViewPortRequest {
            screen,
            x,
            y,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_view_port_checked(&mut self, screen: types::Card16, x: types::Card32, y: types::Card32) -> Result<()> {
        let request = types::xf86vidmode::SetViewPortRequest {
            screen,
            x,
            y,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_dot_clocks(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetDotClocksReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_dot_clocks",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetDotClocksRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_dot_clocks_immediate(&mut self, screen: types::Card16) -> Result<types::xf86vidmode::GetDotClocksReply> {
        let request = types::xf86vidmode::GetDotClocksRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_client_version(&mut self, major: types::Card16, minor: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_client_version",
            major = ?major,
            minor = ?minor,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SetClientVersionRequest {
            major,
            minor,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_client_version_checked(&mut self, major: types::Card16, minor: types::Card16) -> Result<()> {
        let request = types::xf86vidmode::SetClientVersionRequest {
            major,
            minor,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma(&mut self, screen: types::Card16, red: types::Card32, green: types::Card32, blue: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_gamma",
            screen = ?screen,
            red = ?red,
            green = ?green,
            blue = ?blue,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SetGammaRequest {
            screen,
            red,
            green,
            blue,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_checked(&mut self, screen: types::Card16, red: types::Card32, green: types::Card32, blue: types::Card32) -> Result<()> {
        let request = types::xf86vidmode::SetGammaRequest {
            screen,
            red,
            green,
            blue,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetGammaReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetGammaRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_immediate(&mut self, screen: types::Card16) -> Result<types::xf86vidmode::GetGammaReply> {
        let request = types::xf86vidmode::GetGammaRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp(&mut self, screen: types::Card16, size: types::Card16) -> Result<Cookie<types::xf86vidmode::GetGammaRampReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma_ramp",
            screen = ?screen,
            size = ?size,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetGammaRampRequest {
            screen,
            size,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_immediate(&mut self, screen: types::Card16, size: types::Card16) -> Result<types::xf86vidmode::GetGammaRampReply> {
        let request = types::xf86vidmode::GetGammaRampRequest {
            screen,
            size,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_ramp(&mut self, screen: types::Card16, size: types::Card16, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_gamma_ramp",
            screen = ?screen,
            size = ?size,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SetGammaRampRequest {
            screen,
            size,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_ramp_checked(&mut self, screen: types::Card16, size: types::Card16, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> Result<()> {
        let request = types::xf86vidmode::SetGammaRampRequest {
            screen,
            size,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_size(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetGammaRampSizeReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma_ramp_size",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetGammaRampSizeRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_size_immediate(&mut self, screen: types::Card16) -> Result<types::xf86vidmode::GetGammaRampSizeReply> {
        let request = types::xf86vidmode::GetGammaRampSizeRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_permissions(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetPermissionsReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_permissions",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetPermissionsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_permissions_immediate(&mut self, screen: types::Card16) -> Result<types::xf86vidmode::GetPermissionsReply> {
        let request = types::xf86vidmode::GetPermissionsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xfixes")]
    fn xfixes_query_version(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::xfixes::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xfixes_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::xfixes::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_query_version_immediate(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<types::xfixes::QueryVersionReply> {
        let request = types::xfixes::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_save_set(&mut self, mode: types::SaveSetMode, target: types::SaveSetTarget, map: types::SaveSetMapping, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_change_save_set",
            mode = ?mode,
            target = ?target,
            map = ?map,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xfixes::ChangeSaveSetRequest {
            mode,
            target,
            map,
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_save_set_checked(&mut self, mode: types::SaveSetMode, target: types::SaveSetTarget, map: types::SaveSetMapping, window: types::xproto::Window) -> Result<()> {
        let request = types::xfixes::ChangeSaveSetRequest {
            mode,
            target,
            map,
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_selection_input(&mut self, window: types::xproto::Window, selection: types::Atom, event_mask: impl Into<types::SelectionEventMask>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_select_selection_input",
            window = ?window,
            selection = ?selection,
        );
        let _enter = span.enter();
        let request = types::xfixes::SelectSelectionInputRequest {
            window,
            selection,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_selection_input_checked(&mut self, window: types::xproto::Window, selection: types::Atom, event_mask: impl Into<types::SelectionEventMask>) -> Result<()> {
        let request = types::xfixes::SelectSelectionInputRequest {
            window,
            selection,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_cursor_input(&mut self, window: types::xproto::Window, event_mask: impl Into<types::CursorNotifyMask>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_select_cursor_input",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xfixes::SelectCursorInputRequest {
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_cursor_input_checked(&mut self, window: types::xproto::Window, event_mask: impl Into<types::CursorNotifyMask>) -> Result<()> {
        let request = types::xfixes::SelectCursorInputRequest {
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image(&mut self, ) -> Result<Cookie<types::xfixes::GetCursorImageReply>> {
        let span = tracing::info_span!(
            "xfixes_get_cursor_image",
        );
        let _enter = span.enter();
        let request = types::xfixes::GetCursorImageRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_immediate(&mut self, ) -> Result<types::xfixes::GetCursorImageReply> {
        let request = types::xfixes::GetCursorImageRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region(&mut self, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_region",
            region = ?region,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreateRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_checked(&mut self, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> Result<()> {
        let request = types::xfixes::CreateRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_bitmap(&mut self, region: types::Region, bitmap: types::xproto::Pixmap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_bitmap",
            region = ?region,
            bitmap = ?bitmap,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreateRegionFromBitmapRequest {
            region,
            bitmap,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_bitmap_checked(&mut self, region: types::Region, bitmap: types::xproto::Pixmap) -> Result<()> {
        let request = types::xfixes::CreateRegionFromBitmapRequest {
            region,
            bitmap,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_window(&mut self, region: types::Region, window: types::xproto::Window, kind: types::SK) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_window",
            region = ?region,
            window = ?window,
            kind = ?kind,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreateRegionFromWindowRequest {
            region,
            window,
            kind,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_window_checked(&mut self, region: types::Region, window: types::xproto::Window, kind: types::SK) -> Result<()> {
        let request = types::xfixes::CreateRegionFromWindowRequest {
            region,
            window,
            kind,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_gc(&mut self, region: types::Region, gc: types::Gcontext) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_gc",
            region = ?region,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreateRegionFromGCRequest {
            region,
            gc,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_gc_checked(&mut self, region: types::Region, gc: types::Gcontext) -> Result<()> {
        let request = types::xfixes::CreateRegionFromGCRequest {
            region,
            gc,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_picture(&mut self, region: types::Region, picture: types::Picture) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_picture",
            region = ?region,
            picture = ?picture,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreateRegionFromPictureRequest {
            region,
            picture,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_picture_checked(&mut self, region: types::Region, picture: types::Picture) -> Result<()> {
        let request = types::xfixes::CreateRegionFromPictureRequest {
            region,
            picture,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_destroy_region(&mut self, region: types::Region) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_destroy_region",
            region = ?region,
        );
        let _enter = span.enter();
        let request = types::xfixes::DestroyRegionRequest {
            region,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_destroy_region_checked(&mut self, region: types::Region) -> Result<()> {
        let request = types::xfixes::DestroyRegionRequest {
            region,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_region(&mut self, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_set_region",
            region = ?region,
        );
        let _enter = span.enter();
        let request = types::xfixes::SetRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_region_checked(&mut self, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> Result<()> {
        let request = types::xfixes::SetRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_copy_region(&mut self, source: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_copy_region",
            source = ?source,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::CopyRegionRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_copy_region_checked(&mut self, source: types::Region, destination: types::Region) -> Result<()> {
        let request = types::xfixes::CopyRegionRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_union_region(&mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_union_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::UnionRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_union_region_checked(&mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<()> {
        let request = types::xfixes::UnionRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_intersect_region(&mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_intersect_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::IntersectRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_intersect_region_checked(&mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<()> {
        let request = types::xfixes::IntersectRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_subtract_region(&mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_subtract_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::SubtractRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_subtract_region_checked(&mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<()> {
        let request = types::xfixes::SubtractRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_invert_region(&mut self, source: types::Region, bounds: types::Rectangle, destination: types::Region) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_invert_region",
            source = ?source,
            bounds = ?bounds,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::InvertRegionRequest {
            source,
            bounds,
            destination,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_invert_region_checked(&mut self, source: types::Region, bounds: types::Rectangle, destination: types::Region) -> Result<()> {
        let request = types::xfixes::InvertRegionRequest {
            source,
            bounds,
            destination,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_translate_region(&mut self, region: types::Region, dx: types::Int16, dy: types::Int16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_translate_region",
            region = ?region,
            dx = ?dx,
            dy = ?dy,
        );
        let _enter = span.enter();
        let request = types::xfixes::TranslateRegionRequest {
            region,
            dx,
            dy,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_translate_region_checked(&mut self, region: types::Region, dx: types::Int16, dy: types::Int16) -> Result<()> {
        let request = types::xfixes::TranslateRegionRequest {
            region,
            dx,
            dy,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_region_extents(&mut self, source: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_region_extents",
            source = ?source,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::RegionExtentsRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_region_extents_checked(&mut self, source: types::Region, destination: types::Region) -> Result<()> {
        let request = types::xfixes::RegionExtentsRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_fetch_region(&mut self, region: types::Region) -> Result<Cookie<types::xfixes::FetchRegionReply>> {
        let span = tracing::info_span!(
            "xfixes_fetch_region",
            region = ?region,
        );
        let _enter = span.enter();
        let request = types::xfixes::FetchRegionRequest {
            region,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_fetch_region_immediate(&mut self, region: types::Region) -> Result<types::xfixes::FetchRegionReply> {
        let request = types::xfixes::FetchRegionRequest {
            region,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_gc_clip_region(&mut self, gc: types::Gcontext, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_set_gc_clip_region",
            gc = ?gc,
            x_origin = ?x_origin,
            y_origin = ?y_origin,
        );
        let _enter = span.enter();
        let request = types::xfixes::SetGCClipRegionRequest {
            gc,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_gc_clip_region_checked(&mut self, gc: types::Gcontext, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> Result<()> {
        let request = types::xfixes::SetGCClipRegionRequest {
            gc,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_window_shape_region(&mut self, dest: types::xproto::Window, dest_kind: types::SK, x_offset: types::Int16, y_offset: types::Int16, region: impl Into<types::Region>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_set_window_shape_region",
            dest = ?dest,
            dest_kind = ?dest_kind,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let _enter = span.enter();
        let request = types::xfixes::SetWindowShapeRegionRequest {
            dest,
            dest_kind,
            x_offset,
            y_offset,
            region: Into::<u32>::into(region.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_window_shape_region_checked(&mut self, dest: types::xproto::Window, dest_kind: types::SK, x_offset: types::Int16, y_offset: types::Int16, region: impl Into<types::Region>) -> Result<()> {
        let request = types::xfixes::SetWindowShapeRegionRequest {
            dest,
            dest_kind,
            x_offset,
            y_offset,
            region: Into::<u32>::into(region.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_picture_clip_region(&mut self, picture: types::Picture, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_set_picture_clip_region",
            picture = ?picture,
            x_origin = ?x_origin,
            y_origin = ?y_origin,
        );
        let _enter = span.enter();
        let request = types::xfixes::SetPictureClipRegionRequest {
            picture,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_picture_clip_region_checked(&mut self, picture: types::Picture, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> Result<()> {
        let request = types::xfixes::SetPictureClipRegionRequest {
            picture,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_cursor_name(&mut self, cursor: types::xproto::Cursor, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_set_cursor_name",
            cursor = ?cursor,
        );
        let _enter = span.enter();
        let request = types::xfixes::SetCursorNameRequest {
            cursor,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_cursor_name_checked(&mut self, cursor: types::xproto::Cursor, name: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xfixes::SetCursorNameRequest {
            cursor,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_name(&mut self, cursor: types::xproto::Cursor) -> Result<Cookie<types::xfixes::GetCursorNameReply>> {
        let span = tracing::info_span!(
            "xfixes_get_cursor_name",
            cursor = ?cursor,
        );
        let _enter = span.enter();
        let request = types::xfixes::GetCursorNameRequest {
            cursor,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_name_immediate(&mut self, cursor: types::xproto::Cursor) -> Result<types::xfixes::GetCursorNameReply> {
        let request = types::xfixes::GetCursorNameRequest {
            cursor,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_and_name(&mut self, ) -> Result<Cookie<types::xfixes::GetCursorImageAndNameReply>> {
        let span = tracing::info_span!(
            "xfixes_get_cursor_image_and_name",
        );
        let _enter = span.enter();
        let request = types::xfixes::GetCursorImageAndNameRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_and_name_immediate(&mut self, ) -> Result<types::xfixes::GetCursorImageAndNameReply> {
        let request = types::xfixes::GetCursorImageAndNameRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor(&mut self, source: types::xproto::Cursor, destination: types::xproto::Cursor) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_change_cursor",
            source = ?source,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::ChangeCursorRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_checked(&mut self, source: types::xproto::Cursor, destination: types::xproto::Cursor) -> Result<()> {
        let request = types::xfixes::ChangeCursorRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_by_name(&mut self, src: types::xproto::Cursor, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_change_cursor_by_name",
            src = ?src,
        );
        let _enter = span.enter();
        let request = types::xfixes::ChangeCursorByNameRequest {
            src,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_by_name_checked(&mut self, src: types::xproto::Cursor, name: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xfixes::ChangeCursorByNameRequest {
            src,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_expand_region(&mut self, source: types::Region, destination: types::Region, left: types::Card16, right: types::Card16, top: types::Card16, bottom: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_expand_region",
            source = ?source,
            destination = ?destination,
            left = ?left,
            right = ?right,
            top = ?top,
            bottom = ?bottom,
        );
        let _enter = span.enter();
        let request = types::xfixes::ExpandRegionRequest {
            source,
            destination,
            left,
            right,
            top,
            bottom,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_expand_region_checked(&mut self, source: types::Region, destination: types::Region, left: types::Card16, right: types::Card16, top: types::Card16, bottom: types::Card16) -> Result<()> {
        let request = types::xfixes::ExpandRegionRequest {
            source,
            destination,
            left,
            right,
            top,
            bottom,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_hide_cursor(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_hide_cursor",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xfixes::HideCursorRequest {
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_hide_cursor_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let request = types::xfixes::HideCursorRequest {
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_show_cursor(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_show_cursor",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xfixes::ShowCursorRequest {
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_show_cursor_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let request = types::xfixes::ShowCursorRequest {
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_pointer_barrier(&mut self, barrier: types::Barrier, window: types::xproto::Window, x1: types::Card16, y1: types::Card16, x2: types::Card16, y2: types::Card16, directions: impl Into<types::BarrierDirections>, devices: impl AsRef<[types::Card16]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_pointer_barrier",
            barrier = ?barrier,
            window = ?window,
            x1 = ?x1,
            y1 = ?y1,
            x2 = ?x2,
            y2 = ?y2,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreatePointerBarrierRequest {
            barrier,
            window,
            x1,
            y1,
            x2,
            y2,
            directions: Into::<u32>::into(directions.into()) as _,
            devices: Cow::Borrowed(devices.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_pointer_barrier_checked(&mut self, barrier: types::Barrier, window: types::xproto::Window, x1: types::Card16, y1: types::Card16, x2: types::Card16, y2: types::Card16, directions: impl Into<types::BarrierDirections>, devices: impl AsRef<[types::Card16]>) -> Result<()> {
        let request = types::xfixes::CreatePointerBarrierRequest {
            barrier,
            window,
            x1,
            y1,
            x2,
            y2,
            directions: Into::<u32>::into(directions.into()) as _,
            devices: Cow::Borrowed(devices.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_delete_pointer_barrier(&mut self, barrier: types::Barrier) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_delete_pointer_barrier",
            barrier = ?barrier,
        );
        let _enter = span.enter();
        let request = types::xfixes::DeletePointerBarrierRequest {
            barrier,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_delete_pointer_barrier_checked(&mut self, barrier: types::Barrier) -> Result<()> {
        let request = types::xfixes::DeletePointerBarrierRequest {
            barrier,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xinerama")]
    fn xinerama_query_version(&mut self, major: types::Card8, minor: types::Card8) -> Result<Cookie<types::xinerama::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xinerama_query_version",
            major = ?major,
            minor = ?minor,
        );
        let _enter = span.enter();
        let request = types::xinerama::QueryVersionRequest {
            major,
            minor,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_version_immediate(&mut self, major: types::Card8, minor: types::Card8) -> Result<types::xinerama::QueryVersionReply> {
        let request = types::xinerama::QueryVersionRequest {
            major,
            minor,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_state(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinerama::GetStateReply>> {
        let span = tracing::info_span!(
            "xinerama_get_state",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinerama::GetStateRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_state_immediate(&mut self, window: types::xproto::Window) -> Result<types::xinerama::GetStateReply> {
        let request = types::xinerama::GetStateRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_count(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinerama::GetScreenCountReply>> {
        let span = tracing::info_span!(
            "xinerama_get_screen_count",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinerama::GetScreenCountRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_count_immediate(&mut self, window: types::xproto::Window) -> Result<types::xinerama::GetScreenCountReply> {
        let request = types::xinerama::GetScreenCountRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_size(&mut self, window: types::xproto::Window, screen: types::Card32) -> Result<Cookie<types::xinerama::GetScreenSizeReply>> {
        let span = tracing::info_span!(
            "xinerama_get_screen_size",
            window = ?window,
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xinerama::GetScreenSizeRequest {
            window,
            screen,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_size_immediate(&mut self, window: types::xproto::Window, screen: types::Card32) -> Result<types::xinerama::GetScreenSizeReply> {
        let request = types::xinerama::GetScreenSizeRequest {
            window,
            screen,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_is_active(&mut self, ) -> Result<Cookie<types::xinerama::IsActiveReply>> {
        let span = tracing::info_span!(
            "xinerama_is_active",
        );
        let _enter = span.enter();
        let request = types::xinerama::IsActiveRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_is_active_immediate(&mut self, ) -> Result<types::xinerama::IsActiveReply> {
        let request = types::xinerama::IsActiveRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_screens(&mut self, ) -> Result<Cookie<types::xinerama::QueryScreensReply>> {
        let span = tracing::info_span!(
            "xinerama_query_screens",
        );
        let _enter = span.enter();
        let request = types::xinerama::QueryScreensRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_screens_immediate(&mut self, ) -> Result<types::xinerama::QueryScreensReply> {
        let request = types::xinerama::QueryScreensRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xinput")]
    fn xinput_get_extension_version(&mut self, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::xinput::GetExtensionVersionReply>> {
        let span = tracing::info_span!(
            "xinput_get_extension_version",
        );
        let _enter = span.enter();
        let request = types::xinput::GetExtensionVersionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_extension_version_immediate(&mut self, name: impl AsRef<[types::Char]>) -> Result<types::xinput::GetExtensionVersionReply> {
        let request = types::xinput::GetExtensionVersionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_input_devices(&mut self, ) -> Result<Cookie<types::xinput::ListInputDevicesReply>> {
        let span = tracing::info_span!(
            "xinput_list_input_devices",
        );
        let _enter = span.enter();
        let request = types::xinput::ListInputDevicesRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_input_devices_immediate(&mut self, ) -> Result<types::xinput::ListInputDevicesReply> {
        let request = types::xinput::ListInputDevicesRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_open_device(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::OpenDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_open_device",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::OpenDeviceRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_open_device_immediate(&mut self, device_id: types::Card8) -> Result<types::xinput::OpenDeviceReply> {
        let request = types::xinput::OpenDeviceRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_close_device(&mut self, device_id: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_close_device",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::CloseDeviceRequest {
            device_id,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_close_device_checked(&mut self, device_id: types::Card8) -> Result<()> {
        let request = types::xinput::CloseDeviceRequest {
            device_id,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_mode(&mut self, device_id: types::Card8, mode: types::ValuatorMode) -> Result<Cookie<types::xinput::SetDeviceModeReply>> {
        let span = tracing::info_span!(
            "xinput_set_device_mode",
            device_id = ?device_id,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xinput::SetDeviceModeRequest {
            device_id,
            mode,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_mode_immediate(&mut self, device_id: types::Card8, mode: types::ValuatorMode) -> Result<types::xinput::SetDeviceModeReply> {
        let request = types::xinput::SetDeviceModeRequest {
            device_id,
            mode,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_select_extension_event(&mut self, window: types::xproto::Window, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_select_extension_event",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::SelectExtensionEventRequest {
            window,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_select_extension_event_checked(&mut self, window: types::xproto::Window, classes: impl AsRef<[types::EventClass]>) -> Result<()> {
        let request = types::xinput::SelectExtensionEventRequest {
            window,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_selected_extension_events(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinput::GetSelectedExtensionEventsReply>> {
        let span = tracing::info_span!(
            "xinput_get_selected_extension_events",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::GetSelectedExtensionEventsRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_selected_extension_events_immediate(&mut self, window: types::xproto::Window) -> Result<types::xinput::GetSelectedExtensionEventsReply> {
        let request = types::xinput::GetSelectedExtensionEventsRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_dont_propagate_list(&mut self, window: types::xproto::Window, mode: types::PropagateMode, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_change_device_dont_propagate_list",
            window = ?window,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeDeviceDontPropagateListRequest {
            window,
            mode,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_dont_propagate_list_checked(&mut self, window: types::xproto::Window, mode: types::PropagateMode, classes: impl AsRef<[types::EventClass]>) -> Result<()> {
        let request = types::xinput::ChangeDeviceDontPropagateListRequest {
            window,
            mode,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_dont_propagate_list(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinput::GetDeviceDontPropagateListReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_dont_propagate_list",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceDontPropagateListRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_dont_propagate_list_immediate(&mut self, window: types::xproto::Window) -> Result<types::xinput::GetDeviceDontPropagateListReply> {
        let request = types::xinput::GetDeviceDontPropagateListRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_motion_events(&mut self, start: types::Timestamp, stop: impl Into<types::Time>, device_id: types::Card8) -> Result<Cookie<types::xinput::GetDeviceMotionEventsReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_motion_events",
            start = ?start,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceMotionEventsRequest {
            start,
            stop: Into::<u32>::into(stop.into()) as _,
            device_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_motion_events_immediate(&mut self, start: types::Timestamp, stop: impl Into<types::Time>, device_id: types::Card8) -> Result<types::xinput::GetDeviceMotionEventsReply> {
        let request = types::xinput::GetDeviceMotionEventsRequest {
            start,
            stop: Into::<u32>::into(stop.into()) as _,
            device_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_keyboard_device(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::ChangeKeyboardDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_change_keyboard_device",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeKeyboardDeviceRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_keyboard_device_immediate(&mut self, device_id: types::Card8) -> Result<types::xinput::ChangeKeyboardDeviceReply> {
        let request = types::xinput::ChangeKeyboardDeviceRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_pointer_device(&mut self, x_axis: types::Card8, y_axis: types::Card8, device_id: types::Card8) -> Result<Cookie<types::xinput::ChangePointerDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_change_pointer_device",
            x_axis = ?x_axis,
            y_axis = ?y_axis,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangePointerDeviceRequest {
            x_axis,
            y_axis,
            device_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_pointer_device_immediate(&mut self, x_axis: types::Card8, y_axis: types::Card8, device_id: types::Card8) -> Result<types::xinput::ChangePointerDeviceReply> {
        let request = types::xinput::ChangePointerDeviceRequest {
            x_axis,
            y_axis,
            device_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device(&mut self, grab_window: types::xproto::Window, time: impl Into<types::Time>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, device_id: types::Card8, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<types::xinput::GrabDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_grab_device",
            grab_window = ?grab_window,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GrabDeviceRequest {
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            device_id,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_immediate(&mut self, grab_window: types::xproto::Window, time: impl Into<types::Time>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, device_id: types::Card8, classes: impl AsRef<[types::EventClass]>) -> Result<types::xinput::GrabDeviceReply> {
        let request = types::xinput::GrabDeviceRequest {
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            device_id,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device(&mut self, time: impl Into<types::Time>, device_id: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_ungrab_device",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::UngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            device_id,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_checked(&mut self, time: impl Into<types::Time>, device_id: types::Card8) -> Result<()> {
        let request = types::xinput::UngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            device_id,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_key(&mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, grabbed_device: types::Card8, key: impl Into<types::Grab>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_grab_device_key",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
        );
        let _enter = span.enter();
        let request = types::xinput::GrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            grabbed_device,
            key: Into::<u32>::into(key.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_key_checked(&mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, grabbed_device: types::Card8, key: impl Into<types::Grab>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> Result<()> {
        let request = types::xinput::GrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            grabbed_device,
            key: Into::<u32>::into(key.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_key(&mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, key: impl Into<types::Grab>, grabbed_device: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_ungrab_device_key",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
        );
        let _enter = span.enter();
        let request = types::xinput::UngrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            grabbed_device,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_key_checked(&mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, key: impl Into<types::Grab>, grabbed_device: types::Card8) -> Result<()> {
        let request = types::xinput::UngrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            grabbed_device,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_button(&mut self, grab_window: types::xproto::Window, grabbed_device: types::Card8, modifier_device: impl Into<types::ModifierDevice>, modifiers: impl Into<types::ModMask>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, button: impl Into<types::Grab>, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_grab_device_button",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
        );
        let _enter = span.enter();
        let request = types::xinput::GrabDeviceButtonRequest {
            grab_window,
            grabbed_device,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            this_device_mode,
            other_device_mode,
            button: Into::<u32>::into(button.into()) as _,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_button_checked(&mut self, grab_window: types::xproto::Window, grabbed_device: types::Card8, modifier_device: impl Into<types::ModifierDevice>, modifiers: impl Into<types::ModMask>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, button: impl Into<types::Grab>, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> Result<()> {
        let request = types::xinput::GrabDeviceButtonRequest {
            grab_window,
            grabbed_device,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            this_device_mode,
            other_device_mode,
            button: Into::<u32>::into(button.into()) as _,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_button(&mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, button: impl Into<types::Grab>, grabbed_device: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_ungrab_device_button",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
        );
        let _enter = span.enter();
        let request = types::xinput::UngrabDeviceButtonRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            button: Into::<u32>::into(button.into()) as _,
            grabbed_device,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_button_checked(&mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, button: impl Into<types::Grab>, grabbed_device: types::Card8) -> Result<()> {
        let request = types::xinput::UngrabDeviceButtonRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            button: Into::<u32>::into(button.into()) as _,
            grabbed_device,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_allow_device_events(&mut self, time: impl Into<types::Time>, mode: types::DeviceInputMode, device_id: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_allow_device_events",
            mode = ?mode,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::AllowDeviceEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            mode,
            device_id,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_allow_device_events_checked(&mut self, time: impl Into<types::Time>, mode: types::DeviceInputMode, device_id: types::Card8) -> Result<()> {
        let request = types::xinput::AllowDeviceEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            mode,
            device_id,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_focus(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::GetDeviceFocusReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_focus",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceFocusRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_focus_immediate(&mut self, device_id: types::Card8) -> Result<types::xinput::GetDeviceFocusReply> {
        let request = types::xinput::GetDeviceFocusRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_focus(&mut self, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>, revert_to: types::InputFocus, device_id: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_set_device_focus",
            revert_to = ?revert_to,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::SetDeviceFocusRequest {
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            revert_to,
            device_id,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_focus_checked(&mut self, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>, revert_to: types::InputFocus, device_id: types::Card8) -> Result<()> {
        let request = types::xinput::SetDeviceFocusRequest {
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            revert_to,
            device_id,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_feedback_control(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::GetFeedbackControlReply>> {
        let span = tracing::info_span!(
            "xinput_get_feedback_control",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetFeedbackControlRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_feedback_control_immediate(&mut self, device_id: types::Card8) -> Result<types::xinput::GetFeedbackControlReply> {
        let request = types::xinput::GetFeedbackControlRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_feedback_control(&mut self, mask: impl Into<types::ChangeFeedbackControlMask>, device_id: types::Card8, feedback_id: types::Card8, feedback: types::FeedbackCtl) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_change_feedback_control",
            device_id = ?device_id,
            feedback_id = ?feedback_id,
            feedback = ?feedback,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeFeedbackControlRequest {
            mask: Into::<u32>::into(mask.into()) as _,
            device_id,
            feedback_id,
            feedback,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_feedback_control_checked(&mut self, mask: impl Into<types::ChangeFeedbackControlMask>, device_id: types::Card8, feedback_id: types::Card8, feedback: types::FeedbackCtl) -> Result<()> {
        let request = types::xinput::ChangeFeedbackControlRequest {
            mask: Into::<u32>::into(mask.into()) as _,
            device_id,
            feedback_id,
            feedback,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_key_mapping(&mut self, device_id: types::Card8, first_keycode: types::KeyCode, count: types::Card8) -> Result<Cookie<types::xinput::GetDeviceKeyMappingReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_key_mapping",
            device_id = ?device_id,
            first_keycode = ?first_keycode,
            count = ?count,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            count,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_key_mapping_immediate(&mut self, device_id: types::Card8, first_keycode: types::KeyCode, count: types::Card8) -> Result<types::xinput::GetDeviceKeyMappingReply> {
        let request = types::xinput::GetDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            count,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_key_mapping(&mut self, device_id: types::Card8, first_keycode: types::KeyCode, keysyms_per_keycode: types::Card8, keycode_count: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_change_device_key_mapping",
            device_id = ?device_id,
            first_keycode = ?first_keycode,
            keysyms_per_keycode = ?keysyms_per_keycode,
            keycode_count = ?keycode_count,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            keysyms_per_keycode,
            keycode_count,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_key_mapping_checked(&mut self, device_id: types::Card8, first_keycode: types::KeyCode, keysyms_per_keycode: types::Card8, keycode_count: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> Result<()> {
        let request = types::xinput::ChangeDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            keysyms_per_keycode,
            keycode_count,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_modifier_mapping(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::GetDeviceModifierMappingReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_modifier_mapping",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceModifierMappingRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_modifier_mapping_immediate(&mut self, device_id: types::Card8) -> Result<types::xinput::GetDeviceModifierMappingReply> {
        let request = types::xinput::GetDeviceModifierMappingRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_modifier_mapping(&mut self, device_id: types::Card8, keymaps: impl AsRef<[types::Card8]>) -> Result<Cookie<types::xinput::SetDeviceModifierMappingReply>> {
        let span = tracing::info_span!(
            "xinput_set_device_modifier_mapping",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::SetDeviceModifierMappingRequest {
            device_id,
            keymaps: Cow::Borrowed(keymaps.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_modifier_mapping_immediate(&mut self, device_id: types::Card8, keymaps: impl AsRef<[types::Card8]>) -> Result<types::xinput::SetDeviceModifierMappingReply> {
        let request = types::xinput::SetDeviceModifierMappingRequest {
            device_id,
            keymaps: Cow::Borrowed(keymaps.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_button_mapping(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::GetDeviceButtonMappingReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_button_mapping",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceButtonMappingRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_button_mapping_immediate(&mut self, device_id: types::Card8) -> Result<types::xinput::GetDeviceButtonMappingReply> {
        let request = types::xinput::GetDeviceButtonMappingRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_button_mapping(&mut self, device_id: types::Card8, map: impl AsRef<[types::Card8]>) -> Result<Cookie<types::xinput::SetDeviceButtonMappingReply>> {
        let span = tracing::info_span!(
            "xinput_set_device_button_mapping",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::SetDeviceButtonMappingRequest {
            device_id,
            map: Cow::Borrowed(map.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_button_mapping_immediate(&mut self, device_id: types::Card8, map: impl AsRef<[types::Card8]>) -> Result<types::xinput::SetDeviceButtonMappingReply> {
        let request = types::xinput::SetDeviceButtonMappingRequest {
            device_id,
            map: Cow::Borrowed(map.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_query_device_state(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::QueryDeviceStateReply>> {
        let span = tracing::info_span!(
            "xinput_query_device_state",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::QueryDeviceStateRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_query_device_state_immediate(&mut self, device_id: types::Card8) -> Result<types::xinput::QueryDeviceStateReply> {
        let request = types::xinput::QueryDeviceStateRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_device_bell(&mut self, device_id: types::Card8, feedback_id: types::Card8, feedback_class: types::Card8, percent: types::Int8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_device_bell",
            device_id = ?device_id,
            feedback_id = ?feedback_id,
            feedback_class = ?feedback_class,
            percent = ?percent,
        );
        let _enter = span.enter();
        let request = types::xinput::DeviceBellRequest {
            device_id,
            feedback_id,
            feedback_class,
            percent,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_device_bell_checked(&mut self, device_id: types::Card8, feedback_id: types::Card8, feedback_class: types::Card8, percent: types::Int8) -> Result<()> {
        let request = types::xinput::DeviceBellRequest {
            device_id,
            feedback_id,
            feedback_class,
            percent,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_valuators(&mut self, device_id: types::Card8, first_valuator: types::Card8, valuators: impl AsRef<[types::Int32]>) -> Result<Cookie<types::xinput::SetDeviceValuatorsReply>> {
        let span = tracing::info_span!(
            "xinput_set_device_valuators",
            device_id = ?device_id,
            first_valuator = ?first_valuator,
        );
        let _enter = span.enter();
        let request = types::xinput::SetDeviceValuatorsRequest {
            device_id,
            first_valuator,
            valuators: Cow::Borrowed(valuators.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_valuators_immediate(&mut self, device_id: types::Card8, first_valuator: types::Card8, valuators: impl AsRef<[types::Int32]>) -> Result<types::xinput::SetDeviceValuatorsReply> {
        let request = types::xinput::SetDeviceValuatorsRequest {
            device_id,
            first_valuator,
            valuators: Cow::Borrowed(valuators.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_control(&mut self, control_id: types::DeviceControl, device_id: types::Card8) -> Result<Cookie<types::xinput::GetDeviceControlReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_control",
            control_id = ?control_id,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceControlRequest {
            control_id,
            device_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_control_immediate(&mut self, control_id: types::DeviceControl, device_id: types::Card8) -> Result<types::xinput::GetDeviceControlReply> {
        let request = types::xinput::GetDeviceControlRequest {
            control_id,
            device_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_control(&mut self, control_id: types::DeviceControl, device_id: types::Card8, control: types::DeviceCtl) -> Result<Cookie<types::xinput::ChangeDeviceControlReply>> {
        let span = tracing::info_span!(
            "xinput_change_device_control",
            control_id = ?control_id,
            device_id = ?device_id,
            control = ?control,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeDeviceControlRequest {
            control_id,
            device_id,
            control,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_control_immediate(&mut self, control_id: types::DeviceControl, device_id: types::Card8, control: types::DeviceCtl) -> Result<types::xinput::ChangeDeviceControlReply> {
        let request = types::xinput::ChangeDeviceControlRequest {
            control_id,
            device_id,
            control,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_device_properties(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::ListDevicePropertiesReply>> {
        let span = tracing::info_span!(
            "xinput_list_device_properties",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::ListDevicePropertiesRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_device_properties_immediate(&mut self, device_id: types::Card8) -> Result<types::xinput::ListDevicePropertiesReply> {
        let request = types::xinput::ListDevicePropertiesRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_property(&mut self, property: types::Atom, type_: types::Atom, device_id: types::Card8, mode: types::PropMode, num_items: types::Card32, items: impl Borrow<types::xinput::ChangeDevicePropertyAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_change_device_property",
            property = ?property,
            type_ = ?type_,
            device_id = ?device_id,
            mode = ?mode,
            num_items = ?num_items,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeDevicePropertyRequest {
            property,
            type_,
            device_id,
            mode,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_property_checked(&mut self, property: types::Atom, type_: types::Atom, device_id: types::Card8, mode: types::PropMode, num_items: types::Card32, items: impl Borrow<types::xinput::ChangeDevicePropertyAux>) -> Result<()> {
        let request = types::xinput::ChangeDevicePropertyRequest {
            property,
            type_,
            device_id,
            mode,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_delete_device_property(&mut self, property: types::Atom, device_id: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_delete_device_property",
            property = ?property,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::DeleteDevicePropertyRequest {
            property,
            device_id,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_delete_device_property_checked(&mut self, property: types::Atom, device_id: types::Card8) -> Result<()> {
        let request = types::xinput::DeleteDevicePropertyRequest {
            property,
            device_id,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_property(&mut self, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32, device_id: types::Card8, delete: types::Bool) -> Result<Cookie<types::xinput::GetDevicePropertyReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_property",
            property = ?property,
            type_ = ?type_,
            offset = ?offset,
            len = ?len,
            device_id = ?device_id,
            delete = ?delete,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDevicePropertyRequest {
            property,
            type_,
            offset,
            len,
            device_id,
            delete,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_property_immediate(&mut self, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32, device_id: types::Card8, delete: types::Bool) -> Result<types::xinput::GetDevicePropertyReply> {
        let request = types::xinput::GetDevicePropertyRequest {
            property,
            type_,
            offset,
            len,
            device_id,
            delete,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_pointer(&mut self, window: types::xproto::Window, deviceid: impl Into<types::Device>) -> Result<Cookie<types::xinput::XIQueryPointerReply>> {
        let span = tracing::info_span!(
            "xinput_xi_query_pointer",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XIQueryPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_pointer_immediate(&mut self, window: types::xproto::Window, deviceid: impl Into<types::Device>) -> Result<types::xinput::XIQueryPointerReply> {
        let request = types::xinput::XIQueryPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_warp_pointer(&mut self, src_win: types::xproto::Window, dst_win: types::xproto::Window, src_x: types::Fp1616, src_y: types::Fp1616, src_width: types::Card16, src_height: types::Card16, dst_x: types::Fp1616, dst_y: types::Fp1616, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_warp_pointer",
            src_win = ?src_win,
            dst_win = ?dst_win,
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
        );
        let _enter = span.enter();
        let request = types::xinput::XIWarpPointerRequest {
            src_win,
            dst_win,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_warp_pointer_checked(&mut self, src_win: types::xproto::Window, dst_win: types::xproto::Window, src_x: types::Fp1616, src_y: types::Fp1616, src_width: types::Card16, src_height: types::Card16, dst_x: types::Fp1616, dst_y: types::Fp1616, deviceid: impl Into<types::Device>) -> Result<()> {
        let request = types::xinput::XIWarpPointerRequest {
            src_win,
            dst_win,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_cursor(&mut self, window: types::xproto::Window, cursor: types::xproto::Cursor, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_change_cursor",
            window = ?window,
            cursor = ?cursor,
        );
        let _enter = span.enter();
        let request = types::xinput::XIChangeCursorRequest {
            window,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_cursor_checked(&mut self, window: types::xproto::Window, cursor: types::xproto::Cursor, deviceid: impl Into<types::Device>) -> Result<()> {
        let request = types::xinput::XIChangeCursorRequest {
            window,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_hierarchy(&mut self, changes: impl AsRef<[types::HierarchyChange]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_change_hierarchy",
        );
        let _enter = span.enter();
        let request = types::xinput::XIChangeHierarchyRequest {
            changes: Cow::Borrowed(changes.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_hierarchy_checked(&mut self, changes: impl AsRef<[types::HierarchyChange]>) -> Result<()> {
        let request = types::xinput::XIChangeHierarchyRequest {
            changes: Cow::Borrowed(changes.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_client_pointer(&mut self, window: types::xproto::Window, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_set_client_pointer",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XISetClientPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_client_pointer_checked(&mut self, window: types::xproto::Window, deviceid: impl Into<types::Device>) -> Result<()> {
        let request = types::xinput::XISetClientPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_client_pointer(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinput::XIGetClientPointerReply>> {
        let span = tracing::info_span!(
            "xinput_xi_get_client_pointer",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XIGetClientPointerRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_client_pointer_immediate(&mut self, window: types::xproto::Window) -> Result<types::xinput::XIGetClientPointerReply> {
        let request = types::xinput::XIGetClientPointerRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_select_events(&mut self, window: types::xproto::Window, masks: impl AsRef<[types::xinput::EventMask]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_select_events",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XISelectEventsRequest {
            window,
            masks: Cow::Borrowed(masks.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_select_events_checked(&mut self, window: types::xproto::Window, masks: impl AsRef<[types::xinput::EventMask]>) -> Result<()> {
        let request = types::xinput::XISelectEventsRequest {
            window,
            masks: Cow::Borrowed(masks.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_version(&mut self, major_version: types::Card16, minor_version: types::Card16) -> Result<Cookie<types::xinput::XIQueryVersionReply>> {
        let span = tracing::info_span!(
            "xinput_xi_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::xinput::XIQueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_version_immediate(&mut self, major_version: types::Card16, minor_version: types::Card16) -> Result<types::xinput::XIQueryVersionReply> {
        let request = types::xinput::XIQueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_device(&mut self, deviceid: impl Into<types::Device>) -> Result<Cookie<types::xinput::XIQueryDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_xi_query_device",
        );
        let _enter = span.enter();
        let request = types::xinput::XIQueryDeviceRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_device_immediate(&mut self, deviceid: impl Into<types::Device>) -> Result<types::xinput::XIQueryDeviceReply> {
        let request = types::xinput::XIQueryDeviceRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_focus(&mut self, window: types::xproto::Window, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_set_focus",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XISetFocusRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_focus_checked(&mut self, window: types::xproto::Window, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> Result<()> {
        let request = types::xinput::XISetFocusRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_focus(&mut self, deviceid: impl Into<types::Device>) -> Result<Cookie<types::xinput::XIGetFocusReply>> {
        let span = tracing::info_span!(
            "xinput_xi_get_focus",
        );
        let _enter = span.enter();
        let request = types::xinput::XIGetFocusRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_focus_immediate(&mut self, deviceid: impl Into<types::Device>) -> Result<types::xinput::XIGetFocusReply> {
        let request = types::xinput::XIGetFocusRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_grab_device(&mut self, window: types::xproto::Window, time: impl Into<types::Time>, cursor: types::xproto::Cursor, deviceid: impl Into<types::Device>, mode: types::GrabMode, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask: impl AsRef<[types::Card32]>) -> Result<Cookie<types::xinput::XIGrabDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_xi_grab_device",
            window = ?window,
            cursor = ?cursor,
            mode = ?mode,
            paired_device_mode = ?paired_device_mode,
            owner_events = ?owner_events,
        );
        let _enter = span.enter();
        let request = types::xinput::XIGrabDeviceRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_grab_device_immediate(&mut self, window: types::xproto::Window, time: impl Into<types::Time>, cursor: types::xproto::Cursor, deviceid: impl Into<types::Device>, mode: types::GrabMode, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask: impl AsRef<[types::Card32]>) -> Result<types::xinput::XIGrabDeviceReply> {
        let request = types::xinput::XIGrabDeviceRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_ungrab_device(&mut self, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_ungrab_device",
        );
        let _enter = span.enter();
        let request = types::xinput::XIUngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_ungrab_device_checked(&mut self, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> Result<()> {
        let request = types::xinput::XIUngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_allow_events(&mut self, time: impl Into<types::Time>, deviceid: impl Into<types::Device>, event_mode: types::EventMode, touchid: types::Card32, grab_window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_allow_events",
            event_mode = ?event_mode,
            touchid = ?touchid,
            grab_window = ?grab_window,
        );
        let _enter = span.enter();
        let request = types::xinput::XIAllowEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            event_mode,
            touchid,
            grab_window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_allow_events_checked(&mut self, time: impl Into<types::Time>, deviceid: impl Into<types::Device>, event_mode: types::EventMode, touchid: types::Card32, grab_window: types::xproto::Window) -> Result<()> {
        let request = types::xinput::XIAllowEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            event_mode,
            touchid,
            grab_window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_grab_device(&mut self, time: impl Into<types::Time>, grab_window: types::xproto::Window, cursor: types::xproto::Cursor, detail: types::Card32, deviceid: impl Into<types::Device>, grab_type: types::GrabType, grab_mode: types::GrabMode22, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask: impl AsRef<[types::Card32]>, modifiers: impl AsRef<[types::Card32]>) -> Result<Cookie<types::xinput::XIPassiveGrabDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_xi_passive_grab_device",
            grab_window = ?grab_window,
            cursor = ?cursor,
            detail = ?detail,
            grab_type = ?grab_type,
            grab_mode = ?grab_mode,
            paired_device_mode = ?paired_device_mode,
            owner_events = ?owner_events,
        );
        let _enter = span.enter();
        let request = types::xinput::XIPassiveGrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            grab_window,
            cursor,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            grab_mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_grab_device_immediate(&mut self, time: impl Into<types::Time>, grab_window: types::xproto::Window, cursor: types::xproto::Cursor, detail: types::Card32, deviceid: impl Into<types::Device>, grab_type: types::GrabType, grab_mode: types::GrabMode22, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask: impl AsRef<[types::Card32]>, modifiers: impl AsRef<[types::Card32]>) -> Result<types::xinput::XIPassiveGrabDeviceReply> {
        let request = types::xinput::XIPassiveGrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            grab_window,
            cursor,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            grab_mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_ungrab_device(&mut self, grab_window: types::xproto::Window, detail: types::Card32, deviceid: impl Into<types::Device>, grab_type: types::GrabType, modifiers: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_passive_ungrab_device",
            grab_window = ?grab_window,
            detail = ?detail,
            grab_type = ?grab_type,
        );
        let _enter = span.enter();
        let request = types::xinput::XIPassiveUngrabDeviceRequest {
            grab_window,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_ungrab_device_checked(&mut self, grab_window: types::xproto::Window, detail: types::Card32, deviceid: impl Into<types::Device>, grab_type: types::GrabType, modifiers: impl AsRef<[types::Card32]>) -> Result<()> {
        let request = types::xinput::XIPassiveUngrabDeviceRequest {
            grab_window,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_list_properties(&mut self, deviceid: impl Into<types::Device>) -> Result<Cookie<types::xinput::XIListPropertiesReply>> {
        let span = tracing::info_span!(
            "xinput_xi_list_properties",
        );
        let _enter = span.enter();
        let request = types::xinput::XIListPropertiesRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_list_properties_immediate(&mut self, deviceid: impl Into<types::Device>) -> Result<types::xinput::XIListPropertiesReply> {
        let request = types::xinput::XIListPropertiesRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_property(&mut self, deviceid: impl Into<types::Device>, mode: types::PropMode, property: types::Atom, type_: types::Atom, num_items: types::Card32, items: impl Borrow<types::xinput::XIChangePropertyAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_change_property",
            mode = ?mode,
            property = ?property,
            type_ = ?type_,
            num_items = ?num_items,
        );
        let _enter = span.enter();
        let request = types::xinput::XIChangePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            property,
            type_,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_property_checked(&mut self, deviceid: impl Into<types::Device>, mode: types::PropMode, property: types::Atom, type_: types::Atom, num_items: types::Card32, items: impl Borrow<types::xinput::XIChangePropertyAux>) -> Result<()> {
        let request = types::xinput::XIChangePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            property,
            type_,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_delete_property(&mut self, deviceid: impl Into<types::Device>, property: types::Atom) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_delete_property",
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::xinput::XIDeletePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            property,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_delete_property_checked(&mut self, deviceid: impl Into<types::Device>, property: types::Atom) -> Result<()> {
        let request = types::xinput::XIDeletePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            property,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_property(&mut self, deviceid: impl Into<types::Device>, delete: types::Bool, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32) -> Result<Cookie<types::xinput::XIGetPropertyReply>> {
        let span = tracing::info_span!(
            "xinput_xi_get_property",
            delete = ?delete,
            property = ?property,
            type_ = ?type_,
            offset = ?offset,
            len = ?len,
        );
        let _enter = span.enter();
        let request = types::xinput::XIGetPropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            delete,
            property,
            type_,
            offset,
            len,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_property_immediate(&mut self, deviceid: impl Into<types::Device>, delete: types::Bool, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32) -> Result<types::xinput::XIGetPropertyReply> {
        let request = types::xinput::XIGetPropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            delete,
            property,
            type_,
            offset,
            len,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_selected_events(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinput::XIGetSelectedEventsReply>> {
        let span = tracing::info_span!(
            "xinput_xi_get_selected_events",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XIGetSelectedEventsRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_selected_events_immediate(&mut self, window: types::xproto::Window) -> Result<types::xinput::XIGetSelectedEventsReply> {
        let request = types::xinput::XIGetSelectedEventsRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_barrier_release_pointer(&mut self, barriers: impl AsRef<[types::BarrierReleasePointerInfo]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_barrier_release_pointer",
        );
        let _enter = span.enter();
        let request = types::xinput::XIBarrierReleasePointerRequest {
            barriers: Cow::Borrowed(barriers.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_barrier_release_pointer_checked(&mut self, barriers: impl AsRef<[types::BarrierReleasePointerInfo]>) -> Result<()> {
        let request = types::xinput::XIBarrierReleasePointerRequest {
            barriers: Cow::Borrowed(barriers.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_send_extension_event(&mut self, destination: types::xproto::Window, device_id: types::Card8, propagate: types::Bool, events: impl AsRef<[types::EventForSend]>, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_send_extension_event",
            destination = ?destination,
            device_id = ?device_id,
            propagate = ?propagate,
        );
        let _enter = span.enter();
        let request = types::xinput::SendExtensionEventRequest {
            destination,
            device_id,
            propagate,
            events: Cow::Borrowed(events.as_ref()),
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_send_extension_event_checked(&mut self, destination: types::xproto::Window, device_id: types::Card8, propagate: types::Bool, events: impl AsRef<[types::EventForSend]>, classes: impl AsRef<[types::EventClass]>) -> Result<()> {
        let request = types::xinput::SendExtensionEventRequest {
            destination,
            device_id,
            propagate,
            events: Cow::Borrowed(events.as_ref()),
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xkb")]
    fn xkb_use_extension(&mut self, wanted_major: types::Card16, wanted_minor: types::Card16) -> Result<Cookie<types::xkb::UseExtensionReply>> {
        let span = tracing::info_span!(
            "xkb_use_extension",
            wanted_major = ?wanted_major,
            wanted_minor = ?wanted_minor,
        );
        let _enter = span.enter();
        let request = types::xkb::UseExtensionRequest {
            wanted_major,
            wanted_minor,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_use_extension_immediate(&mut self, wanted_major: types::Card16, wanted_minor: types::Card16) -> Result<types::xkb::UseExtensionReply> {
        let request = types::xkb::UseExtensionRequest {
            wanted_major,
            wanted_minor,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_select_events(&mut self, device_spec: types::DeviceSpec, clear: impl Into<types::xkb::EventType>, select_all: impl Into<types::xkb::EventType>, affect_map: impl Into<types::MapPart>, map: impl Into<types::MapPart>, details: impl Borrow<types::xkb::SelectEventsAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_select_events",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::SelectEventsRequest {
            device_spec,
            clear: Into::<u32>::into(clear.into()) as _,
            select_all: Into::<u32>::into(select_all.into()) as _,
            affect_map: Into::<u32>::into(affect_map.into()) as _,
            map: Into::<u32>::into(map.into()) as _,
            details: Cow::Borrowed(details.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_select_events_checked(&mut self, device_spec: types::DeviceSpec, clear: impl Into<types::xkb::EventType>, select_all: impl Into<types::xkb::EventType>, affect_map: impl Into<types::MapPart>, map: impl Into<types::MapPart>, details: impl Borrow<types::xkb::SelectEventsAux>) -> Result<()> {
        let request = types::xkb::SelectEventsRequest {
            device_spec,
            clear: Into::<u32>::into(clear.into()) as _,
            select_all: Into::<u32>::into(select_all.into()) as _,
            affect_map: Into::<u32>::into(affect_map.into()) as _,
            map: Into::<u32>::into(map.into()) as _,
            details: Cow::Borrowed(details.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_bell(&mut self, device_spec: types::DeviceSpec, bell_class: types::BellClassSpec, bell_id: types::IDSpec, percent: types::Int8, force_sound: types::Bool, event_only: types::Bool, pitch: types::Int16, duration: types::Int16, name: types::Atom, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_bell",
            device_spec = ?device_spec,
            bell_class = ?bell_class,
            bell_id = ?bell_id,
            percent = ?percent,
            force_sound = ?force_sound,
            event_only = ?event_only,
            pitch = ?pitch,
            duration = ?duration,
            name = ?name,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xkb::BellRequest {
            device_spec,
            bell_class,
            bell_id,
            percent,
            force_sound,
            event_only,
            pitch,
            duration,
            name,
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_bell_checked(&mut self, device_spec: types::DeviceSpec, bell_class: types::BellClassSpec, bell_id: types::IDSpec, percent: types::Int8, force_sound: types::Bool, event_only: types::Bool, pitch: types::Int16, duration: types::Int16, name: types::Atom, window: types::xproto::Window) -> Result<()> {
        let request = types::xkb::BellRequest {
            device_spec,
            bell_class,
            bell_id,
            percent,
            force_sound,
            event_only,
            pitch,
            duration,
            name,
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_state(&mut self, device_spec: types::DeviceSpec) -> Result<Cookie<types::xkb::GetStateReply>> {
        let span = tracing::info_span!(
            "xkb_get_state",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::GetStateRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_state_immediate(&mut self, device_spec: types::DeviceSpec) -> Result<types::xkb::GetStateReply> {
        let request = types::xkb::GetStateRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_latch_lock_state(&mut self, device_spec: types::DeviceSpec, affect_mod_locks: impl Into<types::ModMask>, mod_locks: impl Into<types::ModMask>, lock_group: types::Bool, group_lock: types::Group, affect_mod_latches: impl Into<types::ModMask>, latch_group: types::Bool, group_latch: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_latch_lock_state",
            device_spec = ?device_spec,
            lock_group = ?lock_group,
            group_lock = ?group_lock,
            latch_group = ?latch_group,
            group_latch = ?group_latch,
        );
        let _enter = span.enter();
        let request = types::xkb::LatchLockStateRequest {
            device_spec,
            affect_mod_locks: Into::<u32>::into(affect_mod_locks.into()) as _,
            mod_locks: Into::<u32>::into(mod_locks.into()) as _,
            lock_group,
            group_lock,
            affect_mod_latches: Into::<u32>::into(affect_mod_latches.into()) as _,
            latch_group,
            group_latch,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_latch_lock_state_checked(&mut self, device_spec: types::DeviceSpec, affect_mod_locks: impl Into<types::ModMask>, mod_locks: impl Into<types::ModMask>, lock_group: types::Bool, group_lock: types::Group, affect_mod_latches: impl Into<types::ModMask>, latch_group: types::Bool, group_latch: types::Card16) -> Result<()> {
        let request = types::xkb::LatchLockStateRequest {
            device_spec,
            affect_mod_locks: Into::<u32>::into(affect_mod_locks.into()) as _,
            mod_locks: Into::<u32>::into(mod_locks.into()) as _,
            lock_group,
            group_lock,
            affect_mod_latches: Into::<u32>::into(affect_mod_latches.into()) as _,
            latch_group,
            group_latch,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_controls(&mut self, device_spec: types::DeviceSpec) -> Result<Cookie<types::xkb::GetControlsReply>> {
        let span = tracing::info_span!(
            "xkb_get_controls",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::GetControlsRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_controls_immediate(&mut self, device_spec: types::DeviceSpec) -> Result<types::xkb::GetControlsReply> {
        let request = types::xkb::GetControlsRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_controls(&mut self, device_spec: types::DeviceSpec, affect_internal_real_mods: impl Into<types::ModMask>, internal_real_mods: impl Into<types::ModMask>, affect_ignore_lock_real_mods: impl Into<types::ModMask>, ignore_lock_real_mods: impl Into<types::ModMask>, affect_internal_virtual_mods: impl Into<types::VMod>, internal_virtual_mods: impl Into<types::VMod>, affect_ignore_lock_virtual_mods: impl Into<types::VMod>, ignore_lock_virtual_mods: impl Into<types::VMod>, mouse_keys_dflt_btn: types::Card8, groups_wrap: types::Card8, access_x_options: impl Into<types::AXOption>, affect_enabled_controls: impl Into<types::BoolCtrl>, enabled_controls: impl Into<types::BoolCtrl>, change_controls: impl Into<types::Control>, repeat_delay: types::Card16, repeat_interval: types::Card16, slow_keys_delay: types::Card16, debounce_delay: types::Card16, mouse_keys_delay: types::Card16, mouse_keys_interval: types::Card16, mouse_keys_time_to_max: types::Card16, mouse_keys_max_speed: types::Card16, mouse_keys_curve: types::Int16, access_x_timeout: types::Card16, access_x_timeout_mask: impl Into<types::BoolCtrl>, access_x_timeout_values: impl Into<types::BoolCtrl>, access_x_timeout_options_mask: impl Into<types::AXOption>, access_x_timeout_options_values: impl Into<types::AXOption>, per_key_repeat: impl Borrow<[types::Card8; 32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_controls",
            device_spec = ?device_spec,
            mouse_keys_dflt_btn = ?mouse_keys_dflt_btn,
            groups_wrap = ?groups_wrap,
            repeat_delay = ?repeat_delay,
            repeat_interval = ?repeat_interval,
            slow_keys_delay = ?slow_keys_delay,
            debounce_delay = ?debounce_delay,
            mouse_keys_delay = ?mouse_keys_delay,
            mouse_keys_interval = ?mouse_keys_interval,
            mouse_keys_time_to_max = ?mouse_keys_time_to_max,
            mouse_keys_max_speed = ?mouse_keys_max_speed,
            mouse_keys_curve = ?mouse_keys_curve,
            access_x_timeout = ?access_x_timeout,
        );
        let _enter = span.enter();
        let request = types::xkb::SetControlsRequest {
            device_spec,
            affect_internal_real_mods: Into::<u32>::into(affect_internal_real_mods.into()) as _,
            internal_real_mods: Into::<u32>::into(internal_real_mods.into()) as _,
            affect_ignore_lock_real_mods: Into::<u32>::into(affect_ignore_lock_real_mods.into()) as _,
            ignore_lock_real_mods: Into::<u32>::into(ignore_lock_real_mods.into()) as _,
            affect_internal_virtual_mods: Into::<u32>::into(affect_internal_virtual_mods.into()) as _,
            internal_virtual_mods: Into::<u32>::into(internal_virtual_mods.into()) as _,
            affect_ignore_lock_virtual_mods: Into::<u32>::into(affect_ignore_lock_virtual_mods.into()) as _,
            ignore_lock_virtual_mods: Into::<u32>::into(ignore_lock_virtual_mods.into()) as _,
            mouse_keys_dflt_btn,
            groups_wrap,
            access_x_options: Into::<u32>::into(access_x_options.into()) as _,
            affect_enabled_controls: Into::<u32>::into(affect_enabled_controls.into()) as _,
            enabled_controls: Into::<u32>::into(enabled_controls.into()) as _,
            change_controls: Into::<u32>::into(change_controls.into()) as _,
            repeat_delay,
            repeat_interval,
            slow_keys_delay,
            debounce_delay,
            mouse_keys_delay,
            mouse_keys_interval,
            mouse_keys_time_to_max,
            mouse_keys_max_speed,
            mouse_keys_curve,
            access_x_timeout,
            access_x_timeout_mask: Into::<u32>::into(access_x_timeout_mask.into()) as _,
            access_x_timeout_values: Into::<u32>::into(access_x_timeout_values.into()) as _,
            access_x_timeout_options_mask: Into::<u32>::into(access_x_timeout_options_mask.into()) as _,
            access_x_timeout_options_values: Into::<u32>::into(access_x_timeout_options_values.into()) as _,
            per_key_repeat: Cow::Borrowed(per_key_repeat.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_controls_checked(&mut self, device_spec: types::DeviceSpec, affect_internal_real_mods: impl Into<types::ModMask>, internal_real_mods: impl Into<types::ModMask>, affect_ignore_lock_real_mods: impl Into<types::ModMask>, ignore_lock_real_mods: impl Into<types::ModMask>, affect_internal_virtual_mods: impl Into<types::VMod>, internal_virtual_mods: impl Into<types::VMod>, affect_ignore_lock_virtual_mods: impl Into<types::VMod>, ignore_lock_virtual_mods: impl Into<types::VMod>, mouse_keys_dflt_btn: types::Card8, groups_wrap: types::Card8, access_x_options: impl Into<types::AXOption>, affect_enabled_controls: impl Into<types::BoolCtrl>, enabled_controls: impl Into<types::BoolCtrl>, change_controls: impl Into<types::Control>, repeat_delay: types::Card16, repeat_interval: types::Card16, slow_keys_delay: types::Card16, debounce_delay: types::Card16, mouse_keys_delay: types::Card16, mouse_keys_interval: types::Card16, mouse_keys_time_to_max: types::Card16, mouse_keys_max_speed: types::Card16, mouse_keys_curve: types::Int16, access_x_timeout: types::Card16, access_x_timeout_mask: impl Into<types::BoolCtrl>, access_x_timeout_values: impl Into<types::BoolCtrl>, access_x_timeout_options_mask: impl Into<types::AXOption>, access_x_timeout_options_values: impl Into<types::AXOption>, per_key_repeat: impl Borrow<[types::Card8; 32]>) -> Result<()> {
        let request = types::xkb::SetControlsRequest {
            device_spec,
            affect_internal_real_mods: Into::<u32>::into(affect_internal_real_mods.into()) as _,
            internal_real_mods: Into::<u32>::into(internal_real_mods.into()) as _,
            affect_ignore_lock_real_mods: Into::<u32>::into(affect_ignore_lock_real_mods.into()) as _,
            ignore_lock_real_mods: Into::<u32>::into(ignore_lock_real_mods.into()) as _,
            affect_internal_virtual_mods: Into::<u32>::into(affect_internal_virtual_mods.into()) as _,
            internal_virtual_mods: Into::<u32>::into(internal_virtual_mods.into()) as _,
            affect_ignore_lock_virtual_mods: Into::<u32>::into(affect_ignore_lock_virtual_mods.into()) as _,
            ignore_lock_virtual_mods: Into::<u32>::into(ignore_lock_virtual_mods.into()) as _,
            mouse_keys_dflt_btn,
            groups_wrap,
            access_x_options: Into::<u32>::into(access_x_options.into()) as _,
            affect_enabled_controls: Into::<u32>::into(affect_enabled_controls.into()) as _,
            enabled_controls: Into::<u32>::into(enabled_controls.into()) as _,
            change_controls: Into::<u32>::into(change_controls.into()) as _,
            repeat_delay,
            repeat_interval,
            slow_keys_delay,
            debounce_delay,
            mouse_keys_delay,
            mouse_keys_interval,
            mouse_keys_time_to_max,
            mouse_keys_max_speed,
            mouse_keys_curve,
            access_x_timeout,
            access_x_timeout_mask: Into::<u32>::into(access_x_timeout_mask.into()) as _,
            access_x_timeout_values: Into::<u32>::into(access_x_timeout_values.into()) as _,
            access_x_timeout_options_mask: Into::<u32>::into(access_x_timeout_options_mask.into()) as _,
            access_x_timeout_options_values: Into::<u32>::into(access_x_timeout_options_values.into()) as _,
            per_key_repeat: Cow::Borrowed(per_key_repeat.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_map(&mut self, device_spec: types::DeviceSpec, full: impl Into<types::MapPart>, partial: impl Into<types::MapPart>, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, first_key_action: types::Keycode, n_key_actions: types::Card8, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, virtual_mods: impl Into<types::VMod>, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8) -> Result<Cookie<types::xkb::GetMapReply>> {
        let span = tracing::info_span!(
            "xkb_get_map",
            device_spec = ?device_spec,
            first_type = ?first_type,
            n_types = ?n_types,
            first_key_sym = ?first_key_sym,
            n_key_syms = ?n_key_syms,
            first_key_action = ?first_key_action,
            n_key_actions = ?n_key_actions,
            first_key_behavior = ?first_key_behavior,
            n_key_behaviors = ?n_key_behaviors,
            first_key_explicit = ?first_key_explicit,
            n_key_explicit = ?n_key_explicit,
            first_mod_map_key = ?first_mod_map_key,
            n_mod_map_keys = ?n_mod_map_keys,
            first_v_mod_map_key = ?first_v_mod_map_key,
            n_v_mod_map_keys = ?n_v_mod_map_keys,
        );
        let _enter = span.enter();
        let request = types::xkb::GetMapRequest {
            device_spec,
            full: Into::<u32>::into(full.into()) as _,
            partial: Into::<u32>::into(partial.into()) as _,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            first_key_action,
            n_key_actions,
            first_key_behavior,
            n_key_behaviors,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_key_explicit,
            n_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_map_immediate(&mut self, device_spec: types::DeviceSpec, full: impl Into<types::MapPart>, partial: impl Into<types::MapPart>, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, first_key_action: types::Keycode, n_key_actions: types::Card8, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, virtual_mods: impl Into<types::VMod>, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8) -> Result<types::xkb::GetMapReply> {
        let request = types::xkb::GetMapRequest {
            device_spec,
            full: Into::<u32>::into(full.into()) as _,
            partial: Into::<u32>::into(partial.into()) as _,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            first_key_action,
            n_key_actions,
            first_key_behavior,
            n_key_behaviors,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_key_explicit,
            n_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_map(&mut self, device_spec: types::DeviceSpec, flags: impl Into<types::SetMapFlags>, min_key_code: types::Keycode, max_key_code: types::Keycode, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, total_syms: types::Card16, first_key_action: types::Keycode, n_key_actions: types::Card8, total_actions: types::Card16, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, total_key_behaviors: types::Card8, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, total_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, total_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8, total_v_mod_map_keys: types::Card8, virtual_mods: impl Into<types::VMod>, values: impl Borrow<types::xkb::SetMapAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_map",
            device_spec = ?device_spec,
            min_key_code = ?min_key_code,
            max_key_code = ?max_key_code,
            first_type = ?first_type,
            n_types = ?n_types,
            first_key_sym = ?first_key_sym,
            n_key_syms = ?n_key_syms,
            total_syms = ?total_syms,
            first_key_action = ?first_key_action,
            n_key_actions = ?n_key_actions,
            total_actions = ?total_actions,
            first_key_behavior = ?first_key_behavior,
            n_key_behaviors = ?n_key_behaviors,
            total_key_behaviors = ?total_key_behaviors,
            first_key_explicit = ?first_key_explicit,
            n_key_explicit = ?n_key_explicit,
            total_key_explicit = ?total_key_explicit,
            first_mod_map_key = ?first_mod_map_key,
            n_mod_map_keys = ?n_mod_map_keys,
            total_mod_map_keys = ?total_mod_map_keys,
            first_v_mod_map_key = ?first_v_mod_map_key,
            n_v_mod_map_keys = ?n_v_mod_map_keys,
            total_v_mod_map_keys = ?total_v_mod_map_keys,
        );
        let _enter = span.enter();
        let request = types::xkb::SetMapRequest {
            device_spec,
            flags: Into::<u32>::into(flags.into()) as _,
            min_key_code,
            max_key_code,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            total_syms,
            first_key_action,
            n_key_actions,
            total_actions,
            first_key_behavior,
            n_key_behaviors,
            total_key_behaviors,
            first_key_explicit,
            n_key_explicit,
            total_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            total_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
            total_v_mod_map_keys,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            values: Cow::Borrowed(values.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_map_checked(&mut self, device_spec: types::DeviceSpec, flags: impl Into<types::SetMapFlags>, min_key_code: types::Keycode, max_key_code: types::Keycode, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, total_syms: types::Card16, first_key_action: types::Keycode, n_key_actions: types::Card8, total_actions: types::Card16, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, total_key_behaviors: types::Card8, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, total_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, total_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8, total_v_mod_map_keys: types::Card8, virtual_mods: impl Into<types::VMod>, values: impl Borrow<types::xkb::SetMapAux>) -> Result<()> {
        let request = types::xkb::SetMapRequest {
            device_spec,
            flags: Into::<u32>::into(flags.into()) as _,
            min_key_code,
            max_key_code,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            total_syms,
            first_key_action,
            n_key_actions,
            total_actions,
            first_key_behavior,
            n_key_behaviors,
            total_key_behaviors,
            first_key_explicit,
            n_key_explicit,
            total_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            total_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
            total_v_mod_map_keys,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            values: Cow::Borrowed(values.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_compat_map(&mut self, device_spec: types::DeviceSpec, groups: impl Into<types::SetOfGroup>, get_all_si: types::Bool, first_si: types::Card16, n_si: types::Card16) -> Result<Cookie<types::xkb::GetCompatMapReply>> {
        let span = tracing::info_span!(
            "xkb_get_compat_map",
            device_spec = ?device_spec,
            get_all_si = ?get_all_si,
            first_si = ?first_si,
            n_si = ?n_si,
        );
        let _enter = span.enter();
        let request = types::xkb::GetCompatMapRequest {
            device_spec,
            groups: Into::<u32>::into(groups.into()) as _,
            get_all_si,
            first_si,
            n_si,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_compat_map_immediate(&mut self, device_spec: types::DeviceSpec, groups: impl Into<types::SetOfGroup>, get_all_si: types::Bool, first_si: types::Card16, n_si: types::Card16) -> Result<types::xkb::GetCompatMapReply> {
        let request = types::xkb::GetCompatMapRequest {
            device_spec,
            groups: Into::<u32>::into(groups.into()) as _,
            get_all_si,
            first_si,
            n_si,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_compat_map(&mut self, device_spec: types::DeviceSpec, recompute_actions: types::Bool, truncate_si: types::Bool, groups: impl Into<types::SetOfGroup>, first_si: types::Card16, si: impl AsRef<[types::SymInterpret]>, group_maps: impl AsRef<[types::ModDef]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_compat_map",
            device_spec = ?device_spec,
            recompute_actions = ?recompute_actions,
            truncate_si = ?truncate_si,
            first_si = ?first_si,
        );
        let _enter = span.enter();
        let request = types::xkb::SetCompatMapRequest {
            device_spec,
            recompute_actions,
            truncate_si,
            groups: Into::<u32>::into(groups.into()) as _,
            first_si,
            si: Cow::Borrowed(si.as_ref()),
            group_maps: Cow::Borrowed(group_maps.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_compat_map_checked(&mut self, device_spec: types::DeviceSpec, recompute_actions: types::Bool, truncate_si: types::Bool, groups: impl Into<types::SetOfGroup>, first_si: types::Card16, si: impl AsRef<[types::SymInterpret]>, group_maps: impl AsRef<[types::ModDef]>) -> Result<()> {
        let request = types::xkb::SetCompatMapRequest {
            device_spec,
            recompute_actions,
            truncate_si,
            groups: Into::<u32>::into(groups.into()) as _,
            first_si,
            si: Cow::Borrowed(si.as_ref()),
            group_maps: Cow::Borrowed(group_maps.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_state(&mut self, device_spec: types::DeviceSpec) -> Result<Cookie<types::xkb::GetIndicatorStateReply>> {
        let span = tracing::info_span!(
            "xkb_get_indicator_state",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::GetIndicatorStateRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_state_immediate(&mut self, device_spec: types::DeviceSpec) -> Result<types::xkb::GetIndicatorStateReply> {
        let request = types::xkb::GetIndicatorStateRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_map(&mut self, device_spec: types::DeviceSpec, which: types::Card32) -> Result<Cookie<types::xkb::GetIndicatorMapReply>> {
        let span = tracing::info_span!(
            "xkb_get_indicator_map",
            device_spec = ?device_spec,
            which = ?which,
        );
        let _enter = span.enter();
        let request = types::xkb::GetIndicatorMapRequest {
            device_spec,
            which,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_map_immediate(&mut self, device_spec: types::DeviceSpec, which: types::Card32) -> Result<types::xkb::GetIndicatorMapReply> {
        let request = types::xkb::GetIndicatorMapRequest {
            device_spec,
            which,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_indicator_map(&mut self, device_spec: types::DeviceSpec, which: types::Card32, maps: impl AsRef<[types::IndicatorMap]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_indicator_map",
            device_spec = ?device_spec,
            which = ?which,
        );
        let _enter = span.enter();
        let request = types::xkb::SetIndicatorMapRequest {
            device_spec,
            which,
            maps: Cow::Borrowed(maps.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_indicator_map_checked(&mut self, device_spec: types::DeviceSpec, which: types::Card32, maps: impl AsRef<[types::IndicatorMap]>) -> Result<()> {
        let request = types::xkb::SetIndicatorMapRequest {
            device_spec,
            which,
            maps: Cow::Borrowed(maps.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_named_indicator(&mut self, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::ID>, indicator: types::Atom) -> Result<Cookie<types::xkb::GetNamedIndicatorReply>> {
        let span = tracing::info_span!(
            "xkb_get_named_indicator",
            device_spec = ?device_spec,
            led_class = ?led_class,
            indicator = ?indicator,
        );
        let _enter = span.enter();
        let request = types::xkb::GetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_named_indicator_immediate(&mut self, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::ID>, indicator: types::Atom) -> Result<types::xkb::GetNamedIndicatorReply> {
        let request = types::xkb::GetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_named_indicator(&mut self, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::ID>, indicator: types::Atom, set_state: types::Bool, on: types::Bool, set_map: types::Bool, create_map: types::Bool, map_flags: impl Into<types::IMFlag>, map_which_groups: impl Into<types::IMGroupsWhich>, map_groups: impl Into<types::SetOfGroups>, map_which_mods: impl Into<types::IMModsWhich>, map_real_mods: impl Into<types::ModMask>, map_vmods: impl Into<types::VMod>, map_ctrls: impl Into<types::BoolCtrl>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_named_indicator",
            device_spec = ?device_spec,
            led_class = ?led_class,
            indicator = ?indicator,
            set_state = ?set_state,
            on = ?on,
            set_map = ?set_map,
            create_map = ?create_map,
        );
        let _enter = span.enter();
        let request = types::xkb::SetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
            set_state,
            on,
            set_map,
            create_map,
            map_flags: Into::<u32>::into(map_flags.into()) as _,
            map_which_groups: Into::<u32>::into(map_which_groups.into()) as _,
            map_groups: Into::<u32>::into(map_groups.into()) as _,
            map_which_mods: Into::<u32>::into(map_which_mods.into()) as _,
            map_real_mods: Into::<u32>::into(map_real_mods.into()) as _,
            map_vmods: Into::<u32>::into(map_vmods.into()) as _,
            map_ctrls: Into::<u32>::into(map_ctrls.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_named_indicator_checked(&mut self, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::ID>, indicator: types::Atom, set_state: types::Bool, on: types::Bool, set_map: types::Bool, create_map: types::Bool, map_flags: impl Into<types::IMFlag>, map_which_groups: impl Into<types::IMGroupsWhich>, map_groups: impl Into<types::SetOfGroups>, map_which_mods: impl Into<types::IMModsWhich>, map_real_mods: impl Into<types::ModMask>, map_vmods: impl Into<types::VMod>, map_ctrls: impl Into<types::BoolCtrl>) -> Result<()> {
        let request = types::xkb::SetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
            set_state,
            on,
            set_map,
            create_map,
            map_flags: Into::<u32>::into(map_flags.into()) as _,
            map_which_groups: Into::<u32>::into(map_which_groups.into()) as _,
            map_groups: Into::<u32>::into(map_groups.into()) as _,
            map_which_mods: Into::<u32>::into(map_which_mods.into()) as _,
            map_real_mods: Into::<u32>::into(map_real_mods.into()) as _,
            map_vmods: Into::<u32>::into(map_vmods.into()) as _,
            map_ctrls: Into::<u32>::into(map_ctrls.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_names(&mut self, device_spec: types::DeviceSpec, which: impl Into<types::NameDetail>) -> Result<Cookie<types::xkb::GetNamesReply>> {
        let span = tracing::info_span!(
            "xkb_get_names",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::GetNamesRequest {
            device_spec,
            which: Into::<u32>::into(which.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_names_immediate(&mut self, device_spec: types::DeviceSpec, which: impl Into<types::NameDetail>) -> Result<types::xkb::GetNamesReply> {
        let request = types::xkb::GetNamesRequest {
            device_spec,
            which: Into::<u32>::into(which.into()) as _,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_names(&mut self, device_spec: types::DeviceSpec, virtual_mods: impl Into<types::VMod>, first_type: types::Card8, n_types: types::Card8, first_kt_levelt: types::Card8, n_kt_levels: types::Card8, indicators: types::Card32, group_names: impl Into<types::SetOfGroup>, n_radio_groups: types::Card8, first_key: types::Keycode, n_keys: types::Card8, n_key_aliases: types::Card8, total_kt_level_names: types::Card16, values: impl Borrow<types::xkb::SetNamesAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_names",
            device_spec = ?device_spec,
            first_type = ?first_type,
            n_types = ?n_types,
            first_kt_levelt = ?first_kt_levelt,
            n_kt_levels = ?n_kt_levels,
            indicators = ?indicators,
            n_radio_groups = ?n_radio_groups,
            first_key = ?first_key,
            n_keys = ?n_keys,
            n_key_aliases = ?n_key_aliases,
            total_kt_level_names = ?total_kt_level_names,
        );
        let _enter = span.enter();
        let request = types::xkb::SetNamesRequest {
            device_spec,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_type,
            n_types,
            first_kt_levelt,
            n_kt_levels,
            indicators,
            group_names: Into::<u32>::into(group_names.into()) as _,
            n_radio_groups,
            first_key,
            n_keys,
            n_key_aliases,
            total_kt_level_names,
            values: Cow::Borrowed(values.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_names_checked(&mut self, device_spec: types::DeviceSpec, virtual_mods: impl Into<types::VMod>, first_type: types::Card8, n_types: types::Card8, first_kt_levelt: types::Card8, n_kt_levels: types::Card8, indicators: types::Card32, group_names: impl Into<types::SetOfGroup>, n_radio_groups: types::Card8, first_key: types::Keycode, n_keys: types::Card8, n_key_aliases: types::Card8, total_kt_level_names: types::Card16, values: impl Borrow<types::xkb::SetNamesAux>) -> Result<()> {
        let request = types::xkb::SetNamesRequest {
            device_spec,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_type,
            n_types,
            first_kt_levelt,
            n_kt_levels,
            indicators,
            group_names: Into::<u32>::into(group_names.into()) as _,
            n_radio_groups,
            first_key,
            n_keys,
            n_key_aliases,
            total_kt_level_names,
            values: Cow::Borrowed(values.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_per_client_flags(&mut self, device_spec: types::DeviceSpec, change: impl Into<types::PerClientFlag>, value: impl Into<types::PerClientFlag>, ctrls_to_change: impl Into<types::BoolCtrl>, auto_ctrls: impl Into<types::BoolCtrl>, auto_ctrls_values: impl Into<types::BoolCtrl>) -> Result<Cookie<types::xkb::PerClientFlagsReply>> {
        let span = tracing::info_span!(
            "xkb_per_client_flags",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::PerClientFlagsRequest {
            device_spec,
            change: Into::<u32>::into(change.into()) as _,
            value: Into::<u32>::into(value.into()) as _,
            ctrls_to_change: Into::<u32>::into(ctrls_to_change.into()) as _,
            auto_ctrls: Into::<u32>::into(auto_ctrls.into()) as _,
            auto_ctrls_values: Into::<u32>::into(auto_ctrls_values.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_per_client_flags_immediate(&mut self, device_spec: types::DeviceSpec, change: impl Into<types::PerClientFlag>, value: impl Into<types::PerClientFlag>, ctrls_to_change: impl Into<types::BoolCtrl>, auto_ctrls: impl Into<types::BoolCtrl>, auto_ctrls_values: impl Into<types::BoolCtrl>) -> Result<types::xkb::PerClientFlagsReply> {
        let request = types::xkb::PerClientFlagsRequest {
            device_spec,
            change: Into::<u32>::into(change.into()) as _,
            value: Into::<u32>::into(value.into()) as _,
            ctrls_to_change: Into::<u32>::into(ctrls_to_change.into()) as _,
            auto_ctrls: Into::<u32>::into(auto_ctrls.into()) as _,
            auto_ctrls_values: Into::<u32>::into(auto_ctrls_values.into()) as _,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_list_components(&mut self, device_spec: types::DeviceSpec, max_names: types::Card16) -> Result<Cookie<types::xkb::ListComponentsReply>> {
        let span = tracing::info_span!(
            "xkb_list_components",
            device_spec = ?device_spec,
            max_names = ?max_names,
        );
        let _enter = span.enter();
        let request = types::xkb::ListComponentsRequest {
            device_spec,
            max_names,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_list_components_immediate(&mut self, device_spec: types::DeviceSpec, max_names: types::Card16) -> Result<types::xkb::ListComponentsReply> {
        let request = types::xkb::ListComponentsRequest {
            device_spec,
            max_names,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_kbd_by_name(&mut self, device_spec: types::DeviceSpec, need: impl Into<types::GBNDetail>, want: impl Into<types::GBNDetail>, load: types::Bool) -> Result<Cookie<types::xkb::GetKbdByNameReply>> {
        let span = tracing::info_span!(
            "xkb_get_kbd_by_name",
            device_spec = ?device_spec,
            load = ?load,
        );
        let _enter = span.enter();
        let request = types::xkb::GetKbdByNameRequest {
            device_spec,
            need: Into::<u32>::into(need.into()) as _,
            want: Into::<u32>::into(want.into()) as _,
            load,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_kbd_by_name_immediate(&mut self, device_spec: types::DeviceSpec, need: impl Into<types::GBNDetail>, want: impl Into<types::GBNDetail>, load: types::Bool) -> Result<types::xkb::GetKbdByNameReply> {
        let request = types::xkb::GetKbdByNameRequest {
            device_spec,
            need: Into::<u32>::into(need.into()) as _,
            want: Into::<u32>::into(want.into()) as _,
            load,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_device_info(&mut self, device_spec: types::DeviceSpec, wanted: impl Into<types::XIFeature>, all_buttons: types::Bool, first_button: types::Card8, n_buttons: types::Card8, led_class: types::LedClass, led_id: impl Into<types::ID>) -> Result<Cookie<types::xkb::GetDeviceInfoReply>> {
        let span = tracing::info_span!(
            "xkb_get_device_info",
            device_spec = ?device_spec,
            all_buttons = ?all_buttons,
            first_button = ?first_button,
            n_buttons = ?n_buttons,
            led_class = ?led_class,
        );
        let _enter = span.enter();
        let request = types::xkb::GetDeviceInfoRequest {
            device_spec,
            wanted: Into::<u32>::into(wanted.into()) as _,
            all_buttons,
            first_button,
            n_buttons,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_device_info_immediate(&mut self, device_spec: types::DeviceSpec, wanted: impl Into<types::XIFeature>, all_buttons: types::Bool, first_button: types::Card8, n_buttons: types::Card8, led_class: types::LedClass, led_id: impl Into<types::ID>) -> Result<types::xkb::GetDeviceInfoReply> {
        let request = types::xkb::GetDeviceInfoRequest {
            device_spec,
            wanted: Into::<u32>::into(wanted.into()) as _,
            all_buttons,
            first_button,
            n_buttons,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_device_info(&mut self, device_spec: types::DeviceSpec, first_btn: types::Card8, change: impl Into<types::XIFeature>, btn_actions: impl AsRef<[types::Action]>, leds: impl AsRef<[types::DeviceLedInfo]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_device_info",
            device_spec = ?device_spec,
            first_btn = ?first_btn,
        );
        let _enter = span.enter();
        let request = types::xkb::SetDeviceInfoRequest {
            device_spec,
            first_btn,
            change: Into::<u32>::into(change.into()) as _,
            btn_actions: Cow::Borrowed(btn_actions.as_ref()),
            leds: Cow::Borrowed(leds.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_device_info_checked(&mut self, device_spec: types::DeviceSpec, first_btn: types::Card8, change: impl Into<types::XIFeature>, btn_actions: impl AsRef<[types::Action]>, leds: impl AsRef<[types::DeviceLedInfo]>) -> Result<()> {
        let request = types::xkb::SetDeviceInfoRequest {
            device_spec,
            first_btn,
            change: Into::<u32>::into(change.into()) as _,
            btn_actions: Cow::Borrowed(btn_actions.as_ref()),
            leds: Cow::Borrowed(leds.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_debugging_flags(&mut self, affect_flags: types::Card32, flags: types::Card32, affect_ctrls: types::Card32, ctrls: types::Card32, message: impl AsRef<[types::xkb::String8]>) -> Result<Cookie<types::xkb::SetDebuggingFlagsReply>> {
        let span = tracing::info_span!(
            "xkb_set_debugging_flags",
            affect_flags = ?affect_flags,
            flags = ?flags,
            affect_ctrls = ?affect_ctrls,
            ctrls = ?ctrls,
        );
        let _enter = span.enter();
        let request = types::xkb::SetDebuggingFlagsRequest {
            affect_flags,
            flags,
            affect_ctrls,
            ctrls,
            message: Cow::Borrowed(message.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_debugging_flags_immediate(&mut self, affect_flags: types::Card32, flags: types::Card32, affect_ctrls: types::Card32, ctrls: types::Card32, message: impl AsRef<[types::xkb::String8]>) -> Result<types::xkb::SetDebuggingFlagsReply> {
        let request = types::xkb::SetDebuggingFlagsRequest {
            affect_flags,
            flags,
            affect_ctrls,
            ctrls,
            message: Cow::Borrowed(message.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xprint")]
    fn xprint_print_query_version(&mut self, ) -> Result<Cookie<types::xprint::PrintQueryVersionReply>> {
        let span = tracing::info_span!(
            "xprint_print_query_version",
        );
        let _enter = span.enter();
        let request = types::xprint::PrintQueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_version_immediate(&mut self, ) -> Result<types::xprint::PrintQueryVersionReply> {
        let request = types::xprint::PrintQueryVersionRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_printer_list(&mut self, printer_name: impl AsRef<[types::xprint::String8]>, locale: impl AsRef<[types::xprint::String8]>) -> Result<Cookie<types::xprint::PrintGetPrinterListReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_printer_list",
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetPrinterListRequest {
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_printer_list_immediate(&mut self, printer_name: impl AsRef<[types::xprint::String8]>, locale: impl AsRef<[types::xprint::String8]>) -> Result<types::xprint::PrintGetPrinterListReply> {
        let request = types::xprint::PrintGetPrinterListRequest {
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_rehash_printer_list(&mut self, ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_rehash_printer_list",
        );
        let _enter = span.enter();
        let request = types::xprint::PrintRehashPrinterListRequest {
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_rehash_printer_list_checked(&mut self, ) -> Result<()> {
        let request = types::xprint::PrintRehashPrinterListRequest {
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_create_context(&mut self, context_id: types::Card32, printer_name: impl AsRef<[types::xprint::String8]>, locale: impl AsRef<[types::xprint::String8]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_create_context",
            context_id = ?context_id,
        );
        let _enter = span.enter();
        let request = types::xprint::CreateContextRequest {
            context_id,
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_create_context_checked(&mut self, context_id: types::Card32, printer_name: impl AsRef<[types::xprint::String8]>, locale: impl AsRef<[types::xprint::String8]>) -> Result<()> {
        let request = types::xprint::CreateContextRequest {
            context_id,
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_context(&mut self, context: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_set_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintSetContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_context_checked(&mut self, context: types::Card32) -> Result<()> {
        let request = types::xprint::PrintSetContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_context(&mut self, ) -> Result<Cookie<types::xprint::PrintGetContextReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_context",
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetContextRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_context_immediate(&mut self, ) -> Result<types::xprint::PrintGetContextReply> {
        let request = types::xprint::PrintGetContextRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_destroy_context(&mut self, context: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_destroy_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintDestroyContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_destroy_context_checked(&mut self, context: types::Card32) -> Result<()> {
        let request = types::xprint::PrintDestroyContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_screen_of_context(&mut self, ) -> Result<Cookie<types::xprint::PrintGetScreenOfContextReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_screen_of_context",
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetScreenOfContextRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_screen_of_context_immediate(&mut self, ) -> Result<types::xprint::PrintGetScreenOfContextReply> {
        let request = types::xprint::PrintGetScreenOfContextRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_job(&mut self, output_mode: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_start_job",
            output_mode = ?output_mode,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintStartJobRequest {
            output_mode,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_job_checked(&mut self, output_mode: types::Card8) -> Result<()> {
        let request = types::xprint::PrintStartJobRequest {
            output_mode,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_job(&mut self, cancel: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_end_job",
            cancel = ?cancel,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintEndJobRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_job_checked(&mut self, cancel: types::Bool) -> Result<()> {
        let request = types::xprint::PrintEndJobRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_doc(&mut self, driver_mode: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_start_doc",
            driver_mode = ?driver_mode,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintStartDocRequest {
            driver_mode,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_doc_checked(&mut self, driver_mode: types::Card8) -> Result<()> {
        let request = types::xprint::PrintStartDocRequest {
            driver_mode,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_doc(&mut self, cancel: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_end_doc",
            cancel = ?cancel,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintEndDocRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_doc_checked(&mut self, cancel: types::Bool) -> Result<()> {
        let request = types::xprint::PrintEndDocRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_put_document_data(&mut self, drawable: types::xproto::Drawable, data: impl AsRef<[types::Byte]>, doc_format: impl AsRef<[types::xprint::String8]>, options: impl AsRef<[types::xprint::String8]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_put_document_data",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintPutDocumentDataRequest {
            drawable,
            data: Cow::Borrowed(data.as_ref()),
            doc_format: Cow::Borrowed(doc_format.as_ref()),
            options: Cow::Borrowed(options.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_put_document_data_checked(&mut self, drawable: types::xproto::Drawable, data: impl AsRef<[types::Byte]>, doc_format: impl AsRef<[types::xprint::String8]>, options: impl AsRef<[types::xprint::String8]>) -> Result<()> {
        let request = types::xprint::PrintPutDocumentDataRequest {
            drawable,
            data: Cow::Borrowed(data.as_ref()),
            doc_format: Cow::Borrowed(doc_format.as_ref()),
            options: Cow::Borrowed(options.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_document_data(&mut self, context: types::Pcontext, max_bytes: types::Card32) -> Result<Cookie<types::xprint::PrintGetDocumentDataReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_document_data",
            context = ?context,
            max_bytes = ?max_bytes,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetDocumentDataRequest {
            context,
            max_bytes,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_document_data_immediate(&mut self, context: types::Pcontext, max_bytes: types::Card32) -> Result<types::xprint::PrintGetDocumentDataReply> {
        let request = types::xprint::PrintGetDocumentDataRequest {
            context,
            max_bytes,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_page(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_start_page",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintStartPageRequest {
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_page_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let request = types::xprint::PrintStartPageRequest {
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_page(&mut self, cancel: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_end_page",
            cancel = ?cancel,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintEndPageRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_page_checked(&mut self, cancel: types::Bool) -> Result<()> {
        let request = types::xprint::PrintEndPageRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_select_input(&mut self, context: types::Pcontext, event_mask: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_select_input",
            context = ?context,
            event_mask = ?event_mask,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintSelectInputRequest {
            context,
            event_mask,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_select_input_checked(&mut self, context: types::Pcontext, event_mask: types::Card32) -> Result<()> {
        let request = types::xprint::PrintSelectInputRequest {
            context,
            event_mask,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_input_selected(&mut self, context: types::Pcontext) -> Result<Cookie<types::xprint::PrintInputSelectedReply>> {
        let span = tracing::info_span!(
            "xprint_print_input_selected",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintInputSelectedRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_input_selected_immediate(&mut self, context: types::Pcontext) -> Result<types::xprint::PrintInputSelectedReply> {
        let request = types::xprint::PrintInputSelectedRequest {
            context,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_attributes(&mut self, context: types::Pcontext, pool: types::Card8) -> Result<Cookie<types::xprint::PrintGetAttributesReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_attributes",
            context = ?context,
            pool = ?pool,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetAttributesRequest {
            context,
            pool,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_attributes_immediate(&mut self, context: types::Pcontext, pool: types::Card8) -> Result<types::xprint::PrintGetAttributesReply> {
        let request = types::xprint::PrintGetAttributesRequest {
            context,
            pool,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_one_attributes(&mut self, context: types::Pcontext, pool: types::Card8, name: impl AsRef<[types::xprint::String8]>) -> Result<Cookie<types::xprint::PrintGetOneAttributesReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_one_attributes",
            context = ?context,
            pool = ?pool,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetOneAttributesRequest {
            context,
            pool,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_one_attributes_immediate(&mut self, context: types::Pcontext, pool: types::Card8, name: impl AsRef<[types::xprint::String8]>) -> Result<types::xprint::PrintGetOneAttributesReply> {
        let request = types::xprint::PrintGetOneAttributesRequest {
            context,
            pool,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_attributes(&mut self, context: types::Pcontext, string_len: types::Card32, pool: types::Card8, rule: types::Card8, attributes: impl AsRef<[types::xprint::String8]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_set_attributes",
            context = ?context,
            string_len = ?string_len,
            pool = ?pool,
            rule = ?rule,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintSetAttributesRequest {
            context,
            string_len,
            pool,
            rule,
            attributes: Cow::Borrowed(attributes.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_attributes_checked(&mut self, context: types::Pcontext, string_len: types::Card32, pool: types::Card8, rule: types::Card8, attributes: impl AsRef<[types::xprint::String8]>) -> Result<()> {
        let request = types::xprint::PrintSetAttributesRequest {
            context,
            string_len,
            pool,
            rule,
            attributes: Cow::Borrowed(attributes.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_page_dimensions(&mut self, context: types::Pcontext) -> Result<Cookie<types::xprint::PrintGetPageDimensionsReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_page_dimensions",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetPageDimensionsRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_page_dimensions_immediate(&mut self, context: types::Pcontext) -> Result<types::xprint::PrintGetPageDimensionsReply> {
        let request = types::xprint::PrintGetPageDimensionsRequest {
            context,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_screens(&mut self, ) -> Result<Cookie<types::xprint::PrintQueryScreensReply>> {
        let span = tracing::info_span!(
            "xprint_print_query_screens",
        );
        let _enter = span.enter();
        let request = types::xprint::PrintQueryScreensRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_screens_immediate(&mut self, ) -> Result<types::xprint::PrintQueryScreensReply> {
        let request = types::xprint::PrintQueryScreensRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_image_resolution(&mut self, context: types::Pcontext, image_resolution: types::Card16) -> Result<Cookie<types::xprint::PrintSetImageResolutionReply>> {
        let span = tracing::info_span!(
            "xprint_print_set_image_resolution",
            context = ?context,
            image_resolution = ?image_resolution,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintSetImageResolutionRequest {
            context,
            image_resolution,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_image_resolution_immediate(&mut self, context: types::Pcontext, image_resolution: types::Card16) -> Result<types::xprint::PrintSetImageResolutionReply> {
        let request = types::xprint::PrintSetImageResolutionRequest {
            context,
            image_resolution,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_image_resolution(&mut self, context: types::Pcontext) -> Result<Cookie<types::xprint::PrintGetImageResolutionReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_image_resolution",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetImageResolutionRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_image_resolution_immediate(&mut self, context: types::Pcontext) -> Result<types::xprint::PrintGetImageResolutionReply> {
        let request = types::xprint::PrintGetImageResolutionRequest {
            context,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    fn create_window(&mut self, depth: types::Card8, wid: types::xproto::Window, parent: types::xproto::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, visual: types::Visualid, value_list: impl Borrow<types::xproto::CreateWindowAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_window",
            depth = ?depth,
            wid = ?wid,
            parent = ?parent,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            border_width = ?border_width,
            class = ?class,
            visual = ?visual,
        );
        let _enter = span.enter();
        let request = types::xproto::CreateWindowRequest {
            depth,
            wid,
            parent,
            x,
            y,
            width,
            height,
            border_width,
            class,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn create_window_checked(&mut self, depth: types::Card8, wid: types::xproto::Window, parent: types::xproto::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, visual: types::Visualid, value_list: impl Borrow<types::xproto::CreateWindowAux>) -> Result<()> {
        let request = types::xproto::CreateWindowRequest {
            depth,
            wid,
            parent,
            x,
            y,
            width,
            height,
            border_width,
            class,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn change_window_attributes(&mut self, window: types::xproto::Window, value_list: impl Borrow<types::xproto::ChangeWindowAttributesAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_window_attributes",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeWindowAttributesRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn change_window_attributes_checked(&mut self, window: types::xproto::Window, value_list: impl Borrow<types::xproto::ChangeWindowAttributesAux>) -> Result<()> {
        let request = types::xproto::ChangeWindowAttributesRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn get_window_attributes(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xproto::GetWindowAttributesReply>> {
        let span = tracing::info_span!(
            "get_window_attributes",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::GetWindowAttributesRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_window_attributes_immediate(&mut self, window: types::xproto::Window) -> Result<types::xproto::GetWindowAttributesReply> {
        let request = types::xproto::GetWindowAttributesRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn destroy_window(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "destroy_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::DestroyWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn destroy_window_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let request = types::xproto::DestroyWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn destroy_subwindows(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "destroy_subwindows",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::DestroySubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn destroy_subwindows_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let request = types::xproto::DestroySubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn change_save_set(&mut self, mode: types::SetMode, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_save_set",
            mode = ?mode,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeSaveSetRequest {
            mode,
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn change_save_set_checked(&mut self, mode: types::SetMode, window: types::xproto::Window) -> Result<()> {
        let request = types::xproto::ChangeSaveSetRequest {
            mode,
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn reparent_window(&mut self, window: types::xproto::Window, parent: types::xproto::Window, x: types::Int16, y: types::Int16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "reparent_window",
            window = ?window,
            parent = ?parent,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::ReparentWindowRequest {
            window,
            parent,
            x,
            y,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn reparent_window_checked(&mut self, window: types::xproto::Window, parent: types::xproto::Window, x: types::Int16, y: types::Int16) -> Result<()> {
        let request = types::xproto::ReparentWindowRequest {
            window,
            parent,
            x,
            y,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn map_window(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "map_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::MapWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn map_window_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let request = types::xproto::MapWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn map_subwindows(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "map_subwindows",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::MapSubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn map_subwindows_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let request = types::xproto::MapSubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn unmap_window(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "unmap_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::UnmapWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn unmap_window_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let request = types::xproto::UnmapWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn unmap_subwindows(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "unmap_subwindows",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::UnmapSubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn unmap_subwindows_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let request = types::xproto::UnmapSubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn configure_window(&mut self, window: types::xproto::Window, value_list: impl Borrow<types::xproto::ConfigureWindowAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "configure_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::ConfigureWindowRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn configure_window_checked(&mut self, window: types::xproto::Window, value_list: impl Borrow<types::xproto::ConfigureWindowAux>) -> Result<()> {
        let request = types::xproto::ConfigureWindowRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn circulate_window(&mut self, direction: types::Circulate, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "circulate_window",
            direction = ?direction,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::CirculateWindowRequest {
            direction,
            window,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn circulate_window_checked(&mut self, direction: types::Circulate, window: types::xproto::Window) -> Result<()> {
        let request = types::xproto::CirculateWindowRequest {
            direction,
            window,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn get_geometry(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<types::xproto::GetGeometryReply>> {
        let span = tracing::info_span!(
            "get_geometry",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xproto::GetGeometryRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_geometry_immediate(&mut self, drawable: types::xproto::Drawable) -> Result<types::xproto::GetGeometryReply> {
        let request = types::xproto::GetGeometryRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn query_tree(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xproto::QueryTreeReply>> {
        let span = tracing::info_span!(
            "query_tree",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryTreeRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn query_tree_immediate(&mut self, window: types::xproto::Window) -> Result<types::xproto::QueryTreeReply> {
        let request = types::xproto::QueryTreeRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn intern_atom(&mut self, only_if_exists: types::Bool, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::InternAtomReply>> {
        let span = tracing::info_span!(
            "intern_atom",
            only_if_exists = ?only_if_exists,
        );
        let _enter = span.enter();
        let request = types::xproto::InternAtomRequest {
            only_if_exists,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn intern_atom_immediate(&mut self, only_if_exists: types::Bool, name: impl AsRef<[types::Char]>) -> Result<types::xproto::InternAtomReply> {
        let request = types::xproto::InternAtomRequest {
            only_if_exists,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn get_atom_name(&mut self, atom: types::Atom) -> Result<Cookie<types::xproto::GetAtomNameReply>> {
        let span = tracing::info_span!(
            "get_atom_name",
            atom = ?atom,
        );
        let _enter = span.enter();
        let request = types::xproto::GetAtomNameRequest {
            atom,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_atom_name_immediate(&mut self, atom: types::Atom) -> Result<types::xproto::GetAtomNameReply> {
        let request = types::xproto::GetAtomNameRequest {
            atom,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn change_property(&mut self, mode: types::PropMode, window: types::xproto::Window, property: types::Atom, type_: types::Atom, format: types::Card8, data_len: types::Card32, data: &(impl crate::Void + ?Sized)) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_property",
            mode = ?mode,
            window = ?window,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            data_len = ?data_len,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangePropertyRequest {
            mode,
            window,
            property,
            type_,
            format,
            data_len,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn change_property_checked(&mut self, mode: types::PropMode, window: types::xproto::Window, property: types::Atom, type_: types::Atom, format: types::Card8, data_len: types::Card32, data: &(impl crate::Void + ?Sized)) -> Result<()> {
        let request = types::xproto::ChangePropertyRequest {
            mode,
            window,
            property,
            type_,
            format,
            data_len,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn delete_property(&mut self, window: types::xproto::Window, property: types::Atom) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "delete_property",
            window = ?window,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::xproto::DeletePropertyRequest {
            window,
            property,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn delete_property_checked(&mut self, window: types::xproto::Window, property: types::Atom) -> Result<()> {
        let request = types::xproto::DeletePropertyRequest {
            window,
            property,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn get_property(&mut self, delete: types::Bool, window: types::xproto::Window, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32) -> Result<Cookie<types::xproto::GetPropertyReply>> {
        let span = tracing::info_span!(
            "get_property",
            delete = ?delete,
            window = ?window,
            property = ?property,
            long_offset = ?long_offset,
            long_length = ?long_length,
        );
        let _enter = span.enter();
        let request = types::xproto::GetPropertyRequest {
            delete,
            window,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_property_immediate(&mut self, delete: types::Bool, window: types::xproto::Window, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32) -> Result<types::xproto::GetPropertyReply> {
        let request = types::xproto::GetPropertyRequest {
            delete,
            window,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn list_properties(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xproto::ListPropertiesReply>> {
        let span = tracing::info_span!(
            "list_properties",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::ListPropertiesRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn list_properties_immediate(&mut self, window: types::xproto::Window) -> Result<types::xproto::ListPropertiesReply> {
        let request = types::xproto::ListPropertiesRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn set_selection_owner(&mut self, owner: impl Into<types::xproto::Window>, selection: types::Atom, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_selection_owner",
            selection = ?selection,
        );
        let _enter = span.enter();
        let request = types::xproto::SetSelectionOwnerRequest {
            owner: Into::<u32>::into(owner.into()) as _,
            selection,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn set_selection_owner_checked(&mut self, owner: impl Into<types::xproto::Window>, selection: types::Atom, time: impl Into<types::Time>) -> Result<()> {
        let request = types::xproto::SetSelectionOwnerRequest {
            owner: Into::<u32>::into(owner.into()) as _,
            selection,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn get_selection_owner(&mut self, selection: types::Atom) -> Result<Cookie<types::xproto::GetSelectionOwnerReply>> {
        let span = tracing::info_span!(
            "get_selection_owner",
            selection = ?selection,
        );
        let _enter = span.enter();
        let request = types::xproto::GetSelectionOwnerRequest {
            selection,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_selection_owner_immediate(&mut self, selection: types::Atom) -> Result<types::xproto::GetSelectionOwnerReply> {
        let request = types::xproto::GetSelectionOwnerRequest {
            selection,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn convert_selection(&mut self, requestor: types::xproto::Window, selection: types::Atom, target: types::Atom, property: impl Into<types::Atom>, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "convert_selection",
            requestor = ?requestor,
            selection = ?selection,
            target = ?target,
        );
        let _enter = span.enter();
        let request = types::xproto::ConvertSelectionRequest {
            requestor,
            selection,
            target,
            property: Into::<u32>::into(property.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn convert_selection_checked(&mut self, requestor: types::xproto::Window, selection: types::Atom, target: types::Atom, property: impl Into<types::Atom>, time: impl Into<types::Time>) -> Result<()> {
        let request = types::xproto::ConvertSelectionRequest {
            requestor,
            selection,
            target,
            property: Into::<u32>::into(property.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn send_event(&mut self, propagate: types::Bool, destination: impl Into<types::SendEventDest>, event_mask: impl Into<types::xproto::EventMask>, event: impl Borrow<[types::Char; 32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "send_event",
            propagate = ?propagate,
        );
        let _enter = span.enter();
        let request = types::xproto::SendEventRequest {
            propagate,
            destination: Into::<u32>::into(destination.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            event: Cow::Borrowed(event.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn send_event_checked(&mut self, propagate: types::Bool, destination: impl Into<types::SendEventDest>, event_mask: impl Into<types::xproto::EventMask>, event: impl Borrow<[types::Char; 32]>) -> Result<()> {
        let request = types::xproto::SendEventRequest {
            propagate,
            destination: Into::<u32>::into(destination.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            event: Cow::Borrowed(event.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn grab_pointer(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, event_mask: impl Into<types::xproto::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::xproto::Window>, cursor: impl Into<types::xproto::Cursor>, time: impl Into<types::Time>) -> Result<Cookie<types::xproto::GrabPointerReply>> {
        let span = tracing::info_span!(
            "grab_pointer",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let _enter = span.enter();
        let request = types::xproto::GrabPointerRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn grab_pointer_immediate(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, event_mask: impl Into<types::xproto::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::xproto::Window>, cursor: impl Into<types::xproto::Cursor>, time: impl Into<types::Time>) -> Result<types::xproto::GrabPointerReply> {
        let request = types::xproto::GrabPointerRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn ungrab_pointer(&mut self, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "ungrab_pointer",
        );
        let _enter = span.enter();
        let request = types::xproto::UngrabPointerRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn ungrab_pointer_checked(&mut self, time: impl Into<types::Time>) -> Result<()> {
        let request = types::xproto::UngrabPointerRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn grab_button(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, event_mask: impl Into<types::xproto::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::xproto::Window>, cursor: impl Into<types::xproto::Cursor>, button: types::ButtonIndex, modifiers: impl Into<types::ModMask>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "grab_button",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
            button = ?button,
        );
        let _enter = span.enter();
        let request = types::xproto::GrabButtonRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            button,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn grab_button_checked(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, event_mask: impl Into<types::xproto::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::xproto::Window>, cursor: impl Into<types::xproto::Cursor>, button: types::ButtonIndex, modifiers: impl Into<types::ModMask>) -> Result<()> {
        let request = types::xproto::GrabButtonRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            button,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn ungrab_button(&mut self, button: types::ButtonIndex, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "ungrab_button",
            button = ?button,
            grab_window = ?grab_window,
        );
        let _enter = span.enter();
        let request = types::xproto::UngrabButtonRequest {
            button,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn ungrab_button_checked(&mut self, button: types::ButtonIndex, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>) -> Result<()> {
        let request = types::xproto::UngrabButtonRequest {
            button,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn change_active_pointer_grab(&mut self, cursor: impl Into<types::xproto::Cursor>, time: impl Into<types::Time>, event_mask: impl Into<types::xproto::EventMask>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_active_pointer_grab",
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeActivePointerGrabRequest {
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn change_active_pointer_grab_checked(&mut self, cursor: impl Into<types::xproto::Cursor>, time: impl Into<types::Time>, event_mask: impl Into<types::xproto::EventMask>) -> Result<()> {
        let request = types::xproto::ChangeActivePointerGrabRequest {
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn grab_keyboard(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, time: impl Into<types::Time>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> Result<Cookie<types::xproto::GrabKeyboardReply>> {
        let span = tracing::info_span!(
            "grab_keyboard",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let _enter = span.enter();
        let request = types::xproto::GrabKeyboardRequest {
            owner_events,
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn grab_keyboard_immediate(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, time: impl Into<types::Time>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> Result<types::xproto::GrabKeyboardReply> {
        let request = types::xproto::GrabKeyboardRequest {
            owner_events,
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn ungrab_keyboard(&mut self, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "ungrab_keyboard",
        );
        let _enter = span.enter();
        let request = types::xproto::UngrabKeyboardRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn ungrab_keyboard_checked(&mut self, time: impl Into<types::Time>) -> Result<()> {
        let request = types::xproto::UngrabKeyboardRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn grab_key(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, key: impl Into<types::Grab>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "grab_key",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let _enter = span.enter();
        let request = types::xproto::GrabKeyRequest {
            owner_events,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn grab_key_checked(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, key: impl Into<types::Grab>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> Result<()> {
        let request = types::xproto::GrabKeyRequest {
            owner_events,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn ungrab_key(&mut self, key: impl Into<types::Grab>, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "ungrab_key",
            grab_window = ?grab_window,
        );
        let _enter = span.enter();
        let request = types::xproto::UngrabKeyRequest {
            key: Into::<u32>::into(key.into()) as _,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn ungrab_key_checked(&mut self, key: impl Into<types::Grab>, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>) -> Result<()> {
        let request = types::xproto::UngrabKeyRequest {
            key: Into::<u32>::into(key.into()) as _,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn allow_events(&mut self, mode: types::Allow, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "allow_events",
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xproto::AllowEventsRequest {
            mode,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn allow_events_checked(&mut self, mode: types::Allow, time: impl Into<types::Time>) -> Result<()> {
        let request = types::xproto::AllowEventsRequest {
            mode,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn grab_server(&mut self, ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "grab_server",
        );
        let _enter = span.enter();
        let request = types::xproto::GrabServerRequest {
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn grab_server_checked(&mut self, ) -> Result<()> {
        let request = types::xproto::GrabServerRequest {
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn ungrab_server(&mut self, ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "ungrab_server",
        );
        let _enter = span.enter();
        let request = types::xproto::UngrabServerRequest {
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn ungrab_server_checked(&mut self, ) -> Result<()> {
        let request = types::xproto::UngrabServerRequest {
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn query_pointer(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xproto::QueryPointerReply>> {
        let span = tracing::info_span!(
            "query_pointer",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryPointerRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn query_pointer_immediate(&mut self, window: types::xproto::Window) -> Result<types::xproto::QueryPointerReply> {
        let request = types::xproto::QueryPointerRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn get_motion_events(&mut self, window: types::xproto::Window, start: impl Into<types::Time>, stop: impl Into<types::Time>) -> Result<Cookie<types::xproto::GetMotionEventsReply>> {
        let span = tracing::info_span!(
            "get_motion_events",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::GetMotionEventsRequest {
            window,
            start: Into::<u32>::into(start.into()) as _,
            stop: Into::<u32>::into(stop.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_motion_events_immediate(&mut self, window: types::xproto::Window, start: impl Into<types::Time>, stop: impl Into<types::Time>) -> Result<types::xproto::GetMotionEventsReply> {
        let request = types::xproto::GetMotionEventsRequest {
            window,
            start: Into::<u32>::into(start.into()) as _,
            stop: Into::<u32>::into(stop.into()) as _,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn translate_coordinates(&mut self, src_window: types::xproto::Window, dst_window: types::xproto::Window, src_x: types::Int16, src_y: types::Int16) -> Result<Cookie<types::xproto::TranslateCoordinatesReply>> {
        let span = tracing::info_span!(
            "translate_coordinates",
            src_window = ?src_window,
            dst_window = ?dst_window,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::xproto::TranslateCoordinatesRequest {
            src_window,
            dst_window,
            src_x,
            src_y,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn translate_coordinates_immediate(&mut self, src_window: types::xproto::Window, dst_window: types::xproto::Window, src_x: types::Int16, src_y: types::Int16) -> Result<types::xproto::TranslateCoordinatesReply> {
        let request = types::xproto::TranslateCoordinatesRequest {
            src_window,
            dst_window,
            src_x,
            src_y,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn warp_pointer(&mut self, src_window: impl Into<types::xproto::Window>, dst_window: impl Into<types::xproto::Window>, src_x: types::Int16, src_y: types::Int16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "warp_pointer",
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
        );
        let _enter = span.enter();
        let request = types::xproto::WarpPointerRequest {
            src_window: Into::<u32>::into(src_window.into()) as _,
            dst_window: Into::<u32>::into(dst_window.into()) as _,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn warp_pointer_checked(&mut self, src_window: impl Into<types::xproto::Window>, dst_window: impl Into<types::xproto::Window>, src_x: types::Int16, src_y: types::Int16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16) -> Result<()> {
        let request = types::xproto::WarpPointerRequest {
            src_window: Into::<u32>::into(src_window.into()) as _,
            dst_window: Into::<u32>::into(dst_window.into()) as _,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn set_input_focus(&mut self, revert_to: types::InputFocus, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_input_focus",
            revert_to = ?revert_to,
        );
        let _enter = span.enter();
        let request = types::xproto::SetInputFocusRequest {
            revert_to,
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn set_input_focus_checked(&mut self, revert_to: types::InputFocus, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>) -> Result<()> {
        let request = types::xproto::SetInputFocusRequest {
            revert_to,
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn get_input_focus(&mut self, ) -> Result<Cookie<types::xproto::GetInputFocusReply>> {
        let span = tracing::info_span!(
            "get_input_focus",
        );
        let _enter = span.enter();
        let request = types::xproto::GetInputFocusRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_input_focus_immediate(&mut self, ) -> Result<types::xproto::GetInputFocusReply> {
        let request = types::xproto::GetInputFocusRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn query_keymap(&mut self, ) -> Result<Cookie<types::xproto::QueryKeymapReply>> {
        let span = tracing::info_span!(
            "query_keymap",
        );
        let _enter = span.enter();
        let request = types::xproto::QueryKeymapRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn query_keymap_immediate(&mut self, ) -> Result<types::xproto::QueryKeymapReply> {
        let request = types::xproto::QueryKeymapRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn open_font(&mut self, fid: types::Font, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "open_font",
            fid = ?fid,
        );
        let _enter = span.enter();
        let request = types::xproto::OpenFontRequest {
            fid,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn open_font_checked(&mut self, fid: types::Font, name: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xproto::OpenFontRequest {
            fid,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn close_font(&mut self, font: types::Font) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "close_font",
            font = ?font,
        );
        let _enter = span.enter();
        let request = types::xproto::CloseFontRequest {
            font,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn close_font_checked(&mut self, font: types::Font) -> Result<()> {
        let request = types::xproto::CloseFontRequest {
            font,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn query_font(&mut self, font: types::Fontable) -> Result<Cookie<types::xproto::QueryFontReply>> {
        let span = tracing::info_span!(
            "query_font",
            font = ?font,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryFontRequest {
            font,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn query_font_immediate(&mut self, font: types::Fontable) -> Result<types::xproto::QueryFontReply> {
        let request = types::xproto::QueryFontRequest {
            font,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn query_text_extents(&mut self, font: types::Fontable, string: impl AsRef<[types::Char2b]>) -> Result<Cookie<types::xproto::QueryTextExtentsReply>> {
        let span = tracing::info_span!(
            "query_text_extents",
            font = ?font,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryTextExtentsRequest {
            font,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn query_text_extents_immediate(&mut self, font: types::Fontable, string: impl AsRef<[types::Char2b]>) -> Result<types::xproto::QueryTextExtentsReply> {
        let request = types::xproto::QueryTextExtentsRequest {
            font,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn list_fonts(&mut self, max_names: types::Card16, pattern: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::ListFontsReply>> {
        let span = tracing::info_span!(
            "list_fonts",
            max_names = ?max_names,
        );
        let _enter = span.enter();
        let request = types::xproto::ListFontsRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn list_fonts_immediate(&mut self, max_names: types::Card16, pattern: impl AsRef<[types::Char]>) -> Result<types::xproto::ListFontsReply> {
        let request = types::xproto::ListFontsRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn list_fonts_with_info(&mut self, max_names: types::Card16, pattern: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::ListFontsWithInfoReply>> {
        let span = tracing::info_span!(
            "list_fonts_with_info",
            max_names = ?max_names,
        );
        let _enter = span.enter();
        let request = types::xproto::ListFontsWithInfoRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn list_fonts_with_info_immediate(&mut self, max_names: types::Card16, pattern: impl AsRef<[types::Char]>) -> Result<types::xproto::ListFontsWithInfoReply> {
        let request = types::xproto::ListFontsWithInfoRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn set_font_path(&mut self, font: impl AsRef<[types::Str]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_font_path",
        );
        let _enter = span.enter();
        let request = types::xproto::SetFontPathRequest {
            font: Cow::Borrowed(font.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn set_font_path_checked(&mut self, font: impl AsRef<[types::Str]>) -> Result<()> {
        let request = types::xproto::SetFontPathRequest {
            font: Cow::Borrowed(font.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn get_font_path(&mut self, ) -> Result<Cookie<types::xproto::GetFontPathReply>> {
        let span = tracing::info_span!(
            "get_font_path",
        );
        let _enter = span.enter();
        let request = types::xproto::GetFontPathRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_font_path_immediate(&mut self, ) -> Result<types::xproto::GetFontPathReply> {
        let request = types::xproto::GetFontPathRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn create_pixmap(&mut self, depth: types::Card8, pid: types::xproto::Pixmap, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_pixmap",
            depth = ?depth,
            pid = ?pid,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xproto::CreatePixmapRequest {
            depth,
            pid,
            drawable,
            width,
            height,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn create_pixmap_checked(&mut self, depth: types::Card8, pid: types::xproto::Pixmap, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16) -> Result<()> {
        let request = types::xproto::CreatePixmapRequest {
            depth,
            pid,
            drawable,
            width,
            height,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn free_pixmap(&mut self, pixmap: types::xproto::Pixmap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "free_pixmap",
            pixmap = ?pixmap,
        );
        let _enter = span.enter();
        let request = types::xproto::FreePixmapRequest {
            pixmap,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn free_pixmap_checked(&mut self, pixmap: types::xproto::Pixmap) -> Result<()> {
        let request = types::xproto::FreePixmapRequest {
            pixmap,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn create_gc(&mut self, cid: types::Gcontext, drawable: types::xproto::Drawable, value_list: impl Borrow<types::xproto::CreateGCAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_gc",
            cid = ?cid,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xproto::CreateGCRequest {
            cid,
            drawable,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn create_gc_checked(&mut self, cid: types::Gcontext, drawable: types::xproto::Drawable, value_list: impl Borrow<types::xproto::CreateGCAux>) -> Result<()> {
        let request = types::xproto::CreateGCRequest {
            cid,
            drawable,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn change_gc(&mut self, gc: types::Gcontext, value_list: impl Borrow<types::xproto::ChangeGCAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_gc",
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeGCRequest {
            gc,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn change_gc_checked(&mut self, gc: types::Gcontext, value_list: impl Borrow<types::xproto::ChangeGCAux>) -> Result<()> {
        let request = types::xproto::ChangeGCRequest {
            gc,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn copy_gc(&mut self, src_gc: types::Gcontext, dst_gc: types::Gcontext, value_mask: impl Into<types::xproto::GC>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "copy_gc",
            src_gc = ?src_gc,
            dst_gc = ?dst_gc,
        );
        let _enter = span.enter();
        let request = types::xproto::CopyGCRequest {
            src_gc,
            dst_gc,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn copy_gc_checked(&mut self, src_gc: types::Gcontext, dst_gc: types::Gcontext, value_mask: impl Into<types::xproto::GC>) -> Result<()> {
        let request = types::xproto::CopyGCRequest {
            src_gc,
            dst_gc,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn set_dashes(&mut self, gc: types::Gcontext, dash_offset: types::Card16, dashes: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_dashes",
            gc = ?gc,
            dash_offset = ?dash_offset,
        );
        let _enter = span.enter();
        let request = types::xproto::SetDashesRequest {
            gc,
            dash_offset,
            dashes: Cow::Borrowed(dashes.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn set_dashes_checked(&mut self, gc: types::Gcontext, dash_offset: types::Card16, dashes: impl AsRef<[types::Card8]>) -> Result<()> {
        let request = types::xproto::SetDashesRequest {
            gc,
            dash_offset,
            dashes: Cow::Borrowed(dashes.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn set_clip_rectangles(&mut self, ordering: types::ClipOrdering, gc: types::Gcontext, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_clip_rectangles",
            ordering = ?ordering,
            gc = ?gc,
            clip_x_origin = ?clip_x_origin,
            clip_y_origin = ?clip_y_origin,
        );
        let _enter = span.enter();
        let request = types::xproto::SetClipRectanglesRequest {
            ordering,
            gc,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn set_clip_rectangles_checked(&mut self, ordering: types::ClipOrdering, gc: types::Gcontext, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<()> {
        let request = types::xproto::SetClipRectanglesRequest {
            ordering,
            gc,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn free_gc(&mut self, gc: types::Gcontext) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "free_gc",
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::FreeGCRequest {
            gc,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn free_gc_checked(&mut self, gc: types::Gcontext) -> Result<()> {
        let request = types::xproto::FreeGCRequest {
            gc,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn clear_area(&mut self, exposures: types::Bool, window: types::xproto::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "clear_area",
            exposures = ?exposures,
            window = ?window,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xproto::ClearAreaRequest {
            exposures,
            window,
            x,
            y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn clear_area_checked(&mut self, exposures: types::Bool, window: types::xproto::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16) -> Result<()> {
        let request = types::xproto::ClearAreaRequest {
            exposures,
            window,
            x,
            y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn copy_area(&mut self, src_drawable: types::xproto::Drawable, dst_drawable: types::xproto::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "copy_area",
            src_drawable = ?src_drawable,
            dst_drawable = ?dst_drawable,
            gc = ?gc,
            src_x = ?src_x,
            src_y = ?src_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xproto::CopyAreaRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn copy_area_checked(&mut self, src_drawable: types::xproto::Drawable, dst_drawable: types::xproto::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> Result<()> {
        let request = types::xproto::CopyAreaRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn copy_plane(&mut self, src_drawable: types::xproto::Drawable, dst_drawable: types::xproto::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16, bit_plane: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "copy_plane",
            src_drawable = ?src_drawable,
            dst_drawable = ?dst_drawable,
            gc = ?gc,
            src_x = ?src_x,
            src_y = ?src_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
            bit_plane = ?bit_plane,
        );
        let _enter = span.enter();
        let request = types::xproto::CopyPlaneRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
            bit_plane,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn copy_plane_checked(&mut self, src_drawable: types::xproto::Drawable, dst_drawable: types::xproto::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16, bit_plane: types::Card32) -> Result<()> {
        let request = types::xproto::CopyPlaneRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
            bit_plane,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn poly_point(&mut self, coordinate_mode: types::CoordMode, drawable: types::xproto::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_point",
            coordinate_mode = ?coordinate_mode,
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyPointRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn poly_point_checked(&mut self, coordinate_mode: types::CoordMode, drawable: types::xproto::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> Result<()> {
        let request = types::xproto::PolyPointRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn poly_line(&mut self, coordinate_mode: types::CoordMode, drawable: types::xproto::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_line",
            coordinate_mode = ?coordinate_mode,
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyLineRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn poly_line_checked(&mut self, coordinate_mode: types::CoordMode, drawable: types::xproto::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> Result<()> {
        let request = types::xproto::PolyLineRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn poly_segment(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, segments: impl AsRef<[types::Segment]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_segment",
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolySegmentRequest {
            drawable,
            gc,
            segments: Cow::Borrowed(segments.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn poly_segment_checked(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, segments: impl AsRef<[types::Segment]>) -> Result<()> {
        let request = types::xproto::PolySegmentRequest {
            drawable,
            gc,
            segments: Cow::Borrowed(segments.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn poly_rectangle(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_rectangle",
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn poly_rectangle_checked(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> Result<()> {
        let request = types::xproto::PolyRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn poly_arc(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_arc",
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn poly_arc_checked(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> Result<()> {
        let request = types::xproto::PolyArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn fill_poly(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, shape: types::PolyShape, coordinate_mode: types::CoordMode, points: impl AsRef<[types::Point]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "fill_poly",
            drawable = ?drawable,
            gc = ?gc,
            shape = ?shape,
            coordinate_mode = ?coordinate_mode,
        );
        let _enter = span.enter();
        let request = types::xproto::FillPolyRequest {
            drawable,
            gc,
            shape,
            coordinate_mode,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn fill_poly_checked(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, shape: types::PolyShape, coordinate_mode: types::CoordMode, points: impl AsRef<[types::Point]>) -> Result<()> {
        let request = types::xproto::FillPolyRequest {
            drawable,
            gc,
            shape,
            coordinate_mode,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn poly_fill_rectangle(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_fill_rectangle",
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyFillRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn poly_fill_rectangle_checked(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> Result<()> {
        let request = types::xproto::PolyFillRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn poly_fill_arc(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_fill_arc",
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyFillArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn poly_fill_arc_checked(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> Result<()> {
        let request = types::xproto::PolyFillArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn put_image(&mut self, format: types::ImageFormat, drawable: types::xproto::Drawable, gc: types::Gcontext, width: types::Card16, height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, left_pad: types::Card8, depth: types::Card8, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "put_image",
            format = ?format,
            drawable = ?drawable,
            gc = ?gc,
            width = ?width,
            height = ?height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            left_pad = ?left_pad,
            depth = ?depth,
        );
        let _enter = span.enter();
        let request = types::xproto::PutImageRequest {
            format,
            drawable,
            gc,
            width,
            height,
            dst_x,
            dst_y,
            left_pad,
            depth,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn put_image_checked(&mut self, format: types::ImageFormat, drawable: types::xproto::Drawable, gc: types::Gcontext, width: types::Card16, height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, left_pad: types::Card8, depth: types::Card8, data: impl AsRef<[types::Byte]>) -> Result<()> {
        let request = types::xproto::PutImageRequest {
            format,
            drawable,
            gc,
            width,
            height,
            dst_x,
            dst_y,
            left_pad,
            depth,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn get_image(&mut self, format: types::ImageFormat, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32) -> Result<Cookie<types::xproto::GetImageReply>> {
        let span = tracing::info_span!(
            "get_image",
            format = ?format,
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            plane_mask = ?plane_mask,
        );
        let _enter = span.enter();
        let request = types::xproto::GetImageRequest {
            format,
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_image_immediate(&mut self, format: types::ImageFormat, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32) -> Result<types::xproto::GetImageReply> {
        let request = types::xproto::GetImageRequest {
            format,
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn poly_text8(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_text8",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyText8Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn poly_text8_checked(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> Result<()> {
        let request = types::xproto::PolyText8Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn poly_text16(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_text16",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyText16Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn poly_text16_checked(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> Result<()> {
        let request = types::xproto::PolyText16Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn image_text8(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "image_text8",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::ImageText8Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn image_text8_checked(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xproto::ImageText8Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn image_text16(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char2b]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "image_text16",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::ImageText16Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn image_text16_checked(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char2b]>) -> Result<()> {
        let request = types::xproto::ImageText16Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn create_colormap(&mut self, alloc: types::ColormapAlloc, mid: types::Colormap, window: types::xproto::Window, visual: types::Visualid) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_colormap",
            alloc = ?alloc,
            mid = ?mid,
            window = ?window,
            visual = ?visual,
        );
        let _enter = span.enter();
        let request = types::xproto::CreateColormapRequest {
            alloc,
            mid,
            window,
            visual,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn create_colormap_checked(&mut self, alloc: types::ColormapAlloc, mid: types::Colormap, window: types::xproto::Window, visual: types::Visualid) -> Result<()> {
        let request = types::xproto::CreateColormapRequest {
            alloc,
            mid,
            window,
            visual,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn free_colormap(&mut self, cmap: types::Colormap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "free_colormap",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::FreeColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn free_colormap_checked(&mut self, cmap: types::Colormap) -> Result<()> {
        let request = types::xproto::FreeColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn copy_colormap_and_free(&mut self, mid: types::Colormap, src_cmap: types::Colormap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "copy_colormap_and_free",
            mid = ?mid,
            src_cmap = ?src_cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::CopyColormapAndFreeRequest {
            mid,
            src_cmap,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn copy_colormap_and_free_checked(&mut self, mid: types::Colormap, src_cmap: types::Colormap) -> Result<()> {
        let request = types::xproto::CopyColormapAndFreeRequest {
            mid,
            src_cmap,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn install_colormap(&mut self, cmap: types::Colormap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "install_colormap",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::InstallColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn install_colormap_checked(&mut self, cmap: types::Colormap) -> Result<()> {
        let request = types::xproto::InstallColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn uninstall_colormap(&mut self, cmap: types::Colormap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "uninstall_colormap",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::UninstallColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn uninstall_colormap_checked(&mut self, cmap: types::Colormap) -> Result<()> {
        let request = types::xproto::UninstallColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn list_installed_colormaps(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xproto::ListInstalledColormapsReply>> {
        let span = tracing::info_span!(
            "list_installed_colormaps",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::ListInstalledColormapsRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn list_installed_colormaps_immediate(&mut self, window: types::xproto::Window) -> Result<types::xproto::ListInstalledColormapsReply> {
        let request = types::xproto::ListInstalledColormapsRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn alloc_color(&mut self, cmap: types::Colormap, red: types::Card16, green: types::Card16, blue: types::Card16) -> Result<Cookie<types::xproto::AllocColorReply>> {
        let span = tracing::info_span!(
            "alloc_color",
            cmap = ?cmap,
            red = ?red,
            green = ?green,
            blue = ?blue,
        );
        let _enter = span.enter();
        let request = types::xproto::AllocColorRequest {
            cmap,
            red,
            green,
            blue,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn alloc_color_immediate(&mut self, cmap: types::Colormap, red: types::Card16, green: types::Card16, blue: types::Card16) -> Result<types::xproto::AllocColorReply> {
        let request = types::xproto::AllocColorRequest {
            cmap,
            red,
            green,
            blue,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn alloc_named_color(&mut self, cmap: types::Colormap, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::AllocNamedColorReply>> {
        let span = tracing::info_span!(
            "alloc_named_color",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::AllocNamedColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn alloc_named_color_immediate(&mut self, cmap: types::Colormap, name: impl AsRef<[types::Char]>) -> Result<types::xproto::AllocNamedColorReply> {
        let request = types::xproto::AllocNamedColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn alloc_color_cells(&mut self, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, planes: types::Card16) -> Result<Cookie<types::xproto::AllocColorCellsReply>> {
        let span = tracing::info_span!(
            "alloc_color_cells",
            contiguous = ?contiguous,
            cmap = ?cmap,
            colors = ?colors,
            planes = ?planes,
        );
        let _enter = span.enter();
        let request = types::xproto::AllocColorCellsRequest {
            contiguous,
            cmap,
            colors,
            planes,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn alloc_color_cells_immediate(&mut self, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, planes: types::Card16) -> Result<types::xproto::AllocColorCellsReply> {
        let request = types::xproto::AllocColorCellsRequest {
            contiguous,
            cmap,
            colors,
            planes,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn alloc_color_planes(&mut self, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, reds: types::Card16, greens: types::Card16, blues: types::Card16) -> Result<Cookie<types::xproto::AllocColorPlanesReply>> {
        let span = tracing::info_span!(
            "alloc_color_planes",
            contiguous = ?contiguous,
            cmap = ?cmap,
            colors = ?colors,
            reds = ?reds,
            greens = ?greens,
            blues = ?blues,
        );
        let _enter = span.enter();
        let request = types::xproto::AllocColorPlanesRequest {
            contiguous,
            cmap,
            colors,
            reds,
            greens,
            blues,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn alloc_color_planes_immediate(&mut self, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, reds: types::Card16, greens: types::Card16, blues: types::Card16) -> Result<types::xproto::AllocColorPlanesReply> {
        let request = types::xproto::AllocColorPlanesRequest {
            contiguous,
            cmap,
            colors,
            reds,
            greens,
            blues,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn free_colors(&mut self, cmap: types::Colormap, plane_mask: types::Card32, pixels: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "free_colors",
            cmap = ?cmap,
            plane_mask = ?plane_mask,
        );
        let _enter = span.enter();
        let request = types::xproto::FreeColorsRequest {
            cmap,
            plane_mask,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn free_colors_checked(&mut self, cmap: types::Colormap, plane_mask: types::Card32, pixels: impl AsRef<[types::Card32]>) -> Result<()> {
        let request = types::xproto::FreeColorsRequest {
            cmap,
            plane_mask,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn store_colors(&mut self, cmap: types::Colormap, items: impl AsRef<[types::Coloritem]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "store_colors",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::StoreColorsRequest {
            cmap,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn store_colors_checked(&mut self, cmap: types::Colormap, items: impl AsRef<[types::Coloritem]>) -> Result<()> {
        let request = types::xproto::StoreColorsRequest {
            cmap,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn store_named_color(&mut self, flags: impl Into<types::ColorFlag>, cmap: types::Colormap, pixel: types::Card32, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "store_named_color",
            cmap = ?cmap,
            pixel = ?pixel,
        );
        let _enter = span.enter();
        let request = types::xproto::StoreNamedColorRequest {
            flags: Into::<u32>::into(flags.into()) as _,
            cmap,
            pixel,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn store_named_color_checked(&mut self, flags: impl Into<types::ColorFlag>, cmap: types::Colormap, pixel: types::Card32, name: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xproto::StoreNamedColorRequest {
            flags: Into::<u32>::into(flags.into()) as _,
            cmap,
            pixel,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn query_colors(&mut self, cmap: types::Colormap, pixels: impl AsRef<[types::Card32]>) -> Result<Cookie<types::xproto::QueryColorsReply>> {
        let span = tracing::info_span!(
            "query_colors",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryColorsRequest {
            cmap,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn query_colors_immediate(&mut self, cmap: types::Colormap, pixels: impl AsRef<[types::Card32]>) -> Result<types::xproto::QueryColorsReply> {
        let request = types::xproto::QueryColorsRequest {
            cmap,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn lookup_color(&mut self, cmap: types::Colormap, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::LookupColorReply>> {
        let span = tracing::info_span!(
            "lookup_color",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::LookupColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn lookup_color_immediate(&mut self, cmap: types::Colormap, name: impl AsRef<[types::Char]>) -> Result<types::xproto::LookupColorReply> {
        let request = types::xproto::LookupColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn create_cursor(&mut self, cid: types::xproto::Cursor, source: types::xproto::Pixmap, mask: impl Into<types::xproto::Pixmap>, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16, x: types::Card16, y: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_cursor",
            cid = ?cid,
            source = ?source,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::CreateCursorRequest {
            cid,
            source,
            mask: Into::<u32>::into(mask.into()) as _,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
            x,
            y,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn create_cursor_checked(&mut self, cid: types::xproto::Cursor, source: types::xproto::Pixmap, mask: impl Into<types::xproto::Pixmap>, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16, x: types::Card16, y: types::Card16) -> Result<()> {
        let request = types::xproto::CreateCursorRequest {
            cid,
            source,
            mask: Into::<u32>::into(mask.into()) as _,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
            x,
            y,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn create_glyph_cursor(&mut self, cid: types::xproto::Cursor, source_font: types::Font, mask_font: impl Into<types::Font>, source_char: types::Card16, mask_char: types::Card16, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_glyph_cursor",
            cid = ?cid,
            source_font = ?source_font,
            source_char = ?source_char,
            mask_char = ?mask_char,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
        );
        let _enter = span.enter();
        let request = types::xproto::CreateGlyphCursorRequest {
            cid,
            source_font,
            mask_font: Into::<u32>::into(mask_font.into()) as _,
            source_char,
            mask_char,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn create_glyph_cursor_checked(&mut self, cid: types::xproto::Cursor, source_font: types::Font, mask_font: impl Into<types::Font>, source_char: types::Card16, mask_char: types::Card16, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> Result<()> {
        let request = types::xproto::CreateGlyphCursorRequest {
            cid,
            source_font,
            mask_font: Into::<u32>::into(mask_font.into()) as _,
            source_char,
            mask_char,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn free_cursor(&mut self, cursor: types::xproto::Cursor) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "free_cursor",
            cursor = ?cursor,
        );
        let _enter = span.enter();
        let request = types::xproto::FreeCursorRequest {
            cursor,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn free_cursor_checked(&mut self, cursor: types::xproto::Cursor) -> Result<()> {
        let request = types::xproto::FreeCursorRequest {
            cursor,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn recolor_cursor(&mut self, cursor: types::xproto::Cursor, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "recolor_cursor",
            cursor = ?cursor,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
        );
        let _enter = span.enter();
        let request = types::xproto::RecolorCursorRequest {
            cursor,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn recolor_cursor_checked(&mut self, cursor: types::xproto::Cursor, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> Result<()> {
        let request = types::xproto::RecolorCursorRequest {
            cursor,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn query_best_size(&mut self, class: types::QueryShapeOf, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16) -> Result<Cookie<types::xproto::QueryBestSizeReply>> {
        let span = tracing::info_span!(
            "query_best_size",
            class = ?class,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryBestSizeRequest {
            class,
            drawable,
            width,
            height,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn query_best_size_immediate(&mut self, class: types::QueryShapeOf, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16) -> Result<types::xproto::QueryBestSizeReply> {
        let request = types::xproto::QueryBestSizeRequest {
            class,
            drawable,
            width,
            height,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn query_extension(&mut self, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::QueryExtensionReply>> {
        let span = tracing::info_span!(
            "query_extension",
        );
        let _enter = span.enter();
        let request = types::xproto::QueryExtensionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn query_extension_immediate(&mut self, name: impl AsRef<[types::Char]>) -> Result<types::xproto::QueryExtensionReply> {
        let request = types::xproto::QueryExtensionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn list_extensions(&mut self, ) -> Result<Cookie<types::xproto::ListExtensionsReply>> {
        let span = tracing::info_span!(
            "list_extensions",
        );
        let _enter = span.enter();
        let request = types::xproto::ListExtensionsRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn list_extensions_immediate(&mut self, ) -> Result<types::xproto::ListExtensionsReply> {
        let request = types::xproto::ListExtensionsRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn change_keyboard_mapping(&mut self, keycode_count: types::Card8, first_keycode: types::Keycode, keysyms_per_keycode: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_keyboard_mapping",
            keycode_count = ?keycode_count,
            first_keycode = ?first_keycode,
            keysyms_per_keycode = ?keysyms_per_keycode,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeKeyboardMappingRequest {
            keycode_count,
            first_keycode,
            keysyms_per_keycode,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn change_keyboard_mapping_checked(&mut self, keycode_count: types::Card8, first_keycode: types::Keycode, keysyms_per_keycode: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> Result<()> {
        let request = types::xproto::ChangeKeyboardMappingRequest {
            keycode_count,
            first_keycode,
            keysyms_per_keycode,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn get_keyboard_mapping(&mut self, first_keycode: types::Keycode, count: types::Card8) -> Result<Cookie<types::xproto::GetKeyboardMappingReply>> {
        let span = tracing::info_span!(
            "get_keyboard_mapping",
            first_keycode = ?first_keycode,
            count = ?count,
        );
        let _enter = span.enter();
        let request = types::xproto::GetKeyboardMappingRequest {
            first_keycode,
            count,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_keyboard_mapping_immediate(&mut self, first_keycode: types::Keycode, count: types::Card8) -> Result<types::xproto::GetKeyboardMappingReply> {
        let request = types::xproto::GetKeyboardMappingRequest {
            first_keycode,
            count,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn change_keyboard_control(&mut self, value_list: impl Borrow<types::xproto::ChangeKeyboardControlAux>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_keyboard_control",
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeKeyboardControlRequest {
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn change_keyboard_control_checked(&mut self, value_list: impl Borrow<types::xproto::ChangeKeyboardControlAux>) -> Result<()> {
        let request = types::xproto::ChangeKeyboardControlRequest {
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn get_keyboard_control(&mut self, ) -> Result<Cookie<types::xproto::GetKeyboardControlReply>> {
        let span = tracing::info_span!(
            "get_keyboard_control",
        );
        let _enter = span.enter();
        let request = types::xproto::GetKeyboardControlRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_keyboard_control_immediate(&mut self, ) -> Result<types::xproto::GetKeyboardControlReply> {
        let request = types::xproto::GetKeyboardControlRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn bell(&mut self, percent: types::Int8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "bell",
            percent = ?percent,
        );
        let _enter = span.enter();
        let request = types::xproto::BellRequest {
            percent,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn bell_checked(&mut self, percent: types::Int8) -> Result<()> {
        let request = types::xproto::BellRequest {
            percent,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn change_pointer_control(&mut self, acceleration_numerator: types::Int16, acceleration_denominator: types::Int16, threshold: types::Int16, do_acceleration: types::Bool, do_threshold: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_pointer_control",
            acceleration_numerator = ?acceleration_numerator,
            acceleration_denominator = ?acceleration_denominator,
            threshold = ?threshold,
            do_acceleration = ?do_acceleration,
            do_threshold = ?do_threshold,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangePointerControlRequest {
            acceleration_numerator,
            acceleration_denominator,
            threshold,
            do_acceleration,
            do_threshold,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn change_pointer_control_checked(&mut self, acceleration_numerator: types::Int16, acceleration_denominator: types::Int16, threshold: types::Int16, do_acceleration: types::Bool, do_threshold: types::Bool) -> Result<()> {
        let request = types::xproto::ChangePointerControlRequest {
            acceleration_numerator,
            acceleration_denominator,
            threshold,
            do_acceleration,
            do_threshold,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn get_pointer_control(&mut self, ) -> Result<Cookie<types::xproto::GetPointerControlReply>> {
        let span = tracing::info_span!(
            "get_pointer_control",
        );
        let _enter = span.enter();
        let request = types::xproto::GetPointerControlRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_pointer_control_immediate(&mut self, ) -> Result<types::xproto::GetPointerControlReply> {
        let request = types::xproto::GetPointerControlRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn set_screen_saver(&mut self, timeout: types::Int16, interval: types::Int16, prefer_blanking: types::Blanking, allow_exposures: types::Exposures) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_screen_saver",
            timeout = ?timeout,
            interval = ?interval,
            prefer_blanking = ?prefer_blanking,
            allow_exposures = ?allow_exposures,
        );
        let _enter = span.enter();
        let request = types::xproto::SetScreenSaverRequest {
            timeout,
            interval,
            prefer_blanking,
            allow_exposures,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn set_screen_saver_checked(&mut self, timeout: types::Int16, interval: types::Int16, prefer_blanking: types::Blanking, allow_exposures: types::Exposures) -> Result<()> {
        let request = types::xproto::SetScreenSaverRequest {
            timeout,
            interval,
            prefer_blanking,
            allow_exposures,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn get_screen_saver(&mut self, ) -> Result<Cookie<types::xproto::GetScreenSaverReply>> {
        let span = tracing::info_span!(
            "get_screen_saver",
        );
        let _enter = span.enter();
        let request = types::xproto::GetScreenSaverRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_screen_saver_immediate(&mut self, ) -> Result<types::xproto::GetScreenSaverReply> {
        let request = types::xproto::GetScreenSaverRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn change_hosts(&mut self, mode: types::HostMode, family: types::Family, address: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_hosts",
            mode = ?mode,
            family = ?family,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeHostsRequest {
            mode,
            family,
            address: Cow::Borrowed(address.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn change_hosts_checked(&mut self, mode: types::HostMode, family: types::Family, address: impl AsRef<[types::Byte]>) -> Result<()> {
        let request = types::xproto::ChangeHostsRequest {
            mode,
            family,
            address: Cow::Borrowed(address.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn list_hosts(&mut self, ) -> Result<Cookie<types::xproto::ListHostsReply>> {
        let span = tracing::info_span!(
            "list_hosts",
        );
        let _enter = span.enter();
        let request = types::xproto::ListHostsRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn list_hosts_immediate(&mut self, ) -> Result<types::xproto::ListHostsReply> {
        let request = types::xproto::ListHostsRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn set_access_control(&mut self, mode: types::AccessControl) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_access_control",
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xproto::SetAccessControlRequest {
            mode,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn set_access_control_checked(&mut self, mode: types::AccessControl) -> Result<()> {
        let request = types::xproto::SetAccessControlRequest {
            mode,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn set_close_down_mode(&mut self, mode: types::CloseDown) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_close_down_mode",
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xproto::SetCloseDownModeRequest {
            mode,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn set_close_down_mode_checked(&mut self, mode: types::CloseDown) -> Result<()> {
        let request = types::xproto::SetCloseDownModeRequest {
            mode,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn kill_client(&mut self, resource: impl Into<types::Kill>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "kill_client",
        );
        let _enter = span.enter();
        let request = types::xproto::KillClientRequest {
            resource: Into::<u32>::into(resource.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn kill_client_checked(&mut self, resource: impl Into<types::Kill>) -> Result<()> {
        let request = types::xproto::KillClientRequest {
            resource: Into::<u32>::into(resource.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn rotate_properties(&mut self, window: types::xproto::Window, delta: types::Int16, atoms: impl AsRef<[types::Atom]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "rotate_properties",
            window = ?window,
            delta = ?delta,
        );
        let _enter = span.enter();
        let request = types::xproto::RotatePropertiesRequest {
            window,
            delta,
            atoms: Cow::Borrowed(atoms.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn rotate_properties_checked(&mut self, window: types::xproto::Window, delta: types::Int16, atoms: impl AsRef<[types::Atom]>) -> Result<()> {
        let request = types::xproto::RotatePropertiesRequest {
            window,
            delta,
            atoms: Cow::Borrowed(atoms.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn force_screen_saver(&mut self, mode: types::ScreenSaver) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "force_screen_saver",
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xproto::ForceScreenSaverRequest {
            mode,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn force_screen_saver_checked(&mut self, mode: types::ScreenSaver) -> Result<()> {
        let request = types::xproto::ForceScreenSaverRequest {
            mode,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    fn set_pointer_mapping(&mut self, map: impl AsRef<[types::Card8]>) -> Result<Cookie<types::xproto::SetPointerMappingReply>> {
        let span = tracing::info_span!(
            "set_pointer_mapping",
        );
        let _enter = span.enter();
        let request = types::xproto::SetPointerMappingRequest {
            map: Cow::Borrowed(map.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn set_pointer_mapping_immediate(&mut self, map: impl AsRef<[types::Card8]>) -> Result<types::xproto::SetPointerMappingReply> {
        let request = types::xproto::SetPointerMappingRequest {
            map: Cow::Borrowed(map.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn get_pointer_mapping(&mut self, ) -> Result<Cookie<types::xproto::GetPointerMappingReply>> {
        let span = tracing::info_span!(
            "get_pointer_mapping",
        );
        let _enter = span.enter();
        let request = types::xproto::GetPointerMappingRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_pointer_mapping_immediate(&mut self, ) -> Result<types::xproto::GetPointerMappingReply> {
        let request = types::xproto::GetPointerMappingRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn set_modifier_mapping(&mut self, keycodes: impl AsRef<[types::Keycode]>) -> Result<Cookie<types::xproto::SetModifierMappingReply>> {
        let span = tracing::info_span!(
            "set_modifier_mapping",
        );
        let _enter = span.enter();
        let request = types::xproto::SetModifierMappingRequest {
            keycodes: Cow::Borrowed(keycodes.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn set_modifier_mapping_immediate(&mut self, keycodes: impl AsRef<[types::Keycode]>) -> Result<types::xproto::SetModifierMappingReply> {
        let request = types::xproto::SetModifierMappingRequest {
            keycodes: Cow::Borrowed(keycodes.as_ref()),
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn get_modifier_mapping(&mut self, ) -> Result<Cookie<types::xproto::GetModifierMappingReply>> {
        let span = tracing::info_span!(
            "get_modifier_mapping",
        );
        let _enter = span.enter();
        let request = types::xproto::GetModifierMappingRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    fn get_modifier_mapping_immediate(&mut self, ) -> Result<types::xproto::GetModifierMappingReply> {
        let request = types::xproto::GetModifierMappingRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    fn no_operation(&mut self, ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "no_operation",
        );
        let _enter = span.enter();
        let request = types::xproto::NoOperationRequest {
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    fn no_operation_checked(&mut self, ) -> Result<()> {
        let request = types::xproto::NoOperationRequest {
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xselinux")]
    fn xselinux_query_version(&mut self, client_major: types::Card8, client_minor: types::Card8) -> Result<Cookie<types::xselinux::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xselinux_query_version",
            client_major = ?client_major,
            client_minor = ?client_minor,
        );
        let _enter = span.enter();
        let request = types::xselinux::QueryVersionRequest {
            client_major,
            client_minor,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_query_version_immediate(&mut self, client_major: types::Card8, client_minor: types::Card8) -> Result<types::xselinux::QueryVersionReply> {
        let request = types::xselinux::QueryVersionRequest {
            client_major,
            client_minor,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_create_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xselinux_set_device_create_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::SetDeviceCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_create_context_checked(&mut self, context: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xselinux::SetDeviceCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_create_context(&mut self, ) -> Result<Cookie<types::xselinux::GetDeviceCreateContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_device_create_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::GetDeviceCreateContextRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_create_context_immediate(&mut self, ) -> Result<types::xselinux::GetDeviceCreateContextReply> {
        let request = types::xselinux::GetDeviceCreateContextRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_context(&mut self, device: types::Card32, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xselinux_set_device_context",
            device = ?device,
        );
        let _enter = span.enter();
        let request = types::xselinux::SetDeviceContextRequest {
            device,
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_context_checked(&mut self, device: types::Card32, context: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xselinux::SetDeviceContextRequest {
            device,
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_context(&mut self, device: types::Card32) -> Result<Cookie<types::xselinux::GetDeviceContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_device_context",
            device = ?device,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetDeviceContextRequest {
            device,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_context_immediate(&mut self, device: types::Card32) -> Result<types::xselinux::GetDeviceContextReply> {
        let request = types::xselinux::GetDeviceContextRequest {
            device,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_window_create_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xselinux_set_window_create_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::SetWindowCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_window_create_context_checked(&mut self, context: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xselinux::SetWindowCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_create_context(&mut self, ) -> Result<Cookie<types::xselinux::GetWindowCreateContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_window_create_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::GetWindowCreateContextRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_create_context_immediate(&mut self, ) -> Result<types::xselinux::GetWindowCreateContextReply> {
        let request = types::xselinux::GetWindowCreateContextRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_context(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xselinux::GetWindowContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_window_context",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetWindowContextRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_context_immediate(&mut self, window: types::xproto::Window) -> Result<types::xselinux::GetWindowContextReply> {
        let request = types::xselinux::GetWindowContextRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_create_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xselinux_set_property_create_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::SetPropertyCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_create_context_checked(&mut self, context: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xselinux::SetPropertyCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_create_context(&mut self, ) -> Result<Cookie<types::xselinux::GetPropertyCreateContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_property_create_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::GetPropertyCreateContextRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_create_context_immediate(&mut self, ) -> Result<types::xselinux::GetPropertyCreateContextReply> {
        let request = types::xselinux::GetPropertyCreateContextRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_use_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xselinux_set_property_use_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::SetPropertyUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_use_context_checked(&mut self, context: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xselinux::SetPropertyUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_use_context(&mut self, ) -> Result<Cookie<types::xselinux::GetPropertyUseContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_property_use_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::GetPropertyUseContextRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_use_context_immediate(&mut self, ) -> Result<types::xselinux::GetPropertyUseContextReply> {
        let request = types::xselinux::GetPropertyUseContextRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_context(&mut self, window: types::xproto::Window, property: types::Atom) -> Result<Cookie<types::xselinux::GetPropertyContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_property_context",
            window = ?window,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetPropertyContextRequest {
            window,
            property,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_context_immediate(&mut self, window: types::xproto::Window, property: types::Atom) -> Result<types::xselinux::GetPropertyContextReply> {
        let request = types::xselinux::GetPropertyContextRequest {
            window,
            property,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_data_context(&mut self, window: types::xproto::Window, property: types::Atom) -> Result<Cookie<types::xselinux::GetPropertyDataContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_property_data_context",
            window = ?window,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetPropertyDataContextRequest {
            window,
            property,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_data_context_immediate(&mut self, window: types::xproto::Window, property: types::Atom) -> Result<types::xselinux::GetPropertyDataContextReply> {
        let request = types::xselinux::GetPropertyDataContextRequest {
            window,
            property,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_properties(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xselinux::ListPropertiesReply>> {
        let span = tracing::info_span!(
            "xselinux_list_properties",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xselinux::ListPropertiesRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_properties_immediate(&mut self, window: types::xproto::Window) -> Result<types::xselinux::ListPropertiesReply> {
        let request = types::xselinux::ListPropertiesRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_create_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xselinux_set_selection_create_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::SetSelectionCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_create_context_checked(&mut self, context: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xselinux::SetSelectionCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_create_context(&mut self, ) -> Result<Cookie<types::xselinux::GetSelectionCreateContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_selection_create_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::GetSelectionCreateContextRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_create_context_immediate(&mut self, ) -> Result<types::xselinux::GetSelectionCreateContextReply> {
        let request = types::xselinux::GetSelectionCreateContextRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_use_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xselinux_set_selection_use_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::SetSelectionUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_use_context_checked(&mut self, context: impl AsRef<[types::Char]>) -> Result<()> {
        let request = types::xselinux::SetSelectionUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_use_context(&mut self, ) -> Result<Cookie<types::xselinux::GetSelectionUseContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_selection_use_context",
        );
        let _enter = span.enter();
        let request = types::xselinux::GetSelectionUseContextRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_use_context_immediate(&mut self, ) -> Result<types::xselinux::GetSelectionUseContextReply> {
        let request = types::xselinux::GetSelectionUseContextRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_context(&mut self, selection: types::Atom) -> Result<Cookie<types::xselinux::GetSelectionContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_selection_context",
            selection = ?selection,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetSelectionContextRequest {
            selection,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_context_immediate(&mut self, selection: types::Atom) -> Result<types::xselinux::GetSelectionContextReply> {
        let request = types::xselinux::GetSelectionContextRequest {
            selection,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_data_context(&mut self, selection: types::Atom) -> Result<Cookie<types::xselinux::GetSelectionDataContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_selection_data_context",
            selection = ?selection,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetSelectionDataContextRequest {
            selection,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_data_context_immediate(&mut self, selection: types::Atom) -> Result<types::xselinux::GetSelectionDataContextReply> {
        let request = types::xselinux::GetSelectionDataContextRequest {
            selection,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_selections(&mut self, ) -> Result<Cookie<types::xselinux::ListSelectionsReply>> {
        let span = tracing::info_span!(
            "xselinux_list_selections",
        );
        let _enter = span.enter();
        let request = types::xselinux::ListSelectionsRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_selections_immediate(&mut self, ) -> Result<types::xselinux::ListSelectionsReply> {
        let request = types::xselinux::ListSelectionsRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_client_context(&mut self, resource: types::Card32) -> Result<Cookie<types::xselinux::GetClientContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_client_context",
            resource = ?resource,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetClientContextRequest {
            resource,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_client_context_immediate(&mut self, resource: types::Card32) -> Result<types::xselinux::GetClientContextReply> {
        let request = types::xselinux::GetClientContextRequest {
            resource,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xtest")]
    fn xtest_get_version(&mut self, major_version: types::Card8, minor_version: types::Card16) -> Result<Cookie<types::xtest::GetVersionReply>> {
        let span = tracing::info_span!(
            "xtest_get_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::xtest::GetVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xtest")]
    fn xtest_get_version_immediate(&mut self, major_version: types::Card8, minor_version: types::Card16) -> Result<types::xtest::GetVersionReply> {
        let request = types::xtest::GetVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xtest")]
    fn xtest_compare_cursor(&mut self, window: types::xproto::Window, cursor: types::xproto::Cursor) -> Result<Cookie<types::xtest::CompareCursorReply>> {
        let span = tracing::info_span!(
            "xtest_compare_cursor",
            window = ?window,
            cursor = ?cursor,
        );
        let _enter = span.enter();
        let request = types::xtest::CompareCursorRequest {
            window,
            cursor,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xtest")]
    fn xtest_compare_cursor_immediate(&mut self, window: types::xproto::Window, cursor: types::xproto::Cursor) -> Result<types::xtest::CompareCursorReply> {
        let request = types::xtest::CompareCursorRequest {
            window,
            cursor,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xtest")]
    fn xtest_fake_input(&mut self, type_: types::Byte, detail: types::Byte, time: types::Card32, root: types::xproto::Window, root_x: types::Int16, root_y: types::Int16, deviceid: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xtest_fake_input",
            type_ = ?type_,
            detail = ?detail,
            time = ?time,
            root = ?root,
            root_x = ?root_x,
            root_y = ?root_y,
            deviceid = ?deviceid,
        );
        let _enter = span.enter();
        let request = types::xtest::FakeInputRequest {
            type_,
            detail,
            time,
            root,
            root_x,
            root_y,
            deviceid,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xtest")]
    fn xtest_fake_input_checked(&mut self, type_: types::Byte, detail: types::Byte, time: types::Card32, root: types::xproto::Window, root_x: types::Int16, root_y: types::Int16, deviceid: types::Card8) -> Result<()> {
        let request = types::xtest::FakeInputRequest {
            type_,
            detail,
            time,
            root,
            root_x,
            root_y,
            deviceid,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xtest")]
    fn xtest_grab_control(&mut self, impervious: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xtest_grab_control",
            impervious = ?impervious,
        );
        let _enter = span.enter();
        let request = types::xtest::GrabControlRequest {
            impervious,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xtest")]
    fn xtest_grab_control_checked(&mut self, impervious: types::Bool) -> Result<()> {
        let request = types::xtest::GrabControlRequest {
            impervious,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xv")]
    fn xv_query_extension(&mut self, ) -> Result<Cookie<types::xv::QueryExtensionReply>> {
        let span = tracing::info_span!(
            "xv_query_extension",
        );
        let _enter = span.enter();
        let request = types::xv::QueryExtensionRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_extension_immediate(&mut self, ) -> Result<types::xv::QueryExtensionReply> {
        let request = types::xv::QueryExtensionRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_query_adaptors(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xv::QueryAdaptorsReply>> {
        let span = tracing::info_span!(
            "xv_query_adaptors",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xv::QueryAdaptorsRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_adaptors_immediate(&mut self, window: types::xproto::Window) -> Result<types::xv::QueryAdaptorsReply> {
        let request = types::xv::QueryAdaptorsRequest {
            window,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_query_encodings(&mut self, port: types::Port) -> Result<Cookie<types::xv::QueryEncodingsReply>> {
        let span = tracing::info_span!(
            "xv_query_encodings",
            port = ?port,
        );
        let _enter = span.enter();
        let request = types::xv::QueryEncodingsRequest {
            port,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_encodings_immediate(&mut self, port: types::Port) -> Result<types::xv::QueryEncodingsReply> {
        let request = types::xv::QueryEncodingsRequest {
            port,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_grab_port(&mut self, port: types::Port, time: impl Into<types::Time>) -> Result<Cookie<types::xv::GrabPortReply>> {
        let span = tracing::info_span!(
            "xv_grab_port",
            port = ?port,
        );
        let _enter = span.enter();
        let request = types::xv::GrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_grab_port_immediate(&mut self, port: types::Port, time: impl Into<types::Time>) -> Result<types::xv::GrabPortReply> {
        let request = types::xv::GrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_ungrab_port(&mut self, port: types::Port, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_ungrab_port",
            port = ?port,
        );
        let _enter = span.enter();
        let request = types::xv::UngrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_ungrab_port_checked(&mut self, port: types::Port, time: impl Into<types::Time>) -> Result<()> {
        let request = types::xv::UngrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_put_video(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_put_video",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let _enter = span.enter();
        let request = types::xv::PutVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_put_video_checked(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<()> {
        let request = types::xv::PutVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_put_still(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_put_still",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let _enter = span.enter();
        let request = types::xv::PutStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_put_still_checked(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<()> {
        let request = types::xv::PutStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_get_video(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_get_video",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let _enter = span.enter();
        let request = types::xv::GetVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_get_video_checked(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<()> {
        let request = types::xv::GetVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_get_still(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_get_still",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let _enter = span.enter();
        let request = types::xv::GetStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_get_still_checked(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<()> {
        let request = types::xv::GetStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_stop_video(&mut self, port: types::Port, drawable: types::xproto::Drawable) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_stop_video",
            port = ?port,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xv::StopVideoRequest {
            port,
            drawable,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_stop_video_checked(&mut self, port: types::Port, drawable: types::xproto::Drawable) -> Result<()> {
        let request = types::xv::StopVideoRequest {
            port,
            drawable,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_select_video_notify(&mut self, drawable: types::xproto::Drawable, onoff: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_select_video_notify",
            drawable = ?drawable,
            onoff = ?onoff,
        );
        let _enter = span.enter();
        let request = types::xv::SelectVideoNotifyRequest {
            drawable,
            onoff,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_select_video_notify_checked(&mut self, drawable: types::xproto::Drawable, onoff: types::Bool) -> Result<()> {
        let request = types::xv::SelectVideoNotifyRequest {
            drawable,
            onoff,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_select_port_notify(&mut self, port: types::Port, onoff: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_select_port_notify",
            port = ?port,
            onoff = ?onoff,
        );
        let _enter = span.enter();
        let request = types::xv::SelectPortNotifyRequest {
            port,
            onoff,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_select_port_notify_checked(&mut self, port: types::Port, onoff: types::Bool) -> Result<()> {
        let request = types::xv::SelectPortNotifyRequest {
            port,
            onoff,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_query_best_size(&mut self, port: types::Port, vid_w: types::Card16, vid_h: types::Card16, drw_w: types::Card16, drw_h: types::Card16, motion: types::Bool) -> Result<Cookie<types::xv::QueryBestSizeReply>> {
        let span = tracing::info_span!(
            "xv_query_best_size",
            port = ?port,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            motion = ?motion,
        );
        let _enter = span.enter();
        let request = types::xv::QueryBestSizeRequest {
            port,
            vid_w,
            vid_h,
            drw_w,
            drw_h,
            motion,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_best_size_immediate(&mut self, port: types::Port, vid_w: types::Card16, vid_h: types::Card16, drw_w: types::Card16, drw_h: types::Card16, motion: types::Bool) -> Result<types::xv::QueryBestSizeReply> {
        let request = types::xv::QueryBestSizeRequest {
            port,
            vid_w,
            vid_h,
            drw_w,
            drw_h,
            motion,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_set_port_attribute(&mut self, port: types::Port, attribute: types::Atom, value: types::Int32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_set_port_attribute",
            port = ?port,
            attribute = ?attribute,
            value = ?value,
        );
        let _enter = span.enter();
        let request = types::xv::SetPortAttributeRequest {
            port,
            attribute,
            value,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_set_port_attribute_checked(&mut self, port: types::Port, attribute: types::Atom, value: types::Int32) -> Result<()> {
        let request = types::xv::SetPortAttributeRequest {
            port,
            attribute,
            value,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_get_port_attribute(&mut self, port: types::Port, attribute: types::Atom) -> Result<Cookie<types::xv::GetPortAttributeReply>> {
        let span = tracing::info_span!(
            "xv_get_port_attribute",
            port = ?port,
            attribute = ?attribute,
        );
        let _enter = span.enter();
        let request = types::xv::GetPortAttributeRequest {
            port,
            attribute,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_get_port_attribute_immediate(&mut self, port: types::Port, attribute: types::Atom) -> Result<types::xv::GetPortAttributeReply> {
        let request = types::xv::GetPortAttributeRequest {
            port,
            attribute,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_query_port_attributes(&mut self, port: types::Port) -> Result<Cookie<types::xv::QueryPortAttributesReply>> {
        let span = tracing::info_span!(
            "xv_query_port_attributes",
            port = ?port,
        );
        let _enter = span.enter();
        let request = types::xv::QueryPortAttributesRequest {
            port,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_port_attributes_immediate(&mut self, port: types::Port) -> Result<types::xv::QueryPortAttributesReply> {
        let request = types::xv::QueryPortAttributesRequest {
            port,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_list_image_formats(&mut self, port: types::Port) -> Result<Cookie<types::xv::ListImageFormatsReply>> {
        let span = tracing::info_span!(
            "xv_list_image_formats",
            port = ?port,
        );
        let _enter = span.enter();
        let request = types::xv::ListImageFormatsRequest {
            port,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_list_image_formats_immediate(&mut self, port: types::Port) -> Result<types::xv::ListImageFormatsReply> {
        let request = types::xv::ListImageFormatsRequest {
            port,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_query_image_attributes(&mut self, port: types::Port, id: types::Card32, width: types::Card16, height: types::Card16) -> Result<Cookie<types::xv::QueryImageAttributesReply>> {
        let span = tracing::info_span!(
            "xv_query_image_attributes",
            port = ?port,
            id = ?id,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xv::QueryImageAttributesRequest {
            port,
            id,
            width,
            height,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_image_attributes_immediate(&mut self, port: types::Port, id: types::Card32, width: types::Card16, height: types::Card16) -> Result<types::xv::QueryImageAttributesReply> {
        let request = types::xv::QueryImageAttributesRequest {
            port,
            id,
            width,
            height,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_put_image(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, id: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, data: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_put_image",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            id = ?id,
            src_x = ?src_x,
            src_y = ?src_y,
            src_w = ?src_w,
            src_h = ?src_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xv::PutImageRequest {
            port,
            drawable,
            gc,
            id,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_put_image_checked(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, id: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, data: impl AsRef<[types::Card8]>) -> Result<()> {
        let request = types::xv::PutImageRequest {
            port,
            drawable,
            gc,
            id,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_shm_put_image(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, shmseg: types::Seg, id: types::Card32, offset: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, send_event: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_shm_put_image",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            shmseg = ?shmseg,
            id = ?id,
            offset = ?offset,
            src_x = ?src_x,
            src_y = ?src_y,
            src_w = ?src_w,
            src_h = ?src_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            width = ?width,
            height = ?height,
            send_event = ?send_event,
        );
        let _enter = span.enter();
        let request = types::xv::ShmPutImageRequest {
            port,
            drawable,
            gc,
            shmseg,
            id,
            offset,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            send_event,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_shm_put_image_checked(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, shmseg: types::Seg, id: types::Card32, offset: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, send_event: types::Card8) -> Result<()> {
        let request = types::xv::ShmPutImageRequest {
            port,
            drawable,
            gc,
            shmseg,
            id,
            offset,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            send_event,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    
    #[cfg(feature = "xvmc")]
    fn xvmc_query_version(&mut self, ) -> Result<Cookie<types::xvmc::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xvmc_query_version",
        );
        let _enter = span.enter();
        let request = types::xvmc::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_query_version_immediate(&mut self, ) -> Result<types::xvmc::QueryVersionReply> {
        let request = types::xvmc::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_surface_types(&mut self, port_id: types::Port) -> Result<Cookie<types::xvmc::ListSurfaceTypesReply>> {
        let span = tracing::info_span!(
            "xvmc_list_surface_types",
            port_id = ?port_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::ListSurfaceTypesRequest {
            port_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_surface_types_immediate(&mut self, port_id: types::Port) -> Result<types::xvmc::ListSurfaceTypesReply> {
        let request = types::xvmc::ListSurfaceTypesRequest {
            port_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_context(&mut self, context_id: types::xvmc::Context, port_id: types::Port, surface_id: types::Surface, width: types::Card16, height: types::Card16, flags: types::Card32) -> Result<Cookie<types::xvmc::CreateContextReply>> {
        let span = tracing::info_span!(
            "xvmc_create_context",
            context_id = ?context_id,
            port_id = ?port_id,
            surface_id = ?surface_id,
            width = ?width,
            height = ?height,
            flags = ?flags,
        );
        let _enter = span.enter();
        let request = types::xvmc::CreateContextRequest {
            context_id,
            port_id,
            surface_id,
            width,
            height,
            flags,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_context_immediate(&mut self, context_id: types::xvmc::Context, port_id: types::Port, surface_id: types::Surface, width: types::Card16, height: types::Card16, flags: types::Card32) -> Result<types::xvmc::CreateContextReply> {
        let request = types::xvmc::CreateContextRequest {
            context_id,
            port_id,
            surface_id,
            width,
            height,
            flags,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_context(&mut self, context_id: types::xvmc::Context) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xvmc_destroy_context",
            context_id = ?context_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::DestroyContextRequest {
            context_id,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_context_checked(&mut self, context_id: types::xvmc::Context) -> Result<()> {
        let request = types::xvmc::DestroyContextRequest {
            context_id,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_surface(&mut self, surface_id: types::Surface, context_id: types::xvmc::Context) -> Result<Cookie<types::xvmc::CreateSurfaceReply>> {
        let span = tracing::info_span!(
            "xvmc_create_surface",
            surface_id = ?surface_id,
            context_id = ?context_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::CreateSurfaceRequest {
            surface_id,
            context_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_surface_immediate(&mut self, surface_id: types::Surface, context_id: types::xvmc::Context) -> Result<types::xvmc::CreateSurfaceReply> {
        let request = types::xvmc::CreateSurfaceRequest {
            surface_id,
            context_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_surface(&mut self, surface_id: types::Surface) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xvmc_destroy_surface",
            surface_id = ?surface_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::DestroySurfaceRequest {
            surface_id,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_surface_checked(&mut self, surface_id: types::Surface) -> Result<()> {
        let request = types::xvmc::DestroySurfaceRequest {
            surface_id,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_subpicture(&mut self, subpicture_id: types::Subpicture, context: types::xvmc::Context, xvimage_id: types::Card32, width: types::Card16, height: types::Card16) -> Result<Cookie<types::xvmc::CreateSubpictureReply>> {
        let span = tracing::info_span!(
            "xvmc_create_subpicture",
            subpicture_id = ?subpicture_id,
            context = ?context,
            xvimage_id = ?xvimage_id,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xvmc::CreateSubpictureRequest {
            subpicture_id,
            context,
            xvimage_id,
            width,
            height,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_subpicture_immediate(&mut self, subpicture_id: types::Subpicture, context: types::xvmc::Context, xvimage_id: types::Card32, width: types::Card16, height: types::Card16) -> Result<types::xvmc::CreateSubpictureReply> {
        let request = types::xvmc::CreateSubpictureRequest {
            subpicture_id,
            context,
            xvimage_id,
            width,
            height,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_subpicture(&mut self, subpicture_id: types::Subpicture) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xvmc_destroy_subpicture",
            subpicture_id = ?subpicture_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::DestroySubpictureRequest {
            subpicture_id,
        };
        let cookie = self.send_void_request(request, true);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_subpicture_checked(&mut self, subpicture_id: types::Subpicture) -> Result<()> {
        let request = types::xvmc::DestroySubpictureRequest {
            subpicture_id,
        };
        let cookie = self.send_void_request(request, false)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_subpicture_types(&mut self, port_id: types::Port, surface_id: types::Surface) -> Result<Cookie<types::xvmc::ListSubpictureTypesReply>> {
        let span = tracing::info_span!(
            "xvmc_list_subpicture_types",
            port_id = ?port_id,
            surface_id = ?surface_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::ListSubpictureTypesRequest {
            port_id,
            surface_id,
        };
        let cookie = self.send_reply_request(request);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_subpicture_types_immediate(&mut self, port_id: types::Port, surface_id: types::Surface) -> Result<types::xvmc::ListSubpictureTypesReply> {
        let request = types::xvmc::ListSubpictureTypesRequest {
            port_id,
            surface_id,
        };
        let cookie = self.send_reply_request(request)?;
        self.wait_for_reply(cookie)
    }
    
}

#[cfg(feature = "async")]
pub trait AsyncDisplayFunctionsExt : AsyncDisplay + Sealed2 {
    fn bigreq_enable<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::bigreq::EnableReply> {
        let span = tracing::info_span!(
            "bigreq_enable",
        );
        let request = types::bigreq::EnableRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn bigreq_enable_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::bigreq::EnableReply> {
        let request = types::bigreq::EnableRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::bigreq::EnableReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "composite")]
    fn composite_query_version<'this>(&'this mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> futures::SendRequest<'this, Self, types::composite::QueryVersionReply> {
        let span = tracing::info_span!(
            "composite_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::composite::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_query_version_immediate<'this>(&'this mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::composite::QueryVersionReply> {
        let request = types::composite::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::composite::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_window<'this>(&'this mut self, window: types::xproto::Window, update: types::Redirect) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "composite_redirect_window",
            window = ?window,
            update = ?update,
        );
        let request = types::composite::RedirectWindowRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_window_checked<'this>(&'this mut self, window: types::xproto::Window, update: types::Redirect) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::composite::RedirectWindowRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_subwindows<'this>(&'this mut self, window: types::xproto::Window, update: types::Redirect) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "composite_redirect_subwindows",
            window = ?window,
            update = ?update,
        );
        let request = types::composite::RedirectSubwindowsRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_subwindows_checked<'this>(&'this mut self, window: types::xproto::Window, update: types::Redirect) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::composite::RedirectSubwindowsRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_window<'this>(&'this mut self, window: types::xproto::Window, update: types::Redirect) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "composite_unredirect_window",
            window = ?window,
            update = ?update,
        );
        let request = types::composite::UnredirectWindowRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_window_checked<'this>(&'this mut self, window: types::xproto::Window, update: types::Redirect) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::composite::UnredirectWindowRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_subwindows<'this>(&'this mut self, window: types::xproto::Window, update: types::Redirect) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "composite_unredirect_subwindows",
            window = ?window,
            update = ?update,
        );
        let request = types::composite::UnredirectSubwindowsRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_subwindows_checked<'this>(&'this mut self, window: types::xproto::Window, update: types::Redirect) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::composite::UnredirectSubwindowsRequest {
            window,
            update,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "composite")]
    fn composite_create_region_from_border_clip<'this>(&'this mut self, region: types::Region, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "composite_create_region_from_border_clip",
            region = ?region,
            window = ?window,
        );
        let request = types::composite::CreateRegionFromBorderClipRequest {
            region,
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_create_region_from_border_clip_checked<'this>(&'this mut self, region: types::Region, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::composite::CreateRegionFromBorderClipRequest {
            region,
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "composite")]
    fn composite_name_window_pixmap<'this>(&'this mut self, window: types::xproto::Window, pixmap: types::xproto::Pixmap) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "composite_name_window_pixmap",
            window = ?window,
            pixmap = ?pixmap,
        );
        let request = types::composite::NameWindowPixmapRequest {
            window,
            pixmap,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_name_window_pixmap_checked<'this>(&'this mut self, window: types::xproto::Window, pixmap: types::xproto::Pixmap) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::composite::NameWindowPixmapRequest {
            window,
            pixmap,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "composite")]
    fn composite_get_overlay_window<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::composite::GetOverlayWindowReply> {
        let span = tracing::info_span!(
            "composite_get_overlay_window",
            window = ?window,
        );
        let request = types::composite::GetOverlayWindowRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_get_overlay_window_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::composite::GetOverlayWindowReply> {
        let request = types::composite::GetOverlayWindowRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::composite::GetOverlayWindowReply> = cookie.into();
        res
    }
    #[cfg(feature = "composite")]
    fn composite_release_overlay_window<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "composite_release_overlay_window",
            window = ?window,
        );
        let request = types::composite::ReleaseOverlayWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "composite")]
    fn composite_release_overlay_window_checked<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::composite::ReleaseOverlayWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    #[cfg(feature = "damage")]
    fn damage_query_version<'this>(&'this mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> futures::SendRequest<'this, Self, types::damage::QueryVersionReply> {
        let span = tracing::info_span!(
            "damage_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::damage::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "damage")]
    fn damage_query_version_immediate<'this>(&'this mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::damage::QueryVersionReply> {
        let request = types::damage::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::damage::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "damage")]
    fn damage_create<'this>(&'this mut self, damage: types::Damage, drawable: types::xproto::Drawable, level: types::ReportLevel) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "damage_create",
            damage = ?damage,
            drawable = ?drawable,
            level = ?level,
        );
        let request = types::damage::CreateRequest {
            damage,
            drawable,
            level,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "damage")]
    fn damage_create_checked<'this>(&'this mut self, damage: types::Damage, drawable: types::xproto::Drawable, level: types::ReportLevel) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::damage::CreateRequest {
            damage,
            drawable,
            level,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "damage")]
    fn damage_destroy<'this>(&'this mut self, damage: types::Damage) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "damage_destroy",
            damage = ?damage,
        );
        let request = types::damage::DestroyRequest {
            damage,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "damage")]
    fn damage_destroy_checked<'this>(&'this mut self, damage: types::Damage) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::damage::DestroyRequest {
            damage,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "damage")]
    fn damage_subtract<'this>(&'this mut self, damage: types::Damage, repair: impl Into<types::Region>, parts: impl Into<types::Region>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "damage_subtract",
            damage = ?damage,
        );
        let request = types::damage::SubtractRequest {
            damage,
            repair: Into::<u32>::into(repair.into()) as _,
            parts: Into::<u32>::into(parts.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "damage")]
    fn damage_subtract_checked<'this>(&'this mut self, damage: types::Damage, repair: impl Into<types::Region>, parts: impl Into<types::Region>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::damage::SubtractRequest {
            damage,
            repair: Into::<u32>::into(repair.into()) as _,
            parts: Into::<u32>::into(parts.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "damage")]
    fn damage_add<'this>(&'this mut self, drawable: types::xproto::Drawable, region: types::Region) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "damage_add",
            drawable = ?drawable,
            region = ?region,
        );
        let request = types::damage::AddRequest {
            drawable,
            region,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "damage")]
    fn damage_add_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, region: types::Region) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::damage::AddRequest {
            drawable,
            region,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    #[cfg(feature = "dpms")]
    fn dpms_get_version<'this>(&'this mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> futures::SendRequest<'this, Self, types::dpms::GetVersionReply> {
        let span = tracing::info_span!(
            "dpms_get_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::dpms::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_version_immediate<'this>(&'this mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::dpms::GetVersionReply> {
        let request = types::dpms::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dpms::GetVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "dpms")]
    fn dpms_capable<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::dpms::CapableReply> {
        let span = tracing::info_span!(
            "dpms_capable",
        );
        let request = types::dpms::CapableRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_capable_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::dpms::CapableReply> {
        let request = types::dpms::CapableRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dpms::CapableReply> = cookie.into();
        res
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_timeouts<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::dpms::GetTimeoutsReply> {
        let span = tracing::info_span!(
            "dpms_get_timeouts",
        );
        let request = types::dpms::GetTimeoutsRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_timeouts_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::dpms::GetTimeoutsReply> {
        let request = types::dpms::GetTimeoutsRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dpms::GetTimeoutsReply> = cookie.into();
        res
    }
    #[cfg(feature = "dpms")]
    fn dpms_set_timeouts<'this>(&'this mut self, standby_timeout: types::Card16, suspend_timeout: types::Card16, off_timeout: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "dpms_set_timeouts",
            standby_timeout = ?standby_timeout,
            suspend_timeout = ?suspend_timeout,
            off_timeout = ?off_timeout,
        );
        let request = types::dpms::SetTimeoutsRequest {
            standby_timeout,
            suspend_timeout,
            off_timeout,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_set_timeouts_checked<'this>(&'this mut self, standby_timeout: types::Card16, suspend_timeout: types::Card16, off_timeout: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::dpms::SetTimeoutsRequest {
            standby_timeout,
            suspend_timeout,
            off_timeout,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "dpms")]
    fn dpms_enable<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "dpms_enable",
        );
        let request = types::dpms::EnableRequest {
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_enable_checked<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::dpms::EnableRequest {
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "dpms")]
    fn dpms_disable<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "dpms_disable",
        );
        let request = types::dpms::DisableRequest {
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_disable_checked<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::dpms::DisableRequest {
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "dpms")]
    fn dpms_force_level<'this>(&'this mut self, power_level: types::DPMSMode) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "dpms_force_level",
            power_level = ?power_level,
        );
        let request = types::dpms::ForceLevelRequest {
            power_level,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_force_level_checked<'this>(&'this mut self, power_level: types::DPMSMode) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::dpms::ForceLevelRequest {
            power_level,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "dpms")]
    fn dpms_info<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::dpms::InfoReply> {
        let span = tracing::info_span!(
            "dpms_info",
        );
        let request = types::dpms::InfoRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dpms")]
    fn dpms_info_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::dpms::InfoReply> {
        let request = types::dpms::InfoRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dpms::InfoReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "dri2")]
    fn dri2_query_version<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32) -> futures::SendRequest<'this, Self, types::dri2::QueryVersionReply> {
        let span = tracing::info_span!(
            "dri2_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::dri2::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_query_version_immediate<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::dri2::QueryVersionReply> {
        let request = types::dri2::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri2")]
    fn dri2_connect<'this>(&'this mut self, window: types::xproto::Window, driver_type: types::DriverType) -> futures::SendRequest<'this, Self, types::dri2::ConnectReply> {
        let span = tracing::info_span!(
            "dri2_connect",
            window = ?window,
            driver_type = ?driver_type,
        );
        let request = types::dri2::ConnectRequest {
            window,
            driver_type,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_connect_immediate<'this>(&'this mut self, window: types::xproto::Window, driver_type: types::DriverType) -> futures::CheckedSendRequest<'this, Self, types::dri2::ConnectReply> {
        let request = types::dri2::ConnectRequest {
            window,
            driver_type,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::ConnectReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri2")]
    fn dri2_authenticate<'this>(&'this mut self, window: types::xproto::Window, magic: types::Card32) -> futures::SendRequest<'this, Self, types::dri2::AuthenticateReply> {
        let span = tracing::info_span!(
            "dri2_authenticate",
            window = ?window,
            magic = ?magic,
        );
        let request = types::dri2::AuthenticateRequest {
            window,
            magic,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_authenticate_immediate<'this>(&'this mut self, window: types::xproto::Window, magic: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::dri2::AuthenticateReply> {
        let request = types::dri2::AuthenticateRequest {
            window,
            magic,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::AuthenticateReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri2")]
    fn dri2_create_drawable<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "dri2_create_drawable",
            drawable = ?drawable,
        );
        let request = types::dri2::CreateDrawableRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_create_drawable_checked<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::dri2::CreateDrawableRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "dri2")]
    fn dri2_destroy_drawable<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "dri2_destroy_drawable",
            drawable = ?drawable,
        );
        let request = types::dri2::DestroyDrawableRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_destroy_drawable_checked<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::dri2::DestroyDrawableRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "dri2")]
    fn dri2_copy_region<'this>(&'this mut self, drawable: types::xproto::Drawable, region: types::Card32, dest: types::Card32, src: types::Card32) -> futures::SendRequest<'this, Self, types::dri2::CopyRegionReply> {
        let span = tracing::info_span!(
            "dri2_copy_region",
            drawable = ?drawable,
            region = ?region,
            dest = ?dest,
            src = ?src,
        );
        let request = types::dri2::CopyRegionRequest {
            drawable,
            region,
            dest,
            src,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_copy_region_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable, region: types::Card32, dest: types::Card32, src: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::dri2::CopyRegionReply> {
        let request = types::dri2::CopyRegionRequest {
            drawable,
            region,
            dest,
            src,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::CopyRegionReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_buffers<'this>(&'this mut self, drawable: types::xproto::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> futures::SendRequest<'this, Self, types::dri2::SwapBuffersReply> {
        let span = tracing::info_span!(
            "dri2_swap_buffers",
            drawable = ?drawable,
            target_msc_hi = ?target_msc_hi,
            target_msc_lo = ?target_msc_lo,
            divisor_hi = ?divisor_hi,
            divisor_lo = ?divisor_lo,
            remainder_hi = ?remainder_hi,
            remainder_lo = ?remainder_lo,
        );
        let request = types::dri2::SwapBuffersRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_buffers_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::dri2::SwapBuffersReply> {
        let request = types::dri2::SwapBuffersRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::SwapBuffersReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_msc<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::SendRequest<'this, Self, types::dri2::GetMSCReply> {
        let span = tracing::info_span!(
            "dri2_get_msc",
            drawable = ?drawable,
        );
        let request = types::dri2::GetMSCRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_msc_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::CheckedSendRequest<'this, Self, types::dri2::GetMSCReply> {
        let request = types::dri2::GetMSCRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::GetMSCReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_msc<'this>(&'this mut self, drawable: types::xproto::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> futures::SendRequest<'this, Self, types::dri2::WaitMSCReply> {
        let span = tracing::info_span!(
            "dri2_wait_msc",
            drawable = ?drawable,
            target_msc_hi = ?target_msc_hi,
            target_msc_lo = ?target_msc_lo,
            divisor_hi = ?divisor_hi,
            divisor_lo = ?divisor_lo,
            remainder_hi = ?remainder_hi,
            remainder_lo = ?remainder_lo,
        );
        let request = types::dri2::WaitMSCRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_msc_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::dri2::WaitMSCReply> {
        let request = types::dri2::WaitMSCRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::WaitMSCReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_sbc<'this>(&'this mut self, drawable: types::xproto::Drawable, target_sbc_hi: types::Card32, target_sbc_lo: types::Card32) -> futures::SendRequest<'this, Self, types::dri2::WaitSBCReply> {
        let span = tracing::info_span!(
            "dri2_wait_sbc",
            drawable = ?drawable,
            target_sbc_hi = ?target_sbc_hi,
            target_sbc_lo = ?target_sbc_lo,
        );
        let request = types::dri2::WaitSBCRequest {
            drawable,
            target_sbc_hi,
            target_sbc_lo,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_sbc_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable, target_sbc_hi: types::Card32, target_sbc_lo: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::dri2::WaitSBCReply> {
        let request = types::dri2::WaitSBCRequest {
            drawable,
            target_sbc_hi,
            target_sbc_lo,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::WaitSBCReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_interval<'this>(&'this mut self, drawable: types::xproto::Drawable, interval: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "dri2_swap_interval",
            drawable = ?drawable,
            interval = ?interval,
        );
        let request = types::dri2::SwapIntervalRequest {
            drawable,
            interval,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_interval_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, interval: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::dri2::SwapIntervalRequest {
            drawable,
            interval,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_param<'this>(&'this mut self, drawable: types::xproto::Drawable, param: types::Card32) -> futures::SendRequest<'this, Self, types::dri2::GetParamReply> {
        let span = tracing::info_span!(
            "dri2_get_param",
            drawable = ?drawable,
            param = ?param,
        );
        let request = types::dri2::GetParamRequest {
            drawable,
            param,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_param_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable, param: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::dri2::GetParamReply> {
        let request = types::dri2::GetParamRequest {
            drawable,
            param,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::GetParamReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "dri3")]
    fn dri3_query_version<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32) -> futures::SendRequest<'this, Self, types::dri3::QueryVersionReply> {
        let span = tracing::info_span!(
            "dri3_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::dri3::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_query_version_immediate<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::dri3::QueryVersionReply> {
        let request = types::dri3::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri3")]
    fn dri3_open<'this>(&'this mut self, drawable: types::xproto::Drawable, provider: types::Card32) -> futures::SendRequest<'this, Self, types::dri3::OpenReply> {
        let span = tracing::info_span!(
            "dri3_open",
            drawable = ?drawable,
            provider = ?provider,
        );
        let request = types::dri3::OpenRequest {
            drawable,
            provider,
        };
        let cookie = self.send_reply_fd_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_open_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable, provider: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::dri3::OpenReply> {
        let request = types::dri3::OpenRequest {
            drawable,
            provider,
        };
        let cookie = self.send_reply_fd_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::OpenReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffer<'this>(&'this mut self, pixmap: types::xproto::Pixmap, drawable: types::xproto::Drawable, size: types::Card32, width: types::Card16, height: types::Card16, stride: types::Card16, depth: types::Card8, bpp: types::Card8, pixmap_fd: types::Fd) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "dri3_pixmap_from_buffer",
            pixmap = ?pixmap,
            drawable = ?drawable,
            size = ?size,
            width = ?width,
            height = ?height,
            stride = ?stride,
            depth = ?depth,
            bpp = ?bpp,
            pixmap_fd = ?pixmap_fd,
        );
        let request = types::dri3::PixmapFromBufferRequest {
            pixmap,
            drawable,
            size,
            width,
            height,
            stride,
            depth,
            bpp,
            pixmap_fd,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffer_checked<'this>(&'this mut self, pixmap: types::xproto::Pixmap, drawable: types::xproto::Drawable, size: types::Card32, width: types::Card16, height: types::Card16, stride: types::Card16, depth: types::Card8, bpp: types::Card8, pixmap_fd: types::Fd) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::dri3::PixmapFromBufferRequest {
            pixmap,
            drawable,
            size,
            width,
            height,
            stride,
            depth,
            bpp,
            pixmap_fd,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffer_from_pixmap<'this>(&'this mut self, pixmap: types::xproto::Pixmap) -> futures::SendRequest<'this, Self, types::dri3::BufferFromPixmapReply> {
        let span = tracing::info_span!(
            "dri3_buffer_from_pixmap",
            pixmap = ?pixmap,
        );
        let request = types::dri3::BufferFromPixmapRequest {
            pixmap,
        };
        let cookie = self.send_reply_fd_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffer_from_pixmap_immediate<'this>(&'this mut self, pixmap: types::xproto::Pixmap) -> futures::CheckedSendRequest<'this, Self, types::dri3::BufferFromPixmapReply> {
        let request = types::dri3::BufferFromPixmapRequest {
            pixmap,
        };
        let cookie = self.send_reply_fd_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::BufferFromPixmapReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri3")]
    fn dri3_fence_from_fd<'this>(&'this mut self, drawable: types::xproto::Drawable, fence: types::Card32, initially_triggered: types::Bool, fence_fd: types::Fd) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "dri3_fence_from_fd",
            drawable = ?drawable,
            fence = ?fence,
            initially_triggered = ?initially_triggered,
            fence_fd = ?fence_fd,
        );
        let request = types::dri3::FenceFromFDRequest {
            drawable,
            fence,
            initially_triggered,
            fence_fd,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_fence_from_fd_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, fence: types::Card32, initially_triggered: types::Bool, fence_fd: types::Fd) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::dri3::FenceFromFDRequest {
            drawable,
            fence,
            initially_triggered,
            fence_fd,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "dri3")]
    fn dri3_fd_from_fence<'this>(&'this mut self, drawable: types::xproto::Drawable, fence: types::Card32) -> futures::SendRequest<'this, Self, types::dri3::FDFromFenceReply> {
        let span = tracing::info_span!(
            "dri3_fd_from_fence",
            drawable = ?drawable,
            fence = ?fence,
        );
        let request = types::dri3::FDFromFenceRequest {
            drawable,
            fence,
        };
        let cookie = self.send_reply_fd_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_fd_from_fence_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable, fence: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::dri3::FDFromFenceReply> {
        let request = types::dri3::FDFromFenceRequest {
            drawable,
            fence,
        };
        let cookie = self.send_reply_fd_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::FDFromFenceReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri3")]
    fn dri3_get_supported_modifiers<'this>(&'this mut self, window: types::Card32, depth: types::Card8, bpp: types::Card8) -> futures::SendRequest<'this, Self, types::dri3::GetSupportedModifiersReply> {
        let span = tracing::info_span!(
            "dri3_get_supported_modifiers",
            window = ?window,
            depth = ?depth,
            bpp = ?bpp,
        );
        let request = types::dri3::GetSupportedModifiersRequest {
            window,
            depth,
            bpp,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_get_supported_modifiers_immediate<'this>(&'this mut self, window: types::Card32, depth: types::Card8, bpp: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::dri3::GetSupportedModifiersReply> {
        let request = types::dri3::GetSupportedModifiersRequest {
            window,
            depth,
            bpp,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::GetSupportedModifiersReply> = cookie.into();
        res
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffers<'this>(&'this mut self, pixmap: types::xproto::Pixmap, window: types::xproto::Window, width: types::Card16, height: types::Card16, stride0: types::Card32, offset0: types::Card32, stride1: types::Card32, offset1: types::Card32, stride2: types::Card32, offset2: types::Card32, stride3: types::Card32, offset3: types::Card32, depth: types::Card8, bpp: types::Card8, modifier: types::Card64, buffers: Vec<types::Fd>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "dri3_pixmap_from_buffers",
            pixmap = ?pixmap,
            window = ?window,
            width = ?width,
            height = ?height,
            stride0 = ?stride0,
            offset0 = ?offset0,
            stride1 = ?stride1,
            offset1 = ?offset1,
            stride2 = ?stride2,
            offset2 = ?offset2,
            stride3 = ?stride3,
            offset3 = ?offset3,
            depth = ?depth,
            bpp = ?bpp,
            modifier = ?modifier,
        );
        let request = types::dri3::PixmapFromBuffersRequest {
            pixmap,
            window,
            width,
            height,
            stride0,
            offset0,
            stride1,
            offset1,
            stride2,
            offset2,
            stride3,
            offset3,
            depth,
            bpp,
            modifier,
            buffers,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffers_checked<'this>(&'this mut self, pixmap: types::xproto::Pixmap, window: types::xproto::Window, width: types::Card16, height: types::Card16, stride0: types::Card32, offset0: types::Card32, stride1: types::Card32, offset1: types::Card32, stride2: types::Card32, offset2: types::Card32, stride3: types::Card32, offset3: types::Card32, depth: types::Card8, bpp: types::Card8, modifier: types::Card64, buffers: Vec<types::Fd>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::dri3::PixmapFromBuffersRequest {
            pixmap,
            window,
            width,
            height,
            stride0,
            offset0,
            stride1,
            offset1,
            stride2,
            offset2,
            stride3,
            offset3,
            depth,
            bpp,
            modifier,
            buffers,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffers_from_pixmap<'this>(&'this mut self, pixmap: types::xproto::Pixmap) -> futures::SendRequest<'this, Self, types::dri3::BuffersFromPixmapReply> {
        let span = tracing::info_span!(
            "dri3_buffers_from_pixmap",
            pixmap = ?pixmap,
        );
        let request = types::dri3::BuffersFromPixmapRequest {
            pixmap,
        };
        let cookie = self.send_reply_fd_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffers_from_pixmap_immediate<'this>(&'this mut self, pixmap: types::xproto::Pixmap) -> futures::CheckedSendRequest<'this, Self, types::dri3::BuffersFromPixmapReply> {
        let request = types::dri3::BuffersFromPixmapRequest {
            pixmap,
        };
        let cookie = self.send_reply_fd_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::BuffersFromPixmapReply> = cookie.into();
        res
    }
    
    fn ge_query_version<'this>(&'this mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> futures::SendRequest<'this, Self, types::ge::QueryVersionReply> {
        let span = tracing::info_span!(
            "ge_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::ge::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn ge_query_version_immediate<'this>(&'this mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::ge::QueryVersionReply> {
        let request = types::ge::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::ge::QueryVersionReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "glx")]
    fn glx_render<'this>(&'this mut self, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_render",
            context_tag = ?context_tag,
        );
        let request = types::glx::RenderRequest {
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_render_checked<'this>(&'this mut self, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::RenderRequest {
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_render_large<'this>(&'this mut self, context_tag: types::ContextTag, request_num: types::Card16, request_total: types::Card16, data: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_render_large",
            context_tag = ?context_tag,
            request_num = ?request_num,
            request_total = ?request_total,
        );
        let request = types::glx::RenderLargeRequest {
            context_tag,
            request_num,
            request_total,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_render_large_checked<'this>(&'this mut self, context_tag: types::ContextTag, request_num: types::Card16, request_total: types::Card16, data: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::RenderLargeRequest {
            context_tag,
            request_num,
            request_total,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_create_context<'this>(&'this mut self, context: types::glx::Context, visual: types::Visualid, screen: types::Card32, share_list: types::glx::Context, is_direct: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_create_context",
            context = ?context,
            visual = ?visual,
            screen = ?screen,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let request = types::glx::CreateContextRequest {
            context,
            visual,
            screen,
            share_list,
            is_direct,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_checked<'this>(&'this mut self, context: types::glx::Context, visual: types::Visualid, screen: types::Card32, share_list: types::glx::Context, is_direct: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::CreateContextRequest {
            context,
            visual,
            screen,
            share_list,
            is_direct,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_context<'this>(&'this mut self, context: types::glx::Context) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_destroy_context",
            context = ?context,
        );
        let request = types::glx::DestroyContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_context_checked<'this>(&'this mut self, context: types::glx::Context) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::DestroyContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_make_current<'this>(&'this mut self, drawable: types::glx::Drawable, context: types::glx::Context, old_context_tag: types::ContextTag) -> futures::SendRequest<'this, Self, types::glx::MakeCurrentReply> {
        let span = tracing::info_span!(
            "glx_make_current",
            drawable = ?drawable,
            context = ?context,
            old_context_tag = ?old_context_tag,
        );
        let request = types::glx::MakeCurrentRequest {
            drawable,
            context,
            old_context_tag,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_make_current_immediate<'this>(&'this mut self, drawable: types::glx::Drawable, context: types::glx::Context, old_context_tag: types::ContextTag) -> futures::CheckedSendRequest<'this, Self, types::glx::MakeCurrentReply> {
        let request = types::glx::MakeCurrentRequest {
            drawable,
            context,
            old_context_tag,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::MakeCurrentReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_is_direct<'this>(&'this mut self, context: types::glx::Context) -> futures::SendRequest<'this, Self, types::glx::IsDirectReply> {
        let span = tracing::info_span!(
            "glx_is_direct",
            context = ?context,
        );
        let request = types::glx::IsDirectRequest {
            context,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_is_direct_immediate<'this>(&'this mut self, context: types::glx::Context) -> futures::CheckedSendRequest<'this, Self, types::glx::IsDirectReply> {
        let request = types::glx::IsDirectRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::IsDirectReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_query_version<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32) -> futures::SendRequest<'this, Self, types::glx::QueryVersionReply> {
        let span = tracing::info_span!(
            "glx_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::glx::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_query_version_immediate<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::QueryVersionReply> {
        let request = types::glx::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_wait_gl<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_wait_gl",
            context_tag = ?context_tag,
        );
        let request = types::glx::WaitGLRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_wait_gl_checked<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::WaitGLRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_wait_x<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_wait_x",
            context_tag = ?context_tag,
        );
        let request = types::glx::WaitXRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_wait_x_checked<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::WaitXRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_copy_context<'this>(&'this mut self, src: types::glx::Context, dest: types::glx::Context, mask: types::Card32, src_context_tag: types::ContextTag) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_copy_context",
            src = ?src,
            dest = ?dest,
            mask = ?mask,
            src_context_tag = ?src_context_tag,
        );
        let request = types::glx::CopyContextRequest {
            src,
            dest,
            mask,
            src_context_tag,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_copy_context_checked<'this>(&'this mut self, src: types::glx::Context, dest: types::glx::Context, mask: types::Card32, src_context_tag: types::ContextTag) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::CopyContextRequest {
            src,
            dest,
            mask,
            src_context_tag,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_swap_buffers<'this>(&'this mut self, context_tag: types::ContextTag, drawable: types::glx::Drawable) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_swap_buffers",
            context_tag = ?context_tag,
            drawable = ?drawable,
        );
        let request = types::glx::SwapBuffersRequest {
            context_tag,
            drawable,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_swap_buffers_checked<'this>(&'this mut self, context_tag: types::ContextTag, drawable: types::glx::Drawable) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::SwapBuffersRequest {
            context_tag,
            drawable,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_use_x_font<'this>(&'this mut self, context_tag: types::ContextTag, font: types::Font, first: types::Card32, count: types::Card32, list_base: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_use_x_font",
            context_tag = ?context_tag,
            font = ?font,
            first = ?first,
            count = ?count,
            list_base = ?list_base,
        );
        let request = types::glx::UseXFontRequest {
            context_tag,
            font,
            first,
            count,
            list_base,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_use_x_font_checked<'this>(&'this mut self, context_tag: types::ContextTag, font: types::Font, first: types::Card32, count: types::Card32, list_base: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::UseXFontRequest {
            context_tag,
            font,
            first,
            count,
            list_base,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_create_glx_pixmap<'this>(&'this mut self, screen: types::Card32, visual: types::Visualid, pixmap: types::xproto::Pixmap, glx_pixmap: types::glx::Pixmap) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_create_glx_pixmap",
            screen = ?screen,
            visual = ?visual,
            pixmap = ?pixmap,
            glx_pixmap = ?glx_pixmap,
        );
        let request = types::glx::CreateGLXPixmapRequest {
            screen,
            visual,
            pixmap,
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_glx_pixmap_checked<'this>(&'this mut self, screen: types::Card32, visual: types::Visualid, pixmap: types::xproto::Pixmap, glx_pixmap: types::glx::Pixmap) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::CreateGLXPixmapRequest {
            screen,
            visual,
            pixmap,
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_visual_configs<'this>(&'this mut self, screen: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetVisualConfigsReply> {
        let span = tracing::info_span!(
            "glx_get_visual_configs",
            screen = ?screen,
        );
        let request = types::glx::GetVisualConfigsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_visual_configs_immediate<'this>(&'this mut self, screen: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetVisualConfigsReply> {
        let request = types::glx::GetVisualConfigsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetVisualConfigsReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_glx_pixmap<'this>(&'this mut self, glx_pixmap: types::glx::Pixmap) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_destroy_glx_pixmap",
            glx_pixmap = ?glx_pixmap,
        );
        let request = types::glx::DestroyGLXPixmapRequest {
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_glx_pixmap_checked<'this>(&'this mut self, glx_pixmap: types::glx::Pixmap) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::DestroyGLXPixmapRequest {
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private<'this>(&'this mut self, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_vendor_private",
            vendor_code = ?vendor_code,
            context_tag = ?context_tag,
        );
        let request = types::glx::VendorPrivateRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_checked<'this>(&'this mut self, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::VendorPrivateRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_with_reply<'this>(&'this mut self, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, types::glx::VendorPrivateWithReplyReply> {
        let span = tracing::info_span!(
            "glx_vendor_private_with_reply",
            vendor_code = ?vendor_code,
            context_tag = ?context_tag,
        );
        let request = types::glx::VendorPrivateWithReplyRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_with_reply_immediate<'this>(&'this mut self, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, types::glx::VendorPrivateWithReplyReply> {
        let request = types::glx::VendorPrivateWithReplyRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::VendorPrivateWithReplyReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_query_extensions_string<'this>(&'this mut self, screen: types::Card32) -> futures::SendRequest<'this, Self, types::glx::QueryExtensionsStringReply> {
        let span = tracing::info_span!(
            "glx_query_extensions_string",
            screen = ?screen,
        );
        let request = types::glx::QueryExtensionsStringRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_query_extensions_string_immediate<'this>(&'this mut self, screen: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::QueryExtensionsStringReply> {
        let request = types::glx::QueryExtensionsStringRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::QueryExtensionsStringReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_query_server_string<'this>(&'this mut self, screen: types::Card32, name: types::Card32) -> futures::SendRequest<'this, Self, types::glx::QueryServerStringReply> {
        let span = tracing::info_span!(
            "glx_query_server_string",
            screen = ?screen,
            name = ?name,
        );
        let request = types::glx::QueryServerStringRequest {
            screen,
            name,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_query_server_string_immediate<'this>(&'this mut self, screen: types::Card32, name: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::QueryServerStringReply> {
        let request = types::glx::QueryServerStringRequest {
            screen,
            name,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::QueryServerStringReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_client_info<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32, string: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_client_info",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::glx::ClientInfoRequest {
            major_version,
            minor_version,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_client_info_checked<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32, string: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::ClientInfoRequest {
            major_version,
            minor_version,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_fb_configs<'this>(&'this mut self, screen: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetFBConfigsReply> {
        let span = tracing::info_span!(
            "glx_get_fb_configs",
            screen = ?screen,
        );
        let request = types::glx::GetFBConfigsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_fb_configs_immediate<'this>(&'this mut self, screen: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetFBConfigsReply> {
        let request = types::glx::GetFBConfigsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetFBConfigsReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_create_pixmap<'this>(&'this mut self, screen: types::Card32, fbconfig: types::Fbconfig, pixmap: types::xproto::Pixmap, glx_pixmap: types::glx::Pixmap, attribs: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_create_pixmap",
            screen = ?screen,
            fbconfig = ?fbconfig,
            pixmap = ?pixmap,
            glx_pixmap = ?glx_pixmap,
        );
        let request = types::glx::CreatePixmapRequest {
            screen,
            fbconfig,
            pixmap,
            glx_pixmap,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_pixmap_checked<'this>(&'this mut self, screen: types::Card32, fbconfig: types::Fbconfig, pixmap: types::xproto::Pixmap, glx_pixmap: types::glx::Pixmap, attribs: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::CreatePixmapRequest {
            screen,
            fbconfig,
            pixmap,
            glx_pixmap,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pixmap<'this>(&'this mut self, glx_pixmap: types::glx::Pixmap) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_destroy_pixmap",
            glx_pixmap = ?glx_pixmap,
        );
        let request = types::glx::DestroyPixmapRequest {
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pixmap_checked<'this>(&'this mut self, glx_pixmap: types::glx::Pixmap) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::DestroyPixmapRequest {
            glx_pixmap,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_create_new_context<'this>(&'this mut self, context: types::glx::Context, fbconfig: types::Fbconfig, screen: types::Card32, render_type: types::Card32, share_list: types::glx::Context, is_direct: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_create_new_context",
            context = ?context,
            fbconfig = ?fbconfig,
            screen = ?screen,
            render_type = ?render_type,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let request = types::glx::CreateNewContextRequest {
            context,
            fbconfig,
            screen,
            render_type,
            share_list,
            is_direct,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_new_context_checked<'this>(&'this mut self, context: types::glx::Context, fbconfig: types::Fbconfig, screen: types::Card32, render_type: types::Card32, share_list: types::glx::Context, is_direct: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::CreateNewContextRequest {
            context,
            fbconfig,
            screen,
            render_type,
            share_list,
            is_direct,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_query_context<'this>(&'this mut self, context: types::glx::Context) -> futures::SendRequest<'this, Self, types::glx::QueryContextReply> {
        let span = tracing::info_span!(
            "glx_query_context",
            context = ?context,
        );
        let request = types::glx::QueryContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_query_context_immediate<'this>(&'this mut self, context: types::glx::Context) -> futures::CheckedSendRequest<'this, Self, types::glx::QueryContextReply> {
        let request = types::glx::QueryContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::QueryContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_make_context_current<'this>(&'this mut self, old_context_tag: types::ContextTag, drawable: types::glx::Drawable, read_drawable: types::glx::Drawable, context: types::glx::Context) -> futures::SendRequest<'this, Self, types::glx::MakeContextCurrentReply> {
        let span = tracing::info_span!(
            "glx_make_context_current",
            old_context_tag = ?old_context_tag,
            drawable = ?drawable,
            read_drawable = ?read_drawable,
            context = ?context,
        );
        let request = types::glx::MakeContextCurrentRequest {
            old_context_tag,
            drawable,
            read_drawable,
            context,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_make_context_current_immediate<'this>(&'this mut self, old_context_tag: types::ContextTag, drawable: types::glx::Drawable, read_drawable: types::glx::Drawable, context: types::glx::Context) -> futures::CheckedSendRequest<'this, Self, types::glx::MakeContextCurrentReply> {
        let request = types::glx::MakeContextCurrentRequest {
            old_context_tag,
            drawable,
            read_drawable,
            context,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::MakeContextCurrentReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_create_pbuffer<'this>(&'this mut self, screen: types::Card32, fbconfig: types::Fbconfig, pbuffer: types::Pbuffer, attribs: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_create_pbuffer",
            screen = ?screen,
            fbconfig = ?fbconfig,
            pbuffer = ?pbuffer,
        );
        let request = types::glx::CreatePbufferRequest {
            screen,
            fbconfig,
            pbuffer,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_pbuffer_checked<'this>(&'this mut self, screen: types::Card32, fbconfig: types::Fbconfig, pbuffer: types::Pbuffer, attribs: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::CreatePbufferRequest {
            screen,
            fbconfig,
            pbuffer,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pbuffer<'this>(&'this mut self, pbuffer: types::Pbuffer) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_destroy_pbuffer",
            pbuffer = ?pbuffer,
        );
        let request = types::glx::DestroyPbufferRequest {
            pbuffer,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pbuffer_checked<'this>(&'this mut self, pbuffer: types::Pbuffer) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::DestroyPbufferRequest {
            pbuffer,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_drawable_attributes<'this>(&'this mut self, drawable: types::glx::Drawable) -> futures::SendRequest<'this, Self, types::glx::GetDrawableAttributesReply> {
        let span = tracing::info_span!(
            "glx_get_drawable_attributes",
            drawable = ?drawable,
        );
        let request = types::glx::GetDrawableAttributesRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_drawable_attributes_immediate<'this>(&'this mut self, drawable: types::glx::Drawable) -> futures::CheckedSendRequest<'this, Self, types::glx::GetDrawableAttributesReply> {
        let request = types::glx::GetDrawableAttributesRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetDrawableAttributesReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_change_drawable_attributes<'this>(&'this mut self, drawable: types::glx::Drawable, attribs: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_change_drawable_attributes",
            drawable = ?drawable,
        );
        let request = types::glx::ChangeDrawableAttributesRequest {
            drawable,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_change_drawable_attributes_checked<'this>(&'this mut self, drawable: types::glx::Drawable, attribs: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::ChangeDrawableAttributesRequest {
            drawable,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_create_window<'this>(&'this mut self, screen: types::Card32, fbconfig: types::Fbconfig, window: types::xproto::Window, glx_window: types::glx::Window, attribs: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_create_window",
            screen = ?screen,
            fbconfig = ?fbconfig,
            window = ?window,
            glx_window = ?glx_window,
        );
        let request = types::glx::CreateWindowRequest {
            screen,
            fbconfig,
            window,
            glx_window,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_window_checked<'this>(&'this mut self, screen: types::Card32, fbconfig: types::Fbconfig, window: types::xproto::Window, glx_window: types::glx::Window, attribs: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::CreateWindowRequest {
            screen,
            fbconfig,
            window,
            glx_window,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_delete_window<'this>(&'this mut self, glxwindow: types::glx::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_delete_window",
            glxwindow = ?glxwindow,
        );
        let request = types::glx::DeleteWindowRequest {
            glxwindow,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_delete_window_checked<'this>(&'this mut self, glxwindow: types::glx::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::DeleteWindowRequest {
            glxwindow,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info_arb<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_set_client_info_arb",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::glx::SetClientInfoARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info_arb_checked<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::SetClientInfoARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_attribs_arb<'this>(&'this mut self, context: types::glx::Context, fbconfig: types::Fbconfig, screen: types::Card32, share_list: types::glx::Context, is_direct: types::Bool, attribs: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_create_context_attribs_arb",
            context = ?context,
            fbconfig = ?fbconfig,
            screen = ?screen,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let request = types::glx::CreateContextAttribsARBRequest {
            context,
            fbconfig,
            screen,
            share_list,
            is_direct,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_attribs_arb_checked<'this>(&'this mut self, context: types::glx::Context, fbconfig: types::Fbconfig, screen: types::Card32, share_list: types::glx::Context, is_direct: types::Bool, attribs: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::CreateContextAttribsARBRequest {
            context,
            fbconfig,
            screen,
            share_list,
            is_direct,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info2_arb<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_set_client_info2_arb",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::glx::SetClientInfo2ARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info2_arb_checked<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::SetClientInfo2ARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_new_list<'this>(&'this mut self, context_tag: types::ContextTag, list: types::Card32, mode: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_new_list",
            context_tag = ?context_tag,
            list = ?list,
            mode = ?mode,
        );
        let request = types::glx::NewListRequest {
            context_tag,
            list,
            mode,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_new_list_checked<'this>(&'this mut self, context_tag: types::ContextTag, list: types::Card32, mode: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::NewListRequest {
            context_tag,
            list,
            mode,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_end_list<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_end_list",
            context_tag = ?context_tag,
        );
        let request = types::glx::EndListRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_end_list_checked<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::EndListRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_delete_lists<'this>(&'this mut self, context_tag: types::ContextTag, list: types::Card32, range: types::Int32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_delete_lists",
            context_tag = ?context_tag,
            list = ?list,
            range = ?range,
        );
        let request = types::glx::DeleteListsRequest {
            context_tag,
            list,
            range,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_delete_lists_checked<'this>(&'this mut self, context_tag: types::ContextTag, list: types::Card32, range: types::Int32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::DeleteListsRequest {
            context_tag,
            list,
            range,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_gen_lists<'this>(&'this mut self, context_tag: types::ContextTag, range: types::Int32) -> futures::SendRequest<'this, Self, types::glx::GenListsReply> {
        let span = tracing::info_span!(
            "glx_gen_lists",
            context_tag = ?context_tag,
            range = ?range,
        );
        let request = types::glx::GenListsRequest {
            context_tag,
            range,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_gen_lists_immediate<'this>(&'this mut self, context_tag: types::ContextTag, range: types::Int32) -> futures::CheckedSendRequest<'this, Self, types::glx::GenListsReply> {
        let request = types::glx::GenListsRequest {
            context_tag,
            range,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GenListsReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_feedback_buffer<'this>(&'this mut self, context_tag: types::ContextTag, size: types::Int32, type_: types::Int32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_feedback_buffer",
            context_tag = ?context_tag,
            size = ?size,
            type_ = ?type_,
        );
        let request = types::glx::FeedbackBufferRequest {
            context_tag,
            size,
            type_,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_feedback_buffer_checked<'this>(&'this mut self, context_tag: types::ContextTag, size: types::Int32, type_: types::Int32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::FeedbackBufferRequest {
            context_tag,
            size,
            type_,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_select_buffer<'this>(&'this mut self, context_tag: types::ContextTag, size: types::Int32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_select_buffer",
            context_tag = ?context_tag,
            size = ?size,
        );
        let request = types::glx::SelectBufferRequest {
            context_tag,
            size,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_select_buffer_checked<'this>(&'this mut self, context_tag: types::ContextTag, size: types::Int32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::SelectBufferRequest {
            context_tag,
            size,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_render_mode<'this>(&'this mut self, context_tag: types::ContextTag, mode: types::Card32) -> futures::SendRequest<'this, Self, types::glx::RenderModeReply> {
        let span = tracing::info_span!(
            "glx_render_mode",
            context_tag = ?context_tag,
            mode = ?mode,
        );
        let request = types::glx::RenderModeRequest {
            context_tag,
            mode,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_render_mode_immediate<'this>(&'this mut self, context_tag: types::ContextTag, mode: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::RenderModeReply> {
        let request = types::glx::RenderModeRequest {
            context_tag,
            mode,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::RenderModeReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_finish<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::SendRequest<'this, Self, types::glx::FinishReply> {
        let span = tracing::info_span!(
            "glx_finish",
            context_tag = ?context_tag,
        );
        let request = types::glx::FinishRequest {
            context_tag,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_finish_immediate<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::CheckedSendRequest<'this, Self, types::glx::FinishReply> {
        let request = types::glx::FinishRequest {
            context_tag,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::FinishReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storef<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Card32, datum: types::Float32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_pixel_storef",
            context_tag = ?context_tag,
            pname = ?pname,
            datum = ?datum,
        );
        let request = types::glx::PixelStorefRequest {
            context_tag,
            pname,
            datum,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storef_checked<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Card32, datum: types::Float32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::PixelStorefRequest {
            context_tag,
            pname,
            datum,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storei<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Card32, datum: types::Int32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_pixel_storei",
            context_tag = ?context_tag,
            pname = ?pname,
            datum = ?datum,
        );
        let request = types::glx::PixelStoreiRequest {
            context_tag,
            pname,
            datum,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storei_checked<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Card32, datum: types::Int32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::PixelStoreiRequest {
            context_tag,
            pname,
            datum,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_read_pixels<'this>(&'this mut self, context_tag: types::ContextTag, x: types::Int32, y: types::Int32, width: types::Int32, height: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, lsb_first: types::Bool) -> futures::SendRequest<'this, Self, types::glx::ReadPixelsReply> {
        let span = tracing::info_span!(
            "glx_read_pixels",
            context_tag = ?context_tag,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            lsb_first = ?lsb_first,
        );
        let request = types::glx::ReadPixelsRequest {
            context_tag,
            x,
            y,
            width,
            height,
            format,
            type_,
            swap_bytes,
            lsb_first,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_read_pixels_immediate<'this>(&'this mut self, context_tag: types::ContextTag, x: types::Int32, y: types::Int32, width: types::Int32, height: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, lsb_first: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::glx::ReadPixelsReply> {
        let request = types::glx::ReadPixelsRequest {
            context_tag,
            x,
            y,
            width,
            height,
            format,
            type_,
            swap_bytes,
            lsb_first,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::ReadPixelsReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_booleanv<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Int32) -> futures::SendRequest<'this, Self, types::glx::GetBooleanvReply> {
        let span = tracing::info_span!(
            "glx_get_booleanv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let request = types::glx::GetBooleanvRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_booleanv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Int32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetBooleanvReply> {
        let request = types::glx::GetBooleanvRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetBooleanvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_clip_plane<'this>(&'this mut self, context_tag: types::ContextTag, plane: types::Int32) -> futures::SendRequest<'this, Self, types::glx::GetClipPlaneReply> {
        let span = tracing::info_span!(
            "glx_get_clip_plane",
            context_tag = ?context_tag,
            plane = ?plane,
        );
        let request = types::glx::GetClipPlaneRequest {
            context_tag,
            plane,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_clip_plane_immediate<'this>(&'this mut self, context_tag: types::ContextTag, plane: types::Int32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetClipPlaneReply> {
        let request = types::glx::GetClipPlaneRequest {
            context_tag,
            plane,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetClipPlaneReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_doublev<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetDoublevReply> {
        let span = tracing::info_span!(
            "glx_get_doublev",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let request = types::glx::GetDoublevRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_doublev_immediate<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetDoublevReply> {
        let request = types::glx::GetDoublevRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetDoublevReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_error<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::SendRequest<'this, Self, types::glx::GetErrorReply> {
        let span = tracing::info_span!(
            "glx_get_error",
            context_tag = ?context_tag,
        );
        let request = types::glx::GetErrorRequest {
            context_tag,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_error_immediate<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::CheckedSendRequest<'this, Self, types::glx::GetErrorReply> {
        let request = types::glx::GetErrorRequest {
            context_tag,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetErrorReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_floatv<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetFloatvReply> {
        let span = tracing::info_span!(
            "glx_get_floatv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let request = types::glx::GetFloatvRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_floatv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetFloatvReply> {
        let request = types::glx::GetFloatvRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetFloatvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_integerv<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetIntegervReply> {
        let span = tracing::info_span!(
            "glx_get_integerv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let request = types::glx::GetIntegervRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_integerv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetIntegervReply> {
        let request = types::glx::GetIntegervRequest {
            context_tag,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetIntegervReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightfv<'this>(&'this mut self, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetLightfvReply> {
        let span = tracing::info_span!(
            "glx_get_lightfv",
            context_tag = ?context_tag,
            light = ?light,
            pname = ?pname,
        );
        let request = types::glx::GetLightfvRequest {
            context_tag,
            light,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetLightfvReply> {
        let request = types::glx::GetLightfvRequest {
            context_tag,
            light,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetLightfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightiv<'this>(&'this mut self, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetLightivReply> {
        let span = tracing::info_span!(
            "glx_get_lightiv",
            context_tag = ?context_tag,
            light = ?light,
            pname = ?pname,
        );
        let request = types::glx::GetLightivRequest {
            context_tag,
            light,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightiv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetLightivReply> {
        let request = types::glx::GetLightivRequest {
            context_tag,
            light,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetLightivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapdv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetMapdvReply> {
        let span = tracing::info_span!(
            "glx_get_mapdv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let request = types::glx::GetMapdvRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapdv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetMapdvReply> {
        let request = types::glx::GetMapdvRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMapdvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapfv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetMapfvReply> {
        let span = tracing::info_span!(
            "glx_get_mapfv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let request = types::glx::GetMapfvRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetMapfvReply> {
        let request = types::glx::GetMapfvRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMapfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapiv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetMapivReply> {
        let span = tracing::info_span!(
            "glx_get_mapiv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let request = types::glx::GetMapivRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapiv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetMapivReply> {
        let request = types::glx::GetMapivRequest {
            context_tag,
            target,
            query,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMapivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialfv<'this>(&'this mut self, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetMaterialfvReply> {
        let span = tracing::info_span!(
            "glx_get_materialfv",
            context_tag = ?context_tag,
            face = ?face,
            pname = ?pname,
        );
        let request = types::glx::GetMaterialfvRequest {
            context_tag,
            face,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetMaterialfvReply> {
        let request = types::glx::GetMaterialfvRequest {
            context_tag,
            face,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMaterialfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialiv<'this>(&'this mut self, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetMaterialivReply> {
        let span = tracing::info_span!(
            "glx_get_materialiv",
            context_tag = ?context_tag,
            face = ?face,
            pname = ?pname,
        );
        let request = types::glx::GetMaterialivRequest {
            context_tag,
            face,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialiv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetMaterialivReply> {
        let request = types::glx::GetMaterialivRequest {
            context_tag,
            face,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMaterialivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapfv<'this>(&'this mut self, context_tag: types::ContextTag, map: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetPixelMapfvReply> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapfv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let request = types::glx::GetPixelMapfvRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, map: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapfvReply> {
        let request = types::glx::GetPixelMapfvRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapuiv<'this>(&'this mut self, context_tag: types::ContextTag, map: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetPixelMapuivReply> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapuiv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let request = types::glx::GetPixelMapuivRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapuiv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, map: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapuivReply> {
        let request = types::glx::GetPixelMapuivRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapuivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapusv<'this>(&'this mut self, context_tag: types::ContextTag, map: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetPixelMapusvReply> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapusv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let request = types::glx::GetPixelMapusvRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapusv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, map: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapusvReply> {
        let request = types::glx::GetPixelMapusvRequest {
            context_tag,
            map,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapusvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_polygon_stipple<'this>(&'this mut self, context_tag: types::ContextTag, lsb_first: types::Bool) -> futures::SendRequest<'this, Self, types::glx::GetPolygonStippleReply> {
        let span = tracing::info_span!(
            "glx_get_polygon_stipple",
            context_tag = ?context_tag,
            lsb_first = ?lsb_first,
        );
        let request = types::glx::GetPolygonStippleRequest {
            context_tag,
            lsb_first,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_polygon_stipple_immediate<'this>(&'this mut self, context_tag: types::ContextTag, lsb_first: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::glx::GetPolygonStippleReply> {
        let request = types::glx::GetPolygonStippleRequest {
            context_tag,
            lsb_first,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetPolygonStippleReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_string<'this>(&'this mut self, context_tag: types::ContextTag, name: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetStringReply> {
        let span = tracing::info_span!(
            "glx_get_string",
            context_tag = ?context_tag,
            name = ?name,
        );
        let request = types::glx::GetStringRequest {
            context_tag,
            name,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_string_immediate<'this>(&'this mut self, context_tag: types::ContextTag, name: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetStringReply> {
        let request = types::glx::GetStringRequest {
            context_tag,
            name,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetStringReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_envfv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetTexEnvfvReply> {
        let span = tracing::info_span!(
            "glx_get_tex_envfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetTexEnvfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_envfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetTexEnvfvReply> {
        let request = types::glx::GetTexEnvfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexEnvfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_enviv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetTexEnvivReply> {
        let span = tracing::info_span!(
            "glx_get_tex_enviv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetTexEnvivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_enviv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetTexEnvivReply> {
        let request = types::glx::GetTexEnvivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexEnvivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_gendv<'this>(&'this mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetTexGendvReply> {
        let span = tracing::info_span!(
            "glx_get_tex_gendv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let request = types::glx::GetTexGendvRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_gendv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetTexGendvReply> {
        let request = types::glx::GetTexGendvRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexGendvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_genfv<'this>(&'this mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetTexGenfvReply> {
        let span = tracing::info_span!(
            "glx_get_tex_genfv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let request = types::glx::GetTexGenfvRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_genfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetTexGenfvReply> {
        let request = types::glx::GetTexGenfvRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexGenfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_geniv<'this>(&'this mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetTexGenivReply> {
        let span = tracing::info_span!(
            "glx_get_tex_geniv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let request = types::glx::GetTexGenivRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_geniv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetTexGenivReply> {
        let request = types::glx::GetTexGenivRequest {
            context_tag,
            coord,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexGenivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_image<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> futures::SendRequest<'this, Self, types::glx::GetTexImageReply> {
        let span = tracing::info_span!(
            "glx_get_tex_image",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let request = types::glx::GetTexImageRequest {
            context_tag,
            target,
            level,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_image_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::glx::GetTexImageReply> {
        let request = types::glx::GetTexImageRequest {
            context_tag,
            target,
            level,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexImageReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameterfv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetTexParameterfvReply> {
        let span = tracing::info_span!(
            "glx_get_tex_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetTexParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameterfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetTexParameterfvReply> {
        let request = types::glx::GetTexParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexParameterfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameteriv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetTexParameterivReply> {
        let span = tracing::info_span!(
            "glx_get_tex_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetTexParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameteriv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetTexParameterivReply> {
        let request = types::glx::GetTexParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexParameterivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameterfv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetTexLevelParameterfvReply> {
        let span = tracing::info_span!(
            "glx_get_tex_level_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            pname = ?pname,
        );
        let request = types::glx::GetTexLevelParameterfvRequest {
            context_tag,
            target,
            level,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameterfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetTexLevelParameterfvReply> {
        let request = types::glx::GetTexLevelParameterfvRequest {
            context_tag,
            target,
            level,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexLevelParameterfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameteriv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetTexLevelParameterivReply> {
        let span = tracing::info_span!(
            "glx_get_tex_level_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            pname = ?pname,
        );
        let request = types::glx::GetTexLevelParameterivRequest {
            context_tag,
            target,
            level,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameteriv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetTexLevelParameterivReply> {
        let request = types::glx::GetTexLevelParameterivRequest {
            context_tag,
            target,
            level,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexLevelParameterivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_is_enabled<'this>(&'this mut self, context_tag: types::ContextTag, capability: types::Card32) -> futures::SendRequest<'this, Self, types::glx::IsEnabledReply> {
        let span = tracing::info_span!(
            "glx_is_enabled",
            context_tag = ?context_tag,
            capability = ?capability,
        );
        let request = types::glx::IsEnabledRequest {
            context_tag,
            capability,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_is_enabled_immediate<'this>(&'this mut self, context_tag: types::ContextTag, capability: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::IsEnabledReply> {
        let request = types::glx::IsEnabledRequest {
            context_tag,
            capability,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::IsEnabledReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_is_list<'this>(&'this mut self, context_tag: types::ContextTag, list: types::Card32) -> futures::SendRequest<'this, Self, types::glx::IsListReply> {
        let span = tracing::info_span!(
            "glx_is_list",
            context_tag = ?context_tag,
            list = ?list,
        );
        let request = types::glx::IsListRequest {
            context_tag,
            list,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_is_list_immediate<'this>(&'this mut self, context_tag: types::ContextTag, list: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::IsListReply> {
        let request = types::glx::IsListRequest {
            context_tag,
            list,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::IsListReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_flush<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_flush",
            context_tag = ?context_tag,
        );
        let request = types::glx::FlushRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_flush_checked<'this>(&'this mut self, context_tag: types::ContextTag) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::FlushRequest {
            context_tag,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_are_textures_resident<'this>(&'this mut self, context_tag: types::ContextTag, textures: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, types::glx::AreTexturesResidentReply> {
        let span = tracing::info_span!(
            "glx_are_textures_resident",
            context_tag = ?context_tag,
        );
        let request = types::glx::AreTexturesResidentRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_are_textures_resident_immediate<'this>(&'this mut self, context_tag: types::ContextTag, textures: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, types::glx::AreTexturesResidentReply> {
        let request = types::glx::AreTexturesResidentRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::AreTexturesResidentReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_delete_textures<'this>(&'this mut self, context_tag: types::ContextTag, textures: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_delete_textures",
            context_tag = ?context_tag,
        );
        let request = types::glx::DeleteTexturesRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_delete_textures_checked<'this>(&'this mut self, context_tag: types::ContextTag, textures: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::DeleteTexturesRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_gen_textures<'this>(&'this mut self, context_tag: types::ContextTag, n: types::Int32) -> futures::SendRequest<'this, Self, types::glx::GenTexturesReply> {
        let span = tracing::info_span!(
            "glx_gen_textures",
            context_tag = ?context_tag,
            n = ?n,
        );
        let request = types::glx::GenTexturesRequest {
            context_tag,
            n,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_gen_textures_immediate<'this>(&'this mut self, context_tag: types::ContextTag, n: types::Int32) -> futures::CheckedSendRequest<'this, Self, types::glx::GenTexturesReply> {
        let request = types::glx::GenTexturesRequest {
            context_tag,
            n,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GenTexturesReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_is_texture<'this>(&'this mut self, context_tag: types::ContextTag, texture: types::Card32) -> futures::SendRequest<'this, Self, types::glx::IsTextureReply> {
        let span = tracing::info_span!(
            "glx_is_texture",
            context_tag = ?context_tag,
            texture = ?texture,
        );
        let request = types::glx::IsTextureRequest {
            context_tag,
            texture,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_is_texture_immediate<'this>(&'this mut self, context_tag: types::ContextTag, texture: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::IsTextureReply> {
        let request = types::glx::IsTextureRequest {
            context_tag,
            texture,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::IsTextureReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> futures::SendRequest<'this, Self, types::glx::GetColorTableReply> {
        let span = tracing::info_span!(
            "glx_get_color_table",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let request = types::glx::GetColorTableRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::glx::GetColorTableReply> {
        let request = types::glx::GetColorTableRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetColorTableReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameterfv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetColorTableParameterfvReply> {
        let span = tracing::info_span!(
            "glx_get_color_table_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetColorTableParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameterfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetColorTableParameterfvReply> {
        let request = types::glx::GetColorTableParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetColorTableParameterfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameteriv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetColorTableParameterivReply> {
        let span = tracing::info_span!(
            "glx_get_color_table_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetColorTableParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameteriv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetColorTableParameterivReply> {
        let request = types::glx::GetColorTableParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetColorTableParameterivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_filter<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> futures::SendRequest<'this, Self, types::glx::GetConvolutionFilterReply> {
        let span = tracing::info_span!(
            "glx_get_convolution_filter",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let request = types::glx::GetConvolutionFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_filter_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::glx::GetConvolutionFilterReply> {
        let request = types::glx::GetConvolutionFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetConvolutionFilterReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameterfv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetConvolutionParameterfvReply> {
        let span = tracing::info_span!(
            "glx_get_convolution_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetConvolutionParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameterfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetConvolutionParameterfvReply> {
        let request = types::glx::GetConvolutionParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetConvolutionParameterfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameteriv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetConvolutionParameterivReply> {
        let span = tracing::info_span!(
            "glx_get_convolution_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetConvolutionParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameteriv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetConvolutionParameterivReply> {
        let request = types::glx::GetConvolutionParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetConvolutionParameterivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_separable_filter<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> futures::SendRequest<'this, Self, types::glx::GetSeparableFilterReply> {
        let span = tracing::info_span!(
            "glx_get_separable_filter",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let request = types::glx::GetSeparableFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_separable_filter_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::glx::GetSeparableFilterReply> {
        let request = types::glx::GetSeparableFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetSeparableFilterReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> futures::SendRequest<'this, Self, types::glx::GetHistogramReply> {
        let span = tracing::info_span!(
            "glx_get_histogram",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            reset = ?reset,
        );
        let request = types::glx::GetHistogramRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::glx::GetHistogramReply> {
        let request = types::glx::GetHistogramRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetHistogramReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameterfv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetHistogramParameterfvReply> {
        let span = tracing::info_span!(
            "glx_get_histogram_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetHistogramParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameterfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetHistogramParameterfvReply> {
        let request = types::glx::GetHistogramParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetHistogramParameterfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameteriv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetHistogramParameterivReply> {
        let span = tracing::info_span!(
            "glx_get_histogram_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetHistogramParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameteriv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetHistogramParameterivReply> {
        let request = types::glx::GetHistogramParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetHistogramParameterivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> futures::SendRequest<'this, Self, types::glx::GetMinmaxReply> {
        let span = tracing::info_span!(
            "glx_get_minmax",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            reset = ?reset,
        );
        let request = types::glx::GetMinmaxRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxReply> {
        let request = types::glx::GetMinmaxRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameterfv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetMinmaxParameterfvReply> {
        let span = tracing::info_span!(
            "glx_get_minmax_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetMinmaxParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameterfv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxParameterfvReply> {
        let request = types::glx::GetMinmaxParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxParameterfvReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameteriv<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetMinmaxParameterivReply> {
        let span = tracing::info_span!(
            "glx_get_minmax_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetMinmaxParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameteriv_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxParameterivReply> {
        let request = types::glx::GetMinmaxParameterivRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxParameterivReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_compressed_tex_image_arb<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32) -> futures::SendRequest<'this, Self, types::glx::GetCompressedTexImageARBReply> {
        let span = tracing::info_span!(
            "glx_get_compressed_tex_image_arb",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
        );
        let request = types::glx::GetCompressedTexImageARBRequest {
            context_tag,
            target,
            level,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_compressed_tex_image_arb_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetCompressedTexImageARBReply> {
        let request = types::glx::GetCompressedTexImageARBRequest {
            context_tag,
            target,
            level,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetCompressedTexImageARBReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_delete_queries_arb<'this>(&'this mut self, context_tag: types::ContextTag, ids: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "glx_delete_queries_arb",
            context_tag = ?context_tag,
        );
        let request = types::glx::DeleteQueriesARBRequest {
            context_tag,
            ids: Cow::Borrowed(ids.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_delete_queries_arb_checked<'this>(&'this mut self, context_tag: types::ContextTag, ids: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::glx::DeleteQueriesARBRequest {
            context_tag,
            ids: Cow::Borrowed(ids.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_gen_queries_arb<'this>(&'this mut self, context_tag: types::ContextTag, n: types::Int32) -> futures::SendRequest<'this, Self, types::glx::GenQueriesARBReply> {
        let span = tracing::info_span!(
            "glx_gen_queries_arb",
            context_tag = ?context_tag,
            n = ?n,
        );
        let request = types::glx::GenQueriesARBRequest {
            context_tag,
            n,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_gen_queries_arb_immediate<'this>(&'this mut self, context_tag: types::ContextTag, n: types::Int32) -> futures::CheckedSendRequest<'this, Self, types::glx::GenQueriesARBReply> {
        let request = types::glx::GenQueriesARBRequest {
            context_tag,
            n,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GenQueriesARBReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_is_query_arb<'this>(&'this mut self, context_tag: types::ContextTag, id: types::Card32) -> futures::SendRequest<'this, Self, types::glx::IsQueryARBReply> {
        let span = tracing::info_span!(
            "glx_is_query_arb",
            context_tag = ?context_tag,
            id = ?id,
        );
        let request = types::glx::IsQueryARBRequest {
            context_tag,
            id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_is_query_arb_immediate<'this>(&'this mut self, context_tag: types::ContextTag, id: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::IsQueryARBReply> {
        let request = types::glx::IsQueryARBRequest {
            context_tag,
            id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::IsQueryARBReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_queryiv_arb<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetQueryivARBReply> {
        let span = tracing::info_span!(
            "glx_get_queryiv_arb",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetQueryivARBRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_queryiv_arb_immediate<'this>(&'this mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetQueryivARBReply> {
        let request = types::glx::GetQueryivARBRequest {
            context_tag,
            target,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetQueryivARBReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectiv_arb<'this>(&'this mut self, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetQueryObjectivARBReply> {
        let span = tracing::info_span!(
            "glx_get_query_objectiv_arb",
            context_tag = ?context_tag,
            id = ?id,
            pname = ?pname,
        );
        let request = types::glx::GetQueryObjectivARBRequest {
            context_tag,
            id,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectiv_arb_immediate<'this>(&'this mut self, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetQueryObjectivARBReply> {
        let request = types::glx::GetQueryObjectivARBRequest {
            context_tag,
            id,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetQueryObjectivARBReply> = cookie.into();
        res
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectuiv_arb<'this>(&'this mut self, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> futures::SendRequest<'this, Self, types::glx::GetQueryObjectuivARBReply> {
        let span = tracing::info_span!(
            "glx_get_query_objectuiv_arb",
            context_tag = ?context_tag,
            id = ?id,
            pname = ?pname,
        );
        let request = types::glx::GetQueryObjectuivARBRequest {
            context_tag,
            id,
            pname,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectuiv_arb_immediate<'this>(&'this mut self, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::glx::GetQueryObjectuivARBReply> {
        let request = types::glx::GetQueryObjectuivARBRequest {
            context_tag,
            id,
            pname,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetQueryObjectuivARBReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "present")]
    fn present_query_version<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32) -> futures::SendRequest<'this, Self, types::present::QueryVersionReply> {
        let span = tracing::info_span!(
            "present_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::present::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "present")]
    fn present_query_version_immediate<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::present::QueryVersionReply> {
        let request = types::present::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::present::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "present")]
    fn present_pixmap<'this>(&'this mut self, window: types::xproto::Window, pixmap: types::xproto::Pixmap, serial: types::Card32, valid: types::Region, update: types::Region, x_off: types::Int16, y_off: types::Int16, target_crtc: types::Crtc, wait_fence: types::Fence, idle_fence: types::Fence, options: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64, notifies: impl AsRef<[types::present::Notify]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "present_pixmap",
            window = ?window,
            pixmap = ?pixmap,
            serial = ?serial,
            valid = ?valid,
            update = ?update,
            x_off = ?x_off,
            y_off = ?y_off,
            target_crtc = ?target_crtc,
            wait_fence = ?wait_fence,
            idle_fence = ?idle_fence,
            options = ?options,
            target_msc = ?target_msc,
            divisor = ?divisor,
            remainder = ?remainder,
        );
        let request = types::present::PixmapRequest {
            window,
            pixmap,
            serial,
            valid,
            update,
            x_off,
            y_off,
            target_crtc,
            wait_fence,
            idle_fence,
            options,
            target_msc,
            divisor,
            remainder,
            notifies: Cow::Borrowed(notifies.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "present")]
    fn present_pixmap_checked<'this>(&'this mut self, window: types::xproto::Window, pixmap: types::xproto::Pixmap, serial: types::Card32, valid: types::Region, update: types::Region, x_off: types::Int16, y_off: types::Int16, target_crtc: types::Crtc, wait_fence: types::Fence, idle_fence: types::Fence, options: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64, notifies: impl AsRef<[types::present::Notify]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::present::PixmapRequest {
            window,
            pixmap,
            serial,
            valid,
            update,
            x_off,
            y_off,
            target_crtc,
            wait_fence,
            idle_fence,
            options,
            target_msc,
            divisor,
            remainder,
            notifies: Cow::Borrowed(notifies.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "present")]
    fn present_notify_msc<'this>(&'this mut self, window: types::xproto::Window, serial: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "present_notify_msc",
            window = ?window,
            serial = ?serial,
            target_msc = ?target_msc,
            divisor = ?divisor,
            remainder = ?remainder,
        );
        let request = types::present::NotifyMSCRequest {
            window,
            serial,
            target_msc,
            divisor,
            remainder,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "present")]
    fn present_notify_msc_checked<'this>(&'this mut self, window: types::xproto::Window, serial: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::present::NotifyMSCRequest {
            window,
            serial,
            target_msc,
            divisor,
            remainder,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "present")]
    fn present_select_input<'this>(&'this mut self, eid: types::present::Event, window: types::xproto::Window, event_mask: impl Into<types::present::EventMask>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "present_select_input",
            eid = ?eid,
            window = ?window,
        );
        let request = types::present::SelectInputRequest {
            eid,
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "present")]
    fn present_select_input_checked<'this>(&'this mut self, eid: types::present::Event, window: types::xproto::Window, event_mask: impl Into<types::present::EventMask>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::present::SelectInputRequest {
            eid,
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "present")]
    fn present_query_capabilities<'this>(&'this mut self, target: types::Card32) -> futures::SendRequest<'this, Self, types::present::QueryCapabilitiesReply> {
        let span = tracing::info_span!(
            "present_query_capabilities",
            target = ?target,
        );
        let request = types::present::QueryCapabilitiesRequest {
            target,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "present")]
    fn present_query_capabilities_immediate<'this>(&'this mut self, target: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::present::QueryCapabilitiesReply> {
        let request = types::present::QueryCapabilitiesRequest {
            target,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::present::QueryCapabilitiesReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "randr")]
    fn randr_query_version<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32) -> futures::SendRequest<'this, Self, types::randr::QueryVersionReply> {
        let span = tracing::info_span!(
            "randr_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::randr::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_query_version_immediate<'this>(&'this mut self, major_version: types::Card32, minor_version: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::randr::QueryVersionReply> {
        let request = types::randr::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_config<'this>(&'this mut self, window: types::xproto::Window, timestamp: types::Timestamp, config_timestamp: types::Timestamp, size_id: types::Card16, rotation: impl Into<types::Rotation>, rate: types::Card16) -> futures::SendRequest<'this, Self, types::randr::SetScreenConfigReply> {
        let span = tracing::info_span!(
            "randr_set_screen_config",
            window = ?window,
            timestamp = ?timestamp,
            config_timestamp = ?config_timestamp,
            size_id = ?size_id,
            rate = ?rate,
        );
        let request = types::randr::SetScreenConfigRequest {
            window,
            timestamp,
            config_timestamp,
            size_id,
            rotation: Into::<u32>::into(rotation.into()) as _,
            rate,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_config_immediate<'this>(&'this mut self, window: types::xproto::Window, timestamp: types::Timestamp, config_timestamp: types::Timestamp, size_id: types::Card16, rotation: impl Into<types::Rotation>, rate: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::randr::SetScreenConfigReply> {
        let request = types::randr::SetScreenConfigRequest {
            window,
            timestamp,
            config_timestamp,
            size_id,
            rotation: Into::<u32>::into(rotation.into()) as _,
            rate,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::SetScreenConfigReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_select_input<'this>(&'this mut self, window: types::xproto::Window, enable: impl Into<types::NotifyMask>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_select_input",
            window = ?window,
        );
        let request = types::randr::SelectInputRequest {
            window,
            enable: Into::<u32>::into(enable.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_select_input_checked<'this>(&'this mut self, window: types::xproto::Window, enable: impl Into<types::NotifyMask>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::SelectInputRequest {
            window,
            enable: Into::<u32>::into(enable.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_info<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::randr::GetScreenInfoReply> {
        let span = tracing::info_span!(
            "randr_get_screen_info",
            window = ?window,
        );
        let request = types::randr::GetScreenInfoRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_info_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::randr::GetScreenInfoReply> {
        let request = types::randr::GetScreenInfoRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetScreenInfoReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_size_range<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::randr::GetScreenSizeRangeReply> {
        let span = tracing::info_span!(
            "randr_get_screen_size_range",
            window = ?window,
        );
        let request = types::randr::GetScreenSizeRangeRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_size_range_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::randr::GetScreenSizeRangeReply> {
        let request = types::randr::GetScreenSizeRangeRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetScreenSizeRangeReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_size<'this>(&'this mut self, window: types::xproto::Window, width: types::Card16, height: types::Card16, mm_width: types::Card32, mm_height: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_set_screen_size",
            window = ?window,
            width = ?width,
            height = ?height,
            mm_width = ?mm_width,
            mm_height = ?mm_height,
        );
        let request = types::randr::SetScreenSizeRequest {
            window,
            width,
            height,
            mm_width,
            mm_height,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_size_checked<'this>(&'this mut self, window: types::xproto::Window, width: types::Card16, height: types::Card16, mm_width: types::Card32, mm_height: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::SetScreenSizeRequest {
            window,
            width,
            height,
            mm_width,
            mm_height,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::randr::GetScreenResourcesReply> {
        let span = tracing::info_span!(
            "randr_get_screen_resources",
            window = ?window,
        );
        let request = types::randr::GetScreenResourcesRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::randr::GetScreenResourcesReply> {
        let request = types::randr::GetScreenResourcesRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetScreenResourcesReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_info<'this>(&'this mut self, output: types::Output, config_timestamp: types::Timestamp) -> futures::SendRequest<'this, Self, types::randr::GetOutputInfoReply> {
        let span = tracing::info_span!(
            "randr_get_output_info",
            output = ?output,
            config_timestamp = ?config_timestamp,
        );
        let request = types::randr::GetOutputInfoRequest {
            output,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_info_immediate<'this>(&'this mut self, output: types::Output, config_timestamp: types::Timestamp) -> futures::CheckedSendRequest<'this, Self, types::randr::GetOutputInfoReply> {
        let request = types::randr::GetOutputInfoRequest {
            output,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetOutputInfoReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_list_output_properties<'this>(&'this mut self, output: types::Output) -> futures::SendRequest<'this, Self, types::randr::ListOutputPropertiesReply> {
        let span = tracing::info_span!(
            "randr_list_output_properties",
            output = ?output,
        );
        let request = types::randr::ListOutputPropertiesRequest {
            output,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_list_output_properties_immediate<'this>(&'this mut self, output: types::Output) -> futures::CheckedSendRequest<'this, Self, types::randr::ListOutputPropertiesReply> {
        let request = types::randr::ListOutputPropertiesRequest {
            output,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::ListOutputPropertiesReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_query_output_property<'this>(&'this mut self, output: types::Output, property: types::Atom) -> futures::SendRequest<'this, Self, types::randr::QueryOutputPropertyReply> {
        let span = tracing::info_span!(
            "randr_query_output_property",
            output = ?output,
            property = ?property,
        );
        let request = types::randr::QueryOutputPropertyRequest {
            output,
            property,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_query_output_property_immediate<'this>(&'this mut self, output: types::Output, property: types::Atom) -> futures::CheckedSendRequest<'this, Self, types::randr::QueryOutputPropertyReply> {
        let request = types::randr::QueryOutputPropertyRequest {
            output,
            property,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::QueryOutputPropertyReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_configure_output_property<'this>(&'this mut self, output: types::Output, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_configure_output_property",
            output = ?output,
            property = ?property,
            pending = ?pending,
            range = ?range,
        );
        let request = types::randr::ConfigureOutputPropertyRequest {
            output,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_configure_output_property_checked<'this>(&'this mut self, output: types::Output, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::ConfigureOutputPropertyRequest {
            output,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_change_output_property<'this>(&'this mut self, output: types::Output, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::PropMode, num_units: types::Card32, data: &(impl crate::Void + ?Sized)) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_change_output_property",
            output = ?output,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            mode = ?mode,
            num_units = ?num_units,
        );
        let request = types::randr::ChangeOutputPropertyRequest {
            output,
            property,
            type_,
            format,
            mode,
            num_units,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_change_output_property_checked<'this>(&'this mut self, output: types::Output, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::PropMode, num_units: types::Card32, data: &(impl crate::Void + ?Sized)) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::ChangeOutputPropertyRequest {
            output,
            property,
            type_,
            format,
            mode,
            num_units,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_property<'this>(&'this mut self, output: types::Output, property: types::Atom) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_delete_output_property",
            output = ?output,
            property = ?property,
        );
        let request = types::randr::DeleteOutputPropertyRequest {
            output,
            property,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_property_checked<'this>(&'this mut self, output: types::Output, property: types::Atom) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::DeleteOutputPropertyRequest {
            output,
            property,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_property<'this>(&'this mut self, output: types::Output, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> futures::SendRequest<'this, Self, types::randr::GetOutputPropertyReply> {
        let span = tracing::info_span!(
            "randr_get_output_property",
            output = ?output,
            property = ?property,
            long_offset = ?long_offset,
            long_length = ?long_length,
            delete = ?delete,
            pending = ?pending,
        );
        let request = types::randr::GetOutputPropertyRequest {
            output,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
            delete,
            pending,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_property_immediate<'this>(&'this mut self, output: types::Output, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::randr::GetOutputPropertyReply> {
        let request = types::randr::GetOutputPropertyRequest {
            output,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
            delete,
            pending,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetOutputPropertyReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_create_mode<'this>(&'this mut self, window: types::xproto::Window, mode_info: types::randr::ModeInfo, name: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, types::randr::CreateModeReply> {
        let span = tracing::info_span!(
            "randr_create_mode",
            window = ?window,
            mode_info = ?mode_info,
        );
        let request = types::randr::CreateModeRequest {
            window,
            mode_info,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_create_mode_immediate<'this>(&'this mut self, window: types::xproto::Window, mode_info: types::randr::ModeInfo, name: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, types::randr::CreateModeReply> {
        let request = types::randr::CreateModeRequest {
            window,
            mode_info,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::CreateModeReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_destroy_mode<'this>(&'this mut self, mode: types::Mode) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_destroy_mode",
            mode = ?mode,
        );
        let request = types::randr::DestroyModeRequest {
            mode,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_destroy_mode_checked<'this>(&'this mut self, mode: types::Mode) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::DestroyModeRequest {
            mode,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_add_output_mode<'this>(&'this mut self, output: types::Output, mode: types::Mode) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_add_output_mode",
            output = ?output,
            mode = ?mode,
        );
        let request = types::randr::AddOutputModeRequest {
            output,
            mode,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_add_output_mode_checked<'this>(&'this mut self, output: types::Output, mode: types::Mode) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::AddOutputModeRequest {
            output,
            mode,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_mode<'this>(&'this mut self, output: types::Output, mode: types::Mode) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_delete_output_mode",
            output = ?output,
            mode = ?mode,
        );
        let request = types::randr::DeleteOutputModeRequest {
            output,
            mode,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_mode_checked<'this>(&'this mut self, output: types::Output, mode: types::Mode) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::DeleteOutputModeRequest {
            output,
            mode,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_info<'this>(&'this mut self, crtc: types::Crtc, config_timestamp: types::Timestamp) -> futures::SendRequest<'this, Self, types::randr::GetCrtcInfoReply> {
        let span = tracing::info_span!(
            "randr_get_crtc_info",
            crtc = ?crtc,
            config_timestamp = ?config_timestamp,
        );
        let request = types::randr::GetCrtcInfoRequest {
            crtc,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_info_immediate<'this>(&'this mut self, crtc: types::Crtc, config_timestamp: types::Timestamp) -> futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcInfoReply> {
        let request = types::randr::GetCrtcInfoRequest {
            crtc,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcInfoReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_config<'this>(&'this mut self, crtc: types::Crtc, timestamp: types::Timestamp, config_timestamp: types::Timestamp, x: types::Int16, y: types::Int16, mode: types::Mode, rotation: impl Into<types::Rotation>, outputs: impl AsRef<[types::Output]>) -> futures::SendRequest<'this, Self, types::randr::SetCrtcConfigReply> {
        let span = tracing::info_span!(
            "randr_set_crtc_config",
            crtc = ?crtc,
            timestamp = ?timestamp,
            config_timestamp = ?config_timestamp,
            x = ?x,
            y = ?y,
            mode = ?mode,
        );
        let request = types::randr::SetCrtcConfigRequest {
            crtc,
            timestamp,
            config_timestamp,
            x,
            y,
            mode,
            rotation: Into::<u32>::into(rotation.into()) as _,
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_config_immediate<'this>(&'this mut self, crtc: types::Crtc, timestamp: types::Timestamp, config_timestamp: types::Timestamp, x: types::Int16, y: types::Int16, mode: types::Mode, rotation: impl Into<types::Rotation>, outputs: impl AsRef<[types::Output]>) -> futures::CheckedSendRequest<'this, Self, types::randr::SetCrtcConfigReply> {
        let request = types::randr::SetCrtcConfigRequest {
            crtc,
            timestamp,
            config_timestamp,
            x,
            y,
            mode,
            rotation: Into::<u32>::into(rotation.into()) as _,
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::SetCrtcConfigReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_size<'this>(&'this mut self, crtc: types::Crtc) -> futures::SendRequest<'this, Self, types::randr::GetCrtcGammaSizeReply> {
        let span = tracing::info_span!(
            "randr_get_crtc_gamma_size",
            crtc = ?crtc,
        );
        let request = types::randr::GetCrtcGammaSizeRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_size_immediate<'this>(&'this mut self, crtc: types::Crtc) -> futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcGammaSizeReply> {
        let request = types::randr::GetCrtcGammaSizeRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcGammaSizeReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma<'this>(&'this mut self, crtc: types::Crtc) -> futures::SendRequest<'this, Self, types::randr::GetCrtcGammaReply> {
        let span = tracing::info_span!(
            "randr_get_crtc_gamma",
            crtc = ?crtc,
        );
        let request = types::randr::GetCrtcGammaRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_immediate<'this>(&'this mut self, crtc: types::Crtc) -> futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcGammaReply> {
        let request = types::randr::GetCrtcGammaRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcGammaReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_gamma<'this>(&'this mut self, crtc: types::Crtc, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_set_crtc_gamma",
            crtc = ?crtc,
        );
        let request = types::randr::SetCrtcGammaRequest {
            crtc,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_gamma_checked<'this>(&'this mut self, crtc: types::Crtc, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::SetCrtcGammaRequest {
            crtc,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_current<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::randr::GetScreenResourcesCurrentReply> {
        let span = tracing::info_span!(
            "randr_get_screen_resources_current",
            window = ?window,
        );
        let request = types::randr::GetScreenResourcesCurrentRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_current_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::randr::GetScreenResourcesCurrentReply> {
        let request = types::randr::GetScreenResourcesCurrentRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetScreenResourcesCurrentReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_transform<'this>(&'this mut self, crtc: types::Crtc, transform: types::render::Transform, filter_name: impl AsRef<[types::Char]>, filter_params: impl AsRef<[types::Fixed]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_set_crtc_transform",
            crtc = ?crtc,
            transform = ?transform,
        );
        let request = types::randr::SetCrtcTransformRequest {
            crtc,
            transform,
            filter_name: Cow::Borrowed(filter_name.as_ref()),
            filter_params: Cow::Borrowed(filter_params.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_transform_checked<'this>(&'this mut self, crtc: types::Crtc, transform: types::render::Transform, filter_name: impl AsRef<[types::Char]>, filter_params: impl AsRef<[types::Fixed]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::SetCrtcTransformRequest {
            crtc,
            transform,
            filter_name: Cow::Borrowed(filter_name.as_ref()),
            filter_params: Cow::Borrowed(filter_params.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_transform<'this>(&'this mut self, crtc: types::Crtc) -> futures::SendRequest<'this, Self, types::randr::GetCrtcTransformReply> {
        let span = tracing::info_span!(
            "randr_get_crtc_transform",
            crtc = ?crtc,
        );
        let request = types::randr::GetCrtcTransformRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_transform_immediate<'this>(&'this mut self, crtc: types::Crtc) -> futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcTransformReply> {
        let request = types::randr::GetCrtcTransformRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcTransformReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_panning<'this>(&'this mut self, crtc: types::Crtc) -> futures::SendRequest<'this, Self, types::randr::GetPanningReply> {
        let span = tracing::info_span!(
            "randr_get_panning",
            crtc = ?crtc,
        );
        let request = types::randr::GetPanningRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_panning_immediate<'this>(&'this mut self, crtc: types::Crtc) -> futures::CheckedSendRequest<'this, Self, types::randr::GetPanningReply> {
        let request = types::randr::GetPanningRequest {
            crtc,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetPanningReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_set_panning<'this>(&'this mut self, crtc: types::Crtc, timestamp: types::Timestamp, left: types::Card16, top: types::Card16, width: types::Card16, height: types::Card16, track_left: types::Card16, track_top: types::Card16, track_width: types::Card16, track_height: types::Card16, border_left: types::Int16, border_top: types::Int16, border_right: types::Int16, border_bottom: types::Int16) -> futures::SendRequest<'this, Self, types::randr::SetPanningReply> {
        let span = tracing::info_span!(
            "randr_set_panning",
            crtc = ?crtc,
            timestamp = ?timestamp,
            left = ?left,
            top = ?top,
            width = ?width,
            height = ?height,
            track_left = ?track_left,
            track_top = ?track_top,
            track_width = ?track_width,
            track_height = ?track_height,
            border_left = ?border_left,
            border_top = ?border_top,
            border_right = ?border_right,
            border_bottom = ?border_bottom,
        );
        let request = types::randr::SetPanningRequest {
            crtc,
            timestamp,
            left,
            top,
            width,
            height,
            track_left,
            track_top,
            track_width,
            track_height,
            border_left,
            border_top,
            border_right,
            border_bottom,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_panning_immediate<'this>(&'this mut self, crtc: types::Crtc, timestamp: types::Timestamp, left: types::Card16, top: types::Card16, width: types::Card16, height: types::Card16, track_left: types::Card16, track_top: types::Card16, track_width: types::Card16, track_height: types::Card16, border_left: types::Int16, border_top: types::Int16, border_right: types::Int16, border_bottom: types::Int16) -> futures::CheckedSendRequest<'this, Self, types::randr::SetPanningReply> {
        let request = types::randr::SetPanningRequest {
            crtc,
            timestamp,
            left,
            top,
            width,
            height,
            track_left,
            track_top,
            track_width,
            track_height,
            border_left,
            border_top,
            border_right,
            border_bottom,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::SetPanningReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_set_output_primary<'this>(&'this mut self, window: types::xproto::Window, output: types::Output) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_set_output_primary",
            window = ?window,
            output = ?output,
        );
        let request = types::randr::SetOutputPrimaryRequest {
            window,
            output,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_output_primary_checked<'this>(&'this mut self, window: types::xproto::Window, output: types::Output) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::SetOutputPrimaryRequest {
            window,
            output,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_primary<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::randr::GetOutputPrimaryReply> {
        let span = tracing::info_span!(
            "randr_get_output_primary",
            window = ?window,
        );
        let request = types::randr::GetOutputPrimaryRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_primary_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::randr::GetOutputPrimaryReply> {
        let request = types::randr::GetOutputPrimaryRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetOutputPrimaryReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_providers<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::randr::GetProvidersReply> {
        let span = tracing::info_span!(
            "randr_get_providers",
            window = ?window,
        );
        let request = types::randr::GetProvidersRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_providers_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::randr::GetProvidersReply> {
        let request = types::randr::GetProvidersRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetProvidersReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_info<'this>(&'this mut self, provider: types::Provider, config_timestamp: types::Timestamp) -> futures::SendRequest<'this, Self, types::randr::GetProviderInfoReply> {
        let span = tracing::info_span!(
            "randr_get_provider_info",
            provider = ?provider,
            config_timestamp = ?config_timestamp,
        );
        let request = types::randr::GetProviderInfoRequest {
            provider,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_info_immediate<'this>(&'this mut self, provider: types::Provider, config_timestamp: types::Timestamp) -> futures::CheckedSendRequest<'this, Self, types::randr::GetProviderInfoReply> {
        let request = types::randr::GetProviderInfoRequest {
            provider,
            config_timestamp,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetProviderInfoReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_offload_sink<'this>(&'this mut self, provider: types::Provider, sink_provider: types::Provider, config_timestamp: types::Timestamp) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_set_provider_offload_sink",
            provider = ?provider,
            sink_provider = ?sink_provider,
            config_timestamp = ?config_timestamp,
        );
        let request = types::randr::SetProviderOffloadSinkRequest {
            provider,
            sink_provider,
            config_timestamp,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_offload_sink_checked<'this>(&'this mut self, provider: types::Provider, sink_provider: types::Provider, config_timestamp: types::Timestamp) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::SetProviderOffloadSinkRequest {
            provider,
            sink_provider,
            config_timestamp,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_output_source<'this>(&'this mut self, provider: types::Provider, source_provider: types::Provider, config_timestamp: types::Timestamp) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_set_provider_output_source",
            provider = ?provider,
            source_provider = ?source_provider,
            config_timestamp = ?config_timestamp,
        );
        let request = types::randr::SetProviderOutputSourceRequest {
            provider,
            source_provider,
            config_timestamp,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_output_source_checked<'this>(&'this mut self, provider: types::Provider, source_provider: types::Provider, config_timestamp: types::Timestamp) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::SetProviderOutputSourceRequest {
            provider,
            source_provider,
            config_timestamp,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_list_provider_properties<'this>(&'this mut self, provider: types::Provider) -> futures::SendRequest<'this, Self, types::randr::ListProviderPropertiesReply> {
        let span = tracing::info_span!(
            "randr_list_provider_properties",
            provider = ?provider,
        );
        let request = types::randr::ListProviderPropertiesRequest {
            provider,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_list_provider_properties_immediate<'this>(&'this mut self, provider: types::Provider) -> futures::CheckedSendRequest<'this, Self, types::randr::ListProviderPropertiesReply> {
        let request = types::randr::ListProviderPropertiesRequest {
            provider,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::ListProviderPropertiesReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_query_provider_property<'this>(&'this mut self, provider: types::Provider, property: types::Atom) -> futures::SendRequest<'this, Self, types::randr::QueryProviderPropertyReply> {
        let span = tracing::info_span!(
            "randr_query_provider_property",
            provider = ?provider,
            property = ?property,
        );
        let request = types::randr::QueryProviderPropertyRequest {
            provider,
            property,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_query_provider_property_immediate<'this>(&'this mut self, provider: types::Provider, property: types::Atom) -> futures::CheckedSendRequest<'this, Self, types::randr::QueryProviderPropertyReply> {
        let request = types::randr::QueryProviderPropertyRequest {
            provider,
            property,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::QueryProviderPropertyReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_configure_provider_property<'this>(&'this mut self, provider: types::Provider, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_configure_provider_property",
            provider = ?provider,
            property = ?property,
            pending = ?pending,
            range = ?range,
        );
        let request = types::randr::ConfigureProviderPropertyRequest {
            provider,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_configure_provider_property_checked<'this>(&'this mut self, provider: types::Provider, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::ConfigureProviderPropertyRequest {
            provider,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_change_provider_property<'this>(&'this mut self, provider: types::Provider, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::Card8, num_items: types::Card32, data: &(impl crate::Void + ?Sized)) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_change_provider_property",
            provider = ?provider,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            mode = ?mode,
            num_items = ?num_items,
        );
        let request = types::randr::ChangeProviderPropertyRequest {
            provider,
            property,
            type_,
            format,
            mode,
            num_items,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_change_provider_property_checked<'this>(&'this mut self, provider: types::Provider, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::Card8, num_items: types::Card32, data: &(impl crate::Void + ?Sized)) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::ChangeProviderPropertyRequest {
            provider,
            property,
            type_,
            format,
            mode,
            num_items,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_delete_provider_property<'this>(&'this mut self, provider: types::Provider, property: types::Atom) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_delete_provider_property",
            provider = ?provider,
            property = ?property,
        );
        let request = types::randr::DeleteProviderPropertyRequest {
            provider,
            property,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_delete_provider_property_checked<'this>(&'this mut self, provider: types::Provider, property: types::Atom) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::DeleteProviderPropertyRequest {
            provider,
            property,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_property<'this>(&'this mut self, provider: types::Provider, property: types::Atom, type_: types::Atom, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> futures::SendRequest<'this, Self, types::randr::GetProviderPropertyReply> {
        let span = tracing::info_span!(
            "randr_get_provider_property",
            provider = ?provider,
            property = ?property,
            type_ = ?type_,
            long_offset = ?long_offset,
            long_length = ?long_length,
            delete = ?delete,
            pending = ?pending,
        );
        let request = types::randr::GetProviderPropertyRequest {
            provider,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_property_immediate<'this>(&'this mut self, provider: types::Provider, property: types::Atom, type_: types::Atom, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::randr::GetProviderPropertyReply> {
        let request = types::randr::GetProviderPropertyRequest {
            provider,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetProviderPropertyReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_get_monitors<'this>(&'this mut self, window: types::xproto::Window, get_active: types::Bool) -> futures::SendRequest<'this, Self, types::randr::GetMonitorsReply> {
        let span = tracing::info_span!(
            "randr_get_monitors",
            window = ?window,
            get_active = ?get_active,
        );
        let request = types::randr::GetMonitorsRequest {
            window,
            get_active,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_get_monitors_immediate<'this>(&'this mut self, window: types::xproto::Window, get_active: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::randr::GetMonitorsReply> {
        let request = types::randr::GetMonitorsRequest {
            window,
            get_active,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetMonitorsReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_set_monitor<'this>(&'this mut self, window: types::xproto::Window, monitorinfo: types::MonitorInfo) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_set_monitor",
            window = ?window,
            monitorinfo = ?monitorinfo,
        );
        let request = types::randr::SetMonitorRequest {
            window,
            monitorinfo,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_set_monitor_checked<'this>(&'this mut self, window: types::xproto::Window, monitorinfo: types::MonitorInfo) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::SetMonitorRequest {
            window,
            monitorinfo,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_delete_monitor<'this>(&'this mut self, window: types::xproto::Window, name: types::Atom) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_delete_monitor",
            window = ?window,
            name = ?name,
        );
        let request = types::randr::DeleteMonitorRequest {
            window,
            name,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_delete_monitor_checked<'this>(&'this mut self, window: types::xproto::Window, name: types::Atom) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::DeleteMonitorRequest {
            window,
            name,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_create_lease<'this>(&'this mut self, window: types::xproto::Window, lid: types::Lease, crtcs: impl AsRef<[types::Crtc]>, outputs: impl AsRef<[types::Output]>) -> futures::SendRequest<'this, Self, types::randr::CreateLeaseReply> {
        let span = tracing::info_span!(
            "randr_create_lease",
            window = ?window,
            lid = ?lid,
        );
        let request = types::randr::CreateLeaseRequest {
            window,
            lid,
            crtcs: Cow::Borrowed(crtcs.as_ref()),
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        let cookie = self.send_reply_fd_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_create_lease_immediate<'this>(&'this mut self, window: types::xproto::Window, lid: types::Lease, crtcs: impl AsRef<[types::Crtc]>, outputs: impl AsRef<[types::Output]>) -> futures::CheckedSendRequest<'this, Self, types::randr::CreateLeaseReply> {
        let request = types::randr::CreateLeaseRequest {
            window,
            lid,
            crtcs: Cow::Borrowed(crtcs.as_ref()),
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        let cookie = self.send_reply_fd_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::randr::CreateLeaseReply> = cookie.into();
        res
    }
    #[cfg(feature = "randr")]
    fn randr_free_lease<'this>(&'this mut self, lid: types::Lease, terminate: types::Byte) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "randr_free_lease",
            lid = ?lid,
            terminate = ?terminate,
        );
        let request = types::randr::FreeLeaseRequest {
            lid,
            terminate,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "randr")]
    fn randr_free_lease_checked<'this>(&'this mut self, lid: types::Lease, terminate: types::Byte) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::randr::FreeLeaseRequest {
            lid,
            terminate,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    #[cfg(feature = "record")]
    fn record_query_version<'this>(&'this mut self, major_version: types::Card16, minor_version: types::Card16) -> futures::SendRequest<'this, Self, types::record::QueryVersionReply> {
        let span = tracing::info_span!(
            "record_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::record::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_query_version_immediate<'this>(&'this mut self, major_version: types::Card16, minor_version: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::record::QueryVersionReply> {
        let request = types::record::QueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::record::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "record")]
    fn record_create_context<'this>(&'this mut self, context: types::record::Context, element_header: types::ElementHeader, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "record_create_context",
            context = ?context,
            element_header = ?element_header,
        );
        let request = types::record::CreateContextRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_create_context_checked<'this>(&'this mut self, context: types::record::Context, element_header: types::ElementHeader, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::record::CreateContextRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "record")]
    fn record_register_clients<'this>(&'this mut self, context: types::record::Context, element_header: types::ElementHeader, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "record_register_clients",
            context = ?context,
            element_header = ?element_header,
        );
        let request = types::record::RegisterClientsRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_register_clients_checked<'this>(&'this mut self, context: types::record::Context, element_header: types::ElementHeader, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::record::RegisterClientsRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "record")]
    fn record_unregister_clients<'this>(&'this mut self, context: types::record::Context, client_specs: impl AsRef<[types::ClientSpec]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "record_unregister_clients",
            context = ?context,
        );
        let request = types::record::UnregisterClientsRequest {
            context,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_unregister_clients_checked<'this>(&'this mut self, context: types::record::Context, client_specs: impl AsRef<[types::ClientSpec]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::record::UnregisterClientsRequest {
            context,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "record")]
    fn record_get_context<'this>(&'this mut self, context: types::record::Context) -> futures::SendRequest<'this, Self, types::record::GetContextReply> {
        let span = tracing::info_span!(
            "record_get_context",
            context = ?context,
        );
        let request = types::record::GetContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_get_context_immediate<'this>(&'this mut self, context: types::record::Context) -> futures::CheckedSendRequest<'this, Self, types::record::GetContextReply> {
        let request = types::record::GetContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::record::GetContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "record")]
    fn record_enable_context<'this>(&'this mut self, context: types::record::Context) -> futures::SendRequest<'this, Self, types::record::EnableContextReply> {
        let span = tracing::info_span!(
            "record_enable_context",
            context = ?context,
        );
        let request = types::record::EnableContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_enable_context_immediate<'this>(&'this mut self, context: types::record::Context) -> futures::CheckedSendRequest<'this, Self, types::record::EnableContextReply> {
        let request = types::record::EnableContextRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::record::EnableContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "record")]
    fn record_disable_context<'this>(&'this mut self, context: types::record::Context) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "record_disable_context",
            context = ?context,
        );
        let request = types::record::DisableContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_disable_context_checked<'this>(&'this mut self, context: types::record::Context) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::record::DisableContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "record")]
    fn record_free_context<'this>(&'this mut self, context: types::record::Context) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "record_free_context",
            context = ?context,
        );
        let request = types::record::FreeContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "record")]
    fn record_free_context_checked<'this>(&'this mut self, context: types::record::Context) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::record::FreeContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    #[cfg(feature = "render")]
    fn render_query_version<'this>(&'this mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> futures::SendRequest<'this, Self, types::render::QueryVersionReply> {
        let span = tracing::info_span!(
            "render_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::render::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_query_version_immediate<'this>(&'this mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::render::QueryVersionReply> {
        let request = types::render::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::render::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_query_pict_formats<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::render::QueryPictFormatsReply> {
        let span = tracing::info_span!(
            "render_query_pict_formats",
        );
        let request = types::render::QueryPictFormatsRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_query_pict_formats_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::render::QueryPictFormatsReply> {
        let request = types::render::QueryPictFormatsRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::render::QueryPictFormatsReply> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_query_pict_index_values<'this>(&'this mut self, format: types::Pictformat) -> futures::SendRequest<'this, Self, types::render::QueryPictIndexValuesReply> {
        let span = tracing::info_span!(
            "render_query_pict_index_values",
            format = ?format,
        );
        let request = types::render::QueryPictIndexValuesRequest {
            format,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_query_pict_index_values_immediate<'this>(&'this mut self, format: types::Pictformat) -> futures::CheckedSendRequest<'this, Self, types::render::QueryPictIndexValuesReply> {
        let request = types::render::QueryPictIndexValuesRequest {
            format,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::render::QueryPictIndexValuesReply> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_create_picture<'this>(&'this mut self, pid: types::Picture, drawable: types::xproto::Drawable, format: types::Pictformat, value_list: impl Borrow<types::render::CreatePictureAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_create_picture",
            pid = ?pid,
            drawable = ?drawable,
            format = ?format,
        );
        let request = types::render::CreatePictureRequest {
            pid,
            drawable,
            format,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_picture_checked<'this>(&'this mut self, pid: types::Picture, drawable: types::xproto::Drawable, format: types::Pictformat, value_list: impl Borrow<types::render::CreatePictureAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CreatePictureRequest {
            pid,
            drawable,
            format,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_change_picture<'this>(&'this mut self, picture: types::Picture, value_list: impl Borrow<types::render::ChangePictureAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_change_picture",
            picture = ?picture,
        );
        let request = types::render::ChangePictureRequest {
            picture,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_change_picture_checked<'this>(&'this mut self, picture: types::Picture, value_list: impl Borrow<types::render::ChangePictureAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::ChangePictureRequest {
            picture,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_set_picture_clip_rectangles<'this>(&'this mut self, picture: types::Picture, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_set_picture_clip_rectangles",
            picture = ?picture,
            clip_x_origin = ?clip_x_origin,
            clip_y_origin = ?clip_y_origin,
        );
        let request = types::render::SetPictureClipRectanglesRequest {
            picture,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_set_picture_clip_rectangles_checked<'this>(&'this mut self, picture: types::Picture, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::SetPictureClipRectanglesRequest {
            picture,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_free_picture<'this>(&'this mut self, picture: types::Picture) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_free_picture",
            picture = ?picture,
        );
        let request = types::render::FreePictureRequest {
            picture,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_free_picture_checked<'this>(&'this mut self, picture: types::Picture) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::FreePictureRequest {
            picture,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_composite<'this>(&'this mut self, op: types::PictOp, src: types::Picture, mask: impl Into<types::Picture>, dst: types::Picture, src_x: types::Int16, src_y: types::Int16, mask_x: types::Int16, mask_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_composite",
            op = ?op,
            src = ?src,
            dst = ?dst,
            src_x = ?src_x,
            src_y = ?src_y,
            mask_x = ?mask_x,
            mask_y = ?mask_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
        );
        let request = types::render::CompositeRequest {
            op,
            src,
            mask: Into::<u32>::into(mask.into()) as _,
            dst,
            src_x,
            src_y,
            mask_x,
            mask_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_composite_checked<'this>(&'this mut self, op: types::PictOp, src: types::Picture, mask: impl Into<types::Picture>, dst: types::Picture, src_x: types::Int16, src_y: types::Int16, mask_x: types::Int16, mask_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CompositeRequest {
            op,
            src,
            mask: Into::<u32>::into(mask.into()) as _,
            dst,
            src_x,
            src_y,
            mask_x,
            mask_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_trapezoids<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, traps: impl AsRef<[types::Trapezoid]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_trapezoids",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::TrapezoidsRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_trapezoids_checked<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, traps: impl AsRef<[types::Trapezoid]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::TrapezoidsRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_triangles<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, triangles: impl AsRef<[types::Triangle]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_triangles",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::TrianglesRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            triangles: Cow::Borrowed(triangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_triangles_checked<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, triangles: impl AsRef<[types::Triangle]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::TrianglesRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            triangles: Cow::Borrowed(triangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_tri_strip<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_tri_strip",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::TriStripRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_tri_strip_checked<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::TriStripRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_tri_fan<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_tri_fan",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::TriFanRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_tri_fan_checked<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::TriFanRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_create_glyph_set<'this>(&'this mut self, gsid: types::Glyphset, format: types::Pictformat) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_create_glyph_set",
            gsid = ?gsid,
            format = ?format,
        );
        let request = types::render::CreateGlyphSetRequest {
            gsid,
            format,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_glyph_set_checked<'this>(&'this mut self, gsid: types::Glyphset, format: types::Pictformat) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CreateGlyphSetRequest {
            gsid,
            format,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_reference_glyph_set<'this>(&'this mut self, gsid: types::Glyphset, existing: types::Glyphset) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_reference_glyph_set",
            gsid = ?gsid,
            existing = ?existing,
        );
        let request = types::render::ReferenceGlyphSetRequest {
            gsid,
            existing,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_reference_glyph_set_checked<'this>(&'this mut self, gsid: types::Glyphset, existing: types::Glyphset) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::ReferenceGlyphSetRequest {
            gsid,
            existing,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_free_glyph_set<'this>(&'this mut self, glyphset: types::Glyphset) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_free_glyph_set",
            glyphset = ?glyphset,
        );
        let request = types::render::FreeGlyphSetRequest {
            glyphset,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_free_glyph_set_checked<'this>(&'this mut self, glyphset: types::Glyphset) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::FreeGlyphSetRequest {
            glyphset,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_add_glyphs<'this>(&'this mut self, glyphset: types::Glyphset, glyphids: impl AsRef<[types::Card32]>, glyphs: impl AsRef<[types::Glyphinfo]>, data: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_add_glyphs",
            glyphset = ?glyphset,
        );
        let request = types::render::AddGlyphsRequest {
            glyphset,
            glyphids: Cow::Borrowed(glyphids.as_ref()),
            glyphs: Cow::Borrowed(glyphs.as_ref()),
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_add_glyphs_checked<'this>(&'this mut self, glyphset: types::Glyphset, glyphids: impl AsRef<[types::Card32]>, glyphs: impl AsRef<[types::Glyphinfo]>, data: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::AddGlyphsRequest {
            glyphset,
            glyphids: Cow::Borrowed(glyphids.as_ref()),
            glyphs: Cow::Borrowed(glyphs.as_ref()),
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_free_glyphs<'this>(&'this mut self, glyphset: types::Glyphset, glyphs: impl AsRef<[types::Glyph]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_free_glyphs",
            glyphset = ?glyphset,
        );
        let request = types::render::FreeGlyphsRequest {
            glyphset,
            glyphs: Cow::Borrowed(glyphs.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_free_glyphs_checked<'this>(&'this mut self, glyphset: types::Glyphset, glyphs: impl AsRef<[types::Glyph]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::FreeGlyphsRequest {
            glyphset,
            glyphs: Cow::Borrowed(glyphs.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs8<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_composite_glyphs8",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::CompositeGlyphs8Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs8_checked<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CompositeGlyphs8Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs16<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_composite_glyphs16",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::CompositeGlyphs16Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs16_checked<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CompositeGlyphs16Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs32<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_composite_glyphs32",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::CompositeGlyphs32Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs32_checked<'this>(&'this mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CompositeGlyphs32Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_fill_rectangles<'this>(&'this mut self, op: types::PictOp, dst: types::Picture, color: types::Color, rects: impl AsRef<[types::Rectangle]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_fill_rectangles",
            op = ?op,
            dst = ?dst,
            color = ?color,
        );
        let request = types::render::FillRectanglesRequest {
            op,
            dst,
            color,
            rects: Cow::Borrowed(rects.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_fill_rectangles_checked<'this>(&'this mut self, op: types::PictOp, dst: types::Picture, color: types::Color, rects: impl AsRef<[types::Rectangle]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::FillRectanglesRequest {
            op,
            dst,
            color,
            rects: Cow::Borrowed(rects.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_create_cursor<'this>(&'this mut self, cid: types::xproto::Cursor, source: types::Picture, x: types::Card16, y: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_create_cursor",
            cid = ?cid,
            source = ?source,
            x = ?x,
            y = ?y,
        );
        let request = types::render::CreateCursorRequest {
            cid,
            source,
            x,
            y,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_cursor_checked<'this>(&'this mut self, cid: types::xproto::Cursor, source: types::Picture, x: types::Card16, y: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CreateCursorRequest {
            cid,
            source,
            x,
            y,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_set_picture_transform<'this>(&'this mut self, picture: types::Picture, transform: types::render::Transform) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_set_picture_transform",
            picture = ?picture,
            transform = ?transform,
        );
        let request = types::render::SetPictureTransformRequest {
            picture,
            transform,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_set_picture_transform_checked<'this>(&'this mut self, picture: types::Picture, transform: types::render::Transform) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::SetPictureTransformRequest {
            picture,
            transform,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_query_filters<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::SendRequest<'this, Self, types::render::QueryFiltersReply> {
        let span = tracing::info_span!(
            "render_query_filters",
            drawable = ?drawable,
        );
        let request = types::render::QueryFiltersRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_query_filters_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::CheckedSendRequest<'this, Self, types::render::QueryFiltersReply> {
        let request = types::render::QueryFiltersRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::render::QueryFiltersReply> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_set_picture_filter<'this>(&'this mut self, picture: types::Picture, filter: impl AsRef<[types::Char]>, values: impl AsRef<[types::Fixed]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_set_picture_filter",
            picture = ?picture,
        );
        let request = types::render::SetPictureFilterRequest {
            picture,
            filter: Cow::Borrowed(filter.as_ref()),
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_set_picture_filter_checked<'this>(&'this mut self, picture: types::Picture, filter: impl AsRef<[types::Char]>, values: impl AsRef<[types::Fixed]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::SetPictureFilterRequest {
            picture,
            filter: Cow::Borrowed(filter.as_ref()),
            values: Cow::Borrowed(values.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_create_anim_cursor<'this>(&'this mut self, cid: types::xproto::Cursor, cursors: impl AsRef<[types::Animcursorelt]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_create_anim_cursor",
            cid = ?cid,
        );
        let request = types::render::CreateAnimCursorRequest {
            cid,
            cursors: Cow::Borrowed(cursors.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_anim_cursor_checked<'this>(&'this mut self, cid: types::xproto::Cursor, cursors: impl AsRef<[types::Animcursorelt]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CreateAnimCursorRequest {
            cid,
            cursors: Cow::Borrowed(cursors.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_add_traps<'this>(&'this mut self, picture: types::Picture, x_off: types::Int16, y_off: types::Int16, traps: impl AsRef<[types::Trap]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_add_traps",
            picture = ?picture,
            x_off = ?x_off,
            y_off = ?y_off,
        );
        let request = types::render::AddTrapsRequest {
            picture,
            x_off,
            y_off,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_add_traps_checked<'this>(&'this mut self, picture: types::Picture, x_off: types::Int16, y_off: types::Int16, traps: impl AsRef<[types::Trap]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::AddTrapsRequest {
            picture,
            x_off,
            y_off,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_create_solid_fill<'this>(&'this mut self, picture: types::Picture, color: types::Color) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_create_solid_fill",
            picture = ?picture,
            color = ?color,
        );
        let request = types::render::CreateSolidFillRequest {
            picture,
            color,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_solid_fill_checked<'this>(&'this mut self, picture: types::Picture, color: types::Color) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CreateSolidFillRequest {
            picture,
            color,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_create_linear_gradient<'this>(&'this mut self, picture: types::Picture, p1: types::Pointfix, p2: types::Pointfix, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_create_linear_gradient",
            picture = ?picture,
            p1 = ?p1,
            p2 = ?p2,
        );
        let request = types::render::CreateLinearGradientRequest {
            picture,
            p1,
            p2,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_linear_gradient_checked<'this>(&'this mut self, picture: types::Picture, p1: types::Pointfix, p2: types::Pointfix, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CreateLinearGradientRequest {
            picture,
            p1,
            p2,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_create_radial_gradient<'this>(&'this mut self, picture: types::Picture, inner: types::Pointfix, outer: types::Pointfix, inner_radius: types::Fixed, outer_radius: types::Fixed, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_create_radial_gradient",
            picture = ?picture,
            inner = ?inner,
            outer = ?outer,
            inner_radius = ?inner_radius,
            outer_radius = ?outer_radius,
        );
        let request = types::render::CreateRadialGradientRequest {
            picture,
            inner,
            outer,
            inner_radius,
            outer_radius,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_radial_gradient_checked<'this>(&'this mut self, picture: types::Picture, inner: types::Pointfix, outer: types::Pointfix, inner_radius: types::Fixed, outer_radius: types::Fixed, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CreateRadialGradientRequest {
            picture,
            inner,
            outer,
            inner_radius,
            outer_radius,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "render")]
    fn render_create_conical_gradient<'this>(&'this mut self, picture: types::Picture, center: types::Pointfix, angle: types::Fixed, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "render_create_conical_gradient",
            picture = ?picture,
            center = ?center,
            angle = ?angle,
        );
        let request = types::render::CreateConicalGradientRequest {
            picture,
            center,
            angle,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "render")]
    fn render_create_conical_gradient_checked<'this>(&'this mut self, picture: types::Picture, center: types::Pointfix, angle: types::Fixed, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::render::CreateConicalGradientRequest {
            picture,
            center,
            angle,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    #[cfg(feature = "res")]
    fn res_query_version<'this>(&'this mut self, client_major: types::Card8, client_minor: types::Card8) -> futures::SendRequest<'this, Self, types::res::QueryVersionReply> {
        let span = tracing::info_span!(
            "res_query_version",
            client_major = ?client_major,
            client_minor = ?client_minor,
        );
        let request = types::res::QueryVersionRequest {
            client_major,
            client_minor,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_version_immediate<'this>(&'this mut self, client_major: types::Card8, client_minor: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::res::QueryVersionReply> {
        let request = types::res::QueryVersionRequest {
            client_major,
            client_minor,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "res")]
    fn res_query_clients<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::res::QueryClientsReply> {
        let span = tracing::info_span!(
            "res_query_clients",
        );
        let request = types::res::QueryClientsRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_clients_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::res::QueryClientsReply> {
        let request = types::res::QueryClientsRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryClientsReply> = cookie.into();
        res
    }
    #[cfg(feature = "res")]
    fn res_query_client_resources<'this>(&'this mut self, xid: types::Card32) -> futures::SendRequest<'this, Self, types::res::QueryClientResourcesReply> {
        let span = tracing::info_span!(
            "res_query_client_resources",
            xid = ?xid,
        );
        let request = types::res::QueryClientResourcesRequest {
            xid,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_client_resources_immediate<'this>(&'this mut self, xid: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::res::QueryClientResourcesReply> {
        let request = types::res::QueryClientResourcesRequest {
            xid,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryClientResourcesReply> = cookie.into();
        res
    }
    #[cfg(feature = "res")]
    fn res_query_client_pixmap_bytes<'this>(&'this mut self, xid: types::Card32) -> futures::SendRequest<'this, Self, types::res::QueryClientPixmapBytesReply> {
        let span = tracing::info_span!(
            "res_query_client_pixmap_bytes",
            xid = ?xid,
        );
        let request = types::res::QueryClientPixmapBytesRequest {
            xid,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_client_pixmap_bytes_immediate<'this>(&'this mut self, xid: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::res::QueryClientPixmapBytesReply> {
        let request = types::res::QueryClientPixmapBytesRequest {
            xid,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryClientPixmapBytesReply> = cookie.into();
        res
    }
    #[cfg(feature = "res")]
    fn res_query_client_ids<'this>(&'this mut self, specs: impl AsRef<[types::ClientIdSpec]>) -> futures::SendRequest<'this, Self, types::res::QueryClientIdsReply> {
        let span = tracing::info_span!(
            "res_query_client_ids",
        );
        let request = types::res::QueryClientIdsRequest {
            specs: Cow::Borrowed(specs.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_client_ids_immediate<'this>(&'this mut self, specs: impl AsRef<[types::ClientIdSpec]>) -> futures::CheckedSendRequest<'this, Self, types::res::QueryClientIdsReply> {
        let request = types::res::QueryClientIdsRequest {
            specs: Cow::Borrowed(specs.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryClientIdsReply> = cookie.into();
        res
    }
    #[cfg(feature = "res")]
    fn res_query_resource_bytes<'this>(&'this mut self, client: types::Card32, specs: impl AsRef<[types::ResourceIdSpec]>) -> futures::SendRequest<'this, Self, types::res::QueryResourceBytesReply> {
        let span = tracing::info_span!(
            "res_query_resource_bytes",
            client = ?client,
        );
        let request = types::res::QueryResourceBytesRequest {
            client,
            specs: Cow::Borrowed(specs.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "res")]
    fn res_query_resource_bytes_immediate<'this>(&'this mut self, client: types::Card32, specs: impl AsRef<[types::ResourceIdSpec]>) -> futures::CheckedSendRequest<'this, Self, types::res::QueryResourceBytesReply> {
        let request = types::res::QueryResourceBytesRequest {
            client,
            specs: Cow::Borrowed(specs.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryResourceBytesReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "screensaver")]
    fn screensaver_query_version<'this>(&'this mut self, client_major_version: types::Card8, client_minor_version: types::Card8) -> futures::SendRequest<'this, Self, types::screensaver::QueryVersionReply> {
        let span = tracing::info_span!(
            "screensaver_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::screensaver::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_version_immediate<'this>(&'this mut self, client_major_version: types::Card8, client_minor_version: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::screensaver::QueryVersionReply> {
        let request = types::screensaver::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::screensaver::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_info<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::SendRequest<'this, Self, types::screensaver::QueryInfoReply> {
        let span = tracing::info_span!(
            "screensaver_query_info",
            drawable = ?drawable,
        );
        let request = types::screensaver::QueryInfoRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_info_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::CheckedSendRequest<'this, Self, types::screensaver::QueryInfoReply> {
        let request = types::screensaver::QueryInfoRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::screensaver::QueryInfoReply> = cookie.into();
        res
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_select_input<'this>(&'this mut self, drawable: types::xproto::Drawable, event_mask: impl Into<types::screensaver::Event>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "screensaver_select_input",
            drawable = ?drawable,
        );
        let request = types::screensaver::SelectInputRequest {
            drawable,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_select_input_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, event_mask: impl Into<types::screensaver::Event>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::screensaver::SelectInputRequest {
            drawable,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_set_attributes<'this>(&'this mut self, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, depth: types::Card8, visual: types::Visualid, value_list: impl Borrow<types::screensaver::SetAttributesAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "screensaver_set_attributes",
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            border_width = ?border_width,
            class = ?class,
            depth = ?depth,
            visual = ?visual,
        );
        let request = types::screensaver::SetAttributesRequest {
            drawable,
            x,
            y,
            width,
            height,
            border_width,
            class,
            depth,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_set_attributes_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, depth: types::Card8, visual: types::Visualid, value_list: impl Borrow<types::screensaver::SetAttributesAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::screensaver::SetAttributesRequest {
            drawable,
            x,
            y,
            width,
            height,
            border_width,
            class,
            depth,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_unset_attributes<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "screensaver_unset_attributes",
            drawable = ?drawable,
        );
        let request = types::screensaver::UnsetAttributesRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_unset_attributes_checked<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::screensaver::UnsetAttributesRequest {
            drawable,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_suspend<'this>(&'this mut self, suspend: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "screensaver_suspend",
            suspend = ?suspend,
        );
        let request = types::screensaver::SuspendRequest {
            suspend,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_suspend_checked<'this>(&'this mut self, suspend: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::screensaver::SuspendRequest {
            suspend,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    #[cfg(feature = "shape")]
    fn shape_query_version<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::shape::QueryVersionReply> {
        let span = tracing::info_span!(
            "shape_query_version",
        );
        let request = types::shape::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_query_version_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::shape::QueryVersionReply> {
        let request = types::shape::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::shape::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "shape")]
    fn shape_rectangles<'this>(&'this mut self, operation: types::SO, destination_kind: types::SK, ordering: types::ClipOrdering, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "shape_rectangles",
            operation = ?operation,
            destination_kind = ?destination_kind,
            ordering = ?ordering,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let request = types::shape::RectanglesRequest {
            operation,
            destination_kind,
            ordering,
            destination_window,
            x_offset,
            y_offset,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_rectangles_checked<'this>(&'this mut self, operation: types::SO, destination_kind: types::SK, ordering: types::ClipOrdering, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::shape::RectanglesRequest {
            operation,
            destination_kind,
            ordering,
            destination_window,
            x_offset,
            y_offset,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "shape")]
    fn shape_mask<'this>(&'this mut self, operation: types::SO, destination_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, source_bitmap: impl Into<types::xproto::Pixmap>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "shape_mask",
            operation = ?operation,
            destination_kind = ?destination_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let request = types::shape::MaskRequest {
            operation,
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
            source_bitmap: Into::<u32>::into(source_bitmap.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_mask_checked<'this>(&'this mut self, operation: types::SO, destination_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, source_bitmap: impl Into<types::xproto::Pixmap>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::shape::MaskRequest {
            operation,
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
            source_bitmap: Into::<u32>::into(source_bitmap.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "shape")]
    fn shape_combine<'this>(&'this mut self, operation: types::SO, destination_kind: types::SK, source_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, source_window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "shape_combine",
            operation = ?operation,
            destination_kind = ?destination_kind,
            source_kind = ?source_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
            source_window = ?source_window,
        );
        let request = types::shape::CombineRequest {
            operation,
            destination_kind,
            source_kind,
            destination_window,
            x_offset,
            y_offset,
            source_window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_combine_checked<'this>(&'this mut self, operation: types::SO, destination_kind: types::SK, source_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, source_window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::shape::CombineRequest {
            operation,
            destination_kind,
            source_kind,
            destination_window,
            x_offset,
            y_offset,
            source_window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "shape")]
    fn shape_offset<'this>(&'this mut self, destination_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "shape_offset",
            destination_kind = ?destination_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let request = types::shape::OffsetRequest {
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_offset_checked<'this>(&'this mut self, destination_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::shape::OffsetRequest {
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "shape")]
    fn shape_query_extents<'this>(&'this mut self, destination_window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::shape::QueryExtentsReply> {
        let span = tracing::info_span!(
            "shape_query_extents",
            destination_window = ?destination_window,
        );
        let request = types::shape::QueryExtentsRequest {
            destination_window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_query_extents_immediate<'this>(&'this mut self, destination_window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::shape::QueryExtentsReply> {
        let request = types::shape::QueryExtentsRequest {
            destination_window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::shape::QueryExtentsReply> = cookie.into();
        res
    }
    #[cfg(feature = "shape")]
    fn shape_select_input<'this>(&'this mut self, destination_window: types::xproto::Window, enable: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "shape_select_input",
            destination_window = ?destination_window,
            enable = ?enable,
        );
        let request = types::shape::SelectInputRequest {
            destination_window,
            enable,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_select_input_checked<'this>(&'this mut self, destination_window: types::xproto::Window, enable: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::shape::SelectInputRequest {
            destination_window,
            enable,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "shape")]
    fn shape_input_selected<'this>(&'this mut self, destination_window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::shape::InputSelectedReply> {
        let span = tracing::info_span!(
            "shape_input_selected",
            destination_window = ?destination_window,
        );
        let request = types::shape::InputSelectedRequest {
            destination_window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_input_selected_immediate<'this>(&'this mut self, destination_window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::shape::InputSelectedReply> {
        let request = types::shape::InputSelectedRequest {
            destination_window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::shape::InputSelectedReply> = cookie.into();
        res
    }
    #[cfg(feature = "shape")]
    fn shape_get_rectangles<'this>(&'this mut self, window: types::xproto::Window, source_kind: types::SK) -> futures::SendRequest<'this, Self, types::shape::GetRectanglesReply> {
        let span = tracing::info_span!(
            "shape_get_rectangles",
            window = ?window,
            source_kind = ?source_kind,
        );
        let request = types::shape::GetRectanglesRequest {
            window,
            source_kind,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "shape")]
    fn shape_get_rectangles_immediate<'this>(&'this mut self, window: types::xproto::Window, source_kind: types::SK) -> futures::CheckedSendRequest<'this, Self, types::shape::GetRectanglesReply> {
        let request = types::shape::GetRectanglesRequest {
            window,
            source_kind,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::shape::GetRectanglesReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "shm")]
    fn shm_query_version<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::shm::QueryVersionReply> {
        let span = tracing::info_span!(
            "shm_query_version",
        );
        let request = types::shm::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_query_version_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::shm::QueryVersionReply> {
        let request = types::shm::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::shm::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "shm")]
    fn shm_attach<'this>(&'this mut self, shmseg: types::Seg, shmid: types::Card32, read_only: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "shm_attach",
            shmseg = ?shmseg,
            shmid = ?shmid,
            read_only = ?read_only,
        );
        let request = types::shm::AttachRequest {
            shmseg,
            shmid,
            read_only,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_attach_checked<'this>(&'this mut self, shmseg: types::Seg, shmid: types::Card32, read_only: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::shm::AttachRequest {
            shmseg,
            shmid,
            read_only,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "shm")]
    fn shm_detach<'this>(&'this mut self, shmseg: types::Seg) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "shm_detach",
            shmseg = ?shmseg,
        );
        let request = types::shm::DetachRequest {
            shmseg,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_detach_checked<'this>(&'this mut self, shmseg: types::Seg) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::shm::DetachRequest {
            shmseg,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "shm")]
    fn shm_put_image<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, total_width: types::Card16, total_height: types::Card16, src_x: types::Card16, src_y: types::Card16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, depth: types::Card8, format: types::Card8, send_event: types::Bool, shmseg: types::Seg, offset: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "shm_put_image",
            drawable = ?drawable,
            gc = ?gc,
            total_width = ?total_width,
            total_height = ?total_height,
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            depth = ?depth,
            format = ?format,
            send_event = ?send_event,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let request = types::shm::PutImageRequest {
            drawable,
            gc,
            total_width,
            total_height,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            depth,
            format,
            send_event,
            shmseg,
            offset,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_put_image_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, total_width: types::Card16, total_height: types::Card16, src_x: types::Card16, src_y: types::Card16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, depth: types::Card8, format: types::Card8, send_event: types::Bool, shmseg: types::Seg, offset: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::shm::PutImageRequest {
            drawable,
            gc,
            total_width,
            total_height,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            depth,
            format,
            send_event,
            shmseg,
            offset,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "shm")]
    fn shm_get_image<'this>(&'this mut self, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32, format: types::Card8, shmseg: types::Seg, offset: types::Card32) -> futures::SendRequest<'this, Self, types::shm::GetImageReply> {
        let span = tracing::info_span!(
            "shm_get_image",
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            plane_mask = ?plane_mask,
            format = ?format,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let request = types::shm::GetImageRequest {
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
            format,
            shmseg,
            offset,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_get_image_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32, format: types::Card8, shmseg: types::Seg, offset: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::shm::GetImageReply> {
        let request = types::shm::GetImageRequest {
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
            format,
            shmseg,
            offset,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::shm::GetImageReply> = cookie.into();
        res
    }
    #[cfg(feature = "shm")]
    fn shm_create_pixmap<'this>(&'this mut self, pid: types::xproto::Pixmap, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16, depth: types::Card8, shmseg: types::Seg, offset: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "shm_create_pixmap",
            pid = ?pid,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
            depth = ?depth,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let request = types::shm::CreatePixmapRequest {
            pid,
            drawable,
            width,
            height,
            depth,
            shmseg,
            offset,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_create_pixmap_checked<'this>(&'this mut self, pid: types::xproto::Pixmap, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16, depth: types::Card8, shmseg: types::Seg, offset: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::shm::CreatePixmapRequest {
            pid,
            drawable,
            width,
            height,
            depth,
            shmseg,
            offset,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "shm")]
    fn shm_attach_fd<'this>(&'this mut self, shmseg: types::Seg, shm_fd: types::Fd, read_only: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "shm_attach_fd",
            shmseg = ?shmseg,
            shm_fd = ?shm_fd,
            read_only = ?read_only,
        );
        let request = types::shm::AttachFdRequest {
            shmseg,
            shm_fd,
            read_only,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_attach_fd_checked<'this>(&'this mut self, shmseg: types::Seg, shm_fd: types::Fd, read_only: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::shm::AttachFdRequest {
            shmseg,
            shm_fd,
            read_only,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "shm")]
    fn shm_create_segment<'this>(&'this mut self, shmseg: types::Seg, size: types::Card32, read_only: types::Bool) -> futures::SendRequest<'this, Self, types::shm::CreateSegmentReply> {
        let span = tracing::info_span!(
            "shm_create_segment",
            shmseg = ?shmseg,
            size = ?size,
            read_only = ?read_only,
        );
        let request = types::shm::CreateSegmentRequest {
            shmseg,
            size,
            read_only,
        };
        let cookie = self.send_reply_fd_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "shm")]
    fn shm_create_segment_immediate<'this>(&'this mut self, shmseg: types::Seg, size: types::Card32, read_only: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::shm::CreateSegmentReply> {
        let request = types::shm::CreateSegmentRequest {
            shmseg,
            size,
            read_only,
        };
        let cookie = self.send_reply_fd_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::shm::CreateSegmentReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "sync")]
    fn sync_initialize<'this>(&'this mut self, desired_major_version: types::Card8, desired_minor_version: types::Card8) -> futures::SendRequest<'this, Self, types::sync::InitializeReply> {
        let span = tracing::info_span!(
            "sync_initialize",
            desired_major_version = ?desired_major_version,
            desired_minor_version = ?desired_minor_version,
        );
        let request = types::sync::InitializeRequest {
            desired_major_version,
            desired_minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_initialize_immediate<'this>(&'this mut self, desired_major_version: types::Card8, desired_minor_version: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::sync::InitializeReply> {
        let request = types::sync::InitializeRequest {
            desired_major_version,
            desired_minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::sync::InitializeReply> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_list_system_counters<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::sync::ListSystemCountersReply> {
        let span = tracing::info_span!(
            "sync_list_system_counters",
        );
        let request = types::sync::ListSystemCountersRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_list_system_counters_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::sync::ListSystemCountersReply> {
        let request = types::sync::ListSystemCountersRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::sync::ListSystemCountersReply> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_create_counter<'this>(&'this mut self, id: types::Counter, initial_value: types::sync::Int64) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_create_counter",
            id = ?id,
            initial_value = ?initial_value,
        );
        let request = types::sync::CreateCounterRequest {
            id,
            initial_value,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_create_counter_checked<'this>(&'this mut self, id: types::Counter, initial_value: types::sync::Int64) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::CreateCounterRequest {
            id,
            initial_value,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_counter<'this>(&'this mut self, counter: types::Counter) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_destroy_counter",
            counter = ?counter,
        );
        let request = types::sync::DestroyCounterRequest {
            counter,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_counter_checked<'this>(&'this mut self, counter: types::Counter) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::DestroyCounterRequest {
            counter,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_query_counter<'this>(&'this mut self, counter: types::Counter) -> futures::SendRequest<'this, Self, types::sync::QueryCounterReply> {
        let span = tracing::info_span!(
            "sync_query_counter",
            counter = ?counter,
        );
        let request = types::sync::QueryCounterRequest {
            counter,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_query_counter_immediate<'this>(&'this mut self, counter: types::Counter) -> futures::CheckedSendRequest<'this, Self, types::sync::QueryCounterReply> {
        let request = types::sync::QueryCounterRequest {
            counter,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::sync::QueryCounterReply> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_await<'this>(&'this mut self, wait_list: impl AsRef<[types::Waitcondition]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_await",
        );
        let request = types::sync::AwaitRequest {
            wait_list: Cow::Borrowed(wait_list.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_await_checked<'this>(&'this mut self, wait_list: impl AsRef<[types::Waitcondition]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::AwaitRequest {
            wait_list: Cow::Borrowed(wait_list.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_change_counter<'this>(&'this mut self, counter: types::Counter, amount: types::sync::Int64) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_change_counter",
            counter = ?counter,
            amount = ?amount,
        );
        let request = types::sync::ChangeCounterRequest {
            counter,
            amount,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_change_counter_checked<'this>(&'this mut self, counter: types::Counter, amount: types::sync::Int64) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::ChangeCounterRequest {
            counter,
            amount,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_set_counter<'this>(&'this mut self, counter: types::Counter, value: types::sync::Int64) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_set_counter",
            counter = ?counter,
            value = ?value,
        );
        let request = types::sync::SetCounterRequest {
            counter,
            value,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_set_counter_checked<'this>(&'this mut self, counter: types::Counter, value: types::sync::Int64) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::SetCounterRequest {
            counter,
            value,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_create_alarm<'this>(&'this mut self, id: types::Alarm, value_list: impl Borrow<types::sync::CreateAlarmAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_create_alarm",
            id = ?id,
        );
        let request = types::sync::CreateAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_create_alarm_checked<'this>(&'this mut self, id: types::Alarm, value_list: impl Borrow<types::sync::CreateAlarmAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::CreateAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_change_alarm<'this>(&'this mut self, id: types::Alarm, value_list: impl Borrow<types::sync::ChangeAlarmAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_change_alarm",
            id = ?id,
        );
        let request = types::sync::ChangeAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_change_alarm_checked<'this>(&'this mut self, id: types::Alarm, value_list: impl Borrow<types::sync::ChangeAlarmAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::ChangeAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_alarm<'this>(&'this mut self, alarm: types::Alarm) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_destroy_alarm",
            alarm = ?alarm,
        );
        let request = types::sync::DestroyAlarmRequest {
            alarm,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_alarm_checked<'this>(&'this mut self, alarm: types::Alarm) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::DestroyAlarmRequest {
            alarm,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_query_alarm<'this>(&'this mut self, alarm: types::Alarm) -> futures::SendRequest<'this, Self, types::sync::QueryAlarmReply> {
        let span = tracing::info_span!(
            "sync_query_alarm",
            alarm = ?alarm,
        );
        let request = types::sync::QueryAlarmRequest {
            alarm,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_query_alarm_immediate<'this>(&'this mut self, alarm: types::Alarm) -> futures::CheckedSendRequest<'this, Self, types::sync::QueryAlarmReply> {
        let request = types::sync::QueryAlarmRequest {
            alarm,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::sync::QueryAlarmReply> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_set_priority<'this>(&'this mut self, id: types::Card32, priority: types::Int32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_set_priority",
            id = ?id,
            priority = ?priority,
        );
        let request = types::sync::SetPriorityRequest {
            id,
            priority,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_set_priority_checked<'this>(&'this mut self, id: types::Card32, priority: types::Int32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::SetPriorityRequest {
            id,
            priority,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_get_priority<'this>(&'this mut self, id: types::Card32) -> futures::SendRequest<'this, Self, types::sync::GetPriorityReply> {
        let span = tracing::info_span!(
            "sync_get_priority",
            id = ?id,
        );
        let request = types::sync::GetPriorityRequest {
            id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_get_priority_immediate<'this>(&'this mut self, id: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::sync::GetPriorityReply> {
        let request = types::sync::GetPriorityRequest {
            id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::sync::GetPriorityReply> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_create_fence<'this>(&'this mut self, drawable: types::xproto::Drawable, fence: types::Fence, initially_triggered: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_create_fence",
            drawable = ?drawable,
            fence = ?fence,
            initially_triggered = ?initially_triggered,
        );
        let request = types::sync::CreateFenceRequest {
            drawable,
            fence,
            initially_triggered,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_create_fence_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, fence: types::Fence, initially_triggered: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::CreateFenceRequest {
            drawable,
            fence,
            initially_triggered,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_trigger_fence<'this>(&'this mut self, fence: types::Fence) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_trigger_fence",
            fence = ?fence,
        );
        let request = types::sync::TriggerFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_trigger_fence_checked<'this>(&'this mut self, fence: types::Fence) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::TriggerFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_reset_fence<'this>(&'this mut self, fence: types::Fence) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_reset_fence",
            fence = ?fence,
        );
        let request = types::sync::ResetFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_reset_fence_checked<'this>(&'this mut self, fence: types::Fence) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::ResetFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_fence<'this>(&'this mut self, fence: types::Fence) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_destroy_fence",
            fence = ?fence,
        );
        let request = types::sync::DestroyFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_fence_checked<'this>(&'this mut self, fence: types::Fence) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::DestroyFenceRequest {
            fence,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_query_fence<'this>(&'this mut self, fence: types::Fence) -> futures::SendRequest<'this, Self, types::sync::QueryFenceReply> {
        let span = tracing::info_span!(
            "sync_query_fence",
            fence = ?fence,
        );
        let request = types::sync::QueryFenceRequest {
            fence,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_query_fence_immediate<'this>(&'this mut self, fence: types::Fence) -> futures::CheckedSendRequest<'this, Self, types::sync::QueryFenceReply> {
        let request = types::sync::QueryFenceRequest {
            fence,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::sync::QueryFenceReply> = cookie.into();
        res
    }
    #[cfg(feature = "sync")]
    fn sync_await_fence<'this>(&'this mut self, fence_list: impl AsRef<[types::Fence]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "sync_await_fence",
        );
        let request = types::sync::AwaitFenceRequest {
            fence_list: Cow::Borrowed(fence_list.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "sync")]
    fn sync_await_fence_checked<'this>(&'this mut self, fence_list: impl AsRef<[types::Fence]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::sync::AwaitFenceRequest {
            fence_list: Cow::Borrowed(fence_list.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    fn xc_misc_get_version<'this>(&'this mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> futures::SendRequest<'this, Self, types::xc_misc::GetVersionReply> {
        let span = tracing::info_span!(
            "xc_misc_get_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::xc_misc::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn xc_misc_get_version_immediate<'this>(&'this mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xc_misc::GetVersionReply> {
        let request = types::xc_misc::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xc_misc::GetVersionReply> = cookie.into();
        res
    }
    fn xc_misc_get_xid_range<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xc_misc::GetXIDRangeReply> {
        let span = tracing::info_span!(
            "xc_misc_get_xid_range",
        );
        let request = types::xc_misc::GetXIDRangeRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn xc_misc_get_xid_range_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xc_misc::GetXIDRangeReply> {
        let request = types::xc_misc::GetXIDRangeRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xc_misc::GetXIDRangeReply> = cookie.into();
        res
    }
    fn xc_misc_get_xid_list<'this>(&'this mut self, count: types::Card32) -> futures::SendRequest<'this, Self, types::xc_misc::GetXIDListReply> {
        let span = tracing::info_span!(
            "xc_misc_get_xid_list",
            count = ?count,
        );
        let request = types::xc_misc::GetXIDListRequest {
            count,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn xc_misc_get_xid_list_immediate<'this>(&'this mut self, count: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xc_misc::GetXIDListReply> {
        let request = types::xc_misc::GetXIDListRequest {
            count,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xc_misc::GetXIDListReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "xevie")]
    fn xevie_query_version<'this>(&'this mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> futures::SendRequest<'this, Self, types::xevie::QueryVersionReply> {
        let span = tracing::info_span!(
            "xevie_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::xevie::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xevie")]
    fn xevie_query_version_immediate<'this>(&'this mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xevie::QueryVersionReply> {
        let request = types::xevie::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xevie::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xevie")]
    fn xevie_start<'this>(&'this mut self, screen: types::Card32) -> futures::SendRequest<'this, Self, types::xevie::StartReply> {
        let span = tracing::info_span!(
            "xevie_start",
            screen = ?screen,
        );
        let request = types::xevie::StartRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xevie")]
    fn xevie_start_immediate<'this>(&'this mut self, screen: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xevie::StartReply> {
        let request = types::xevie::StartRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xevie::StartReply> = cookie.into();
        res
    }
    #[cfg(feature = "xevie")]
    fn xevie_end<'this>(&'this mut self, cmap: types::Card32) -> futures::SendRequest<'this, Self, types::xevie::EndReply> {
        let span = tracing::info_span!(
            "xevie_end",
            cmap = ?cmap,
        );
        let request = types::xevie::EndRequest {
            cmap,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xevie")]
    fn xevie_end_immediate<'this>(&'this mut self, cmap: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xevie::EndReply> {
        let request = types::xevie::EndRequest {
            cmap,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xevie::EndReply> = cookie.into();
        res
    }
    #[cfg(feature = "xevie")]
    fn xevie_send<'this>(&'this mut self, event: types::xevie::Event, data_type: types::Card32) -> futures::SendRequest<'this, Self, types::xevie::SendReply> {
        let span = tracing::info_span!(
            "xevie_send",
            event = ?event,
            data_type = ?data_type,
        );
        let request = types::xevie::SendRequest {
            event,
            data_type,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xevie")]
    fn xevie_send_immediate<'this>(&'this mut self, event: types::xevie::Event, data_type: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xevie::SendReply> {
        let request = types::xevie::SendRequest {
            event,
            data_type,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xevie::SendReply> = cookie.into();
        res
    }
    #[cfg(feature = "xevie")]
    fn xevie_select_input<'this>(&'this mut self, event_mask: types::Card32) -> futures::SendRequest<'this, Self, types::xevie::SelectInputReply> {
        let span = tracing::info_span!(
            "xevie_select_input",
            event_mask = ?event_mask,
        );
        let request = types::xevie::SelectInputRequest {
            event_mask,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xevie")]
    fn xevie_select_input_immediate<'this>(&'this mut self, event_mask: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xevie::SelectInputReply> {
        let request = types::xevie::SelectInputRequest {
            event_mask,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xevie::SelectInputReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_version<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xf86dri::QueryVersionReply> {
        let span = tracing::info_span!(
            "xf86dri_query_version",
        );
        let request = types::xf86dri::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_version_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xf86dri::QueryVersionReply> {
        let request = types::xf86dri::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_direct_rendering_capable<'this>(&'this mut self, screen: types::Card32) -> futures::SendRequest<'this, Self, types::xf86dri::QueryDirectRenderingCapableReply> {
        let span = tracing::info_span!(
            "xf86dri_query_direct_rendering_capable",
            screen = ?screen,
        );
        let request = types::xf86dri::QueryDirectRenderingCapableRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_direct_rendering_capable_immediate<'this>(&'this mut self, screen: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xf86dri::QueryDirectRenderingCapableReply> {
        let request = types::xf86dri::QueryDirectRenderingCapableRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::QueryDirectRenderingCapableReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_open_connection<'this>(&'this mut self, screen: types::Card32) -> futures::SendRequest<'this, Self, types::xf86dri::OpenConnectionReply> {
        let span = tracing::info_span!(
            "xf86dri_open_connection",
            screen = ?screen,
        );
        let request = types::xf86dri::OpenConnectionRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_open_connection_immediate<'this>(&'this mut self, screen: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xf86dri::OpenConnectionReply> {
        let request = types::xf86dri::OpenConnectionRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::OpenConnectionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_close_connection<'this>(&'this mut self, screen: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86dri_close_connection",
            screen = ?screen,
        );
        let request = types::xf86dri::CloseConnectionRequest {
            screen,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_close_connection_checked<'this>(&'this mut self, screen: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86dri::CloseConnectionRequest {
            screen,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_client_driver_name<'this>(&'this mut self, screen: types::Card32) -> futures::SendRequest<'this, Self, types::xf86dri::GetClientDriverNameReply> {
        let span = tracing::info_span!(
            "xf86dri_get_client_driver_name",
            screen = ?screen,
        );
        let request = types::xf86dri::GetClientDriverNameRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_client_driver_name_immediate<'this>(&'this mut self, screen: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xf86dri::GetClientDriverNameReply> {
        let request = types::xf86dri::GetClientDriverNameRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::GetClientDriverNameReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_context<'this>(&'this mut self, screen: types::Card32, visual: types::Card32, context: types::Card32) -> futures::SendRequest<'this, Self, types::xf86dri::CreateContextReply> {
        let span = tracing::info_span!(
            "xf86dri_create_context",
            screen = ?screen,
            visual = ?visual,
            context = ?context,
        );
        let request = types::xf86dri::CreateContextRequest {
            screen,
            visual,
            context,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_context_immediate<'this>(&'this mut self, screen: types::Card32, visual: types::Card32, context: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xf86dri::CreateContextReply> {
        let request = types::xf86dri::CreateContextRequest {
            screen,
            visual,
            context,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::CreateContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_context<'this>(&'this mut self, screen: types::Card32, context: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86dri_destroy_context",
            screen = ?screen,
            context = ?context,
        );
        let request = types::xf86dri::DestroyContextRequest {
            screen,
            context,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_context_checked<'this>(&'this mut self, screen: types::Card32, context: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86dri::DestroyContextRequest {
            screen,
            context,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_drawable<'this>(&'this mut self, screen: types::Card32, drawable: types::Card32) -> futures::SendRequest<'this, Self, types::xf86dri::CreateDrawableReply> {
        let span = tracing::info_span!(
            "xf86dri_create_drawable",
            screen = ?screen,
            drawable = ?drawable,
        );
        let request = types::xf86dri::CreateDrawableRequest {
            screen,
            drawable,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_drawable_immediate<'this>(&'this mut self, screen: types::Card32, drawable: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xf86dri::CreateDrawableReply> {
        let request = types::xf86dri::CreateDrawableRequest {
            screen,
            drawable,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::CreateDrawableReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_drawable<'this>(&'this mut self, screen: types::Card32, drawable: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86dri_destroy_drawable",
            screen = ?screen,
            drawable = ?drawable,
        );
        let request = types::xf86dri::DestroyDrawableRequest {
            screen,
            drawable,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_drawable_checked<'this>(&'this mut self, screen: types::Card32, drawable: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86dri::DestroyDrawableRequest {
            screen,
            drawable,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_drawable_info<'this>(&'this mut self, screen: types::Card32, drawable: types::Card32) -> futures::SendRequest<'this, Self, types::xf86dri::GetDrawableInfoReply> {
        let span = tracing::info_span!(
            "xf86dri_get_drawable_info",
            screen = ?screen,
            drawable = ?drawable,
        );
        let request = types::xf86dri::GetDrawableInfoRequest {
            screen,
            drawable,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_drawable_info_immediate<'this>(&'this mut self, screen: types::Card32, drawable: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xf86dri::GetDrawableInfoReply> {
        let request = types::xf86dri::GetDrawableInfoRequest {
            screen,
            drawable,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::GetDrawableInfoReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_device_info<'this>(&'this mut self, screen: types::Card32) -> futures::SendRequest<'this, Self, types::xf86dri::GetDeviceInfoReply> {
        let span = tracing::info_span!(
            "xf86dri_get_device_info",
            screen = ?screen,
        );
        let request = types::xf86dri::GetDeviceInfoRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_device_info_immediate<'this>(&'this mut self, screen: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xf86dri::GetDeviceInfoReply> {
        let request = types::xf86dri::GetDeviceInfoRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::GetDeviceInfoReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_auth_connection<'this>(&'this mut self, screen: types::Card32, magic: types::Card32) -> futures::SendRequest<'this, Self, types::xf86dri::AuthConnectionReply> {
        let span = tracing::info_span!(
            "xf86dri_auth_connection",
            screen = ?screen,
            magic = ?magic,
        );
        let request = types::xf86dri::AuthConnectionRequest {
            screen,
            magic,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_auth_connection_immediate<'this>(&'this mut self, screen: types::Card32, magic: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xf86dri::AuthConnectionReply> {
        let request = types::xf86dri::AuthConnectionRequest {
            screen,
            magic,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::AuthConnectionReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_query_version<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xf86vidmode::QueryVersionReply> {
        let span = tracing::info_span!(
            "xf86vidmode_query_version",
        );
        let request = types::xf86vidmode::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_query_version_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xf86vidmode::QueryVersionReply> {
        let request = types::xf86vidmode::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_mode_line<'this>(&'this mut self, screen: types::Card16) -> futures::SendRequest<'this, Self, types::xf86vidmode::GetModeLineReply> {
        let span = tracing::info_span!(
            "xf86vidmode_get_mode_line",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetModeLineRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_mode_line_immediate<'this>(&'this mut self, screen: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetModeLineReply> {
        let request = types::xf86vidmode::GetModeLineRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetModeLineReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_mod_mode_line<'this>(&'this mut self, screen: types::Card32, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86vidmode_mod_mode_line",
            screen = ?screen,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let request = types::xf86vidmode::ModModeLineRequest {
            screen,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_mod_mode_line_checked<'this>(&'this mut self, screen: types::Card32, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86vidmode::ModModeLineRequest {
            screen,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_mode<'this>(&'this mut self, screen: types::Card16, zoom: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86vidmode_switch_mode",
            screen = ?screen,
            zoom = ?zoom,
        );
        let request = types::xf86vidmode::SwitchModeRequest {
            screen,
            zoom,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_mode_checked<'this>(&'this mut self, screen: types::Card16, zoom: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86vidmode::SwitchModeRequest {
            screen,
            zoom,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_monitor<'this>(&'this mut self, screen: types::Card16) -> futures::SendRequest<'this, Self, types::xf86vidmode::GetMonitorReply> {
        let span = tracing::info_span!(
            "xf86vidmode_get_monitor",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetMonitorRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_monitor_immediate<'this>(&'this mut self, screen: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetMonitorReply> {
        let request = types::xf86vidmode::GetMonitorRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetMonitorReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_lock_mode_switch<'this>(&'this mut self, screen: types::Card16, lock: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86vidmode_lock_mode_switch",
            screen = ?screen,
            lock = ?lock,
        );
        let request = types::xf86vidmode::LockModeSwitchRequest {
            screen,
            lock,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_lock_mode_switch_checked<'this>(&'this mut self, screen: types::Card16, lock: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86vidmode::LockModeSwitchRequest {
            screen,
            lock,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_all_mode_lines<'this>(&'this mut self, screen: types::Card16) -> futures::SendRequest<'this, Self, types::xf86vidmode::GetAllModeLinesReply> {
        let span = tracing::info_span!(
            "xf86vidmode_get_all_mode_lines",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetAllModeLinesRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_all_mode_lines_immediate<'this>(&'this mut self, screen: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetAllModeLinesReply> {
        let request = types::xf86vidmode::GetAllModeLinesRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetAllModeLinesReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_add_mode_line<'this>(&'this mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, after_dotclock: types::Dotclock, after_hdisplay: types::Card16, after_hsyncstart: types::Card16, after_hsyncend: types::Card16, after_htotal: types::Card16, after_hskew: types::Card16, after_vdisplay: types::Card16, after_vsyncstart: types::Card16, after_vsyncend: types::Card16, after_vtotal: types::Card16, after_flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86vidmode_add_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
            after_dotclock = ?after_dotclock,
            after_hdisplay = ?after_hdisplay,
            after_hsyncstart = ?after_hsyncstart,
            after_hsyncend = ?after_hsyncend,
            after_htotal = ?after_htotal,
            after_hskew = ?after_hskew,
            after_vdisplay = ?after_vdisplay,
            after_vsyncstart = ?after_vsyncstart,
            after_vsyncend = ?after_vsyncend,
            after_vtotal = ?after_vtotal,
        );
        let request = types::xf86vidmode::AddModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            after_dotclock,
            after_hdisplay,
            after_hsyncstart,
            after_hsyncend,
            after_htotal,
            after_hskew,
            after_vdisplay,
            after_vsyncstart,
            after_vsyncend,
            after_vtotal,
            after_flags: Into::<u32>::into(after_flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_add_mode_line_checked<'this>(&'this mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, after_dotclock: types::Dotclock, after_hdisplay: types::Card16, after_hsyncstart: types::Card16, after_hsyncend: types::Card16, after_htotal: types::Card16, after_hskew: types::Card16, after_vdisplay: types::Card16, after_vsyncstart: types::Card16, after_vsyncend: types::Card16, after_vtotal: types::Card16, after_flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86vidmode::AddModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            after_dotclock,
            after_hdisplay,
            after_hsyncstart,
            after_hsyncend,
            after_htotal,
            after_hskew,
            after_vdisplay,
            after_vsyncstart,
            after_vsyncend,
            after_vtotal,
            after_flags: Into::<u32>::into(after_flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_delete_mode_line<'this>(&'this mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86vidmode_delete_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let request = types::xf86vidmode::DeleteModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_delete_mode_line_checked<'this>(&'this mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86vidmode::DeleteModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_validate_mode_line<'this>(&'this mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> futures::SendRequest<'this, Self, types::xf86vidmode::ValidateModeLineReply> {
        let span = tracing::info_span!(
            "xf86vidmode_validate_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let request = types::xf86vidmode::ValidateModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_validate_mode_line_immediate<'this>(&'this mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> futures::CheckedSendRequest<'this, Self, types::xf86vidmode::ValidateModeLineReply> {
        let request = types::xf86vidmode::ValidateModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::ValidateModeLineReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_to_mode<'this>(&'this mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86vidmode_switch_to_mode",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let request = types::xf86vidmode::SwitchToModeRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_to_mode_checked<'this>(&'this mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86vidmode::SwitchToModeRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_view_port<'this>(&'this mut self, screen: types::Card16) -> futures::SendRequest<'this, Self, types::xf86vidmode::GetViewPortReply> {
        let span = tracing::info_span!(
            "xf86vidmode_get_view_port",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetViewPortRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_view_port_immediate<'this>(&'this mut self, screen: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetViewPortReply> {
        let request = types::xf86vidmode::GetViewPortRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetViewPortReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_view_port<'this>(&'this mut self, screen: types::Card16, x: types::Card32, y: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86vidmode_set_view_port",
            screen = ?screen,
            x = ?x,
            y = ?y,
        );
        let request = types::xf86vidmode::SetViewPortRequest {
            screen,
            x,
            y,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_view_port_checked<'this>(&'this mut self, screen: types::Card16, x: types::Card32, y: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86vidmode::SetViewPortRequest {
            screen,
            x,
            y,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_dot_clocks<'this>(&'this mut self, screen: types::Card16) -> futures::SendRequest<'this, Self, types::xf86vidmode::GetDotClocksReply> {
        let span = tracing::info_span!(
            "xf86vidmode_get_dot_clocks",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetDotClocksRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_dot_clocks_immediate<'this>(&'this mut self, screen: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetDotClocksReply> {
        let request = types::xf86vidmode::GetDotClocksRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetDotClocksReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_client_version<'this>(&'this mut self, major: types::Card16, minor: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86vidmode_set_client_version",
            major = ?major,
            minor = ?minor,
        );
        let request = types::xf86vidmode::SetClientVersionRequest {
            major,
            minor,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_client_version_checked<'this>(&'this mut self, major: types::Card16, minor: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86vidmode::SetClientVersionRequest {
            major,
            minor,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma<'this>(&'this mut self, screen: types::Card16, red: types::Card32, green: types::Card32, blue: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86vidmode_set_gamma",
            screen = ?screen,
            red = ?red,
            green = ?green,
            blue = ?blue,
        );
        let request = types::xf86vidmode::SetGammaRequest {
            screen,
            red,
            green,
            blue,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_checked<'this>(&'this mut self, screen: types::Card16, red: types::Card32, green: types::Card32, blue: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86vidmode::SetGammaRequest {
            screen,
            red,
            green,
            blue,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma<'this>(&'this mut self, screen: types::Card16) -> futures::SendRequest<'this, Self, types::xf86vidmode::GetGammaReply> {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetGammaRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_immediate<'this>(&'this mut self, screen: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetGammaReply> {
        let request = types::xf86vidmode::GetGammaRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetGammaReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp<'this>(&'this mut self, screen: types::Card16, size: types::Card16) -> futures::SendRequest<'this, Self, types::xf86vidmode::GetGammaRampReply> {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma_ramp",
            screen = ?screen,
            size = ?size,
        );
        let request = types::xf86vidmode::GetGammaRampRequest {
            screen,
            size,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_immediate<'this>(&'this mut self, screen: types::Card16, size: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetGammaRampReply> {
        let request = types::xf86vidmode::GetGammaRampRequest {
            screen,
            size,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetGammaRampReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_ramp<'this>(&'this mut self, screen: types::Card16, size: types::Card16, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xf86vidmode_set_gamma_ramp",
            screen = ?screen,
            size = ?size,
        );
        let request = types::xf86vidmode::SetGammaRampRequest {
            screen,
            size,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_ramp_checked<'this>(&'this mut self, screen: types::Card16, size: types::Card16, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xf86vidmode::SetGammaRampRequest {
            screen,
            size,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_size<'this>(&'this mut self, screen: types::Card16) -> futures::SendRequest<'this, Self, types::xf86vidmode::GetGammaRampSizeReply> {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma_ramp_size",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetGammaRampSizeRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_size_immediate<'this>(&'this mut self, screen: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetGammaRampSizeReply> {
        let request = types::xf86vidmode::GetGammaRampSizeRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetGammaRampSizeReply> = cookie.into();
        res
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_permissions<'this>(&'this mut self, screen: types::Card16) -> futures::SendRequest<'this, Self, types::xf86vidmode::GetPermissionsReply> {
        let span = tracing::info_span!(
            "xf86vidmode_get_permissions",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetPermissionsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_permissions_immediate<'this>(&'this mut self, screen: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetPermissionsReply> {
        let request = types::xf86vidmode::GetPermissionsRequest {
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetPermissionsReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "xfixes")]
    fn xfixes_query_version<'this>(&'this mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> futures::SendRequest<'this, Self, types::xfixes::QueryVersionReply> {
        let span = tracing::info_span!(
            "xfixes_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::xfixes::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_query_version_immediate<'this>(&'this mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xfixes::QueryVersionReply> {
        let request = types::xfixes::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xfixes::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_save_set<'this>(&'this mut self, mode: types::SaveSetMode, target: types::SaveSetTarget, map: types::SaveSetMapping, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_change_save_set",
            mode = ?mode,
            target = ?target,
            map = ?map,
            window = ?window,
        );
        let request = types::xfixes::ChangeSaveSetRequest {
            mode,
            target,
            map,
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_save_set_checked<'this>(&'this mut self, mode: types::SaveSetMode, target: types::SaveSetTarget, map: types::SaveSetMapping, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::ChangeSaveSetRequest {
            mode,
            target,
            map,
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_selection_input<'this>(&'this mut self, window: types::xproto::Window, selection: types::Atom, event_mask: impl Into<types::SelectionEventMask>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_select_selection_input",
            window = ?window,
            selection = ?selection,
        );
        let request = types::xfixes::SelectSelectionInputRequest {
            window,
            selection,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_selection_input_checked<'this>(&'this mut self, window: types::xproto::Window, selection: types::Atom, event_mask: impl Into<types::SelectionEventMask>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::SelectSelectionInputRequest {
            window,
            selection,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_cursor_input<'this>(&'this mut self, window: types::xproto::Window, event_mask: impl Into<types::CursorNotifyMask>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_select_cursor_input",
            window = ?window,
        );
        let request = types::xfixes::SelectCursorInputRequest {
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_cursor_input_checked<'this>(&'this mut self, window: types::xproto::Window, event_mask: impl Into<types::CursorNotifyMask>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::SelectCursorInputRequest {
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xfixes::GetCursorImageReply> {
        let span = tracing::info_span!(
            "xfixes_get_cursor_image",
        );
        let request = types::xfixes::GetCursorImageRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xfixes::GetCursorImageReply> {
        let request = types::xfixes::GetCursorImageRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xfixes::GetCursorImageReply> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region<'this>(&'this mut self, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_create_region",
            region = ?region,
        );
        let request = types::xfixes::CreateRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_checked<'this>(&'this mut self, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::CreateRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_bitmap<'this>(&'this mut self, region: types::Region, bitmap: types::xproto::Pixmap) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_bitmap",
            region = ?region,
            bitmap = ?bitmap,
        );
        let request = types::xfixes::CreateRegionFromBitmapRequest {
            region,
            bitmap,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_bitmap_checked<'this>(&'this mut self, region: types::Region, bitmap: types::xproto::Pixmap) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::CreateRegionFromBitmapRequest {
            region,
            bitmap,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_window<'this>(&'this mut self, region: types::Region, window: types::xproto::Window, kind: types::SK) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_window",
            region = ?region,
            window = ?window,
            kind = ?kind,
        );
        let request = types::xfixes::CreateRegionFromWindowRequest {
            region,
            window,
            kind,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_window_checked<'this>(&'this mut self, region: types::Region, window: types::xproto::Window, kind: types::SK) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::CreateRegionFromWindowRequest {
            region,
            window,
            kind,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_gc<'this>(&'this mut self, region: types::Region, gc: types::Gcontext) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_gc",
            region = ?region,
            gc = ?gc,
        );
        let request = types::xfixes::CreateRegionFromGCRequest {
            region,
            gc,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_gc_checked<'this>(&'this mut self, region: types::Region, gc: types::Gcontext) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::CreateRegionFromGCRequest {
            region,
            gc,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_picture<'this>(&'this mut self, region: types::Region, picture: types::Picture) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_picture",
            region = ?region,
            picture = ?picture,
        );
        let request = types::xfixes::CreateRegionFromPictureRequest {
            region,
            picture,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_picture_checked<'this>(&'this mut self, region: types::Region, picture: types::Picture) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::CreateRegionFromPictureRequest {
            region,
            picture,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_destroy_region<'this>(&'this mut self, region: types::Region) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_destroy_region",
            region = ?region,
        );
        let request = types::xfixes::DestroyRegionRequest {
            region,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_destroy_region_checked<'this>(&'this mut self, region: types::Region) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::DestroyRegionRequest {
            region,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_region<'this>(&'this mut self, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_set_region",
            region = ?region,
        );
        let request = types::xfixes::SetRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_region_checked<'this>(&'this mut self, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::SetRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_copy_region<'this>(&'this mut self, source: types::Region, destination: types::Region) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_copy_region",
            source = ?source,
            destination = ?destination,
        );
        let request = types::xfixes::CopyRegionRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_copy_region_checked<'this>(&'this mut self, source: types::Region, destination: types::Region) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::CopyRegionRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_union_region<'this>(&'this mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_union_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let request = types::xfixes::UnionRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_union_region_checked<'this>(&'this mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::UnionRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_intersect_region<'this>(&'this mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_intersect_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let request = types::xfixes::IntersectRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_intersect_region_checked<'this>(&'this mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::IntersectRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_subtract_region<'this>(&'this mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_subtract_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let request = types::xfixes::SubtractRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_subtract_region_checked<'this>(&'this mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::SubtractRegionRequest {
            source1,
            source2,
            destination,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_invert_region<'this>(&'this mut self, source: types::Region, bounds: types::Rectangle, destination: types::Region) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_invert_region",
            source = ?source,
            bounds = ?bounds,
            destination = ?destination,
        );
        let request = types::xfixes::InvertRegionRequest {
            source,
            bounds,
            destination,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_invert_region_checked<'this>(&'this mut self, source: types::Region, bounds: types::Rectangle, destination: types::Region) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::InvertRegionRequest {
            source,
            bounds,
            destination,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_translate_region<'this>(&'this mut self, region: types::Region, dx: types::Int16, dy: types::Int16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_translate_region",
            region = ?region,
            dx = ?dx,
            dy = ?dy,
        );
        let request = types::xfixes::TranslateRegionRequest {
            region,
            dx,
            dy,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_translate_region_checked<'this>(&'this mut self, region: types::Region, dx: types::Int16, dy: types::Int16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::TranslateRegionRequest {
            region,
            dx,
            dy,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_region_extents<'this>(&'this mut self, source: types::Region, destination: types::Region) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_region_extents",
            source = ?source,
            destination = ?destination,
        );
        let request = types::xfixes::RegionExtentsRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_region_extents_checked<'this>(&'this mut self, source: types::Region, destination: types::Region) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::RegionExtentsRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_fetch_region<'this>(&'this mut self, region: types::Region) -> futures::SendRequest<'this, Self, types::xfixes::FetchRegionReply> {
        let span = tracing::info_span!(
            "xfixes_fetch_region",
            region = ?region,
        );
        let request = types::xfixes::FetchRegionRequest {
            region,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_fetch_region_immediate<'this>(&'this mut self, region: types::Region) -> futures::CheckedSendRequest<'this, Self, types::xfixes::FetchRegionReply> {
        let request = types::xfixes::FetchRegionRequest {
            region,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xfixes::FetchRegionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_gc_clip_region<'this>(&'this mut self, gc: types::Gcontext, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_set_gc_clip_region",
            gc = ?gc,
            x_origin = ?x_origin,
            y_origin = ?y_origin,
        );
        let request = types::xfixes::SetGCClipRegionRequest {
            gc,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_gc_clip_region_checked<'this>(&'this mut self, gc: types::Gcontext, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::SetGCClipRegionRequest {
            gc,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_window_shape_region<'this>(&'this mut self, dest: types::xproto::Window, dest_kind: types::SK, x_offset: types::Int16, y_offset: types::Int16, region: impl Into<types::Region>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_set_window_shape_region",
            dest = ?dest,
            dest_kind = ?dest_kind,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let request = types::xfixes::SetWindowShapeRegionRequest {
            dest,
            dest_kind,
            x_offset,
            y_offset,
            region: Into::<u32>::into(region.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_window_shape_region_checked<'this>(&'this mut self, dest: types::xproto::Window, dest_kind: types::SK, x_offset: types::Int16, y_offset: types::Int16, region: impl Into<types::Region>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::SetWindowShapeRegionRequest {
            dest,
            dest_kind,
            x_offset,
            y_offset,
            region: Into::<u32>::into(region.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_picture_clip_region<'this>(&'this mut self, picture: types::Picture, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_set_picture_clip_region",
            picture = ?picture,
            x_origin = ?x_origin,
            y_origin = ?y_origin,
        );
        let request = types::xfixes::SetPictureClipRegionRequest {
            picture,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_picture_clip_region_checked<'this>(&'this mut self, picture: types::Picture, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::SetPictureClipRegionRequest {
            picture,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_cursor_name<'this>(&'this mut self, cursor: types::xproto::Cursor, name: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_set_cursor_name",
            cursor = ?cursor,
        );
        let request = types::xfixes::SetCursorNameRequest {
            cursor,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_cursor_name_checked<'this>(&'this mut self, cursor: types::xproto::Cursor, name: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::SetCursorNameRequest {
            cursor,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_name<'this>(&'this mut self, cursor: types::xproto::Cursor) -> futures::SendRequest<'this, Self, types::xfixes::GetCursorNameReply> {
        let span = tracing::info_span!(
            "xfixes_get_cursor_name",
            cursor = ?cursor,
        );
        let request = types::xfixes::GetCursorNameRequest {
            cursor,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_name_immediate<'this>(&'this mut self, cursor: types::xproto::Cursor) -> futures::CheckedSendRequest<'this, Self, types::xfixes::GetCursorNameReply> {
        let request = types::xfixes::GetCursorNameRequest {
            cursor,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xfixes::GetCursorNameReply> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_and_name<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xfixes::GetCursorImageAndNameReply> {
        let span = tracing::info_span!(
            "xfixes_get_cursor_image_and_name",
        );
        let request = types::xfixes::GetCursorImageAndNameRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_and_name_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xfixes::GetCursorImageAndNameReply> {
        let request = types::xfixes::GetCursorImageAndNameRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xfixes::GetCursorImageAndNameReply> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor<'this>(&'this mut self, source: types::xproto::Cursor, destination: types::xproto::Cursor) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_change_cursor",
            source = ?source,
            destination = ?destination,
        );
        let request = types::xfixes::ChangeCursorRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_checked<'this>(&'this mut self, source: types::xproto::Cursor, destination: types::xproto::Cursor) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::ChangeCursorRequest {
            source,
            destination,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_by_name<'this>(&'this mut self, src: types::xproto::Cursor, name: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_change_cursor_by_name",
            src = ?src,
        );
        let request = types::xfixes::ChangeCursorByNameRequest {
            src,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_by_name_checked<'this>(&'this mut self, src: types::xproto::Cursor, name: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::ChangeCursorByNameRequest {
            src,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_expand_region<'this>(&'this mut self, source: types::Region, destination: types::Region, left: types::Card16, right: types::Card16, top: types::Card16, bottom: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_expand_region",
            source = ?source,
            destination = ?destination,
            left = ?left,
            right = ?right,
            top = ?top,
            bottom = ?bottom,
        );
        let request = types::xfixes::ExpandRegionRequest {
            source,
            destination,
            left,
            right,
            top,
            bottom,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_expand_region_checked<'this>(&'this mut self, source: types::Region, destination: types::Region, left: types::Card16, right: types::Card16, top: types::Card16, bottom: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::ExpandRegionRequest {
            source,
            destination,
            left,
            right,
            top,
            bottom,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_hide_cursor<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_hide_cursor",
            window = ?window,
        );
        let request = types::xfixes::HideCursorRequest {
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_hide_cursor_checked<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::HideCursorRequest {
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_show_cursor<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_show_cursor",
            window = ?window,
        );
        let request = types::xfixes::ShowCursorRequest {
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_show_cursor_checked<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::ShowCursorRequest {
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_pointer_barrier<'this>(&'this mut self, barrier: types::Barrier, window: types::xproto::Window, x1: types::Card16, y1: types::Card16, x2: types::Card16, y2: types::Card16, directions: impl Into<types::BarrierDirections>, devices: impl AsRef<[types::Card16]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_create_pointer_barrier",
            barrier = ?barrier,
            window = ?window,
            x1 = ?x1,
            y1 = ?y1,
            x2 = ?x2,
            y2 = ?y2,
        );
        let request = types::xfixes::CreatePointerBarrierRequest {
            barrier,
            window,
            x1,
            y1,
            x2,
            y2,
            directions: Into::<u32>::into(directions.into()) as _,
            devices: Cow::Borrowed(devices.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_pointer_barrier_checked<'this>(&'this mut self, barrier: types::Barrier, window: types::xproto::Window, x1: types::Card16, y1: types::Card16, x2: types::Card16, y2: types::Card16, directions: impl Into<types::BarrierDirections>, devices: impl AsRef<[types::Card16]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::CreatePointerBarrierRequest {
            barrier,
            window,
            x1,
            y1,
            x2,
            y2,
            directions: Into::<u32>::into(directions.into()) as _,
            devices: Cow::Borrowed(devices.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_delete_pointer_barrier<'this>(&'this mut self, barrier: types::Barrier) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xfixes_delete_pointer_barrier",
            barrier = ?barrier,
        );
        let request = types::xfixes::DeletePointerBarrierRequest {
            barrier,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_delete_pointer_barrier_checked<'this>(&'this mut self, barrier: types::Barrier) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xfixes::DeletePointerBarrierRequest {
            barrier,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    #[cfg(feature = "xinerama")]
    fn xinerama_query_version<'this>(&'this mut self, major: types::Card8, minor: types::Card8) -> futures::SendRequest<'this, Self, types::xinerama::QueryVersionReply> {
        let span = tracing::info_span!(
            "xinerama_query_version",
            major = ?major,
            minor = ?minor,
        );
        let request = types::xinerama::QueryVersionRequest {
            major,
            minor,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_version_immediate<'this>(&'this mut self, major: types::Card8, minor: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinerama::QueryVersionReply> {
        let request = types::xinerama::QueryVersionRequest {
            major,
            minor,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_state<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xinerama::GetStateReply> {
        let span = tracing::info_span!(
            "xinerama_get_state",
            window = ?window,
        );
        let request = types::xinerama::GetStateRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_state_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xinerama::GetStateReply> {
        let request = types::xinerama::GetStateRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::GetStateReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_count<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xinerama::GetScreenCountReply> {
        let span = tracing::info_span!(
            "xinerama_get_screen_count",
            window = ?window,
        );
        let request = types::xinerama::GetScreenCountRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_count_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xinerama::GetScreenCountReply> {
        let request = types::xinerama::GetScreenCountRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::GetScreenCountReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_size<'this>(&'this mut self, window: types::xproto::Window, screen: types::Card32) -> futures::SendRequest<'this, Self, types::xinerama::GetScreenSizeReply> {
        let span = tracing::info_span!(
            "xinerama_get_screen_size",
            window = ?window,
            screen = ?screen,
        );
        let request = types::xinerama::GetScreenSizeRequest {
            window,
            screen,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_size_immediate<'this>(&'this mut self, window: types::xproto::Window, screen: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xinerama::GetScreenSizeReply> {
        let request = types::xinerama::GetScreenSizeRequest {
            window,
            screen,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::GetScreenSizeReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_is_active<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xinerama::IsActiveReply> {
        let span = tracing::info_span!(
            "xinerama_is_active",
        );
        let request = types::xinerama::IsActiveRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_is_active_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xinerama::IsActiveReply> {
        let request = types::xinerama::IsActiveRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::IsActiveReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_screens<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xinerama::QueryScreensReply> {
        let span = tracing::info_span!(
            "xinerama_query_screens",
        );
        let request = types::xinerama::QueryScreensRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_screens_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xinerama::QueryScreensReply> {
        let request = types::xinerama::QueryScreensRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::QueryScreensReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "xinput")]
    fn xinput_get_extension_version<'this>(&'this mut self, name: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, types::xinput::GetExtensionVersionReply> {
        let span = tracing::info_span!(
            "xinput_get_extension_version",
        );
        let request = types::xinput::GetExtensionVersionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_extension_version_immediate<'this>(&'this mut self, name: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, types::xinput::GetExtensionVersionReply> {
        let request = types::xinput::GetExtensionVersionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetExtensionVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_input_devices<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xinput::ListInputDevicesReply> {
        let span = tracing::info_span!(
            "xinput_list_input_devices",
        );
        let request = types::xinput::ListInputDevicesRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_input_devices_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xinput::ListInputDevicesReply> {
        let request = types::xinput::ListInputDevicesRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::ListInputDevicesReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_open_device<'this>(&'this mut self, device_id: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::OpenDeviceReply> {
        let span = tracing::info_span!(
            "xinput_open_device",
            device_id = ?device_id,
        );
        let request = types::xinput::OpenDeviceRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_open_device_immediate<'this>(&'this mut self, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::OpenDeviceReply> {
        let request = types::xinput::OpenDeviceRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::OpenDeviceReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_close_device<'this>(&'this mut self, device_id: types::Card8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_close_device",
            device_id = ?device_id,
        );
        let request = types::xinput::CloseDeviceRequest {
            device_id,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_close_device_checked<'this>(&'this mut self, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::CloseDeviceRequest {
            device_id,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_mode<'this>(&'this mut self, device_id: types::Card8, mode: types::ValuatorMode) -> futures::SendRequest<'this, Self, types::xinput::SetDeviceModeReply> {
        let span = tracing::info_span!(
            "xinput_set_device_mode",
            device_id = ?device_id,
            mode = ?mode,
        );
        let request = types::xinput::SetDeviceModeRequest {
            device_id,
            mode,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_mode_immediate<'this>(&'this mut self, device_id: types::Card8, mode: types::ValuatorMode) -> futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceModeReply> {
        let request = types::xinput::SetDeviceModeRequest {
            device_id,
            mode,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceModeReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_select_extension_event<'this>(&'this mut self, window: types::xproto::Window, classes: impl AsRef<[types::EventClass]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_select_extension_event",
            window = ?window,
        );
        let request = types::xinput::SelectExtensionEventRequest {
            window,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_select_extension_event_checked<'this>(&'this mut self, window: types::xproto::Window, classes: impl AsRef<[types::EventClass]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::SelectExtensionEventRequest {
            window,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_selected_extension_events<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xinput::GetSelectedExtensionEventsReply> {
        let span = tracing::info_span!(
            "xinput_get_selected_extension_events",
            window = ?window,
        );
        let request = types::xinput::GetSelectedExtensionEventsRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_selected_extension_events_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xinput::GetSelectedExtensionEventsReply> {
        let request = types::xinput::GetSelectedExtensionEventsRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetSelectedExtensionEventsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_dont_propagate_list<'this>(&'this mut self, window: types::xproto::Window, mode: types::PropagateMode, classes: impl AsRef<[types::EventClass]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_change_device_dont_propagate_list",
            window = ?window,
            mode = ?mode,
        );
        let request = types::xinput::ChangeDeviceDontPropagateListRequest {
            window,
            mode,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_dont_propagate_list_checked<'this>(&'this mut self, window: types::xproto::Window, mode: types::PropagateMode, classes: impl AsRef<[types::EventClass]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::ChangeDeviceDontPropagateListRequest {
            window,
            mode,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_dont_propagate_list<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xinput::GetDeviceDontPropagateListReply> {
        let span = tracing::info_span!(
            "xinput_get_device_dont_propagate_list",
            window = ?window,
        );
        let request = types::xinput::GetDeviceDontPropagateListRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_dont_propagate_list_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceDontPropagateListReply> {
        let request = types::xinput::GetDeviceDontPropagateListRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceDontPropagateListReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_motion_events<'this>(&'this mut self, start: types::Timestamp, stop: impl Into<types::Time>, device_id: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::GetDeviceMotionEventsReply> {
        let span = tracing::info_span!(
            "xinput_get_device_motion_events",
            start = ?start,
            device_id = ?device_id,
        );
        let request = types::xinput::GetDeviceMotionEventsRequest {
            start,
            stop: Into::<u32>::into(stop.into()) as _,
            device_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_motion_events_immediate<'this>(&'this mut self, start: types::Timestamp, stop: impl Into<types::Time>, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceMotionEventsReply> {
        let request = types::xinput::GetDeviceMotionEventsRequest {
            start,
            stop: Into::<u32>::into(stop.into()) as _,
            device_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceMotionEventsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_keyboard_device<'this>(&'this mut self, device_id: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::ChangeKeyboardDeviceReply> {
        let span = tracing::info_span!(
            "xinput_change_keyboard_device",
            device_id = ?device_id,
        );
        let request = types::xinput::ChangeKeyboardDeviceRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_keyboard_device_immediate<'this>(&'this mut self, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::ChangeKeyboardDeviceReply> {
        let request = types::xinput::ChangeKeyboardDeviceRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::ChangeKeyboardDeviceReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_pointer_device<'this>(&'this mut self, x_axis: types::Card8, y_axis: types::Card8, device_id: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::ChangePointerDeviceReply> {
        let span = tracing::info_span!(
            "xinput_change_pointer_device",
            x_axis = ?x_axis,
            y_axis = ?y_axis,
            device_id = ?device_id,
        );
        let request = types::xinput::ChangePointerDeviceRequest {
            x_axis,
            y_axis,
            device_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_pointer_device_immediate<'this>(&'this mut self, x_axis: types::Card8, y_axis: types::Card8, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::ChangePointerDeviceReply> {
        let request = types::xinput::ChangePointerDeviceRequest {
            x_axis,
            y_axis,
            device_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::ChangePointerDeviceReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device<'this>(&'this mut self, grab_window: types::xproto::Window, time: impl Into<types::Time>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, device_id: types::Card8, classes: impl AsRef<[types::EventClass]>) -> futures::SendRequest<'this, Self, types::xinput::GrabDeviceReply> {
        let span = tracing::info_span!(
            "xinput_grab_device",
            grab_window = ?grab_window,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
            device_id = ?device_id,
        );
        let request = types::xinput::GrabDeviceRequest {
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            device_id,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_immediate<'this>(&'this mut self, grab_window: types::xproto::Window, time: impl Into<types::Time>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, device_id: types::Card8, classes: impl AsRef<[types::EventClass]>) -> futures::CheckedSendRequest<'this, Self, types::xinput::GrabDeviceReply> {
        let request = types::xinput::GrabDeviceRequest {
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            device_id,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GrabDeviceReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device<'this>(&'this mut self, time: impl Into<types::Time>, device_id: types::Card8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_ungrab_device",
            device_id = ?device_id,
        );
        let request = types::xinput::UngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            device_id,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_checked<'this>(&'this mut self, time: impl Into<types::Time>, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::UngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            device_id,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_key<'this>(&'this mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, grabbed_device: types::Card8, key: impl Into<types::Grab>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_grab_device_key",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
        );
        let request = types::xinput::GrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            grabbed_device,
            key: Into::<u32>::into(key.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_key_checked<'this>(&'this mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, grabbed_device: types::Card8, key: impl Into<types::Grab>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::GrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            grabbed_device,
            key: Into::<u32>::into(key.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_key<'this>(&'this mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, key: impl Into<types::Grab>, grabbed_device: types::Card8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_ungrab_device_key",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
        );
        let request = types::xinput::UngrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            grabbed_device,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_key_checked<'this>(&'this mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, key: impl Into<types::Grab>, grabbed_device: types::Card8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::UngrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            grabbed_device,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_button<'this>(&'this mut self, grab_window: types::xproto::Window, grabbed_device: types::Card8, modifier_device: impl Into<types::ModifierDevice>, modifiers: impl Into<types::ModMask>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, button: impl Into<types::Grab>, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_grab_device_button",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
        );
        let request = types::xinput::GrabDeviceButtonRequest {
            grab_window,
            grabbed_device,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            this_device_mode,
            other_device_mode,
            button: Into::<u32>::into(button.into()) as _,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_button_checked<'this>(&'this mut self, grab_window: types::xproto::Window, grabbed_device: types::Card8, modifier_device: impl Into<types::ModifierDevice>, modifiers: impl Into<types::ModMask>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, button: impl Into<types::Grab>, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::GrabDeviceButtonRequest {
            grab_window,
            grabbed_device,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            this_device_mode,
            other_device_mode,
            button: Into::<u32>::into(button.into()) as _,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_button<'this>(&'this mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, button: impl Into<types::Grab>, grabbed_device: types::Card8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_ungrab_device_button",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
        );
        let request = types::xinput::UngrabDeviceButtonRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            button: Into::<u32>::into(button.into()) as _,
            grabbed_device,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_button_checked<'this>(&'this mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, button: impl Into<types::Grab>, grabbed_device: types::Card8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::UngrabDeviceButtonRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            button: Into::<u32>::into(button.into()) as _,
            grabbed_device,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_allow_device_events<'this>(&'this mut self, time: impl Into<types::Time>, mode: types::DeviceInputMode, device_id: types::Card8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_allow_device_events",
            mode = ?mode,
            device_id = ?device_id,
        );
        let request = types::xinput::AllowDeviceEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            mode,
            device_id,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_allow_device_events_checked<'this>(&'this mut self, time: impl Into<types::Time>, mode: types::DeviceInputMode, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::AllowDeviceEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            mode,
            device_id,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_focus<'this>(&'this mut self, device_id: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::GetDeviceFocusReply> {
        let span = tracing::info_span!(
            "xinput_get_device_focus",
            device_id = ?device_id,
        );
        let request = types::xinput::GetDeviceFocusRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_focus_immediate<'this>(&'this mut self, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceFocusReply> {
        let request = types::xinput::GetDeviceFocusRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceFocusReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_focus<'this>(&'this mut self, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>, revert_to: types::InputFocus, device_id: types::Card8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_set_device_focus",
            revert_to = ?revert_to,
            device_id = ?device_id,
        );
        let request = types::xinput::SetDeviceFocusRequest {
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            revert_to,
            device_id,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_focus_checked<'this>(&'this mut self, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>, revert_to: types::InputFocus, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::SetDeviceFocusRequest {
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            revert_to,
            device_id,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_feedback_control<'this>(&'this mut self, device_id: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::GetFeedbackControlReply> {
        let span = tracing::info_span!(
            "xinput_get_feedback_control",
            device_id = ?device_id,
        );
        let request = types::xinput::GetFeedbackControlRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_feedback_control_immediate<'this>(&'this mut self, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::GetFeedbackControlReply> {
        let request = types::xinput::GetFeedbackControlRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetFeedbackControlReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_feedback_control<'this>(&'this mut self, mask: impl Into<types::ChangeFeedbackControlMask>, device_id: types::Card8, feedback_id: types::Card8, feedback: types::FeedbackCtl) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_change_feedback_control",
            device_id = ?device_id,
            feedback_id = ?feedback_id,
            feedback = ?feedback,
        );
        let request = types::xinput::ChangeFeedbackControlRequest {
            mask: Into::<u32>::into(mask.into()) as _,
            device_id,
            feedback_id,
            feedback,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_feedback_control_checked<'this>(&'this mut self, mask: impl Into<types::ChangeFeedbackControlMask>, device_id: types::Card8, feedback_id: types::Card8, feedback: types::FeedbackCtl) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::ChangeFeedbackControlRequest {
            mask: Into::<u32>::into(mask.into()) as _,
            device_id,
            feedback_id,
            feedback,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_key_mapping<'this>(&'this mut self, device_id: types::Card8, first_keycode: types::KeyCode, count: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::GetDeviceKeyMappingReply> {
        let span = tracing::info_span!(
            "xinput_get_device_key_mapping",
            device_id = ?device_id,
            first_keycode = ?first_keycode,
            count = ?count,
        );
        let request = types::xinput::GetDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            count,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_key_mapping_immediate<'this>(&'this mut self, device_id: types::Card8, first_keycode: types::KeyCode, count: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceKeyMappingReply> {
        let request = types::xinput::GetDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            count,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceKeyMappingReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_key_mapping<'this>(&'this mut self, device_id: types::Card8, first_keycode: types::KeyCode, keysyms_per_keycode: types::Card8, keycode_count: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_change_device_key_mapping",
            device_id = ?device_id,
            first_keycode = ?first_keycode,
            keysyms_per_keycode = ?keysyms_per_keycode,
            keycode_count = ?keycode_count,
        );
        let request = types::xinput::ChangeDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            keysyms_per_keycode,
            keycode_count,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_key_mapping_checked<'this>(&'this mut self, device_id: types::Card8, first_keycode: types::KeyCode, keysyms_per_keycode: types::Card8, keycode_count: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::ChangeDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            keysyms_per_keycode,
            keycode_count,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_modifier_mapping<'this>(&'this mut self, device_id: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::GetDeviceModifierMappingReply> {
        let span = tracing::info_span!(
            "xinput_get_device_modifier_mapping",
            device_id = ?device_id,
        );
        let request = types::xinput::GetDeviceModifierMappingRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_modifier_mapping_immediate<'this>(&'this mut self, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceModifierMappingReply> {
        let request = types::xinput::GetDeviceModifierMappingRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceModifierMappingReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_modifier_mapping<'this>(&'this mut self, device_id: types::Card8, keymaps: impl AsRef<[types::Card8]>) -> futures::SendRequest<'this, Self, types::xinput::SetDeviceModifierMappingReply> {
        let span = tracing::info_span!(
            "xinput_set_device_modifier_mapping",
            device_id = ?device_id,
        );
        let request = types::xinput::SetDeviceModifierMappingRequest {
            device_id,
            keymaps: Cow::Borrowed(keymaps.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_modifier_mapping_immediate<'this>(&'this mut self, device_id: types::Card8, keymaps: impl AsRef<[types::Card8]>) -> futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceModifierMappingReply> {
        let request = types::xinput::SetDeviceModifierMappingRequest {
            device_id,
            keymaps: Cow::Borrowed(keymaps.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceModifierMappingReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_button_mapping<'this>(&'this mut self, device_id: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::GetDeviceButtonMappingReply> {
        let span = tracing::info_span!(
            "xinput_get_device_button_mapping",
            device_id = ?device_id,
        );
        let request = types::xinput::GetDeviceButtonMappingRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_button_mapping_immediate<'this>(&'this mut self, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceButtonMappingReply> {
        let request = types::xinput::GetDeviceButtonMappingRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceButtonMappingReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_button_mapping<'this>(&'this mut self, device_id: types::Card8, map: impl AsRef<[types::Card8]>) -> futures::SendRequest<'this, Self, types::xinput::SetDeviceButtonMappingReply> {
        let span = tracing::info_span!(
            "xinput_set_device_button_mapping",
            device_id = ?device_id,
        );
        let request = types::xinput::SetDeviceButtonMappingRequest {
            device_id,
            map: Cow::Borrowed(map.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_button_mapping_immediate<'this>(&'this mut self, device_id: types::Card8, map: impl AsRef<[types::Card8]>) -> futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceButtonMappingReply> {
        let request = types::xinput::SetDeviceButtonMappingRequest {
            device_id,
            map: Cow::Borrowed(map.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceButtonMappingReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_query_device_state<'this>(&'this mut self, device_id: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::QueryDeviceStateReply> {
        let span = tracing::info_span!(
            "xinput_query_device_state",
            device_id = ?device_id,
        );
        let request = types::xinput::QueryDeviceStateRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_query_device_state_immediate<'this>(&'this mut self, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::QueryDeviceStateReply> {
        let request = types::xinput::QueryDeviceStateRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::QueryDeviceStateReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_device_bell<'this>(&'this mut self, device_id: types::Card8, feedback_id: types::Card8, feedback_class: types::Card8, percent: types::Int8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_device_bell",
            device_id = ?device_id,
            feedback_id = ?feedback_id,
            feedback_class = ?feedback_class,
            percent = ?percent,
        );
        let request = types::xinput::DeviceBellRequest {
            device_id,
            feedback_id,
            feedback_class,
            percent,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_device_bell_checked<'this>(&'this mut self, device_id: types::Card8, feedback_id: types::Card8, feedback_class: types::Card8, percent: types::Int8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::DeviceBellRequest {
            device_id,
            feedback_id,
            feedback_class,
            percent,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_valuators<'this>(&'this mut self, device_id: types::Card8, first_valuator: types::Card8, valuators: impl AsRef<[types::Int32]>) -> futures::SendRequest<'this, Self, types::xinput::SetDeviceValuatorsReply> {
        let span = tracing::info_span!(
            "xinput_set_device_valuators",
            device_id = ?device_id,
            first_valuator = ?first_valuator,
        );
        let request = types::xinput::SetDeviceValuatorsRequest {
            device_id,
            first_valuator,
            valuators: Cow::Borrowed(valuators.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_valuators_immediate<'this>(&'this mut self, device_id: types::Card8, first_valuator: types::Card8, valuators: impl AsRef<[types::Int32]>) -> futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceValuatorsReply> {
        let request = types::xinput::SetDeviceValuatorsRequest {
            device_id,
            first_valuator,
            valuators: Cow::Borrowed(valuators.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceValuatorsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_control<'this>(&'this mut self, control_id: types::DeviceControl, device_id: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::GetDeviceControlReply> {
        let span = tracing::info_span!(
            "xinput_get_device_control",
            control_id = ?control_id,
            device_id = ?device_id,
        );
        let request = types::xinput::GetDeviceControlRequest {
            control_id,
            device_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_control_immediate<'this>(&'this mut self, control_id: types::DeviceControl, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceControlReply> {
        let request = types::xinput::GetDeviceControlRequest {
            control_id,
            device_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceControlReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_control<'this>(&'this mut self, control_id: types::DeviceControl, device_id: types::Card8, control: types::DeviceCtl) -> futures::SendRequest<'this, Self, types::xinput::ChangeDeviceControlReply> {
        let span = tracing::info_span!(
            "xinput_change_device_control",
            control_id = ?control_id,
            device_id = ?device_id,
            control = ?control,
        );
        let request = types::xinput::ChangeDeviceControlRequest {
            control_id,
            device_id,
            control,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_control_immediate<'this>(&'this mut self, control_id: types::DeviceControl, device_id: types::Card8, control: types::DeviceCtl) -> futures::CheckedSendRequest<'this, Self, types::xinput::ChangeDeviceControlReply> {
        let request = types::xinput::ChangeDeviceControlRequest {
            control_id,
            device_id,
            control,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::ChangeDeviceControlReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_device_properties<'this>(&'this mut self, device_id: types::Card8) -> futures::SendRequest<'this, Self, types::xinput::ListDevicePropertiesReply> {
        let span = tracing::info_span!(
            "xinput_list_device_properties",
            device_id = ?device_id,
        );
        let request = types::xinput::ListDevicePropertiesRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_device_properties_immediate<'this>(&'this mut self, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xinput::ListDevicePropertiesReply> {
        let request = types::xinput::ListDevicePropertiesRequest {
            device_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::ListDevicePropertiesReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_property<'this>(&'this mut self, property: types::Atom, type_: types::Atom, device_id: types::Card8, mode: types::PropMode, num_items: types::Card32, items: impl Borrow<types::xinput::ChangeDevicePropertyAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_change_device_property",
            property = ?property,
            type_ = ?type_,
            device_id = ?device_id,
            mode = ?mode,
            num_items = ?num_items,
        );
        let request = types::xinput::ChangeDevicePropertyRequest {
            property,
            type_,
            device_id,
            mode,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_property_checked<'this>(&'this mut self, property: types::Atom, type_: types::Atom, device_id: types::Card8, mode: types::PropMode, num_items: types::Card32, items: impl Borrow<types::xinput::ChangeDevicePropertyAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::ChangeDevicePropertyRequest {
            property,
            type_,
            device_id,
            mode,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_delete_device_property<'this>(&'this mut self, property: types::Atom, device_id: types::Card8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_delete_device_property",
            property = ?property,
            device_id = ?device_id,
        );
        let request = types::xinput::DeleteDevicePropertyRequest {
            property,
            device_id,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_delete_device_property_checked<'this>(&'this mut self, property: types::Atom, device_id: types::Card8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::DeleteDevicePropertyRequest {
            property,
            device_id,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_property<'this>(&'this mut self, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32, device_id: types::Card8, delete: types::Bool) -> futures::SendRequest<'this, Self, types::xinput::GetDevicePropertyReply> {
        let span = tracing::info_span!(
            "xinput_get_device_property",
            property = ?property,
            type_ = ?type_,
            offset = ?offset,
            len = ?len,
            device_id = ?device_id,
            delete = ?delete,
        );
        let request = types::xinput::GetDevicePropertyRequest {
            property,
            type_,
            offset,
            len,
            device_id,
            delete,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_property_immediate<'this>(&'this mut self, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32, device_id: types::Card8, delete: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::xinput::GetDevicePropertyReply> {
        let request = types::xinput::GetDevicePropertyRequest {
            property,
            type_,
            offset,
            len,
            device_id,
            delete,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDevicePropertyReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_pointer<'this>(&'this mut self, window: types::xproto::Window, deviceid: impl Into<types::Device>) -> futures::SendRequest<'this, Self, types::xinput::XIQueryPointerReply> {
        let span = tracing::info_span!(
            "xinput_xi_query_pointer",
            window = ?window,
        );
        let request = types::xinput::XIQueryPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_pointer_immediate<'this>(&'this mut self, window: types::xproto::Window, deviceid: impl Into<types::Device>) -> futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryPointerReply> {
        let request = types::xinput::XIQueryPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryPointerReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_warp_pointer<'this>(&'this mut self, src_win: types::xproto::Window, dst_win: types::xproto::Window, src_x: types::Fp1616, src_y: types::Fp1616, src_width: types::Card16, src_height: types::Card16, dst_x: types::Fp1616, dst_y: types::Fp1616, deviceid: impl Into<types::Device>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_warp_pointer",
            src_win = ?src_win,
            dst_win = ?dst_win,
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
        );
        let request = types::xinput::XIWarpPointerRequest {
            src_win,
            dst_win,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_warp_pointer_checked<'this>(&'this mut self, src_win: types::xproto::Window, dst_win: types::xproto::Window, src_x: types::Fp1616, src_y: types::Fp1616, src_width: types::Card16, src_height: types::Card16, dst_x: types::Fp1616, dst_y: types::Fp1616, deviceid: impl Into<types::Device>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XIWarpPointerRequest {
            src_win,
            dst_win,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_cursor<'this>(&'this mut self, window: types::xproto::Window, cursor: types::xproto::Cursor, deviceid: impl Into<types::Device>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_change_cursor",
            window = ?window,
            cursor = ?cursor,
        );
        let request = types::xinput::XIChangeCursorRequest {
            window,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_cursor_checked<'this>(&'this mut self, window: types::xproto::Window, cursor: types::xproto::Cursor, deviceid: impl Into<types::Device>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XIChangeCursorRequest {
            window,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_hierarchy<'this>(&'this mut self, changes: impl AsRef<[types::HierarchyChange]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_change_hierarchy",
        );
        let request = types::xinput::XIChangeHierarchyRequest {
            changes: Cow::Borrowed(changes.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_hierarchy_checked<'this>(&'this mut self, changes: impl AsRef<[types::HierarchyChange]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XIChangeHierarchyRequest {
            changes: Cow::Borrowed(changes.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_client_pointer<'this>(&'this mut self, window: types::xproto::Window, deviceid: impl Into<types::Device>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_set_client_pointer",
            window = ?window,
        );
        let request = types::xinput::XISetClientPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_client_pointer_checked<'this>(&'this mut self, window: types::xproto::Window, deviceid: impl Into<types::Device>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XISetClientPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_client_pointer<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xinput::XIGetClientPointerReply> {
        let span = tracing::info_span!(
            "xinput_xi_get_client_pointer",
            window = ?window,
        );
        let request = types::xinput::XIGetClientPointerRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_client_pointer_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xinput::XIGetClientPointerReply> {
        let request = types::xinput::XIGetClientPointerRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIGetClientPointerReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_select_events<'this>(&'this mut self, window: types::xproto::Window, masks: impl AsRef<[types::xinput::EventMask]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_select_events",
            window = ?window,
        );
        let request = types::xinput::XISelectEventsRequest {
            window,
            masks: Cow::Borrowed(masks.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_select_events_checked<'this>(&'this mut self, window: types::xproto::Window, masks: impl AsRef<[types::xinput::EventMask]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XISelectEventsRequest {
            window,
            masks: Cow::Borrowed(masks.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_version<'this>(&'this mut self, major_version: types::Card16, minor_version: types::Card16) -> futures::SendRequest<'this, Self, types::xinput::XIQueryVersionReply> {
        let span = tracing::info_span!(
            "xinput_xi_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::xinput::XIQueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_version_immediate<'this>(&'this mut self, major_version: types::Card16, minor_version: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryVersionReply> {
        let request = types::xinput::XIQueryVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_device<'this>(&'this mut self, deviceid: impl Into<types::Device>) -> futures::SendRequest<'this, Self, types::xinput::XIQueryDeviceReply> {
        let span = tracing::info_span!(
            "xinput_xi_query_device",
        );
        let request = types::xinput::XIQueryDeviceRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_device_immediate<'this>(&'this mut self, deviceid: impl Into<types::Device>) -> futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryDeviceReply> {
        let request = types::xinput::XIQueryDeviceRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryDeviceReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_focus<'this>(&'this mut self, window: types::xproto::Window, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_set_focus",
            window = ?window,
        );
        let request = types::xinput::XISetFocusRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_focus_checked<'this>(&'this mut self, window: types::xproto::Window, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XISetFocusRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_focus<'this>(&'this mut self, deviceid: impl Into<types::Device>) -> futures::SendRequest<'this, Self, types::xinput::XIGetFocusReply> {
        let span = tracing::info_span!(
            "xinput_xi_get_focus",
        );
        let request = types::xinput::XIGetFocusRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_focus_immediate<'this>(&'this mut self, deviceid: impl Into<types::Device>) -> futures::CheckedSendRequest<'this, Self, types::xinput::XIGetFocusReply> {
        let request = types::xinput::XIGetFocusRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIGetFocusReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_grab_device<'this>(&'this mut self, window: types::xproto::Window, time: impl Into<types::Time>, cursor: types::xproto::Cursor, deviceid: impl Into<types::Device>, mode: types::GrabMode, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, types::xinput::XIGrabDeviceReply> {
        let span = tracing::info_span!(
            "xinput_xi_grab_device",
            window = ?window,
            cursor = ?cursor,
            mode = ?mode,
            paired_device_mode = ?paired_device_mode,
            owner_events = ?owner_events,
        );
        let request = types::xinput::XIGrabDeviceRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_grab_device_immediate<'this>(&'this mut self, window: types::xproto::Window, time: impl Into<types::Time>, cursor: types::xproto::Cursor, deviceid: impl Into<types::Device>, mode: types::GrabMode, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, types::xinput::XIGrabDeviceReply> {
        let request = types::xinput::XIGrabDeviceRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIGrabDeviceReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_ungrab_device<'this>(&'this mut self, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_ungrab_device",
        );
        let request = types::xinput::XIUngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_ungrab_device_checked<'this>(&'this mut self, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XIUngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_allow_events<'this>(&'this mut self, time: impl Into<types::Time>, deviceid: impl Into<types::Device>, event_mode: types::EventMode, touchid: types::Card32, grab_window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_allow_events",
            event_mode = ?event_mode,
            touchid = ?touchid,
            grab_window = ?grab_window,
        );
        let request = types::xinput::XIAllowEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            event_mode,
            touchid,
            grab_window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_allow_events_checked<'this>(&'this mut self, time: impl Into<types::Time>, deviceid: impl Into<types::Device>, event_mode: types::EventMode, touchid: types::Card32, grab_window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XIAllowEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            event_mode,
            touchid,
            grab_window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_grab_device<'this>(&'this mut self, time: impl Into<types::Time>, grab_window: types::xproto::Window, cursor: types::xproto::Cursor, detail: types::Card32, deviceid: impl Into<types::Device>, grab_type: types::GrabType, grab_mode: types::GrabMode22, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask: impl AsRef<[types::Card32]>, modifiers: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, types::xinput::XIPassiveGrabDeviceReply> {
        let span = tracing::info_span!(
            "xinput_xi_passive_grab_device",
            grab_window = ?grab_window,
            cursor = ?cursor,
            detail = ?detail,
            grab_type = ?grab_type,
            grab_mode = ?grab_mode,
            paired_device_mode = ?paired_device_mode,
            owner_events = ?owner_events,
        );
        let request = types::xinput::XIPassiveGrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            grab_window,
            cursor,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            grab_mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_grab_device_immediate<'this>(&'this mut self, time: impl Into<types::Time>, grab_window: types::xproto::Window, cursor: types::xproto::Cursor, detail: types::Card32, deviceid: impl Into<types::Device>, grab_type: types::GrabType, grab_mode: types::GrabMode22, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask: impl AsRef<[types::Card32]>, modifiers: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, types::xinput::XIPassiveGrabDeviceReply> {
        let request = types::xinput::XIPassiveGrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            grab_window,
            cursor,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            grab_mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIPassiveGrabDeviceReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_ungrab_device<'this>(&'this mut self, grab_window: types::xproto::Window, detail: types::Card32, deviceid: impl Into<types::Device>, grab_type: types::GrabType, modifiers: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_passive_ungrab_device",
            grab_window = ?grab_window,
            detail = ?detail,
            grab_type = ?grab_type,
        );
        let request = types::xinput::XIPassiveUngrabDeviceRequest {
            grab_window,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_ungrab_device_checked<'this>(&'this mut self, grab_window: types::xproto::Window, detail: types::Card32, deviceid: impl Into<types::Device>, grab_type: types::GrabType, modifiers: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XIPassiveUngrabDeviceRequest {
            grab_window,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_list_properties<'this>(&'this mut self, deviceid: impl Into<types::Device>) -> futures::SendRequest<'this, Self, types::xinput::XIListPropertiesReply> {
        let span = tracing::info_span!(
            "xinput_xi_list_properties",
        );
        let request = types::xinput::XIListPropertiesRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_list_properties_immediate<'this>(&'this mut self, deviceid: impl Into<types::Device>) -> futures::CheckedSendRequest<'this, Self, types::xinput::XIListPropertiesReply> {
        let request = types::xinput::XIListPropertiesRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIListPropertiesReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_property<'this>(&'this mut self, deviceid: impl Into<types::Device>, mode: types::PropMode, property: types::Atom, type_: types::Atom, num_items: types::Card32, items: impl Borrow<types::xinput::XIChangePropertyAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_change_property",
            mode = ?mode,
            property = ?property,
            type_ = ?type_,
            num_items = ?num_items,
        );
        let request = types::xinput::XIChangePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            property,
            type_,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_property_checked<'this>(&'this mut self, deviceid: impl Into<types::Device>, mode: types::PropMode, property: types::Atom, type_: types::Atom, num_items: types::Card32, items: impl Borrow<types::xinput::XIChangePropertyAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XIChangePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            property,
            type_,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_delete_property<'this>(&'this mut self, deviceid: impl Into<types::Device>, property: types::Atom) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_delete_property",
            property = ?property,
        );
        let request = types::xinput::XIDeletePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            property,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_delete_property_checked<'this>(&'this mut self, deviceid: impl Into<types::Device>, property: types::Atom) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XIDeletePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            property,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_property<'this>(&'this mut self, deviceid: impl Into<types::Device>, delete: types::Bool, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32) -> futures::SendRequest<'this, Self, types::xinput::XIGetPropertyReply> {
        let span = tracing::info_span!(
            "xinput_xi_get_property",
            delete = ?delete,
            property = ?property,
            type_ = ?type_,
            offset = ?offset,
            len = ?len,
        );
        let request = types::xinput::XIGetPropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            delete,
            property,
            type_,
            offset,
            len,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_property_immediate<'this>(&'this mut self, deviceid: impl Into<types::Device>, delete: types::Bool, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xinput::XIGetPropertyReply> {
        let request = types::xinput::XIGetPropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            delete,
            property,
            type_,
            offset,
            len,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIGetPropertyReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_selected_events<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xinput::XIGetSelectedEventsReply> {
        let span = tracing::info_span!(
            "xinput_xi_get_selected_events",
            window = ?window,
        );
        let request = types::xinput::XIGetSelectedEventsRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_selected_events_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xinput::XIGetSelectedEventsReply> {
        let request = types::xinput::XIGetSelectedEventsRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIGetSelectedEventsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_barrier_release_pointer<'this>(&'this mut self, barriers: impl AsRef<[types::BarrierReleasePointerInfo]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_xi_barrier_release_pointer",
        );
        let request = types::xinput::XIBarrierReleasePointerRequest {
            barriers: Cow::Borrowed(barriers.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_barrier_release_pointer_checked<'this>(&'this mut self, barriers: impl AsRef<[types::BarrierReleasePointerInfo]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::XIBarrierReleasePointerRequest {
            barriers: Cow::Borrowed(barriers.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xinput")]
    fn xinput_send_extension_event<'this>(&'this mut self, destination: types::xproto::Window, device_id: types::Card8, propagate: types::Bool, events: impl AsRef<[types::EventForSend]>, classes: impl AsRef<[types::EventClass]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xinput_send_extension_event",
            destination = ?destination,
            device_id = ?device_id,
            propagate = ?propagate,
        );
        let request = types::xinput::SendExtensionEventRequest {
            destination,
            device_id,
            propagate,
            events: Cow::Borrowed(events.as_ref()),
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xinput")]
    fn xinput_send_extension_event_checked<'this>(&'this mut self, destination: types::xproto::Window, device_id: types::Card8, propagate: types::Bool, events: impl AsRef<[types::EventForSend]>, classes: impl AsRef<[types::EventClass]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xinput::SendExtensionEventRequest {
            destination,
            device_id,
            propagate,
            events: Cow::Borrowed(events.as_ref()),
            classes: Cow::Borrowed(classes.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    #[cfg(feature = "xkb")]
    fn xkb_use_extension<'this>(&'this mut self, wanted_major: types::Card16, wanted_minor: types::Card16) -> futures::SendRequest<'this, Self, types::xkb::UseExtensionReply> {
        let span = tracing::info_span!(
            "xkb_use_extension",
            wanted_major = ?wanted_major,
            wanted_minor = ?wanted_minor,
        );
        let request = types::xkb::UseExtensionRequest {
            wanted_major,
            wanted_minor,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_use_extension_immediate<'this>(&'this mut self, wanted_major: types::Card16, wanted_minor: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xkb::UseExtensionReply> {
        let request = types::xkb::UseExtensionRequest {
            wanted_major,
            wanted_minor,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::UseExtensionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_select_events<'this>(&'this mut self, device_spec: types::DeviceSpec, clear: impl Into<types::xkb::EventType>, select_all: impl Into<types::xkb::EventType>, affect_map: impl Into<types::MapPart>, map: impl Into<types::MapPart>, details: impl Borrow<types::xkb::SelectEventsAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xkb_select_events",
            device_spec = ?device_spec,
        );
        let request = types::xkb::SelectEventsRequest {
            device_spec,
            clear: Into::<u32>::into(clear.into()) as _,
            select_all: Into::<u32>::into(select_all.into()) as _,
            affect_map: Into::<u32>::into(affect_map.into()) as _,
            map: Into::<u32>::into(map.into()) as _,
            details: Cow::Borrowed(details.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_select_events_checked<'this>(&'this mut self, device_spec: types::DeviceSpec, clear: impl Into<types::xkb::EventType>, select_all: impl Into<types::xkb::EventType>, affect_map: impl Into<types::MapPart>, map: impl Into<types::MapPart>, details: impl Borrow<types::xkb::SelectEventsAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xkb::SelectEventsRequest {
            device_spec,
            clear: Into::<u32>::into(clear.into()) as _,
            select_all: Into::<u32>::into(select_all.into()) as _,
            affect_map: Into::<u32>::into(affect_map.into()) as _,
            map: Into::<u32>::into(map.into()) as _,
            details: Cow::Borrowed(details.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_bell<'this>(&'this mut self, device_spec: types::DeviceSpec, bell_class: types::BellClassSpec, bell_id: types::IDSpec, percent: types::Int8, force_sound: types::Bool, event_only: types::Bool, pitch: types::Int16, duration: types::Int16, name: types::Atom, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xkb_bell",
            device_spec = ?device_spec,
            bell_class = ?bell_class,
            bell_id = ?bell_id,
            percent = ?percent,
            force_sound = ?force_sound,
            event_only = ?event_only,
            pitch = ?pitch,
            duration = ?duration,
            name = ?name,
            window = ?window,
        );
        let request = types::xkb::BellRequest {
            device_spec,
            bell_class,
            bell_id,
            percent,
            force_sound,
            event_only,
            pitch,
            duration,
            name,
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_bell_checked<'this>(&'this mut self, device_spec: types::DeviceSpec, bell_class: types::BellClassSpec, bell_id: types::IDSpec, percent: types::Int8, force_sound: types::Bool, event_only: types::Bool, pitch: types::Int16, duration: types::Int16, name: types::Atom, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xkb::BellRequest {
            device_spec,
            bell_class,
            bell_id,
            percent,
            force_sound,
            event_only,
            pitch,
            duration,
            name,
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_state<'this>(&'this mut self, device_spec: types::DeviceSpec) -> futures::SendRequest<'this, Self, types::xkb::GetStateReply> {
        let span = tracing::info_span!(
            "xkb_get_state",
            device_spec = ?device_spec,
        );
        let request = types::xkb::GetStateRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_state_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec) -> futures::CheckedSendRequest<'this, Self, types::xkb::GetStateReply> {
        let request = types::xkb::GetStateRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetStateReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_latch_lock_state<'this>(&'this mut self, device_spec: types::DeviceSpec, affect_mod_locks: impl Into<types::ModMask>, mod_locks: impl Into<types::ModMask>, lock_group: types::Bool, group_lock: types::Group, affect_mod_latches: impl Into<types::ModMask>, latch_group: types::Bool, group_latch: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xkb_latch_lock_state",
            device_spec = ?device_spec,
            lock_group = ?lock_group,
            group_lock = ?group_lock,
            latch_group = ?latch_group,
            group_latch = ?group_latch,
        );
        let request = types::xkb::LatchLockStateRequest {
            device_spec,
            affect_mod_locks: Into::<u32>::into(affect_mod_locks.into()) as _,
            mod_locks: Into::<u32>::into(mod_locks.into()) as _,
            lock_group,
            group_lock,
            affect_mod_latches: Into::<u32>::into(affect_mod_latches.into()) as _,
            latch_group,
            group_latch,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_latch_lock_state_checked<'this>(&'this mut self, device_spec: types::DeviceSpec, affect_mod_locks: impl Into<types::ModMask>, mod_locks: impl Into<types::ModMask>, lock_group: types::Bool, group_lock: types::Group, affect_mod_latches: impl Into<types::ModMask>, latch_group: types::Bool, group_latch: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xkb::LatchLockStateRequest {
            device_spec,
            affect_mod_locks: Into::<u32>::into(affect_mod_locks.into()) as _,
            mod_locks: Into::<u32>::into(mod_locks.into()) as _,
            lock_group,
            group_lock,
            affect_mod_latches: Into::<u32>::into(affect_mod_latches.into()) as _,
            latch_group,
            group_latch,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_controls<'this>(&'this mut self, device_spec: types::DeviceSpec) -> futures::SendRequest<'this, Self, types::xkb::GetControlsReply> {
        let span = tracing::info_span!(
            "xkb_get_controls",
            device_spec = ?device_spec,
        );
        let request = types::xkb::GetControlsRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_controls_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec) -> futures::CheckedSendRequest<'this, Self, types::xkb::GetControlsReply> {
        let request = types::xkb::GetControlsRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetControlsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_controls<'this>(&'this mut self, device_spec: types::DeviceSpec, affect_internal_real_mods: impl Into<types::ModMask>, internal_real_mods: impl Into<types::ModMask>, affect_ignore_lock_real_mods: impl Into<types::ModMask>, ignore_lock_real_mods: impl Into<types::ModMask>, affect_internal_virtual_mods: impl Into<types::VMod>, internal_virtual_mods: impl Into<types::VMod>, affect_ignore_lock_virtual_mods: impl Into<types::VMod>, ignore_lock_virtual_mods: impl Into<types::VMod>, mouse_keys_dflt_btn: types::Card8, groups_wrap: types::Card8, access_x_options: impl Into<types::AXOption>, affect_enabled_controls: impl Into<types::BoolCtrl>, enabled_controls: impl Into<types::BoolCtrl>, change_controls: impl Into<types::Control>, repeat_delay: types::Card16, repeat_interval: types::Card16, slow_keys_delay: types::Card16, debounce_delay: types::Card16, mouse_keys_delay: types::Card16, mouse_keys_interval: types::Card16, mouse_keys_time_to_max: types::Card16, mouse_keys_max_speed: types::Card16, mouse_keys_curve: types::Int16, access_x_timeout: types::Card16, access_x_timeout_mask: impl Into<types::BoolCtrl>, access_x_timeout_values: impl Into<types::BoolCtrl>, access_x_timeout_options_mask: impl Into<types::AXOption>, access_x_timeout_options_values: impl Into<types::AXOption>, per_key_repeat: impl Borrow<[types::Card8; 32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xkb_set_controls",
            device_spec = ?device_spec,
            mouse_keys_dflt_btn = ?mouse_keys_dflt_btn,
            groups_wrap = ?groups_wrap,
            repeat_delay = ?repeat_delay,
            repeat_interval = ?repeat_interval,
            slow_keys_delay = ?slow_keys_delay,
            debounce_delay = ?debounce_delay,
            mouse_keys_delay = ?mouse_keys_delay,
            mouse_keys_interval = ?mouse_keys_interval,
            mouse_keys_time_to_max = ?mouse_keys_time_to_max,
            mouse_keys_max_speed = ?mouse_keys_max_speed,
            mouse_keys_curve = ?mouse_keys_curve,
            access_x_timeout = ?access_x_timeout,
        );
        let request = types::xkb::SetControlsRequest {
            device_spec,
            affect_internal_real_mods: Into::<u32>::into(affect_internal_real_mods.into()) as _,
            internal_real_mods: Into::<u32>::into(internal_real_mods.into()) as _,
            affect_ignore_lock_real_mods: Into::<u32>::into(affect_ignore_lock_real_mods.into()) as _,
            ignore_lock_real_mods: Into::<u32>::into(ignore_lock_real_mods.into()) as _,
            affect_internal_virtual_mods: Into::<u32>::into(affect_internal_virtual_mods.into()) as _,
            internal_virtual_mods: Into::<u32>::into(internal_virtual_mods.into()) as _,
            affect_ignore_lock_virtual_mods: Into::<u32>::into(affect_ignore_lock_virtual_mods.into()) as _,
            ignore_lock_virtual_mods: Into::<u32>::into(ignore_lock_virtual_mods.into()) as _,
            mouse_keys_dflt_btn,
            groups_wrap,
            access_x_options: Into::<u32>::into(access_x_options.into()) as _,
            affect_enabled_controls: Into::<u32>::into(affect_enabled_controls.into()) as _,
            enabled_controls: Into::<u32>::into(enabled_controls.into()) as _,
            change_controls: Into::<u32>::into(change_controls.into()) as _,
            repeat_delay,
            repeat_interval,
            slow_keys_delay,
            debounce_delay,
            mouse_keys_delay,
            mouse_keys_interval,
            mouse_keys_time_to_max,
            mouse_keys_max_speed,
            mouse_keys_curve,
            access_x_timeout,
            access_x_timeout_mask: Into::<u32>::into(access_x_timeout_mask.into()) as _,
            access_x_timeout_values: Into::<u32>::into(access_x_timeout_values.into()) as _,
            access_x_timeout_options_mask: Into::<u32>::into(access_x_timeout_options_mask.into()) as _,
            access_x_timeout_options_values: Into::<u32>::into(access_x_timeout_options_values.into()) as _,
            per_key_repeat: Cow::Borrowed(per_key_repeat.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_controls_checked<'this>(&'this mut self, device_spec: types::DeviceSpec, affect_internal_real_mods: impl Into<types::ModMask>, internal_real_mods: impl Into<types::ModMask>, affect_ignore_lock_real_mods: impl Into<types::ModMask>, ignore_lock_real_mods: impl Into<types::ModMask>, affect_internal_virtual_mods: impl Into<types::VMod>, internal_virtual_mods: impl Into<types::VMod>, affect_ignore_lock_virtual_mods: impl Into<types::VMod>, ignore_lock_virtual_mods: impl Into<types::VMod>, mouse_keys_dflt_btn: types::Card8, groups_wrap: types::Card8, access_x_options: impl Into<types::AXOption>, affect_enabled_controls: impl Into<types::BoolCtrl>, enabled_controls: impl Into<types::BoolCtrl>, change_controls: impl Into<types::Control>, repeat_delay: types::Card16, repeat_interval: types::Card16, slow_keys_delay: types::Card16, debounce_delay: types::Card16, mouse_keys_delay: types::Card16, mouse_keys_interval: types::Card16, mouse_keys_time_to_max: types::Card16, mouse_keys_max_speed: types::Card16, mouse_keys_curve: types::Int16, access_x_timeout: types::Card16, access_x_timeout_mask: impl Into<types::BoolCtrl>, access_x_timeout_values: impl Into<types::BoolCtrl>, access_x_timeout_options_mask: impl Into<types::AXOption>, access_x_timeout_options_values: impl Into<types::AXOption>, per_key_repeat: impl Borrow<[types::Card8; 32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xkb::SetControlsRequest {
            device_spec,
            affect_internal_real_mods: Into::<u32>::into(affect_internal_real_mods.into()) as _,
            internal_real_mods: Into::<u32>::into(internal_real_mods.into()) as _,
            affect_ignore_lock_real_mods: Into::<u32>::into(affect_ignore_lock_real_mods.into()) as _,
            ignore_lock_real_mods: Into::<u32>::into(ignore_lock_real_mods.into()) as _,
            affect_internal_virtual_mods: Into::<u32>::into(affect_internal_virtual_mods.into()) as _,
            internal_virtual_mods: Into::<u32>::into(internal_virtual_mods.into()) as _,
            affect_ignore_lock_virtual_mods: Into::<u32>::into(affect_ignore_lock_virtual_mods.into()) as _,
            ignore_lock_virtual_mods: Into::<u32>::into(ignore_lock_virtual_mods.into()) as _,
            mouse_keys_dflt_btn,
            groups_wrap,
            access_x_options: Into::<u32>::into(access_x_options.into()) as _,
            affect_enabled_controls: Into::<u32>::into(affect_enabled_controls.into()) as _,
            enabled_controls: Into::<u32>::into(enabled_controls.into()) as _,
            change_controls: Into::<u32>::into(change_controls.into()) as _,
            repeat_delay,
            repeat_interval,
            slow_keys_delay,
            debounce_delay,
            mouse_keys_delay,
            mouse_keys_interval,
            mouse_keys_time_to_max,
            mouse_keys_max_speed,
            mouse_keys_curve,
            access_x_timeout,
            access_x_timeout_mask: Into::<u32>::into(access_x_timeout_mask.into()) as _,
            access_x_timeout_values: Into::<u32>::into(access_x_timeout_values.into()) as _,
            access_x_timeout_options_mask: Into::<u32>::into(access_x_timeout_options_mask.into()) as _,
            access_x_timeout_options_values: Into::<u32>::into(access_x_timeout_options_values.into()) as _,
            per_key_repeat: Cow::Borrowed(per_key_repeat.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_map<'this>(&'this mut self, device_spec: types::DeviceSpec, full: impl Into<types::MapPart>, partial: impl Into<types::MapPart>, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, first_key_action: types::Keycode, n_key_actions: types::Card8, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, virtual_mods: impl Into<types::VMod>, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8) -> futures::SendRequest<'this, Self, types::xkb::GetMapReply> {
        let span = tracing::info_span!(
            "xkb_get_map",
            device_spec = ?device_spec,
            first_type = ?first_type,
            n_types = ?n_types,
            first_key_sym = ?first_key_sym,
            n_key_syms = ?n_key_syms,
            first_key_action = ?first_key_action,
            n_key_actions = ?n_key_actions,
            first_key_behavior = ?first_key_behavior,
            n_key_behaviors = ?n_key_behaviors,
            first_key_explicit = ?first_key_explicit,
            n_key_explicit = ?n_key_explicit,
            first_mod_map_key = ?first_mod_map_key,
            n_mod_map_keys = ?n_mod_map_keys,
            first_v_mod_map_key = ?first_v_mod_map_key,
            n_v_mod_map_keys = ?n_v_mod_map_keys,
        );
        let request = types::xkb::GetMapRequest {
            device_spec,
            full: Into::<u32>::into(full.into()) as _,
            partial: Into::<u32>::into(partial.into()) as _,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            first_key_action,
            n_key_actions,
            first_key_behavior,
            n_key_behaviors,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_key_explicit,
            n_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_map_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec, full: impl Into<types::MapPart>, partial: impl Into<types::MapPart>, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, first_key_action: types::Keycode, n_key_actions: types::Card8, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, virtual_mods: impl Into<types::VMod>, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xkb::GetMapReply> {
        let request = types::xkb::GetMapRequest {
            device_spec,
            full: Into::<u32>::into(full.into()) as _,
            partial: Into::<u32>::into(partial.into()) as _,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            first_key_action,
            n_key_actions,
            first_key_behavior,
            n_key_behaviors,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_key_explicit,
            n_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetMapReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_map<'this>(&'this mut self, device_spec: types::DeviceSpec, flags: impl Into<types::SetMapFlags>, min_key_code: types::Keycode, max_key_code: types::Keycode, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, total_syms: types::Card16, first_key_action: types::Keycode, n_key_actions: types::Card8, total_actions: types::Card16, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, total_key_behaviors: types::Card8, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, total_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, total_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8, total_v_mod_map_keys: types::Card8, virtual_mods: impl Into<types::VMod>, values: impl Borrow<types::xkb::SetMapAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xkb_set_map",
            device_spec = ?device_spec,
            min_key_code = ?min_key_code,
            max_key_code = ?max_key_code,
            first_type = ?first_type,
            n_types = ?n_types,
            first_key_sym = ?first_key_sym,
            n_key_syms = ?n_key_syms,
            total_syms = ?total_syms,
            first_key_action = ?first_key_action,
            n_key_actions = ?n_key_actions,
            total_actions = ?total_actions,
            first_key_behavior = ?first_key_behavior,
            n_key_behaviors = ?n_key_behaviors,
            total_key_behaviors = ?total_key_behaviors,
            first_key_explicit = ?first_key_explicit,
            n_key_explicit = ?n_key_explicit,
            total_key_explicit = ?total_key_explicit,
            first_mod_map_key = ?first_mod_map_key,
            n_mod_map_keys = ?n_mod_map_keys,
            total_mod_map_keys = ?total_mod_map_keys,
            first_v_mod_map_key = ?first_v_mod_map_key,
            n_v_mod_map_keys = ?n_v_mod_map_keys,
            total_v_mod_map_keys = ?total_v_mod_map_keys,
        );
        let request = types::xkb::SetMapRequest {
            device_spec,
            flags: Into::<u32>::into(flags.into()) as _,
            min_key_code,
            max_key_code,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            total_syms,
            first_key_action,
            n_key_actions,
            total_actions,
            first_key_behavior,
            n_key_behaviors,
            total_key_behaviors,
            first_key_explicit,
            n_key_explicit,
            total_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            total_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
            total_v_mod_map_keys,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            values: Cow::Borrowed(values.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_map_checked<'this>(&'this mut self, device_spec: types::DeviceSpec, flags: impl Into<types::SetMapFlags>, min_key_code: types::Keycode, max_key_code: types::Keycode, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, total_syms: types::Card16, first_key_action: types::Keycode, n_key_actions: types::Card8, total_actions: types::Card16, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, total_key_behaviors: types::Card8, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, total_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, total_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8, total_v_mod_map_keys: types::Card8, virtual_mods: impl Into<types::VMod>, values: impl Borrow<types::xkb::SetMapAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xkb::SetMapRequest {
            device_spec,
            flags: Into::<u32>::into(flags.into()) as _,
            min_key_code,
            max_key_code,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            total_syms,
            first_key_action,
            n_key_actions,
            total_actions,
            first_key_behavior,
            n_key_behaviors,
            total_key_behaviors,
            first_key_explicit,
            n_key_explicit,
            total_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            total_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
            total_v_mod_map_keys,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            values: Cow::Borrowed(values.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_compat_map<'this>(&'this mut self, device_spec: types::DeviceSpec, groups: impl Into<types::SetOfGroup>, get_all_si: types::Bool, first_si: types::Card16, n_si: types::Card16) -> futures::SendRequest<'this, Self, types::xkb::GetCompatMapReply> {
        let span = tracing::info_span!(
            "xkb_get_compat_map",
            device_spec = ?device_spec,
            get_all_si = ?get_all_si,
            first_si = ?first_si,
            n_si = ?n_si,
        );
        let request = types::xkb::GetCompatMapRequest {
            device_spec,
            groups: Into::<u32>::into(groups.into()) as _,
            get_all_si,
            first_si,
            n_si,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_compat_map_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec, groups: impl Into<types::SetOfGroup>, get_all_si: types::Bool, first_si: types::Card16, n_si: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xkb::GetCompatMapReply> {
        let request = types::xkb::GetCompatMapRequest {
            device_spec,
            groups: Into::<u32>::into(groups.into()) as _,
            get_all_si,
            first_si,
            n_si,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetCompatMapReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_compat_map<'this>(&'this mut self, device_spec: types::DeviceSpec, recompute_actions: types::Bool, truncate_si: types::Bool, groups: impl Into<types::SetOfGroup>, first_si: types::Card16, si: impl AsRef<[types::SymInterpret]>, group_maps: impl AsRef<[types::ModDef]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xkb_set_compat_map",
            device_spec = ?device_spec,
            recompute_actions = ?recompute_actions,
            truncate_si = ?truncate_si,
            first_si = ?first_si,
        );
        let request = types::xkb::SetCompatMapRequest {
            device_spec,
            recompute_actions,
            truncate_si,
            groups: Into::<u32>::into(groups.into()) as _,
            first_si,
            si: Cow::Borrowed(si.as_ref()),
            group_maps: Cow::Borrowed(group_maps.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_compat_map_checked<'this>(&'this mut self, device_spec: types::DeviceSpec, recompute_actions: types::Bool, truncate_si: types::Bool, groups: impl Into<types::SetOfGroup>, first_si: types::Card16, si: impl AsRef<[types::SymInterpret]>, group_maps: impl AsRef<[types::ModDef]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xkb::SetCompatMapRequest {
            device_spec,
            recompute_actions,
            truncate_si,
            groups: Into::<u32>::into(groups.into()) as _,
            first_si,
            si: Cow::Borrowed(si.as_ref()),
            group_maps: Cow::Borrowed(group_maps.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_state<'this>(&'this mut self, device_spec: types::DeviceSpec) -> futures::SendRequest<'this, Self, types::xkb::GetIndicatorStateReply> {
        let span = tracing::info_span!(
            "xkb_get_indicator_state",
            device_spec = ?device_spec,
        );
        let request = types::xkb::GetIndicatorStateRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_state_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec) -> futures::CheckedSendRequest<'this, Self, types::xkb::GetIndicatorStateReply> {
        let request = types::xkb::GetIndicatorStateRequest {
            device_spec,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetIndicatorStateReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_map<'this>(&'this mut self, device_spec: types::DeviceSpec, which: types::Card32) -> futures::SendRequest<'this, Self, types::xkb::GetIndicatorMapReply> {
        let span = tracing::info_span!(
            "xkb_get_indicator_map",
            device_spec = ?device_spec,
            which = ?which,
        );
        let request = types::xkb::GetIndicatorMapRequest {
            device_spec,
            which,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_map_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec, which: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xkb::GetIndicatorMapReply> {
        let request = types::xkb::GetIndicatorMapRequest {
            device_spec,
            which,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetIndicatorMapReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_indicator_map<'this>(&'this mut self, device_spec: types::DeviceSpec, which: types::Card32, maps: impl AsRef<[types::IndicatorMap]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xkb_set_indicator_map",
            device_spec = ?device_spec,
            which = ?which,
        );
        let request = types::xkb::SetIndicatorMapRequest {
            device_spec,
            which,
            maps: Cow::Borrowed(maps.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_indicator_map_checked<'this>(&'this mut self, device_spec: types::DeviceSpec, which: types::Card32, maps: impl AsRef<[types::IndicatorMap]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xkb::SetIndicatorMapRequest {
            device_spec,
            which,
            maps: Cow::Borrowed(maps.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_named_indicator<'this>(&'this mut self, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::ID>, indicator: types::Atom) -> futures::SendRequest<'this, Self, types::xkb::GetNamedIndicatorReply> {
        let span = tracing::info_span!(
            "xkb_get_named_indicator",
            device_spec = ?device_spec,
            led_class = ?led_class,
            indicator = ?indicator,
        );
        let request = types::xkb::GetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_named_indicator_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::ID>, indicator: types::Atom) -> futures::CheckedSendRequest<'this, Self, types::xkb::GetNamedIndicatorReply> {
        let request = types::xkb::GetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetNamedIndicatorReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_named_indicator<'this>(&'this mut self, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::ID>, indicator: types::Atom, set_state: types::Bool, on: types::Bool, set_map: types::Bool, create_map: types::Bool, map_flags: impl Into<types::IMFlag>, map_which_groups: impl Into<types::IMGroupsWhich>, map_groups: impl Into<types::SetOfGroups>, map_which_mods: impl Into<types::IMModsWhich>, map_real_mods: impl Into<types::ModMask>, map_vmods: impl Into<types::VMod>, map_ctrls: impl Into<types::BoolCtrl>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xkb_set_named_indicator",
            device_spec = ?device_spec,
            led_class = ?led_class,
            indicator = ?indicator,
            set_state = ?set_state,
            on = ?on,
            set_map = ?set_map,
            create_map = ?create_map,
        );
        let request = types::xkb::SetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
            set_state,
            on,
            set_map,
            create_map,
            map_flags: Into::<u32>::into(map_flags.into()) as _,
            map_which_groups: Into::<u32>::into(map_which_groups.into()) as _,
            map_groups: Into::<u32>::into(map_groups.into()) as _,
            map_which_mods: Into::<u32>::into(map_which_mods.into()) as _,
            map_real_mods: Into::<u32>::into(map_real_mods.into()) as _,
            map_vmods: Into::<u32>::into(map_vmods.into()) as _,
            map_ctrls: Into::<u32>::into(map_ctrls.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_named_indicator_checked<'this>(&'this mut self, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::ID>, indicator: types::Atom, set_state: types::Bool, on: types::Bool, set_map: types::Bool, create_map: types::Bool, map_flags: impl Into<types::IMFlag>, map_which_groups: impl Into<types::IMGroupsWhich>, map_groups: impl Into<types::SetOfGroups>, map_which_mods: impl Into<types::IMModsWhich>, map_real_mods: impl Into<types::ModMask>, map_vmods: impl Into<types::VMod>, map_ctrls: impl Into<types::BoolCtrl>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xkb::SetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
            set_state,
            on,
            set_map,
            create_map,
            map_flags: Into::<u32>::into(map_flags.into()) as _,
            map_which_groups: Into::<u32>::into(map_which_groups.into()) as _,
            map_groups: Into::<u32>::into(map_groups.into()) as _,
            map_which_mods: Into::<u32>::into(map_which_mods.into()) as _,
            map_real_mods: Into::<u32>::into(map_real_mods.into()) as _,
            map_vmods: Into::<u32>::into(map_vmods.into()) as _,
            map_ctrls: Into::<u32>::into(map_ctrls.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_names<'this>(&'this mut self, device_spec: types::DeviceSpec, which: impl Into<types::NameDetail>) -> futures::SendRequest<'this, Self, types::xkb::GetNamesReply> {
        let span = tracing::info_span!(
            "xkb_get_names",
            device_spec = ?device_spec,
        );
        let request = types::xkb::GetNamesRequest {
            device_spec,
            which: Into::<u32>::into(which.into()) as _,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_names_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec, which: impl Into<types::NameDetail>) -> futures::CheckedSendRequest<'this, Self, types::xkb::GetNamesReply> {
        let request = types::xkb::GetNamesRequest {
            device_spec,
            which: Into::<u32>::into(which.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetNamesReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_names<'this>(&'this mut self, device_spec: types::DeviceSpec, virtual_mods: impl Into<types::VMod>, first_type: types::Card8, n_types: types::Card8, first_kt_levelt: types::Card8, n_kt_levels: types::Card8, indicators: types::Card32, group_names: impl Into<types::SetOfGroup>, n_radio_groups: types::Card8, first_key: types::Keycode, n_keys: types::Card8, n_key_aliases: types::Card8, total_kt_level_names: types::Card16, values: impl Borrow<types::xkb::SetNamesAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xkb_set_names",
            device_spec = ?device_spec,
            first_type = ?first_type,
            n_types = ?n_types,
            first_kt_levelt = ?first_kt_levelt,
            n_kt_levels = ?n_kt_levels,
            indicators = ?indicators,
            n_radio_groups = ?n_radio_groups,
            first_key = ?first_key,
            n_keys = ?n_keys,
            n_key_aliases = ?n_key_aliases,
            total_kt_level_names = ?total_kt_level_names,
        );
        let request = types::xkb::SetNamesRequest {
            device_spec,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_type,
            n_types,
            first_kt_levelt,
            n_kt_levels,
            indicators,
            group_names: Into::<u32>::into(group_names.into()) as _,
            n_radio_groups,
            first_key,
            n_keys,
            n_key_aliases,
            total_kt_level_names,
            values: Cow::Borrowed(values.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_names_checked<'this>(&'this mut self, device_spec: types::DeviceSpec, virtual_mods: impl Into<types::VMod>, first_type: types::Card8, n_types: types::Card8, first_kt_levelt: types::Card8, n_kt_levels: types::Card8, indicators: types::Card32, group_names: impl Into<types::SetOfGroup>, n_radio_groups: types::Card8, first_key: types::Keycode, n_keys: types::Card8, n_key_aliases: types::Card8, total_kt_level_names: types::Card16, values: impl Borrow<types::xkb::SetNamesAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xkb::SetNamesRequest {
            device_spec,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_type,
            n_types,
            first_kt_levelt,
            n_kt_levels,
            indicators,
            group_names: Into::<u32>::into(group_names.into()) as _,
            n_radio_groups,
            first_key,
            n_keys,
            n_key_aliases,
            total_kt_level_names,
            values: Cow::Borrowed(values.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_per_client_flags<'this>(&'this mut self, device_spec: types::DeviceSpec, change: impl Into<types::PerClientFlag>, value: impl Into<types::PerClientFlag>, ctrls_to_change: impl Into<types::BoolCtrl>, auto_ctrls: impl Into<types::BoolCtrl>, auto_ctrls_values: impl Into<types::BoolCtrl>) -> futures::SendRequest<'this, Self, types::xkb::PerClientFlagsReply> {
        let span = tracing::info_span!(
            "xkb_per_client_flags",
            device_spec = ?device_spec,
        );
        let request = types::xkb::PerClientFlagsRequest {
            device_spec,
            change: Into::<u32>::into(change.into()) as _,
            value: Into::<u32>::into(value.into()) as _,
            ctrls_to_change: Into::<u32>::into(ctrls_to_change.into()) as _,
            auto_ctrls: Into::<u32>::into(auto_ctrls.into()) as _,
            auto_ctrls_values: Into::<u32>::into(auto_ctrls_values.into()) as _,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_per_client_flags_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec, change: impl Into<types::PerClientFlag>, value: impl Into<types::PerClientFlag>, ctrls_to_change: impl Into<types::BoolCtrl>, auto_ctrls: impl Into<types::BoolCtrl>, auto_ctrls_values: impl Into<types::BoolCtrl>) -> futures::CheckedSendRequest<'this, Self, types::xkb::PerClientFlagsReply> {
        let request = types::xkb::PerClientFlagsRequest {
            device_spec,
            change: Into::<u32>::into(change.into()) as _,
            value: Into::<u32>::into(value.into()) as _,
            ctrls_to_change: Into::<u32>::into(ctrls_to_change.into()) as _,
            auto_ctrls: Into::<u32>::into(auto_ctrls.into()) as _,
            auto_ctrls_values: Into::<u32>::into(auto_ctrls_values.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::PerClientFlagsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_list_components<'this>(&'this mut self, device_spec: types::DeviceSpec, max_names: types::Card16) -> futures::SendRequest<'this, Self, types::xkb::ListComponentsReply> {
        let span = tracing::info_span!(
            "xkb_list_components",
            device_spec = ?device_spec,
            max_names = ?max_names,
        );
        let request = types::xkb::ListComponentsRequest {
            device_spec,
            max_names,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_list_components_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec, max_names: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xkb::ListComponentsReply> {
        let request = types::xkb::ListComponentsRequest {
            device_spec,
            max_names,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::ListComponentsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_kbd_by_name<'this>(&'this mut self, device_spec: types::DeviceSpec, need: impl Into<types::GBNDetail>, want: impl Into<types::GBNDetail>, load: types::Bool) -> futures::SendRequest<'this, Self, types::xkb::GetKbdByNameReply> {
        let span = tracing::info_span!(
            "xkb_get_kbd_by_name",
            device_spec = ?device_spec,
            load = ?load,
        );
        let request = types::xkb::GetKbdByNameRequest {
            device_spec,
            need: Into::<u32>::into(need.into()) as _,
            want: Into::<u32>::into(want.into()) as _,
            load,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_kbd_by_name_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec, need: impl Into<types::GBNDetail>, want: impl Into<types::GBNDetail>, load: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::xkb::GetKbdByNameReply> {
        let request = types::xkb::GetKbdByNameRequest {
            device_spec,
            need: Into::<u32>::into(need.into()) as _,
            want: Into::<u32>::into(want.into()) as _,
            load,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetKbdByNameReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_device_info<'this>(&'this mut self, device_spec: types::DeviceSpec, wanted: impl Into<types::XIFeature>, all_buttons: types::Bool, first_button: types::Card8, n_buttons: types::Card8, led_class: types::LedClass, led_id: impl Into<types::ID>) -> futures::SendRequest<'this, Self, types::xkb::GetDeviceInfoReply> {
        let span = tracing::info_span!(
            "xkb_get_device_info",
            device_spec = ?device_spec,
            all_buttons = ?all_buttons,
            first_button = ?first_button,
            n_buttons = ?n_buttons,
            led_class = ?led_class,
        );
        let request = types::xkb::GetDeviceInfoRequest {
            device_spec,
            wanted: Into::<u32>::into(wanted.into()) as _,
            all_buttons,
            first_button,
            n_buttons,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_device_info_immediate<'this>(&'this mut self, device_spec: types::DeviceSpec, wanted: impl Into<types::XIFeature>, all_buttons: types::Bool, first_button: types::Card8, n_buttons: types::Card8, led_class: types::LedClass, led_id: impl Into<types::ID>) -> futures::CheckedSendRequest<'this, Self, types::xkb::GetDeviceInfoReply> {
        let request = types::xkb::GetDeviceInfoRequest {
            device_spec,
            wanted: Into::<u32>::into(wanted.into()) as _,
            all_buttons,
            first_button,
            n_buttons,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetDeviceInfoReply> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_device_info<'this>(&'this mut self, device_spec: types::DeviceSpec, first_btn: types::Card8, change: impl Into<types::XIFeature>, btn_actions: impl AsRef<[types::Action]>, leds: impl AsRef<[types::DeviceLedInfo]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xkb_set_device_info",
            device_spec = ?device_spec,
            first_btn = ?first_btn,
        );
        let request = types::xkb::SetDeviceInfoRequest {
            device_spec,
            first_btn,
            change: Into::<u32>::into(change.into()) as _,
            btn_actions: Cow::Borrowed(btn_actions.as_ref()),
            leds: Cow::Borrowed(leds.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_device_info_checked<'this>(&'this mut self, device_spec: types::DeviceSpec, first_btn: types::Card8, change: impl Into<types::XIFeature>, btn_actions: impl AsRef<[types::Action]>, leds: impl AsRef<[types::DeviceLedInfo]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xkb::SetDeviceInfoRequest {
            device_spec,
            first_btn,
            change: Into::<u32>::into(change.into()) as _,
            btn_actions: Cow::Borrowed(btn_actions.as_ref()),
            leds: Cow::Borrowed(leds.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_debugging_flags<'this>(&'this mut self, affect_flags: types::Card32, flags: types::Card32, affect_ctrls: types::Card32, ctrls: types::Card32, message: impl AsRef<[types::xkb::String8]>) -> futures::SendRequest<'this, Self, types::xkb::SetDebuggingFlagsReply> {
        let span = tracing::info_span!(
            "xkb_set_debugging_flags",
            affect_flags = ?affect_flags,
            flags = ?flags,
            affect_ctrls = ?affect_ctrls,
            ctrls = ?ctrls,
        );
        let request = types::xkb::SetDebuggingFlagsRequest {
            affect_flags,
            flags,
            affect_ctrls,
            ctrls,
            message: Cow::Borrowed(message.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_debugging_flags_immediate<'this>(&'this mut self, affect_flags: types::Card32, flags: types::Card32, affect_ctrls: types::Card32, ctrls: types::Card32, message: impl AsRef<[types::xkb::String8]>) -> futures::CheckedSendRequest<'this, Self, types::xkb::SetDebuggingFlagsReply> {
        let request = types::xkb::SetDebuggingFlagsRequest {
            affect_flags,
            flags,
            affect_ctrls,
            ctrls,
            message: Cow::Borrowed(message.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::SetDebuggingFlagsReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "xprint")]
    fn xprint_print_query_version<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xprint::PrintQueryVersionReply> {
        let span = tracing::info_span!(
            "xprint_print_query_version",
        );
        let request = types::xprint::PrintQueryVersionRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_version_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintQueryVersionReply> {
        let request = types::xprint::PrintQueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintQueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_printer_list<'this>(&'this mut self, printer_name: impl AsRef<[types::xprint::String8]>, locale: impl AsRef<[types::xprint::String8]>) -> futures::SendRequest<'this, Self, types::xprint::PrintGetPrinterListReply> {
        let span = tracing::info_span!(
            "xprint_print_get_printer_list",
        );
        let request = types::xprint::PrintGetPrinterListRequest {
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_printer_list_immediate<'this>(&'this mut self, printer_name: impl AsRef<[types::xprint::String8]>, locale: impl AsRef<[types::xprint::String8]>) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetPrinterListReply> {
        let request = types::xprint::PrintGetPrinterListRequest {
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetPrinterListReply> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_rehash_printer_list<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_rehash_printer_list",
        );
        let request = types::xprint::PrintRehashPrinterListRequest {
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_rehash_printer_list_checked<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintRehashPrinterListRequest {
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_create_context<'this>(&'this mut self, context_id: types::Card32, printer_name: impl AsRef<[types::xprint::String8]>, locale: impl AsRef<[types::xprint::String8]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_create_context",
            context_id = ?context_id,
        );
        let request = types::xprint::CreateContextRequest {
            context_id,
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_create_context_checked<'this>(&'this mut self, context_id: types::Card32, printer_name: impl AsRef<[types::xprint::String8]>, locale: impl AsRef<[types::xprint::String8]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::CreateContextRequest {
            context_id,
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_context<'this>(&'this mut self, context: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_set_context",
            context = ?context,
        );
        let request = types::xprint::PrintSetContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_context_checked<'this>(&'this mut self, context: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintSetContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_context<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xprint::PrintGetContextReply> {
        let span = tracing::info_span!(
            "xprint_print_get_context",
        );
        let request = types::xprint::PrintGetContextRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_context_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetContextReply> {
        let request = types::xprint::PrintGetContextRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_destroy_context<'this>(&'this mut self, context: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_destroy_context",
            context = ?context,
        );
        let request = types::xprint::PrintDestroyContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_destroy_context_checked<'this>(&'this mut self, context: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintDestroyContextRequest {
            context,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_screen_of_context<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xprint::PrintGetScreenOfContextReply> {
        let span = tracing::info_span!(
            "xprint_print_get_screen_of_context",
        );
        let request = types::xprint::PrintGetScreenOfContextRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_screen_of_context_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetScreenOfContextReply> {
        let request = types::xprint::PrintGetScreenOfContextRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetScreenOfContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_job<'this>(&'this mut self, output_mode: types::Card8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_start_job",
            output_mode = ?output_mode,
        );
        let request = types::xprint::PrintStartJobRequest {
            output_mode,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_job_checked<'this>(&'this mut self, output_mode: types::Card8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintStartJobRequest {
            output_mode,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_job<'this>(&'this mut self, cancel: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_end_job",
            cancel = ?cancel,
        );
        let request = types::xprint::PrintEndJobRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_job_checked<'this>(&'this mut self, cancel: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintEndJobRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_doc<'this>(&'this mut self, driver_mode: types::Card8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_start_doc",
            driver_mode = ?driver_mode,
        );
        let request = types::xprint::PrintStartDocRequest {
            driver_mode,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_doc_checked<'this>(&'this mut self, driver_mode: types::Card8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintStartDocRequest {
            driver_mode,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_doc<'this>(&'this mut self, cancel: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_end_doc",
            cancel = ?cancel,
        );
        let request = types::xprint::PrintEndDocRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_doc_checked<'this>(&'this mut self, cancel: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintEndDocRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_put_document_data<'this>(&'this mut self, drawable: types::xproto::Drawable, data: impl AsRef<[types::Byte]>, doc_format: impl AsRef<[types::xprint::String8]>, options: impl AsRef<[types::xprint::String8]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_put_document_data",
            drawable = ?drawable,
        );
        let request = types::xprint::PrintPutDocumentDataRequest {
            drawable,
            data: Cow::Borrowed(data.as_ref()),
            doc_format: Cow::Borrowed(doc_format.as_ref()),
            options: Cow::Borrowed(options.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_put_document_data_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, data: impl AsRef<[types::Byte]>, doc_format: impl AsRef<[types::xprint::String8]>, options: impl AsRef<[types::xprint::String8]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintPutDocumentDataRequest {
            drawable,
            data: Cow::Borrowed(data.as_ref()),
            doc_format: Cow::Borrowed(doc_format.as_ref()),
            options: Cow::Borrowed(options.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_document_data<'this>(&'this mut self, context: types::Pcontext, max_bytes: types::Card32) -> futures::SendRequest<'this, Self, types::xprint::PrintGetDocumentDataReply> {
        let span = tracing::info_span!(
            "xprint_print_get_document_data",
            context = ?context,
            max_bytes = ?max_bytes,
        );
        let request = types::xprint::PrintGetDocumentDataRequest {
            context,
            max_bytes,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_document_data_immediate<'this>(&'this mut self, context: types::Pcontext, max_bytes: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetDocumentDataReply> {
        let request = types::xprint::PrintGetDocumentDataRequest {
            context,
            max_bytes,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetDocumentDataReply> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_page<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_start_page",
            window = ?window,
        );
        let request = types::xprint::PrintStartPageRequest {
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_page_checked<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintStartPageRequest {
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_page<'this>(&'this mut self, cancel: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_end_page",
            cancel = ?cancel,
        );
        let request = types::xprint::PrintEndPageRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_page_checked<'this>(&'this mut self, cancel: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintEndPageRequest {
            cancel,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_select_input<'this>(&'this mut self, context: types::Pcontext, event_mask: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_select_input",
            context = ?context,
            event_mask = ?event_mask,
        );
        let request = types::xprint::PrintSelectInputRequest {
            context,
            event_mask,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_select_input_checked<'this>(&'this mut self, context: types::Pcontext, event_mask: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintSelectInputRequest {
            context,
            event_mask,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_input_selected<'this>(&'this mut self, context: types::Pcontext) -> futures::SendRequest<'this, Self, types::xprint::PrintInputSelectedReply> {
        let span = tracing::info_span!(
            "xprint_print_input_selected",
            context = ?context,
        );
        let request = types::xprint::PrintInputSelectedRequest {
            context,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_input_selected_immediate<'this>(&'this mut self, context: types::Pcontext) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintInputSelectedReply> {
        let request = types::xprint::PrintInputSelectedRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintInputSelectedReply> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_attributes<'this>(&'this mut self, context: types::Pcontext, pool: types::Card8) -> futures::SendRequest<'this, Self, types::xprint::PrintGetAttributesReply> {
        let span = tracing::info_span!(
            "xprint_print_get_attributes",
            context = ?context,
            pool = ?pool,
        );
        let request = types::xprint::PrintGetAttributesRequest {
            context,
            pool,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_attributes_immediate<'this>(&'this mut self, context: types::Pcontext, pool: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetAttributesReply> {
        let request = types::xprint::PrintGetAttributesRequest {
            context,
            pool,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetAttributesReply> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_one_attributes<'this>(&'this mut self, context: types::Pcontext, pool: types::Card8, name: impl AsRef<[types::xprint::String8]>) -> futures::SendRequest<'this, Self, types::xprint::PrintGetOneAttributesReply> {
        let span = tracing::info_span!(
            "xprint_print_get_one_attributes",
            context = ?context,
            pool = ?pool,
        );
        let request = types::xprint::PrintGetOneAttributesRequest {
            context,
            pool,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_one_attributes_immediate<'this>(&'this mut self, context: types::Pcontext, pool: types::Card8, name: impl AsRef<[types::xprint::String8]>) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetOneAttributesReply> {
        let request = types::xprint::PrintGetOneAttributesRequest {
            context,
            pool,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetOneAttributesReply> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_attributes<'this>(&'this mut self, context: types::Pcontext, string_len: types::Card32, pool: types::Card8, rule: types::Card8, attributes: impl AsRef<[types::xprint::String8]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xprint_print_set_attributes",
            context = ?context,
            string_len = ?string_len,
            pool = ?pool,
            rule = ?rule,
        );
        let request = types::xprint::PrintSetAttributesRequest {
            context,
            string_len,
            pool,
            rule,
            attributes: Cow::Borrowed(attributes.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_attributes_checked<'this>(&'this mut self, context: types::Pcontext, string_len: types::Card32, pool: types::Card8, rule: types::Card8, attributes: impl AsRef<[types::xprint::String8]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xprint::PrintSetAttributesRequest {
            context,
            string_len,
            pool,
            rule,
            attributes: Cow::Borrowed(attributes.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_page_dimensions<'this>(&'this mut self, context: types::Pcontext) -> futures::SendRequest<'this, Self, types::xprint::PrintGetPageDimensionsReply> {
        let span = tracing::info_span!(
            "xprint_print_get_page_dimensions",
            context = ?context,
        );
        let request = types::xprint::PrintGetPageDimensionsRequest {
            context,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_page_dimensions_immediate<'this>(&'this mut self, context: types::Pcontext) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetPageDimensionsReply> {
        let request = types::xprint::PrintGetPageDimensionsRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetPageDimensionsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_screens<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xprint::PrintQueryScreensReply> {
        let span = tracing::info_span!(
            "xprint_print_query_screens",
        );
        let request = types::xprint::PrintQueryScreensRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_screens_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintQueryScreensReply> {
        let request = types::xprint::PrintQueryScreensRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintQueryScreensReply> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_image_resolution<'this>(&'this mut self, context: types::Pcontext, image_resolution: types::Card16) -> futures::SendRequest<'this, Self, types::xprint::PrintSetImageResolutionReply> {
        let span = tracing::info_span!(
            "xprint_print_set_image_resolution",
            context = ?context,
            image_resolution = ?image_resolution,
        );
        let request = types::xprint::PrintSetImageResolutionRequest {
            context,
            image_resolution,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_image_resolution_immediate<'this>(&'this mut self, context: types::Pcontext, image_resolution: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintSetImageResolutionReply> {
        let request = types::xprint::PrintSetImageResolutionRequest {
            context,
            image_resolution,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintSetImageResolutionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_image_resolution<'this>(&'this mut self, context: types::Pcontext) -> futures::SendRequest<'this, Self, types::xprint::PrintGetImageResolutionReply> {
        let span = tracing::info_span!(
            "xprint_print_get_image_resolution",
            context = ?context,
        );
        let request = types::xprint::PrintGetImageResolutionRequest {
            context,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_image_resolution_immediate<'this>(&'this mut self, context: types::Pcontext) -> futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetImageResolutionReply> {
        let request = types::xprint::PrintGetImageResolutionRequest {
            context,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetImageResolutionReply> = cookie.into();
        res
    }
    
    fn create_window<'this>(&'this mut self, depth: types::Card8, wid: types::xproto::Window, parent: types::xproto::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, visual: types::Visualid, value_list: impl Borrow<types::xproto::CreateWindowAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "create_window",
            depth = ?depth,
            wid = ?wid,
            parent = ?parent,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            border_width = ?border_width,
            class = ?class,
            visual = ?visual,
        );
        let request = types::xproto::CreateWindowRequest {
            depth,
            wid,
            parent,
            x,
            y,
            width,
            height,
            border_width,
            class,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn create_window_checked<'this>(&'this mut self, depth: types::Card8, wid: types::xproto::Window, parent: types::xproto::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, visual: types::Visualid, value_list: impl Borrow<types::xproto::CreateWindowAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CreateWindowRequest {
            depth,
            wid,
            parent,
            x,
            y,
            width,
            height,
            border_width,
            class,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn change_window_attributes<'this>(&'this mut self, window: types::xproto::Window, value_list: impl Borrow<types::xproto::ChangeWindowAttributesAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "change_window_attributes",
            window = ?window,
        );
        let request = types::xproto::ChangeWindowAttributesRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn change_window_attributes_checked<'this>(&'this mut self, window: types::xproto::Window, value_list: impl Borrow<types::xproto::ChangeWindowAttributesAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ChangeWindowAttributesRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn get_window_attributes<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xproto::GetWindowAttributesReply> {
        let span = tracing::info_span!(
            "get_window_attributes",
            window = ?window,
        );
        let request = types::xproto::GetWindowAttributesRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_window_attributes_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetWindowAttributesReply> {
        let request = types::xproto::GetWindowAttributesRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetWindowAttributesReply> = cookie.into();
        res
    }
    fn destroy_window<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "destroy_window",
            window = ?window,
        );
        let request = types::xproto::DestroyWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn destroy_window_checked<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::DestroyWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn destroy_subwindows<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "destroy_subwindows",
            window = ?window,
        );
        let request = types::xproto::DestroySubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn destroy_subwindows_checked<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::DestroySubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn change_save_set<'this>(&'this mut self, mode: types::SetMode, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "change_save_set",
            mode = ?mode,
            window = ?window,
        );
        let request = types::xproto::ChangeSaveSetRequest {
            mode,
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn change_save_set_checked<'this>(&'this mut self, mode: types::SetMode, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ChangeSaveSetRequest {
            mode,
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn reparent_window<'this>(&'this mut self, window: types::xproto::Window, parent: types::xproto::Window, x: types::Int16, y: types::Int16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "reparent_window",
            window = ?window,
            parent = ?parent,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::ReparentWindowRequest {
            window,
            parent,
            x,
            y,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn reparent_window_checked<'this>(&'this mut self, window: types::xproto::Window, parent: types::xproto::Window, x: types::Int16, y: types::Int16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ReparentWindowRequest {
            window,
            parent,
            x,
            y,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn map_window<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "map_window",
            window = ?window,
        );
        let request = types::xproto::MapWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn map_window_checked<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::MapWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn map_subwindows<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "map_subwindows",
            window = ?window,
        );
        let request = types::xproto::MapSubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn map_subwindows_checked<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::MapSubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn unmap_window<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "unmap_window",
            window = ?window,
        );
        let request = types::xproto::UnmapWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn unmap_window_checked<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::UnmapWindowRequest {
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn unmap_subwindows<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "unmap_subwindows",
            window = ?window,
        );
        let request = types::xproto::UnmapSubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn unmap_subwindows_checked<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::UnmapSubwindowsRequest {
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn configure_window<'this>(&'this mut self, window: types::xproto::Window, value_list: impl Borrow<types::xproto::ConfigureWindowAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "configure_window",
            window = ?window,
        );
        let request = types::xproto::ConfigureWindowRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn configure_window_checked<'this>(&'this mut self, window: types::xproto::Window, value_list: impl Borrow<types::xproto::ConfigureWindowAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ConfigureWindowRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn circulate_window<'this>(&'this mut self, direction: types::Circulate, window: types::xproto::Window) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "circulate_window",
            direction = ?direction,
            window = ?window,
        );
        let request = types::xproto::CirculateWindowRequest {
            direction,
            window,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn circulate_window_checked<'this>(&'this mut self, direction: types::Circulate, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CirculateWindowRequest {
            direction,
            window,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn get_geometry<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::SendRequest<'this, Self, types::xproto::GetGeometryReply> {
        let span = tracing::info_span!(
            "get_geometry",
            drawable = ?drawable,
        );
        let request = types::xproto::GetGeometryRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_geometry_immediate<'this>(&'this mut self, drawable: types::xproto::Drawable) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetGeometryReply> {
        let request = types::xproto::GetGeometryRequest {
            drawable,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetGeometryReply> = cookie.into();
        res
    }
    fn query_tree<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xproto::QueryTreeReply> {
        let span = tracing::info_span!(
            "query_tree",
            window = ?window,
        );
        let request = types::xproto::QueryTreeRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn query_tree_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xproto::QueryTreeReply> {
        let request = types::xproto::QueryTreeRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryTreeReply> = cookie.into();
        res
    }
    fn intern_atom<'this>(&'this mut self, only_if_exists: types::Bool, name: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, types::xproto::InternAtomReply> {
        let span = tracing::info_span!(
            "intern_atom",
            only_if_exists = ?only_if_exists,
        );
        let request = types::xproto::InternAtomRequest {
            only_if_exists,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn intern_atom_immediate<'this>(&'this mut self, only_if_exists: types::Bool, name: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, types::xproto::InternAtomReply> {
        let request = types::xproto::InternAtomRequest {
            only_if_exists,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::InternAtomReply> = cookie.into();
        res
    }
    fn get_atom_name<'this>(&'this mut self, atom: types::Atom) -> futures::SendRequest<'this, Self, types::xproto::GetAtomNameReply> {
        let span = tracing::info_span!(
            "get_atom_name",
            atom = ?atom,
        );
        let request = types::xproto::GetAtomNameRequest {
            atom,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_atom_name_immediate<'this>(&'this mut self, atom: types::Atom) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetAtomNameReply> {
        let request = types::xproto::GetAtomNameRequest {
            atom,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetAtomNameReply> = cookie.into();
        res
    }
    fn change_property<'this>(&'this mut self, mode: types::PropMode, window: types::xproto::Window, property: types::Atom, type_: types::Atom, format: types::Card8, data_len: types::Card32, data: &(impl crate::Void + ?Sized)) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "change_property",
            mode = ?mode,
            window = ?window,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            data_len = ?data_len,
        );
        let request = types::xproto::ChangePropertyRequest {
            mode,
            window,
            property,
            type_,
            format,
            data_len,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn change_property_checked<'this>(&'this mut self, mode: types::PropMode, window: types::xproto::Window, property: types::Atom, type_: types::Atom, format: types::Card8, data_len: types::Card32, data: &(impl crate::Void + ?Sized)) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ChangePropertyRequest {
            mode,
            window,
            property,
            type_,
            format,
            data_len,
            data: Cow::Borrowed(data.bytes()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn delete_property<'this>(&'this mut self, window: types::xproto::Window, property: types::Atom) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "delete_property",
            window = ?window,
            property = ?property,
        );
        let request = types::xproto::DeletePropertyRequest {
            window,
            property,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn delete_property_checked<'this>(&'this mut self, window: types::xproto::Window, property: types::Atom) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::DeletePropertyRequest {
            window,
            property,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn get_property<'this>(&'this mut self, delete: types::Bool, window: types::xproto::Window, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32) -> futures::SendRequest<'this, Self, types::xproto::GetPropertyReply> {
        let span = tracing::info_span!(
            "get_property",
            delete = ?delete,
            window = ?window,
            property = ?property,
            long_offset = ?long_offset,
            long_length = ?long_length,
        );
        let request = types::xproto::GetPropertyRequest {
            delete,
            window,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_property_immediate<'this>(&'this mut self, delete: types::Bool, window: types::xproto::Window, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetPropertyReply> {
        let request = types::xproto::GetPropertyRequest {
            delete,
            window,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetPropertyReply> = cookie.into();
        res
    }
    fn list_properties<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xproto::ListPropertiesReply> {
        let span = tracing::info_span!(
            "list_properties",
            window = ?window,
        );
        let request = types::xproto::ListPropertiesRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn list_properties_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xproto::ListPropertiesReply> {
        let request = types::xproto::ListPropertiesRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::ListPropertiesReply> = cookie.into();
        res
    }
    fn set_selection_owner<'this>(&'this mut self, owner: impl Into<types::xproto::Window>, selection: types::Atom, time: impl Into<types::Time>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "set_selection_owner",
            selection = ?selection,
        );
        let request = types::xproto::SetSelectionOwnerRequest {
            owner: Into::<u32>::into(owner.into()) as _,
            selection,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn set_selection_owner_checked<'this>(&'this mut self, owner: impl Into<types::xproto::Window>, selection: types::Atom, time: impl Into<types::Time>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::SetSelectionOwnerRequest {
            owner: Into::<u32>::into(owner.into()) as _,
            selection,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn get_selection_owner<'this>(&'this mut self, selection: types::Atom) -> futures::SendRequest<'this, Self, types::xproto::GetSelectionOwnerReply> {
        let span = tracing::info_span!(
            "get_selection_owner",
            selection = ?selection,
        );
        let request = types::xproto::GetSelectionOwnerRequest {
            selection,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_selection_owner_immediate<'this>(&'this mut self, selection: types::Atom) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetSelectionOwnerReply> {
        let request = types::xproto::GetSelectionOwnerRequest {
            selection,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetSelectionOwnerReply> = cookie.into();
        res
    }
    fn convert_selection<'this>(&'this mut self, requestor: types::xproto::Window, selection: types::Atom, target: types::Atom, property: impl Into<types::Atom>, time: impl Into<types::Time>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "convert_selection",
            requestor = ?requestor,
            selection = ?selection,
            target = ?target,
        );
        let request = types::xproto::ConvertSelectionRequest {
            requestor,
            selection,
            target,
            property: Into::<u32>::into(property.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn convert_selection_checked<'this>(&'this mut self, requestor: types::xproto::Window, selection: types::Atom, target: types::Atom, property: impl Into<types::Atom>, time: impl Into<types::Time>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ConvertSelectionRequest {
            requestor,
            selection,
            target,
            property: Into::<u32>::into(property.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn send_event<'this>(&'this mut self, propagate: types::Bool, destination: impl Into<types::SendEventDest>, event_mask: impl Into<types::xproto::EventMask>, event: impl Borrow<[types::Char; 32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "send_event",
            propagate = ?propagate,
        );
        let request = types::xproto::SendEventRequest {
            propagate,
            destination: Into::<u32>::into(destination.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            event: Cow::Borrowed(event.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn send_event_checked<'this>(&'this mut self, propagate: types::Bool, destination: impl Into<types::SendEventDest>, event_mask: impl Into<types::xproto::EventMask>, event: impl Borrow<[types::Char; 32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::SendEventRequest {
            propagate,
            destination: Into::<u32>::into(destination.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            event: Cow::Borrowed(event.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn grab_pointer<'this>(&'this mut self, owner_events: types::Bool, grab_window: types::xproto::Window, event_mask: impl Into<types::xproto::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::xproto::Window>, cursor: impl Into<types::xproto::Cursor>, time: impl Into<types::Time>) -> futures::SendRequest<'this, Self, types::xproto::GrabPointerReply> {
        let span = tracing::info_span!(
            "grab_pointer",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let request = types::xproto::GrabPointerRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn grab_pointer_immediate<'this>(&'this mut self, owner_events: types::Bool, grab_window: types::xproto::Window, event_mask: impl Into<types::xproto::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::xproto::Window>, cursor: impl Into<types::xproto::Cursor>, time: impl Into<types::Time>) -> futures::CheckedSendRequest<'this, Self, types::xproto::GrabPointerReply> {
        let request = types::xproto::GrabPointerRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GrabPointerReply> = cookie.into();
        res
    }
    fn ungrab_pointer<'this>(&'this mut self, time: impl Into<types::Time>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "ungrab_pointer",
        );
        let request = types::xproto::UngrabPointerRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn ungrab_pointer_checked<'this>(&'this mut self, time: impl Into<types::Time>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::UngrabPointerRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn grab_button<'this>(&'this mut self, owner_events: types::Bool, grab_window: types::xproto::Window, event_mask: impl Into<types::xproto::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::xproto::Window>, cursor: impl Into<types::xproto::Cursor>, button: types::ButtonIndex, modifiers: impl Into<types::ModMask>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "grab_button",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
            button = ?button,
        );
        let request = types::xproto::GrabButtonRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            button,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn grab_button_checked<'this>(&'this mut self, owner_events: types::Bool, grab_window: types::xproto::Window, event_mask: impl Into<types::xproto::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::xproto::Window>, cursor: impl Into<types::xproto::Cursor>, button: types::ButtonIndex, modifiers: impl Into<types::ModMask>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::GrabButtonRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            button,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn ungrab_button<'this>(&'this mut self, button: types::ButtonIndex, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "ungrab_button",
            button = ?button,
            grab_window = ?grab_window,
        );
        let request = types::xproto::UngrabButtonRequest {
            button,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn ungrab_button_checked<'this>(&'this mut self, button: types::ButtonIndex, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::UngrabButtonRequest {
            button,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn change_active_pointer_grab<'this>(&'this mut self, cursor: impl Into<types::xproto::Cursor>, time: impl Into<types::Time>, event_mask: impl Into<types::xproto::EventMask>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "change_active_pointer_grab",
        );
        let request = types::xproto::ChangeActivePointerGrabRequest {
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn change_active_pointer_grab_checked<'this>(&'this mut self, cursor: impl Into<types::xproto::Cursor>, time: impl Into<types::Time>, event_mask: impl Into<types::xproto::EventMask>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ChangeActivePointerGrabRequest {
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn grab_keyboard<'this>(&'this mut self, owner_events: types::Bool, grab_window: types::xproto::Window, time: impl Into<types::Time>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> futures::SendRequest<'this, Self, types::xproto::GrabKeyboardReply> {
        let span = tracing::info_span!(
            "grab_keyboard",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let request = types::xproto::GrabKeyboardRequest {
            owner_events,
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn grab_keyboard_immediate<'this>(&'this mut self, owner_events: types::Bool, grab_window: types::xproto::Window, time: impl Into<types::Time>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> futures::CheckedSendRequest<'this, Self, types::xproto::GrabKeyboardReply> {
        let request = types::xproto::GrabKeyboardRequest {
            owner_events,
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GrabKeyboardReply> = cookie.into();
        res
    }
    fn ungrab_keyboard<'this>(&'this mut self, time: impl Into<types::Time>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "ungrab_keyboard",
        );
        let request = types::xproto::UngrabKeyboardRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn ungrab_keyboard_checked<'this>(&'this mut self, time: impl Into<types::Time>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::UngrabKeyboardRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn grab_key<'this>(&'this mut self, owner_events: types::Bool, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, key: impl Into<types::Grab>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "grab_key",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let request = types::xproto::GrabKeyRequest {
            owner_events,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn grab_key_checked<'this>(&'this mut self, owner_events: types::Bool, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, key: impl Into<types::Grab>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::GrabKeyRequest {
            owner_events,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn ungrab_key<'this>(&'this mut self, key: impl Into<types::Grab>, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "ungrab_key",
            grab_window = ?grab_window,
        );
        let request = types::xproto::UngrabKeyRequest {
            key: Into::<u32>::into(key.into()) as _,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn ungrab_key_checked<'this>(&'this mut self, key: impl Into<types::Grab>, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::UngrabKeyRequest {
            key: Into::<u32>::into(key.into()) as _,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn allow_events<'this>(&'this mut self, mode: types::Allow, time: impl Into<types::Time>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "allow_events",
            mode = ?mode,
        );
        let request = types::xproto::AllowEventsRequest {
            mode,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn allow_events_checked<'this>(&'this mut self, mode: types::Allow, time: impl Into<types::Time>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::AllowEventsRequest {
            mode,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn grab_server<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "grab_server",
        );
        let request = types::xproto::GrabServerRequest {
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn grab_server_checked<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::GrabServerRequest {
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn ungrab_server<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "ungrab_server",
        );
        let request = types::xproto::UngrabServerRequest {
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn ungrab_server_checked<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::UngrabServerRequest {
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn query_pointer<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xproto::QueryPointerReply> {
        let span = tracing::info_span!(
            "query_pointer",
            window = ?window,
        );
        let request = types::xproto::QueryPointerRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn query_pointer_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xproto::QueryPointerReply> {
        let request = types::xproto::QueryPointerRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryPointerReply> = cookie.into();
        res
    }
    fn get_motion_events<'this>(&'this mut self, window: types::xproto::Window, start: impl Into<types::Time>, stop: impl Into<types::Time>) -> futures::SendRequest<'this, Self, types::xproto::GetMotionEventsReply> {
        let span = tracing::info_span!(
            "get_motion_events",
            window = ?window,
        );
        let request = types::xproto::GetMotionEventsRequest {
            window,
            start: Into::<u32>::into(start.into()) as _,
            stop: Into::<u32>::into(stop.into()) as _,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_motion_events_immediate<'this>(&'this mut self, window: types::xproto::Window, start: impl Into<types::Time>, stop: impl Into<types::Time>) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetMotionEventsReply> {
        let request = types::xproto::GetMotionEventsRequest {
            window,
            start: Into::<u32>::into(start.into()) as _,
            stop: Into::<u32>::into(stop.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetMotionEventsReply> = cookie.into();
        res
    }
    fn translate_coordinates<'this>(&'this mut self, src_window: types::xproto::Window, dst_window: types::xproto::Window, src_x: types::Int16, src_y: types::Int16) -> futures::SendRequest<'this, Self, types::xproto::TranslateCoordinatesReply> {
        let span = tracing::info_span!(
            "translate_coordinates",
            src_window = ?src_window,
            dst_window = ?dst_window,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::xproto::TranslateCoordinatesRequest {
            src_window,
            dst_window,
            src_x,
            src_y,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn translate_coordinates_immediate<'this>(&'this mut self, src_window: types::xproto::Window, dst_window: types::xproto::Window, src_x: types::Int16, src_y: types::Int16) -> futures::CheckedSendRequest<'this, Self, types::xproto::TranslateCoordinatesReply> {
        let request = types::xproto::TranslateCoordinatesRequest {
            src_window,
            dst_window,
            src_x,
            src_y,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::TranslateCoordinatesReply> = cookie.into();
        res
    }
    fn warp_pointer<'this>(&'this mut self, src_window: impl Into<types::xproto::Window>, dst_window: impl Into<types::xproto::Window>, src_x: types::Int16, src_y: types::Int16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "warp_pointer",
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
        );
        let request = types::xproto::WarpPointerRequest {
            src_window: Into::<u32>::into(src_window.into()) as _,
            dst_window: Into::<u32>::into(dst_window.into()) as _,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn warp_pointer_checked<'this>(&'this mut self, src_window: impl Into<types::xproto::Window>, dst_window: impl Into<types::xproto::Window>, src_x: types::Int16, src_y: types::Int16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::WarpPointerRequest {
            src_window: Into::<u32>::into(src_window.into()) as _,
            dst_window: Into::<u32>::into(dst_window.into()) as _,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn set_input_focus<'this>(&'this mut self, revert_to: types::InputFocus, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "set_input_focus",
            revert_to = ?revert_to,
        );
        let request = types::xproto::SetInputFocusRequest {
            revert_to,
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn set_input_focus_checked<'this>(&'this mut self, revert_to: types::InputFocus, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::SetInputFocusRequest {
            revert_to,
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn get_input_focus<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xproto::GetInputFocusReply> {
        let span = tracing::info_span!(
            "get_input_focus",
        );
        let request = types::xproto::GetInputFocusRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_input_focus_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetInputFocusReply> {
        let request = types::xproto::GetInputFocusRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetInputFocusReply> = cookie.into();
        res
    }
    fn query_keymap<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xproto::QueryKeymapReply> {
        let span = tracing::info_span!(
            "query_keymap",
        );
        let request = types::xproto::QueryKeymapRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn query_keymap_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xproto::QueryKeymapReply> {
        let request = types::xproto::QueryKeymapRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryKeymapReply> = cookie.into();
        res
    }
    fn open_font<'this>(&'this mut self, fid: types::Font, name: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "open_font",
            fid = ?fid,
        );
        let request = types::xproto::OpenFontRequest {
            fid,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn open_font_checked<'this>(&'this mut self, fid: types::Font, name: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::OpenFontRequest {
            fid,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn close_font<'this>(&'this mut self, font: types::Font) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "close_font",
            font = ?font,
        );
        let request = types::xproto::CloseFontRequest {
            font,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn close_font_checked<'this>(&'this mut self, font: types::Font) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CloseFontRequest {
            font,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn query_font<'this>(&'this mut self, font: types::Fontable) -> futures::SendRequest<'this, Self, types::xproto::QueryFontReply> {
        let span = tracing::info_span!(
            "query_font",
            font = ?font,
        );
        let request = types::xproto::QueryFontRequest {
            font,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn query_font_immediate<'this>(&'this mut self, font: types::Fontable) -> futures::CheckedSendRequest<'this, Self, types::xproto::QueryFontReply> {
        let request = types::xproto::QueryFontRequest {
            font,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryFontReply> = cookie.into();
        res
    }
    fn query_text_extents<'this>(&'this mut self, font: types::Fontable, string: impl AsRef<[types::Char2b]>) -> futures::SendRequest<'this, Self, types::xproto::QueryTextExtentsReply> {
        let span = tracing::info_span!(
            "query_text_extents",
            font = ?font,
        );
        let request = types::xproto::QueryTextExtentsRequest {
            font,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn query_text_extents_immediate<'this>(&'this mut self, font: types::Fontable, string: impl AsRef<[types::Char2b]>) -> futures::CheckedSendRequest<'this, Self, types::xproto::QueryTextExtentsReply> {
        let request = types::xproto::QueryTextExtentsRequest {
            font,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryTextExtentsReply> = cookie.into();
        res
    }
    fn list_fonts<'this>(&'this mut self, max_names: types::Card16, pattern: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, types::xproto::ListFontsReply> {
        let span = tracing::info_span!(
            "list_fonts",
            max_names = ?max_names,
        );
        let request = types::xproto::ListFontsRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn list_fonts_immediate<'this>(&'this mut self, max_names: types::Card16, pattern: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, types::xproto::ListFontsReply> {
        let request = types::xproto::ListFontsRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::ListFontsReply> = cookie.into();
        res
    }
    fn list_fonts_with_info<'this>(&'this mut self, max_names: types::Card16, pattern: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, types::xproto::ListFontsWithInfoReply> {
        let span = tracing::info_span!(
            "list_fonts_with_info",
            max_names = ?max_names,
        );
        let request = types::xproto::ListFontsWithInfoRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn list_fonts_with_info_immediate<'this>(&'this mut self, max_names: types::Card16, pattern: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, types::xproto::ListFontsWithInfoReply> {
        let request = types::xproto::ListFontsWithInfoRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::ListFontsWithInfoReply> = cookie.into();
        res
    }
    fn set_font_path<'this>(&'this mut self, font: impl AsRef<[types::Str]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "set_font_path",
        );
        let request = types::xproto::SetFontPathRequest {
            font: Cow::Borrowed(font.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn set_font_path_checked<'this>(&'this mut self, font: impl AsRef<[types::Str]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::SetFontPathRequest {
            font: Cow::Borrowed(font.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn get_font_path<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xproto::GetFontPathReply> {
        let span = tracing::info_span!(
            "get_font_path",
        );
        let request = types::xproto::GetFontPathRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_font_path_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetFontPathReply> {
        let request = types::xproto::GetFontPathRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetFontPathReply> = cookie.into();
        res
    }
    fn create_pixmap<'this>(&'this mut self, depth: types::Card8, pid: types::xproto::Pixmap, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "create_pixmap",
            depth = ?depth,
            pid = ?pid,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
        );
        let request = types::xproto::CreatePixmapRequest {
            depth,
            pid,
            drawable,
            width,
            height,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn create_pixmap_checked<'this>(&'this mut self, depth: types::Card8, pid: types::xproto::Pixmap, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CreatePixmapRequest {
            depth,
            pid,
            drawable,
            width,
            height,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn free_pixmap<'this>(&'this mut self, pixmap: types::xproto::Pixmap) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "free_pixmap",
            pixmap = ?pixmap,
        );
        let request = types::xproto::FreePixmapRequest {
            pixmap,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn free_pixmap_checked<'this>(&'this mut self, pixmap: types::xproto::Pixmap) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::FreePixmapRequest {
            pixmap,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn create_gc<'this>(&'this mut self, cid: types::Gcontext, drawable: types::xproto::Drawable, value_list: impl Borrow<types::xproto::CreateGCAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "create_gc",
            cid = ?cid,
            drawable = ?drawable,
        );
        let request = types::xproto::CreateGCRequest {
            cid,
            drawable,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn create_gc_checked<'this>(&'this mut self, cid: types::Gcontext, drawable: types::xproto::Drawable, value_list: impl Borrow<types::xproto::CreateGCAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CreateGCRequest {
            cid,
            drawable,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn change_gc<'this>(&'this mut self, gc: types::Gcontext, value_list: impl Borrow<types::xproto::ChangeGCAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "change_gc",
            gc = ?gc,
        );
        let request = types::xproto::ChangeGCRequest {
            gc,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn change_gc_checked<'this>(&'this mut self, gc: types::Gcontext, value_list: impl Borrow<types::xproto::ChangeGCAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ChangeGCRequest {
            gc,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn copy_gc<'this>(&'this mut self, src_gc: types::Gcontext, dst_gc: types::Gcontext, value_mask: impl Into<types::xproto::GC>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "copy_gc",
            src_gc = ?src_gc,
            dst_gc = ?dst_gc,
        );
        let request = types::xproto::CopyGCRequest {
            src_gc,
            dst_gc,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn copy_gc_checked<'this>(&'this mut self, src_gc: types::Gcontext, dst_gc: types::Gcontext, value_mask: impl Into<types::xproto::GC>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CopyGCRequest {
            src_gc,
            dst_gc,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn set_dashes<'this>(&'this mut self, gc: types::Gcontext, dash_offset: types::Card16, dashes: impl AsRef<[types::Card8]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "set_dashes",
            gc = ?gc,
            dash_offset = ?dash_offset,
        );
        let request = types::xproto::SetDashesRequest {
            gc,
            dash_offset,
            dashes: Cow::Borrowed(dashes.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn set_dashes_checked<'this>(&'this mut self, gc: types::Gcontext, dash_offset: types::Card16, dashes: impl AsRef<[types::Card8]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::SetDashesRequest {
            gc,
            dash_offset,
            dashes: Cow::Borrowed(dashes.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn set_clip_rectangles<'this>(&'this mut self, ordering: types::ClipOrdering, gc: types::Gcontext, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "set_clip_rectangles",
            ordering = ?ordering,
            gc = ?gc,
            clip_x_origin = ?clip_x_origin,
            clip_y_origin = ?clip_y_origin,
        );
        let request = types::xproto::SetClipRectanglesRequest {
            ordering,
            gc,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn set_clip_rectangles_checked<'this>(&'this mut self, ordering: types::ClipOrdering, gc: types::Gcontext, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::SetClipRectanglesRequest {
            ordering,
            gc,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn free_gc<'this>(&'this mut self, gc: types::Gcontext) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "free_gc",
            gc = ?gc,
        );
        let request = types::xproto::FreeGCRequest {
            gc,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn free_gc_checked<'this>(&'this mut self, gc: types::Gcontext) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::FreeGCRequest {
            gc,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn clear_area<'this>(&'this mut self, exposures: types::Bool, window: types::xproto::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "clear_area",
            exposures = ?exposures,
            window = ?window,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
        );
        let request = types::xproto::ClearAreaRequest {
            exposures,
            window,
            x,
            y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn clear_area_checked<'this>(&'this mut self, exposures: types::Bool, window: types::xproto::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ClearAreaRequest {
            exposures,
            window,
            x,
            y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn copy_area<'this>(&'this mut self, src_drawable: types::xproto::Drawable, dst_drawable: types::xproto::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "copy_area",
            src_drawable = ?src_drawable,
            dst_drawable = ?dst_drawable,
            gc = ?gc,
            src_x = ?src_x,
            src_y = ?src_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
        );
        let request = types::xproto::CopyAreaRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn copy_area_checked<'this>(&'this mut self, src_drawable: types::xproto::Drawable, dst_drawable: types::xproto::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CopyAreaRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn copy_plane<'this>(&'this mut self, src_drawable: types::xproto::Drawable, dst_drawable: types::xproto::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16, bit_plane: types::Card32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "copy_plane",
            src_drawable = ?src_drawable,
            dst_drawable = ?dst_drawable,
            gc = ?gc,
            src_x = ?src_x,
            src_y = ?src_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
            bit_plane = ?bit_plane,
        );
        let request = types::xproto::CopyPlaneRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
            bit_plane,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn copy_plane_checked<'this>(&'this mut self, src_drawable: types::xproto::Drawable, dst_drawable: types::xproto::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16, bit_plane: types::Card32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CopyPlaneRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
            bit_plane,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn poly_point<'this>(&'this mut self, coordinate_mode: types::CoordMode, drawable: types::xproto::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "poly_point",
            coordinate_mode = ?coordinate_mode,
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyPointRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn poly_point_checked<'this>(&'this mut self, coordinate_mode: types::CoordMode, drawable: types::xproto::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::PolyPointRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn poly_line<'this>(&'this mut self, coordinate_mode: types::CoordMode, drawable: types::xproto::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "poly_line",
            coordinate_mode = ?coordinate_mode,
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyLineRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn poly_line_checked<'this>(&'this mut self, coordinate_mode: types::CoordMode, drawable: types::xproto::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::PolyLineRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn poly_segment<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, segments: impl AsRef<[types::Segment]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "poly_segment",
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolySegmentRequest {
            drawable,
            gc,
            segments: Cow::Borrowed(segments.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn poly_segment_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, segments: impl AsRef<[types::Segment]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::PolySegmentRequest {
            drawable,
            gc,
            segments: Cow::Borrowed(segments.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn poly_rectangle<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "poly_rectangle",
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn poly_rectangle_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::PolyRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn poly_arc<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "poly_arc",
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn poly_arc_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::PolyArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn fill_poly<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, shape: types::PolyShape, coordinate_mode: types::CoordMode, points: impl AsRef<[types::Point]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "fill_poly",
            drawable = ?drawable,
            gc = ?gc,
            shape = ?shape,
            coordinate_mode = ?coordinate_mode,
        );
        let request = types::xproto::FillPolyRequest {
            drawable,
            gc,
            shape,
            coordinate_mode,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn fill_poly_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, shape: types::PolyShape, coordinate_mode: types::CoordMode, points: impl AsRef<[types::Point]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::FillPolyRequest {
            drawable,
            gc,
            shape,
            coordinate_mode,
            points: Cow::Borrowed(points.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn poly_fill_rectangle<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "poly_fill_rectangle",
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyFillRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn poly_fill_rectangle_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::PolyFillRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn poly_fill_arc<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "poly_fill_arc",
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyFillArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn poly_fill_arc_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::PolyFillArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn put_image<'this>(&'this mut self, format: types::ImageFormat, drawable: types::xproto::Drawable, gc: types::Gcontext, width: types::Card16, height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, left_pad: types::Card8, depth: types::Card8, data: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "put_image",
            format = ?format,
            drawable = ?drawable,
            gc = ?gc,
            width = ?width,
            height = ?height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            left_pad = ?left_pad,
            depth = ?depth,
        );
        let request = types::xproto::PutImageRequest {
            format,
            drawable,
            gc,
            width,
            height,
            dst_x,
            dst_y,
            left_pad,
            depth,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn put_image_checked<'this>(&'this mut self, format: types::ImageFormat, drawable: types::xproto::Drawable, gc: types::Gcontext, width: types::Card16, height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, left_pad: types::Card8, depth: types::Card8, data: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::PutImageRequest {
            format,
            drawable,
            gc,
            width,
            height,
            dst_x,
            dst_y,
            left_pad,
            depth,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn get_image<'this>(&'this mut self, format: types::ImageFormat, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32) -> futures::SendRequest<'this, Self, types::xproto::GetImageReply> {
        let span = tracing::info_span!(
            "get_image",
            format = ?format,
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            plane_mask = ?plane_mask,
        );
        let request = types::xproto::GetImageRequest {
            format,
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_image_immediate<'this>(&'this mut self, format: types::ImageFormat, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetImageReply> {
        let request = types::xproto::GetImageRequest {
            format,
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetImageReply> = cookie.into();
        res
    }
    fn poly_text8<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "poly_text8",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::PolyText8Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn poly_text8_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::PolyText8Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn poly_text16<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "poly_text16",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::PolyText16Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn poly_text16_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::PolyText16Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn image_text8<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "image_text8",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::ImageText8Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn image_text8_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ImageText8Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn image_text16<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char2b]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "image_text16",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::ImageText16Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn image_text16_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char2b]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ImageText16Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn create_colormap<'this>(&'this mut self, alloc: types::ColormapAlloc, mid: types::Colormap, window: types::xproto::Window, visual: types::Visualid) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "create_colormap",
            alloc = ?alloc,
            mid = ?mid,
            window = ?window,
            visual = ?visual,
        );
        let request = types::xproto::CreateColormapRequest {
            alloc,
            mid,
            window,
            visual,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn create_colormap_checked<'this>(&'this mut self, alloc: types::ColormapAlloc, mid: types::Colormap, window: types::xproto::Window, visual: types::Visualid) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CreateColormapRequest {
            alloc,
            mid,
            window,
            visual,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn free_colormap<'this>(&'this mut self, cmap: types::Colormap) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "free_colormap",
            cmap = ?cmap,
        );
        let request = types::xproto::FreeColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn free_colormap_checked<'this>(&'this mut self, cmap: types::Colormap) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::FreeColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn copy_colormap_and_free<'this>(&'this mut self, mid: types::Colormap, src_cmap: types::Colormap) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "copy_colormap_and_free",
            mid = ?mid,
            src_cmap = ?src_cmap,
        );
        let request = types::xproto::CopyColormapAndFreeRequest {
            mid,
            src_cmap,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn copy_colormap_and_free_checked<'this>(&'this mut self, mid: types::Colormap, src_cmap: types::Colormap) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CopyColormapAndFreeRequest {
            mid,
            src_cmap,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn install_colormap<'this>(&'this mut self, cmap: types::Colormap) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "install_colormap",
            cmap = ?cmap,
        );
        let request = types::xproto::InstallColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn install_colormap_checked<'this>(&'this mut self, cmap: types::Colormap) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::InstallColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn uninstall_colormap<'this>(&'this mut self, cmap: types::Colormap) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "uninstall_colormap",
            cmap = ?cmap,
        );
        let request = types::xproto::UninstallColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn uninstall_colormap_checked<'this>(&'this mut self, cmap: types::Colormap) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::UninstallColormapRequest {
            cmap,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn list_installed_colormaps<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xproto::ListInstalledColormapsReply> {
        let span = tracing::info_span!(
            "list_installed_colormaps",
            window = ?window,
        );
        let request = types::xproto::ListInstalledColormapsRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn list_installed_colormaps_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xproto::ListInstalledColormapsReply> {
        let request = types::xproto::ListInstalledColormapsRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::ListInstalledColormapsReply> = cookie.into();
        res
    }
    fn alloc_color<'this>(&'this mut self, cmap: types::Colormap, red: types::Card16, green: types::Card16, blue: types::Card16) -> futures::SendRequest<'this, Self, types::xproto::AllocColorReply> {
        let span = tracing::info_span!(
            "alloc_color",
            cmap = ?cmap,
            red = ?red,
            green = ?green,
            blue = ?blue,
        );
        let request = types::xproto::AllocColorRequest {
            cmap,
            red,
            green,
            blue,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn alloc_color_immediate<'this>(&'this mut self, cmap: types::Colormap, red: types::Card16, green: types::Card16, blue: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorReply> {
        let request = types::xproto::AllocColorRequest {
            cmap,
            red,
            green,
            blue,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorReply> = cookie.into();
        res
    }
    fn alloc_named_color<'this>(&'this mut self, cmap: types::Colormap, name: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, types::xproto::AllocNamedColorReply> {
        let span = tracing::info_span!(
            "alloc_named_color",
            cmap = ?cmap,
        );
        let request = types::xproto::AllocNamedColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn alloc_named_color_immediate<'this>(&'this mut self, cmap: types::Colormap, name: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, types::xproto::AllocNamedColorReply> {
        let request = types::xproto::AllocNamedColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::AllocNamedColorReply> = cookie.into();
        res
    }
    fn alloc_color_cells<'this>(&'this mut self, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, planes: types::Card16) -> futures::SendRequest<'this, Self, types::xproto::AllocColorCellsReply> {
        let span = tracing::info_span!(
            "alloc_color_cells",
            contiguous = ?contiguous,
            cmap = ?cmap,
            colors = ?colors,
            planes = ?planes,
        );
        let request = types::xproto::AllocColorCellsRequest {
            contiguous,
            cmap,
            colors,
            planes,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn alloc_color_cells_immediate<'this>(&'this mut self, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, planes: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorCellsReply> {
        let request = types::xproto::AllocColorCellsRequest {
            contiguous,
            cmap,
            colors,
            planes,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorCellsReply> = cookie.into();
        res
    }
    fn alloc_color_planes<'this>(&'this mut self, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, reds: types::Card16, greens: types::Card16, blues: types::Card16) -> futures::SendRequest<'this, Self, types::xproto::AllocColorPlanesReply> {
        let span = tracing::info_span!(
            "alloc_color_planes",
            contiguous = ?contiguous,
            cmap = ?cmap,
            colors = ?colors,
            reds = ?reds,
            greens = ?greens,
            blues = ?blues,
        );
        let request = types::xproto::AllocColorPlanesRequest {
            contiguous,
            cmap,
            colors,
            reds,
            greens,
            blues,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn alloc_color_planes_immediate<'this>(&'this mut self, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, reds: types::Card16, greens: types::Card16, blues: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorPlanesReply> {
        let request = types::xproto::AllocColorPlanesRequest {
            contiguous,
            cmap,
            colors,
            reds,
            greens,
            blues,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorPlanesReply> = cookie.into();
        res
    }
    fn free_colors<'this>(&'this mut self, cmap: types::Colormap, plane_mask: types::Card32, pixels: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "free_colors",
            cmap = ?cmap,
            plane_mask = ?plane_mask,
        );
        let request = types::xproto::FreeColorsRequest {
            cmap,
            plane_mask,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn free_colors_checked<'this>(&'this mut self, cmap: types::Colormap, plane_mask: types::Card32, pixels: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::FreeColorsRequest {
            cmap,
            plane_mask,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn store_colors<'this>(&'this mut self, cmap: types::Colormap, items: impl AsRef<[types::Coloritem]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "store_colors",
            cmap = ?cmap,
        );
        let request = types::xproto::StoreColorsRequest {
            cmap,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn store_colors_checked<'this>(&'this mut self, cmap: types::Colormap, items: impl AsRef<[types::Coloritem]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::StoreColorsRequest {
            cmap,
            items: Cow::Borrowed(items.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn store_named_color<'this>(&'this mut self, flags: impl Into<types::ColorFlag>, cmap: types::Colormap, pixel: types::Card32, name: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "store_named_color",
            cmap = ?cmap,
            pixel = ?pixel,
        );
        let request = types::xproto::StoreNamedColorRequest {
            flags: Into::<u32>::into(flags.into()) as _,
            cmap,
            pixel,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn store_named_color_checked<'this>(&'this mut self, flags: impl Into<types::ColorFlag>, cmap: types::Colormap, pixel: types::Card32, name: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::StoreNamedColorRequest {
            flags: Into::<u32>::into(flags.into()) as _,
            cmap,
            pixel,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn query_colors<'this>(&'this mut self, cmap: types::Colormap, pixels: impl AsRef<[types::Card32]>) -> futures::SendRequest<'this, Self, types::xproto::QueryColorsReply> {
        let span = tracing::info_span!(
            "query_colors",
            cmap = ?cmap,
        );
        let request = types::xproto::QueryColorsRequest {
            cmap,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn query_colors_immediate<'this>(&'this mut self, cmap: types::Colormap, pixels: impl AsRef<[types::Card32]>) -> futures::CheckedSendRequest<'this, Self, types::xproto::QueryColorsReply> {
        let request = types::xproto::QueryColorsRequest {
            cmap,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryColorsReply> = cookie.into();
        res
    }
    fn lookup_color<'this>(&'this mut self, cmap: types::Colormap, name: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, types::xproto::LookupColorReply> {
        let span = tracing::info_span!(
            "lookup_color",
            cmap = ?cmap,
        );
        let request = types::xproto::LookupColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn lookup_color_immediate<'this>(&'this mut self, cmap: types::Colormap, name: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, types::xproto::LookupColorReply> {
        let request = types::xproto::LookupColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::LookupColorReply> = cookie.into();
        res
    }
    fn create_cursor<'this>(&'this mut self, cid: types::xproto::Cursor, source: types::xproto::Pixmap, mask: impl Into<types::xproto::Pixmap>, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16, x: types::Card16, y: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "create_cursor",
            cid = ?cid,
            source = ?source,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::CreateCursorRequest {
            cid,
            source,
            mask: Into::<u32>::into(mask.into()) as _,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
            x,
            y,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn create_cursor_checked<'this>(&'this mut self, cid: types::xproto::Cursor, source: types::xproto::Pixmap, mask: impl Into<types::xproto::Pixmap>, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16, x: types::Card16, y: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CreateCursorRequest {
            cid,
            source,
            mask: Into::<u32>::into(mask.into()) as _,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
            x,
            y,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn create_glyph_cursor<'this>(&'this mut self, cid: types::xproto::Cursor, source_font: types::Font, mask_font: impl Into<types::Font>, source_char: types::Card16, mask_char: types::Card16, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "create_glyph_cursor",
            cid = ?cid,
            source_font = ?source_font,
            source_char = ?source_char,
            mask_char = ?mask_char,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
        );
        let request = types::xproto::CreateGlyphCursorRequest {
            cid,
            source_font,
            mask_font: Into::<u32>::into(mask_font.into()) as _,
            source_char,
            mask_char,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn create_glyph_cursor_checked<'this>(&'this mut self, cid: types::xproto::Cursor, source_font: types::Font, mask_font: impl Into<types::Font>, source_char: types::Card16, mask_char: types::Card16, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::CreateGlyphCursorRequest {
            cid,
            source_font,
            mask_font: Into::<u32>::into(mask_font.into()) as _,
            source_char,
            mask_char,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn free_cursor<'this>(&'this mut self, cursor: types::xproto::Cursor) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "free_cursor",
            cursor = ?cursor,
        );
        let request = types::xproto::FreeCursorRequest {
            cursor,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn free_cursor_checked<'this>(&'this mut self, cursor: types::xproto::Cursor) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::FreeCursorRequest {
            cursor,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn recolor_cursor<'this>(&'this mut self, cursor: types::xproto::Cursor, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "recolor_cursor",
            cursor = ?cursor,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
        );
        let request = types::xproto::RecolorCursorRequest {
            cursor,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn recolor_cursor_checked<'this>(&'this mut self, cursor: types::xproto::Cursor, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::RecolorCursorRequest {
            cursor,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn query_best_size<'this>(&'this mut self, class: types::QueryShapeOf, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16) -> futures::SendRequest<'this, Self, types::xproto::QueryBestSizeReply> {
        let span = tracing::info_span!(
            "query_best_size",
            class = ?class,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
        );
        let request = types::xproto::QueryBestSizeRequest {
            class,
            drawable,
            width,
            height,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn query_best_size_immediate<'this>(&'this mut self, class: types::QueryShapeOf, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xproto::QueryBestSizeReply> {
        let request = types::xproto::QueryBestSizeRequest {
            class,
            drawable,
            width,
            height,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryBestSizeReply> = cookie.into();
        res
    }
    fn query_extension<'this>(&'this mut self, name: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, types::xproto::QueryExtensionReply> {
        let span = tracing::info_span!(
            "query_extension",
        );
        let request = types::xproto::QueryExtensionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn query_extension_immediate<'this>(&'this mut self, name: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, types::xproto::QueryExtensionReply> {
        let request = types::xproto::QueryExtensionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryExtensionReply> = cookie.into();
        res
    }
    fn list_extensions<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xproto::ListExtensionsReply> {
        let span = tracing::info_span!(
            "list_extensions",
        );
        let request = types::xproto::ListExtensionsRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn list_extensions_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xproto::ListExtensionsReply> {
        let request = types::xproto::ListExtensionsRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::ListExtensionsReply> = cookie.into();
        res
    }
    fn change_keyboard_mapping<'this>(&'this mut self, keycode_count: types::Card8, first_keycode: types::Keycode, keysyms_per_keycode: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "change_keyboard_mapping",
            keycode_count = ?keycode_count,
            first_keycode = ?first_keycode,
            keysyms_per_keycode = ?keysyms_per_keycode,
        );
        let request = types::xproto::ChangeKeyboardMappingRequest {
            keycode_count,
            first_keycode,
            keysyms_per_keycode,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn change_keyboard_mapping_checked<'this>(&'this mut self, keycode_count: types::Card8, first_keycode: types::Keycode, keysyms_per_keycode: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ChangeKeyboardMappingRequest {
            keycode_count,
            first_keycode,
            keysyms_per_keycode,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn get_keyboard_mapping<'this>(&'this mut self, first_keycode: types::Keycode, count: types::Card8) -> futures::SendRequest<'this, Self, types::xproto::GetKeyboardMappingReply> {
        let span = tracing::info_span!(
            "get_keyboard_mapping",
            first_keycode = ?first_keycode,
            count = ?count,
        );
        let request = types::xproto::GetKeyboardMappingRequest {
            first_keycode,
            count,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_keyboard_mapping_immediate<'this>(&'this mut self, first_keycode: types::Keycode, count: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetKeyboardMappingReply> {
        let request = types::xproto::GetKeyboardMappingRequest {
            first_keycode,
            count,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetKeyboardMappingReply> = cookie.into();
        res
    }
    fn change_keyboard_control<'this>(&'this mut self, value_list: impl Borrow<types::xproto::ChangeKeyboardControlAux>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "change_keyboard_control",
        );
        let request = types::xproto::ChangeKeyboardControlRequest {
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn change_keyboard_control_checked<'this>(&'this mut self, value_list: impl Borrow<types::xproto::ChangeKeyboardControlAux>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ChangeKeyboardControlRequest {
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn get_keyboard_control<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xproto::GetKeyboardControlReply> {
        let span = tracing::info_span!(
            "get_keyboard_control",
        );
        let request = types::xproto::GetKeyboardControlRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_keyboard_control_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetKeyboardControlReply> {
        let request = types::xproto::GetKeyboardControlRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetKeyboardControlReply> = cookie.into();
        res
    }
    fn bell<'this>(&'this mut self, percent: types::Int8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "bell",
            percent = ?percent,
        );
        let request = types::xproto::BellRequest {
            percent,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn bell_checked<'this>(&'this mut self, percent: types::Int8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::BellRequest {
            percent,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn change_pointer_control<'this>(&'this mut self, acceleration_numerator: types::Int16, acceleration_denominator: types::Int16, threshold: types::Int16, do_acceleration: types::Bool, do_threshold: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "change_pointer_control",
            acceleration_numerator = ?acceleration_numerator,
            acceleration_denominator = ?acceleration_denominator,
            threshold = ?threshold,
            do_acceleration = ?do_acceleration,
            do_threshold = ?do_threshold,
        );
        let request = types::xproto::ChangePointerControlRequest {
            acceleration_numerator,
            acceleration_denominator,
            threshold,
            do_acceleration,
            do_threshold,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn change_pointer_control_checked<'this>(&'this mut self, acceleration_numerator: types::Int16, acceleration_denominator: types::Int16, threshold: types::Int16, do_acceleration: types::Bool, do_threshold: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ChangePointerControlRequest {
            acceleration_numerator,
            acceleration_denominator,
            threshold,
            do_acceleration,
            do_threshold,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn get_pointer_control<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xproto::GetPointerControlReply> {
        let span = tracing::info_span!(
            "get_pointer_control",
        );
        let request = types::xproto::GetPointerControlRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_pointer_control_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetPointerControlReply> {
        let request = types::xproto::GetPointerControlRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetPointerControlReply> = cookie.into();
        res
    }
    fn set_screen_saver<'this>(&'this mut self, timeout: types::Int16, interval: types::Int16, prefer_blanking: types::Blanking, allow_exposures: types::Exposures) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "set_screen_saver",
            timeout = ?timeout,
            interval = ?interval,
            prefer_blanking = ?prefer_blanking,
            allow_exposures = ?allow_exposures,
        );
        let request = types::xproto::SetScreenSaverRequest {
            timeout,
            interval,
            prefer_blanking,
            allow_exposures,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn set_screen_saver_checked<'this>(&'this mut self, timeout: types::Int16, interval: types::Int16, prefer_blanking: types::Blanking, allow_exposures: types::Exposures) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::SetScreenSaverRequest {
            timeout,
            interval,
            prefer_blanking,
            allow_exposures,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn get_screen_saver<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xproto::GetScreenSaverReply> {
        let span = tracing::info_span!(
            "get_screen_saver",
        );
        let request = types::xproto::GetScreenSaverRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_screen_saver_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetScreenSaverReply> {
        let request = types::xproto::GetScreenSaverRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetScreenSaverReply> = cookie.into();
        res
    }
    fn change_hosts<'this>(&'this mut self, mode: types::HostMode, family: types::Family, address: impl AsRef<[types::Byte]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "change_hosts",
            mode = ?mode,
            family = ?family,
        );
        let request = types::xproto::ChangeHostsRequest {
            mode,
            family,
            address: Cow::Borrowed(address.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn change_hosts_checked<'this>(&'this mut self, mode: types::HostMode, family: types::Family, address: impl AsRef<[types::Byte]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ChangeHostsRequest {
            mode,
            family,
            address: Cow::Borrowed(address.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn list_hosts<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xproto::ListHostsReply> {
        let span = tracing::info_span!(
            "list_hosts",
        );
        let request = types::xproto::ListHostsRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn list_hosts_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xproto::ListHostsReply> {
        let request = types::xproto::ListHostsRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::ListHostsReply> = cookie.into();
        res
    }
    fn set_access_control<'this>(&'this mut self, mode: types::AccessControl) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "set_access_control",
            mode = ?mode,
        );
        let request = types::xproto::SetAccessControlRequest {
            mode,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn set_access_control_checked<'this>(&'this mut self, mode: types::AccessControl) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::SetAccessControlRequest {
            mode,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn set_close_down_mode<'this>(&'this mut self, mode: types::CloseDown) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "set_close_down_mode",
            mode = ?mode,
        );
        let request = types::xproto::SetCloseDownModeRequest {
            mode,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn set_close_down_mode_checked<'this>(&'this mut self, mode: types::CloseDown) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::SetCloseDownModeRequest {
            mode,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn kill_client<'this>(&'this mut self, resource: impl Into<types::Kill>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "kill_client",
        );
        let request = types::xproto::KillClientRequest {
            resource: Into::<u32>::into(resource.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn kill_client_checked<'this>(&'this mut self, resource: impl Into<types::Kill>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::KillClientRequest {
            resource: Into::<u32>::into(resource.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn rotate_properties<'this>(&'this mut self, window: types::xproto::Window, delta: types::Int16, atoms: impl AsRef<[types::Atom]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "rotate_properties",
            window = ?window,
            delta = ?delta,
        );
        let request = types::xproto::RotatePropertiesRequest {
            window,
            delta,
            atoms: Cow::Borrowed(atoms.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn rotate_properties_checked<'this>(&'this mut self, window: types::xproto::Window, delta: types::Int16, atoms: impl AsRef<[types::Atom]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::RotatePropertiesRequest {
            window,
            delta,
            atoms: Cow::Borrowed(atoms.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn force_screen_saver<'this>(&'this mut self, mode: types::ScreenSaver) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "force_screen_saver",
            mode = ?mode,
        );
        let request = types::xproto::ForceScreenSaverRequest {
            mode,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn force_screen_saver_checked<'this>(&'this mut self, mode: types::ScreenSaver) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::ForceScreenSaverRequest {
            mode,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    fn set_pointer_mapping<'this>(&'this mut self, map: impl AsRef<[types::Card8]>) -> futures::SendRequest<'this, Self, types::xproto::SetPointerMappingReply> {
        let span = tracing::info_span!(
            "set_pointer_mapping",
        );
        let request = types::xproto::SetPointerMappingRequest {
            map: Cow::Borrowed(map.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn set_pointer_mapping_immediate<'this>(&'this mut self, map: impl AsRef<[types::Card8]>) -> futures::CheckedSendRequest<'this, Self, types::xproto::SetPointerMappingReply> {
        let request = types::xproto::SetPointerMappingRequest {
            map: Cow::Borrowed(map.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::SetPointerMappingReply> = cookie.into();
        res
    }
    fn get_pointer_mapping<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xproto::GetPointerMappingReply> {
        let span = tracing::info_span!(
            "get_pointer_mapping",
        );
        let request = types::xproto::GetPointerMappingRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_pointer_mapping_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetPointerMappingReply> {
        let request = types::xproto::GetPointerMappingRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetPointerMappingReply> = cookie.into();
        res
    }
    fn set_modifier_mapping<'this>(&'this mut self, keycodes: impl AsRef<[types::Keycode]>) -> futures::SendRequest<'this, Self, types::xproto::SetModifierMappingReply> {
        let span = tracing::info_span!(
            "set_modifier_mapping",
        );
        let request = types::xproto::SetModifierMappingRequest {
            keycodes: Cow::Borrowed(keycodes.as_ref()),
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn set_modifier_mapping_immediate<'this>(&'this mut self, keycodes: impl AsRef<[types::Keycode]>) -> futures::CheckedSendRequest<'this, Self, types::xproto::SetModifierMappingReply> {
        let request = types::xproto::SetModifierMappingRequest {
            keycodes: Cow::Borrowed(keycodes.as_ref()),
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::SetModifierMappingReply> = cookie.into();
        res
    }
    fn get_modifier_mapping<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xproto::GetModifierMappingReply> {
        let span = tracing::info_span!(
            "get_modifier_mapping",
        );
        let request = types::xproto::GetModifierMappingRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    fn get_modifier_mapping_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xproto::GetModifierMappingReply> {
        let request = types::xproto::GetModifierMappingRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetModifierMappingReply> = cookie.into();
        res
    }
    fn no_operation<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "no_operation",
        );
        let request = types::xproto::NoOperationRequest {
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    fn no_operation_checked<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xproto::NoOperationRequest {
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    #[cfg(feature = "xselinux")]
    fn xselinux_query_version<'this>(&'this mut self, client_major: types::Card8, client_minor: types::Card8) -> futures::SendRequest<'this, Self, types::xselinux::QueryVersionReply> {
        let span = tracing::info_span!(
            "xselinux_query_version",
            client_major = ?client_major,
            client_minor = ?client_minor,
        );
        let request = types::xselinux::QueryVersionRequest {
            client_major,
            client_minor,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_query_version_immediate<'this>(&'this mut self, client_major: types::Card8, client_minor: types::Card8) -> futures::CheckedSendRequest<'this, Self, types::xselinux::QueryVersionReply> {
        let request = types::xselinux::QueryVersionRequest {
            client_major,
            client_minor,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_create_context<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xselinux_set_device_create_context",
        );
        let request = types::xselinux::SetDeviceCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_create_context_checked<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xselinux::SetDeviceCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_create_context<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xselinux::GetDeviceCreateContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_device_create_context",
        );
        let request = types::xselinux::GetDeviceCreateContextRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_create_context_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetDeviceCreateContextReply> {
        let request = types::xselinux::GetDeviceCreateContextRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetDeviceCreateContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_context<'this>(&'this mut self, device: types::Card32, context: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xselinux_set_device_context",
            device = ?device,
        );
        let request = types::xselinux::SetDeviceContextRequest {
            device,
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_context_checked<'this>(&'this mut self, device: types::Card32, context: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xselinux::SetDeviceContextRequest {
            device,
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_context<'this>(&'this mut self, device: types::Card32) -> futures::SendRequest<'this, Self, types::xselinux::GetDeviceContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_device_context",
            device = ?device,
        );
        let request = types::xselinux::GetDeviceContextRequest {
            device,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_context_immediate<'this>(&'this mut self, device: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetDeviceContextReply> {
        let request = types::xselinux::GetDeviceContextRequest {
            device,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetDeviceContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_window_create_context<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xselinux_set_window_create_context",
        );
        let request = types::xselinux::SetWindowCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_window_create_context_checked<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xselinux::SetWindowCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_create_context<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xselinux::GetWindowCreateContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_window_create_context",
        );
        let request = types::xselinux::GetWindowCreateContextRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_create_context_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetWindowCreateContextReply> {
        let request = types::xselinux::GetWindowCreateContextRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetWindowCreateContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_context<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xselinux::GetWindowContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_window_context",
            window = ?window,
        );
        let request = types::xselinux::GetWindowContextRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_context_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetWindowContextReply> {
        let request = types::xselinux::GetWindowContextRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetWindowContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_create_context<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xselinux_set_property_create_context",
        );
        let request = types::xselinux::SetPropertyCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_create_context_checked<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xselinux::SetPropertyCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_create_context<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xselinux::GetPropertyCreateContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_property_create_context",
        );
        let request = types::xselinux::GetPropertyCreateContextRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_create_context_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyCreateContextReply> {
        let request = types::xselinux::GetPropertyCreateContextRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyCreateContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_use_context<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xselinux_set_property_use_context",
        );
        let request = types::xselinux::SetPropertyUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_use_context_checked<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xselinux::SetPropertyUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_use_context<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xselinux::GetPropertyUseContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_property_use_context",
        );
        let request = types::xselinux::GetPropertyUseContextRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_use_context_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyUseContextReply> {
        let request = types::xselinux::GetPropertyUseContextRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyUseContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_context<'this>(&'this mut self, window: types::xproto::Window, property: types::Atom) -> futures::SendRequest<'this, Self, types::xselinux::GetPropertyContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_property_context",
            window = ?window,
            property = ?property,
        );
        let request = types::xselinux::GetPropertyContextRequest {
            window,
            property,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_context_immediate<'this>(&'this mut self, window: types::xproto::Window, property: types::Atom) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyContextReply> {
        let request = types::xselinux::GetPropertyContextRequest {
            window,
            property,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_data_context<'this>(&'this mut self, window: types::xproto::Window, property: types::Atom) -> futures::SendRequest<'this, Self, types::xselinux::GetPropertyDataContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_property_data_context",
            window = ?window,
            property = ?property,
        );
        let request = types::xselinux::GetPropertyDataContextRequest {
            window,
            property,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_data_context_immediate<'this>(&'this mut self, window: types::xproto::Window, property: types::Atom) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyDataContextReply> {
        let request = types::xselinux::GetPropertyDataContextRequest {
            window,
            property,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyDataContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_properties<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xselinux::ListPropertiesReply> {
        let span = tracing::info_span!(
            "xselinux_list_properties",
            window = ?window,
        );
        let request = types::xselinux::ListPropertiesRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_properties_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xselinux::ListPropertiesReply> {
        let request = types::xselinux::ListPropertiesRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::ListPropertiesReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_create_context<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xselinux_set_selection_create_context",
        );
        let request = types::xselinux::SetSelectionCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_create_context_checked<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xselinux::SetSelectionCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_create_context<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xselinux::GetSelectionCreateContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_selection_create_context",
        );
        let request = types::xselinux::GetSelectionCreateContextRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_create_context_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionCreateContextReply> {
        let request = types::xselinux::GetSelectionCreateContextRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionCreateContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_use_context<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xselinux_set_selection_use_context",
        );
        let request = types::xselinux::SetSelectionUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_use_context_checked<'this>(&'this mut self, context: impl AsRef<[types::Char]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xselinux::SetSelectionUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_use_context<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xselinux::GetSelectionUseContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_selection_use_context",
        );
        let request = types::xselinux::GetSelectionUseContextRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_use_context_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionUseContextReply> {
        let request = types::xselinux::GetSelectionUseContextRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionUseContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_context<'this>(&'this mut self, selection: types::Atom) -> futures::SendRequest<'this, Self, types::xselinux::GetSelectionContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_selection_context",
            selection = ?selection,
        );
        let request = types::xselinux::GetSelectionContextRequest {
            selection,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_context_immediate<'this>(&'this mut self, selection: types::Atom) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionContextReply> {
        let request = types::xselinux::GetSelectionContextRequest {
            selection,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_data_context<'this>(&'this mut self, selection: types::Atom) -> futures::SendRequest<'this, Self, types::xselinux::GetSelectionDataContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_selection_data_context",
            selection = ?selection,
        );
        let request = types::xselinux::GetSelectionDataContextRequest {
            selection,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_data_context_immediate<'this>(&'this mut self, selection: types::Atom) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionDataContextReply> {
        let request = types::xselinux::GetSelectionDataContextRequest {
            selection,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionDataContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_selections<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xselinux::ListSelectionsReply> {
        let span = tracing::info_span!(
            "xselinux_list_selections",
        );
        let request = types::xselinux::ListSelectionsRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_selections_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xselinux::ListSelectionsReply> {
        let request = types::xselinux::ListSelectionsRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::ListSelectionsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_client_context<'this>(&'this mut self, resource: types::Card32) -> futures::SendRequest<'this, Self, types::xselinux::GetClientContextReply> {
        let span = tracing::info_span!(
            "xselinux_get_client_context",
            resource = ?resource,
        );
        let request = types::xselinux::GetClientContextRequest {
            resource,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_client_context_immediate<'this>(&'this mut self, resource: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xselinux::GetClientContextReply> {
        let request = types::xselinux::GetClientContextRequest {
            resource,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetClientContextReply> = cookie.into();
        res
    }
    
    #[cfg(feature = "xtest")]
    fn xtest_get_version<'this>(&'this mut self, major_version: types::Card8, minor_version: types::Card16) -> futures::SendRequest<'this, Self, types::xtest::GetVersionReply> {
        let span = tracing::info_span!(
            "xtest_get_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::xtest::GetVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xtest")]
    fn xtest_get_version_immediate<'this>(&'this mut self, major_version: types::Card8, minor_version: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xtest::GetVersionReply> {
        let request = types::xtest::GetVersionRequest {
            major_version,
            minor_version,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xtest::GetVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xtest")]
    fn xtest_compare_cursor<'this>(&'this mut self, window: types::xproto::Window, cursor: types::xproto::Cursor) -> futures::SendRequest<'this, Self, types::xtest::CompareCursorReply> {
        let span = tracing::info_span!(
            "xtest_compare_cursor",
            window = ?window,
            cursor = ?cursor,
        );
        let request = types::xtest::CompareCursorRequest {
            window,
            cursor,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xtest")]
    fn xtest_compare_cursor_immediate<'this>(&'this mut self, window: types::xproto::Window, cursor: types::xproto::Cursor) -> futures::CheckedSendRequest<'this, Self, types::xtest::CompareCursorReply> {
        let request = types::xtest::CompareCursorRequest {
            window,
            cursor,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xtest::CompareCursorReply> = cookie.into();
        res
    }
    #[cfg(feature = "xtest")]
    fn xtest_fake_input<'this>(&'this mut self, type_: types::Byte, detail: types::Byte, time: types::Card32, root: types::xproto::Window, root_x: types::Int16, root_y: types::Int16, deviceid: types::Card8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xtest_fake_input",
            type_ = ?type_,
            detail = ?detail,
            time = ?time,
            root = ?root,
            root_x = ?root_x,
            root_y = ?root_y,
            deviceid = ?deviceid,
        );
        let request = types::xtest::FakeInputRequest {
            type_,
            detail,
            time,
            root,
            root_x,
            root_y,
            deviceid,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xtest")]
    fn xtest_fake_input_checked<'this>(&'this mut self, type_: types::Byte, detail: types::Byte, time: types::Card32, root: types::xproto::Window, root_x: types::Int16, root_y: types::Int16, deviceid: types::Card8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xtest::FakeInputRequest {
            type_,
            detail,
            time,
            root,
            root_x,
            root_y,
            deviceid,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xtest")]
    fn xtest_grab_control<'this>(&'this mut self, impervious: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xtest_grab_control",
            impervious = ?impervious,
        );
        let request = types::xtest::GrabControlRequest {
            impervious,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xtest")]
    fn xtest_grab_control_checked<'this>(&'this mut self, impervious: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xtest::GrabControlRequest {
            impervious,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    #[cfg(feature = "xv")]
    fn xv_query_extension<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xv::QueryExtensionReply> {
        let span = tracing::info_span!(
            "xv_query_extension",
        );
        let request = types::xv::QueryExtensionRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_extension_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xv::QueryExtensionReply> {
        let request = types::xv::QueryExtensionRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryExtensionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_query_adaptors<'this>(&'this mut self, window: types::xproto::Window) -> futures::SendRequest<'this, Self, types::xv::QueryAdaptorsReply> {
        let span = tracing::info_span!(
            "xv_query_adaptors",
            window = ?window,
        );
        let request = types::xv::QueryAdaptorsRequest {
            window,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_adaptors_immediate<'this>(&'this mut self, window: types::xproto::Window) -> futures::CheckedSendRequest<'this, Self, types::xv::QueryAdaptorsReply> {
        let request = types::xv::QueryAdaptorsRequest {
            window,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryAdaptorsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_query_encodings<'this>(&'this mut self, port: types::Port) -> futures::SendRequest<'this, Self, types::xv::QueryEncodingsReply> {
        let span = tracing::info_span!(
            "xv_query_encodings",
            port = ?port,
        );
        let request = types::xv::QueryEncodingsRequest {
            port,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_encodings_immediate<'this>(&'this mut self, port: types::Port) -> futures::CheckedSendRequest<'this, Self, types::xv::QueryEncodingsReply> {
        let request = types::xv::QueryEncodingsRequest {
            port,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryEncodingsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_grab_port<'this>(&'this mut self, port: types::Port, time: impl Into<types::Time>) -> futures::SendRequest<'this, Self, types::xv::GrabPortReply> {
        let span = tracing::info_span!(
            "xv_grab_port",
            port = ?port,
        );
        let request = types::xv::GrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_grab_port_immediate<'this>(&'this mut self, port: types::Port, time: impl Into<types::Time>) -> futures::CheckedSendRequest<'this, Self, types::xv::GrabPortReply> {
        let request = types::xv::GrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xv::GrabPortReply> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_ungrab_port<'this>(&'this mut self, port: types::Port, time: impl Into<types::Time>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xv_ungrab_port",
            port = ?port,
        );
        let request = types::xv::UngrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_ungrab_port_checked<'this>(&'this mut self, port: types::Port, time: impl Into<types::Time>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xv::UngrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_put_video<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xv_put_video",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let request = types::xv::PutVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_put_video_checked<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xv::PutVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_put_still<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xv_put_still",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let request = types::xv::PutStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_put_still_checked<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xv::PutStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_get_video<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xv_get_video",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let request = types::xv::GetVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_get_video_checked<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xv::GetVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_get_still<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xv_get_still",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let request = types::xv::GetStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_get_still_checked<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xv::GetStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_stop_video<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xv_stop_video",
            port = ?port,
            drawable = ?drawable,
        );
        let request = types::xv::StopVideoRequest {
            port,
            drawable,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_stop_video_checked<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xv::StopVideoRequest {
            port,
            drawable,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_select_video_notify<'this>(&'this mut self, drawable: types::xproto::Drawable, onoff: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xv_select_video_notify",
            drawable = ?drawable,
            onoff = ?onoff,
        );
        let request = types::xv::SelectVideoNotifyRequest {
            drawable,
            onoff,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_select_video_notify_checked<'this>(&'this mut self, drawable: types::xproto::Drawable, onoff: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xv::SelectVideoNotifyRequest {
            drawable,
            onoff,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_select_port_notify<'this>(&'this mut self, port: types::Port, onoff: types::Bool) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xv_select_port_notify",
            port = ?port,
            onoff = ?onoff,
        );
        let request = types::xv::SelectPortNotifyRequest {
            port,
            onoff,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_select_port_notify_checked<'this>(&'this mut self, port: types::Port, onoff: types::Bool) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xv::SelectPortNotifyRequest {
            port,
            onoff,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_query_best_size<'this>(&'this mut self, port: types::Port, vid_w: types::Card16, vid_h: types::Card16, drw_w: types::Card16, drw_h: types::Card16, motion: types::Bool) -> futures::SendRequest<'this, Self, types::xv::QueryBestSizeReply> {
        let span = tracing::info_span!(
            "xv_query_best_size",
            port = ?port,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            motion = ?motion,
        );
        let request = types::xv::QueryBestSizeRequest {
            port,
            vid_w,
            vid_h,
            drw_w,
            drw_h,
            motion,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_best_size_immediate<'this>(&'this mut self, port: types::Port, vid_w: types::Card16, vid_h: types::Card16, drw_w: types::Card16, drw_h: types::Card16, motion: types::Bool) -> futures::CheckedSendRequest<'this, Self, types::xv::QueryBestSizeReply> {
        let request = types::xv::QueryBestSizeRequest {
            port,
            vid_w,
            vid_h,
            drw_w,
            drw_h,
            motion,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryBestSizeReply> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_set_port_attribute<'this>(&'this mut self, port: types::Port, attribute: types::Atom, value: types::Int32) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xv_set_port_attribute",
            port = ?port,
            attribute = ?attribute,
            value = ?value,
        );
        let request = types::xv::SetPortAttributeRequest {
            port,
            attribute,
            value,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_set_port_attribute_checked<'this>(&'this mut self, port: types::Port, attribute: types::Atom, value: types::Int32) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xv::SetPortAttributeRequest {
            port,
            attribute,
            value,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_get_port_attribute<'this>(&'this mut self, port: types::Port, attribute: types::Atom) -> futures::SendRequest<'this, Self, types::xv::GetPortAttributeReply> {
        let span = tracing::info_span!(
            "xv_get_port_attribute",
            port = ?port,
            attribute = ?attribute,
        );
        let request = types::xv::GetPortAttributeRequest {
            port,
            attribute,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_get_port_attribute_immediate<'this>(&'this mut self, port: types::Port, attribute: types::Atom) -> futures::CheckedSendRequest<'this, Self, types::xv::GetPortAttributeReply> {
        let request = types::xv::GetPortAttributeRequest {
            port,
            attribute,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xv::GetPortAttributeReply> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_query_port_attributes<'this>(&'this mut self, port: types::Port) -> futures::SendRequest<'this, Self, types::xv::QueryPortAttributesReply> {
        let span = tracing::info_span!(
            "xv_query_port_attributes",
            port = ?port,
        );
        let request = types::xv::QueryPortAttributesRequest {
            port,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_port_attributes_immediate<'this>(&'this mut self, port: types::Port) -> futures::CheckedSendRequest<'this, Self, types::xv::QueryPortAttributesReply> {
        let request = types::xv::QueryPortAttributesRequest {
            port,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryPortAttributesReply> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_list_image_formats<'this>(&'this mut self, port: types::Port) -> futures::SendRequest<'this, Self, types::xv::ListImageFormatsReply> {
        let span = tracing::info_span!(
            "xv_list_image_formats",
            port = ?port,
        );
        let request = types::xv::ListImageFormatsRequest {
            port,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_list_image_formats_immediate<'this>(&'this mut self, port: types::Port) -> futures::CheckedSendRequest<'this, Self, types::xv::ListImageFormatsReply> {
        let request = types::xv::ListImageFormatsRequest {
            port,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xv::ListImageFormatsReply> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_query_image_attributes<'this>(&'this mut self, port: types::Port, id: types::Card32, width: types::Card16, height: types::Card16) -> futures::SendRequest<'this, Self, types::xv::QueryImageAttributesReply> {
        let span = tracing::info_span!(
            "xv_query_image_attributes",
            port = ?port,
            id = ?id,
            width = ?width,
            height = ?height,
        );
        let request = types::xv::QueryImageAttributesRequest {
            port,
            id,
            width,
            height,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_query_image_attributes_immediate<'this>(&'this mut self, port: types::Port, id: types::Card32, width: types::Card16, height: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xv::QueryImageAttributesReply> {
        let request = types::xv::QueryImageAttributesRequest {
            port,
            id,
            width,
            height,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryImageAttributesReply> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_put_image<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, id: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, data: impl AsRef<[types::Card8]>) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xv_put_image",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            id = ?id,
            src_x = ?src_x,
            src_y = ?src_y,
            src_w = ?src_w,
            src_h = ?src_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            width = ?width,
            height = ?height,
        );
        let request = types::xv::PutImageRequest {
            port,
            drawable,
            gc,
            id,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_put_image_checked<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, id: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, data: impl AsRef<[types::Card8]>) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xv::PutImageRequest {
            port,
            drawable,
            gc,
            id,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            data: Cow::Borrowed(data.as_ref()),
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xv")]
    fn xv_shm_put_image<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, shmseg: types::Seg, id: types::Card32, offset: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, send_event: types::Card8) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xv_shm_put_image",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            shmseg = ?shmseg,
            id = ?id,
            offset = ?offset,
            src_x = ?src_x,
            src_y = ?src_y,
            src_w = ?src_w,
            src_h = ?src_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            width = ?width,
            height = ?height,
            send_event = ?send_event,
        );
        let request = types::xv::ShmPutImageRequest {
            port,
            drawable,
            gc,
            shmseg,
            id,
            offset,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            send_event,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xv")]
    fn xv_shm_put_image_checked<'this>(&'this mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, shmseg: types::Seg, id: types::Card32, offset: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, send_event: types::Card8) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xv::ShmPutImageRequest {
            port,
            drawable,
            gc,
            shmseg,
            id,
            offset,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            send_event,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    
    #[cfg(feature = "xvmc")]
    fn xvmc_query_version<'this>(&'this mut self, ) -> futures::SendRequest<'this, Self, types::xvmc::QueryVersionReply> {
        let span = tracing::info_span!(
            "xvmc_query_version",
        );
        let request = types::xvmc::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_query_version_immediate<'this>(&'this mut self, ) -> futures::CheckedSendRequest<'this, Self, types::xvmc::QueryVersionReply> {
        let request = types::xvmc::QueryVersionRequest {
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::QueryVersionReply> = cookie.into();
        res
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_surface_types<'this>(&'this mut self, port_id: types::Port) -> futures::SendRequest<'this, Self, types::xvmc::ListSurfaceTypesReply> {
        let span = tracing::info_span!(
            "xvmc_list_surface_types",
            port_id = ?port_id,
        );
        let request = types::xvmc::ListSurfaceTypesRequest {
            port_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_surface_types_immediate<'this>(&'this mut self, port_id: types::Port) -> futures::CheckedSendRequest<'this, Self, types::xvmc::ListSurfaceTypesReply> {
        let request = types::xvmc::ListSurfaceTypesRequest {
            port_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::ListSurfaceTypesReply> = cookie.into();
        res
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_context<'this>(&'this mut self, context_id: types::xvmc::Context, port_id: types::Port, surface_id: types::Surface, width: types::Card16, height: types::Card16, flags: types::Card32) -> futures::SendRequest<'this, Self, types::xvmc::CreateContextReply> {
        let span = tracing::info_span!(
            "xvmc_create_context",
            context_id = ?context_id,
            port_id = ?port_id,
            surface_id = ?surface_id,
            width = ?width,
            height = ?height,
            flags = ?flags,
        );
        let request = types::xvmc::CreateContextRequest {
            context_id,
            port_id,
            surface_id,
            width,
            height,
            flags,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_context_immediate<'this>(&'this mut self, context_id: types::xvmc::Context, port_id: types::Port, surface_id: types::Surface, width: types::Card16, height: types::Card16, flags: types::Card32) -> futures::CheckedSendRequest<'this, Self, types::xvmc::CreateContextReply> {
        let request = types::xvmc::CreateContextRequest {
            context_id,
            port_id,
            surface_id,
            width,
            height,
            flags,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::CreateContextReply> = cookie.into();
        res
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_context<'this>(&'this mut self, context_id: types::xvmc::Context) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xvmc_destroy_context",
            context_id = ?context_id,
        );
        let request = types::xvmc::DestroyContextRequest {
            context_id,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_context_checked<'this>(&'this mut self, context_id: types::xvmc::Context) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xvmc::DestroyContextRequest {
            context_id,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_surface<'this>(&'this mut self, surface_id: types::Surface, context_id: types::xvmc::Context) -> futures::SendRequest<'this, Self, types::xvmc::CreateSurfaceReply> {
        let span = tracing::info_span!(
            "xvmc_create_surface",
            surface_id = ?surface_id,
            context_id = ?context_id,
        );
        let request = types::xvmc::CreateSurfaceRequest {
            surface_id,
            context_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_surface_immediate<'this>(&'this mut self, surface_id: types::Surface, context_id: types::xvmc::Context) -> futures::CheckedSendRequest<'this, Self, types::xvmc::CreateSurfaceReply> {
        let request = types::xvmc::CreateSurfaceRequest {
            surface_id,
            context_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::CreateSurfaceReply> = cookie.into();
        res
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_surface<'this>(&'this mut self, surface_id: types::Surface) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xvmc_destroy_surface",
            surface_id = ?surface_id,
        );
        let request = types::xvmc::DestroySurfaceRequest {
            surface_id,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_surface_checked<'this>(&'this mut self, surface_id: types::Surface) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xvmc::DestroySurfaceRequest {
            surface_id,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_subpicture<'this>(&'this mut self, subpicture_id: types::Subpicture, context: types::xvmc::Context, xvimage_id: types::Card32, width: types::Card16, height: types::Card16) -> futures::SendRequest<'this, Self, types::xvmc::CreateSubpictureReply> {
        let span = tracing::info_span!(
            "xvmc_create_subpicture",
            subpicture_id = ?subpicture_id,
            context = ?context,
            xvimage_id = ?xvimage_id,
            width = ?width,
            height = ?height,
        );
        let request = types::xvmc::CreateSubpictureRequest {
            subpicture_id,
            context,
            xvimage_id,
            width,
            height,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_subpicture_immediate<'this>(&'this mut self, subpicture_id: types::Subpicture, context: types::xvmc::Context, xvimage_id: types::Card32, width: types::Card16, height: types::Card16) -> futures::CheckedSendRequest<'this, Self, types::xvmc::CreateSubpictureReply> {
        let request = types::xvmc::CreateSubpictureRequest {
            subpicture_id,
            context,
            xvimage_id,
            width,
            height,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::CreateSubpictureReply> = cookie.into();
        res
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_subpicture<'this>(&'this mut self, subpicture_id: types::Subpicture) -> futures::SendRequest<'this, Self, ()> {
        let span = tracing::info_span!(
            "xvmc_destroy_subpicture",
            subpicture_id = ?subpicture_id,
        );
        let request = types::xvmc::DestroySubpictureRequest {
            subpicture_id,
        };
        let cookie = self.send_void_request(request, true).with_span(span);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_subpicture_checked<'this>(&'this mut self, subpicture_id: types::Subpicture) -> futures::CheckedSendRequest<'this, Self, ()> {
        let request = types::xvmc::DestroySubpictureRequest {
            subpicture_id,
        };
        let cookie = self.send_void_request(request, false);
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_subpicture_types<'this>(&'this mut self, port_id: types::Port, surface_id: types::Surface) -> futures::SendRequest<'this, Self, types::xvmc::ListSubpictureTypesReply> {
        let span = tracing::info_span!(
            "xvmc_list_subpicture_types",
            port_id = ?port_id,
            surface_id = ?surface_id,
        );
        let request = types::xvmc::ListSubpictureTypesRequest {
            port_id,
            surface_id,
        };
        let cookie = self.send_reply_request(request).with_span(span);
        cookie
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_subpicture_types_immediate<'this>(&'this mut self, port_id: types::Port, surface_id: types::Surface) -> futures::CheckedSendRequest<'this, Self, types::xvmc::ListSubpictureTypesReply> {
        let request = types::xvmc::ListSubpictureTypesRequest {
            port_id,
            surface_id,
        };
        let cookie = self.send_reply_request(request);
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::ListSubpictureTypesReply> = cookie.into();
        res
    }
    }

impl<D: Display + ?Sized> DisplayFunctionsExt for D {}

#[cfg(feature = "async")]
impl<D: AsyncDisplay + ?Sized> AsyncDisplayFunctionsExt for D {}

mod __private {
    use crate::display::Display;

    pub trait Sealed {
        fn __sealed_trait_marker() {}
    }

    impl<D: Display + ?Sized> Sealed for D {}

    cfg_async! {
        use crate::display::AsyncDisplay;

        pub trait Sealed2 {
            fn __sealed_trait_marker() {}
        }

        impl<D: AsyncDisplay + ?Sized> Sealed2 for D {}
    }
}


#[allow(dead_code, unused_imports)]
mod types {
    pub(crate) type Card8 = u8;
    pub(crate) type Card16 = u16;
    pub(crate) type Card32 = u32;
    pub(crate) type Card64 = u64;
    pub(crate) type Bool = bool;
    pub(crate) type Char = u8;
    pub(crate) type Byte = u8;
    pub(crate) type Int8 = i8;
    pub(crate) type Int16 = i16;
    pub(crate) type Int32 = i32;
    pub(crate) type Float = f32;
    pub(crate) type Double = f64;
    pub(crate) type Void = u8;

    pub(crate) use crate::Fd;
    pub(crate) use crate::protocol::bigreq::{self, *};
    #[cfg(feature = "composite")]
    pub(crate) use crate::protocol::composite::{self, *};
    #[cfg(feature = "damage")]
    pub(crate) use crate::protocol::damage::{self, *};
    #[cfg(feature = "dpms")]
    pub(crate) use crate::protocol::dpms::{self, *};
    #[cfg(feature = "dri2")]
    pub(crate) use crate::protocol::dri2::{self, *};
    #[cfg(feature = "dri3")]
    pub(crate) use crate::protocol::dri3::{self, *};
    pub(crate) use crate::protocol::ge::{self, *};
    #[cfg(feature = "glx")]
    pub(crate) use crate::protocol::glx::{self, *};
    #[cfg(feature = "present")]
    pub(crate) use crate::protocol::present::{self, *};
    #[cfg(feature = "randr")]
    pub(crate) use crate::protocol::randr::{self, *};
    #[cfg(feature = "record")]
    pub(crate) use crate::protocol::record::{self, *};
    #[cfg(feature = "render")]
    pub(crate) use crate::protocol::render::{self, *};
    #[cfg(feature = "res")]
    pub(crate) use crate::protocol::res::{self, *};
    #[cfg(feature = "screensaver")]
    pub(crate) use crate::protocol::screensaver::{self, *};
    #[cfg(feature = "shape")]
    pub(crate) use crate::protocol::shape::{self, *};
    #[cfg(feature = "shm")]
    pub(crate) use crate::protocol::shm::{self, *};
    #[cfg(feature = "sync")]
    pub(crate) use crate::protocol::sync::{self, *};
    pub(crate) use crate::protocol::xc_misc::{self, *};
    #[cfg(feature = "xevie")]
    pub(crate) use crate::protocol::xevie::{self, *};
    #[cfg(feature = "xf86dri")]
    pub(crate) use crate::protocol::xf86dri::{self, *};
    #[cfg(feature = "xf86vidmode")]
    pub(crate) use crate::protocol::xf86vidmode::{self, *};
    #[cfg(feature = "xfixes")]
    pub(crate) use crate::protocol::xfixes::{self, *};
    #[cfg(feature = "xinerama")]
    pub(crate) use crate::protocol::xinerama::{self, *};
    #[cfg(feature = "xinput")]
    pub(crate) use crate::protocol::xinput::{self, *};
    #[cfg(feature = "xkb")]
    pub(crate) use crate::protocol::xkb::{self, *};
    #[cfg(feature = "xprint")]
    pub(crate) use crate::protocol::xprint::{self, *};
    pub(crate) use crate::protocol::xproto::{self, *};
    #[cfg(feature = "xselinux")]
    pub(crate) use crate::protocol::xselinux::{self, *};
    #[cfg(feature = "xtest")]
    pub(crate) use crate::protocol::xtest::{self, *};
    #[cfg(feature = "xv")]
    pub(crate) use crate::protocol::xv::{self, *};
    #[cfg(feature = "xvmc")]
    pub(crate) use crate::protocol::xvmc::{self, *};
}