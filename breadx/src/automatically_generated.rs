
// This file is automatically generated by the `breadx-generator` crate.
// Do not edit this file directly.

use crate::{Result, display::{Cookie, Display, DisplayExt}};
use alloc::borrow::Cow;
use core::borrow::Borrow;

cfg_async! {
    use crate::display::AsyncDisplay;
}

//! Contains automatically generated items.\n
pub trait DisplayFunctionsExt {
    fn bigreq_enable(display: &mut impl Display, ) -> Result<Cookie<types::EnableReply>> {
        let mut request = types::EnableRequest {
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "composite")]
    fn composite_query_version(display: &mut impl Display, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_window(display: &mut impl Display, window: types::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let mut request = types::RedirectWindowRequest {
            window,
            update,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_subwindows(display: &mut impl Display, window: types::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let mut request = types::RedirectSubwindowsRequest {
            window,
            update,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_window(display: &mut impl Display, window: types::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let mut request = types::UnredirectWindowRequest {
            window,
            update,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_subwindows(display: &mut impl Display, window: types::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let mut request = types::UnredirectSubwindowsRequest {
            window,
            update,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_create_region_from_border_clip(display: &mut impl Display, region: types::Region, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::CreateRegionFromBorderClipRequest {
            region,
            window,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_name_window_pixmap(display: &mut impl Display, window: types::Window, pixmap: types::Pixmap) -> Result<Cookie<()>> {
        let mut request = types::NameWindowPixmapRequest {
            window,
            pixmap,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_get_overlay_window(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetOverlayWindowReply>> {
        let mut request = types::GetOverlayWindowRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_release_overlay_window(display: &mut impl Display, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::ReleaseOverlayWindowRequest {
            window,
        };
        display.send_void_request(request)
    }
    
    #[cfg(feature = "damage")]
    fn damage_query_version(display: &mut impl Display, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_create(display: &mut impl Display, damage: types::Damage, drawable: types::Drawable, level: types::ReportLevel) -> Result<Cookie<()>> {
        let mut request = types::CreateRequest {
            damage,
            drawable,
            level,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_destroy(display: &mut impl Display, damage: types::Damage) -> Result<Cookie<()>> {
        let mut request = types::DestroyRequest {
            damage,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_subtract(display: &mut impl Display, damage: types::Damage, repair: impl Into<types::Region>, parts: impl Into<types::Region>) -> Result<Cookie<()>> {
        let mut request = types::SubtractRequest {
            damage,
            repair: Into::<u32>::into(repair.into()) as _,
            parts: Into::<u32>::into(parts.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_add(display: &mut impl Display, drawable: types::Drawable, region: types::Region) -> Result<Cookie<()>> {
        let mut request = types::AddRequest {
            drawable,
            region,
        };
        display.send_void_request(request)
    }
    
    #[cfg(feature = "dpms")]
    fn dpms_get_version(display: &mut impl Display, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::GetVersionReply>> {
        let mut request = types::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_capable(display: &mut impl Display, ) -> Result<Cookie<types::CapableReply>> {
        let mut request = types::CapableRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_timeouts(display: &mut impl Display, ) -> Result<Cookie<types::GetTimeoutsReply>> {
        let mut request = types::GetTimeoutsRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_set_timeouts(display: &mut impl Display, standby_timeout: types::Card16, suspend_timeout: types::Card16, off_timeout: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::SetTimeoutsRequest {
            standby_timeout,
            suspend_timeout,
            off_timeout,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_enable(display: &mut impl Display, ) -> Result<Cookie<()>> {
        let mut request = types::EnableRequest {
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_disable(display: &mut impl Display, ) -> Result<Cookie<()>> {
        let mut request = types::DisableRequest {
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_force_level(display: &mut impl Display, power_level: types::DpmsMode) -> Result<Cookie<()>> {
        let mut request = types::ForceLevelRequest {
            power_level,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_info(display: &mut impl Display, ) -> Result<Cookie<types::InfoReply>> {
        let mut request = types::InfoRequest {
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "dri2")]
    fn dri2_query_version(display: &mut impl Display, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            major_version,
            minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_connect(display: &mut impl Display, window: types::Window, driver_type: types::DriverType) -> Result<Cookie<types::ConnectReply>> {
        let mut request = types::ConnectRequest {
            window,
            driver_type,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_authenticate(display: &mut impl Display, window: types::Window, magic: types::Card32) -> Result<Cookie<types::AuthenticateReply>> {
        let mut request = types::AuthenticateRequest {
            window,
            magic,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_create_drawable(display: &mut impl Display, drawable: types::Drawable) -> Result<Cookie<()>> {
        let mut request = types::CreateDrawableRequest {
            drawable,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_destroy_drawable(display: &mut impl Display, drawable: types::Drawable) -> Result<Cookie<()>> {
        let mut request = types::DestroyDrawableRequest {
            drawable,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_buffers(display: &mut impl Display, drawable: types::Drawable, count: types::Card32, attachments: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let mut request = types::GetBuffersRequest {
            drawable,
            count,
            attachments: Cow::Borrowed(attachments.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_copy_region(display: &mut impl Display, drawable: types::Drawable, region: types::Card32, dest: types::Card32, src: types::Card32) -> Result<Cookie<types::CopyRegionReply>> {
        let mut request = types::CopyRegionRequest {
            drawable,
            region,
            dest,
            src,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_buffers_with_format(display: &mut impl Display, drawable: types::Drawable, count: types::Card32, attachments: impl AsRef<[types::AttachFormat]>) -> Result<Cookie<()>> {
        let mut request = types::GetBuffersWithFormatRequest {
            drawable,
            count,
            attachments: Cow::Borrowed(attachments.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_buffers(display: &mut impl Display, drawable: types::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> Result<Cookie<types::SwapBuffersReply>> {
        let mut request = types::SwapBuffersRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_msc(display: &mut impl Display, drawable: types::Drawable) -> Result<Cookie<types::GetMscReply>> {
        let mut request = types::GetMscRequest {
            drawable,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_msc(display: &mut impl Display, drawable: types::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> Result<Cookie<types::WaitMscReply>> {
        let mut request = types::WaitMscRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_sbc(display: &mut impl Display, drawable: types::Drawable, target_sbc_hi: types::Card32, target_sbc_lo: types::Card32) -> Result<Cookie<types::WaitSbcReply>> {
        let mut request = types::WaitSbcRequest {
            drawable,
            target_sbc_hi,
            target_sbc_lo,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_interval(display: &mut impl Display, drawable: types::Drawable, interval: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::SwapIntervalRequest {
            drawable,
            interval,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_param(display: &mut impl Display, drawable: types::Drawable, param: types::Card32) -> Result<Cookie<types::GetParamReply>> {
        let mut request = types::GetParamRequest {
            drawable,
            param,
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "dri3")]
    fn dri3_query_version(display: &mut impl Display, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            major_version,
            minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_open(display: &mut impl Display, drawable: types::Drawable, provider: types::Card32) -> Result<Cookie<types::OpenReply>> {
        let mut request = types::OpenRequest {
            drawable,
            provider,
        };
        display.send_reply_fd_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffer(display: &mut impl Display, pixmap: types::Pixmap, drawable: types::Drawable, size: types::Card32, width: types::Card16, height: types::Card16, stride: types::Card16, depth: types::Card8, bpp: types::Card8, pixmap_fd: types::Fd) -> Result<Cookie<()>> {
        let mut request = types::PixmapFromBufferRequest {
            pixmap,
            drawable,
            size,
            width,
            height,
            stride,
            depth,
            bpp,
            pixmap_fd,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffer_from_pixmap(display: &mut impl Display, pixmap: types::Pixmap) -> Result<Cookie<types::BufferFromPixmapReply>> {
        let mut request = types::BufferFromPixmapRequest {
            pixmap,
        };
        display.send_reply_fd_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fence_from_fd(display: &mut impl Display, drawable: types::Drawable, fence: types::Card32, initially_triggered: types::Bool, fence_fd: types::Fd) -> Result<Cookie<()>> {
        let mut request = types::FenceFromFdRequest {
            drawable,
            fence,
            initially_triggered,
            fence_fd,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fd_from_fence(display: &mut impl Display, drawable: types::Drawable, fence: types::Card32) -> Result<Cookie<types::FdFromFenceReply>> {
        let mut request = types::FdFromFenceRequest {
            drawable,
            fence,
        };
        display.send_reply_fd_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_get_supported_modifiers(display: &mut impl Display, window: types::Card32, depth: types::Card8, bpp: types::Card8) -> Result<Cookie<types::GetSupportedModifiersReply>> {
        let mut request = types::GetSupportedModifiersRequest {
            window,
            depth,
            bpp,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffers(display: &mut impl Display, pixmap: types::Pixmap, window: types::Window, num_buffers: types::Card8, width: types::Card16, height: types::Card16, stride0: types::Card32, offset0: types::Card32, stride1: types::Card32, offset1: types::Card32, stride2: types::Card32, offset2: types::Card32, stride3: types::Card32, offset3: types::Card32, depth: types::Card8, bpp: types::Card8, modifier: types::Card64, buffers: impl AsRef<[types::Fd]>) -> Result<Cookie<()>> {
        let mut request = types::PixmapFromBuffersRequest {
            pixmap,
            window,
            num_buffers,
            width,
            height,
            stride0,
            offset0,
            stride1,
            offset1,
            stride2,
            offset2,
            stride3,
            offset3,
            depth,
            bpp,
            modifier,
            buffers: Cow::Borrowed(buffers.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffers_from_pixmap(display: &mut impl Display, pixmap: types::Pixmap) -> Result<Cookie<types::BuffersFromPixmapReply>> {
        let mut request = types::BuffersFromPixmapRequest {
            pixmap,
        };
        display.send_reply_fd_request(request)
    }
    
    #[cfg(feature = "ge")]
    fn ge_query_version(display: &mut impl Display, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "glx")]
    fn glx_render(display: &mut impl Display, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let mut request = types::RenderRequest {
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_render_large(display: &mut impl Display, context_tag: types::ContextTag, request_num: types::Card16, request_total: types::Card16, data_len: types::Card32, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let mut request = types::RenderLargeRequest {
            context_tag,
            request_num,
            request_total,
            data_len,
            data: Cow::Borrowed(data.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context(display: &mut impl Display, context: types::GlxContext, visual: types::Visualid, screen: types::Card32, share_list: types::GlxContext, is_direct: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::CreateContextRequest {
            context,
            visual,
            screen,
            share_list,
            is_direct,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_context(display: &mut impl Display, context: types::GlxContext) -> Result<Cookie<()>> {
        let mut request = types::DestroyContextRequest {
            context,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_make_current(display: &mut impl Display, drawable: types::GlxDrawable, context: types::GlxContext, old_context_tag: types::ContextTag) -> Result<Cookie<types::MakeCurrentReply>> {
        let mut request = types::MakeCurrentRequest {
            drawable,
            context,
            old_context_tag,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_direct(display: &mut impl Display, context: types::GlxContext) -> Result<Cookie<types::IsDirectReply>> {
        let mut request = types::IsDirectRequest {
            context,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_version(display: &mut impl Display, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            major_version,
            minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_gl(display: &mut impl Display, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let mut request = types::WaitGlRequest {
            context_tag,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_x(display: &mut impl Display, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let mut request = types::WaitXRequest {
            context_tag,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_copy_context(display: &mut impl Display, src: types::GlxContext, dest: types::GlxContext, mask: types::Card32, src_context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let mut request = types::CopyContextRequest {
            src,
            dest,
            mask,
            src_context_tag,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_swap_buffers(display: &mut impl Display, context_tag: types::ContextTag, drawable: types::GlxDrawable) -> Result<Cookie<()>> {
        let mut request = types::SwapBuffersRequest {
            context_tag,
            drawable,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_use_x_font(display: &mut impl Display, context_tag: types::ContextTag, font: types::Font, first: types::Card32, count: types::Card32, list_base: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::UseXFontRequest {
            context_tag,
            font,
            first,
            count,
            list_base,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_glx_pixmap(display: &mut impl Display, screen: types::Card32, visual: types::Visualid, pixmap: types::XprotoPixmap, glx_pixmap: types::GlxPixmap) -> Result<Cookie<()>> {
        let mut request = types::CreateGlxPixmapRequest {
            screen,
            visual,
            pixmap,
            glx_pixmap,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_visual_configs(display: &mut impl Display, screen: types::Card32) -> Result<Cookie<types::GetVisualConfigsReply>> {
        let mut request = types::GetVisualConfigsRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_glx_pixmap(display: &mut impl Display, glx_pixmap: types::GlxPixmap) -> Result<Cookie<()>> {
        let mut request = types::DestroyGlxPixmapRequest {
            glx_pixmap,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private(display: &mut impl Display, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let mut request = types::VendorPrivateRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_with_reply(display: &mut impl Display, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<Cookie<types::VendorPrivateWithReplyReply>> {
        let mut request = types::VendorPrivateWithReplyRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_extensions_string(display: &mut impl Display, screen: types::Card32) -> Result<Cookie<types::QueryExtensionsStringReply>> {
        let mut request = types::QueryExtensionsStringRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_server_string(display: &mut impl Display, screen: types::Card32, name: types::Card32) -> Result<Cookie<types::QueryServerStringReply>> {
        let mut request = types::QueryServerStringRequest {
            screen,
            name,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_client_info(display: &mut impl Display, major_version: types::Card32, minor_version: types::Card32, str_len: types::Card32, string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::ClientInfoRequest {
            major_version,
            minor_version,
            str_len,
            string: Cow::Borrowed(string.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_fb_configs(display: &mut impl Display, screen: types::Card32) -> Result<Cookie<types::GetFbConfigsReply>> {
        let mut request = types::GetFbConfigsRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pixmap(display: &mut impl Display, screen: types::Card32, fbconfig: types::Fbconfig, pixmap: types::XprotoPixmap, glx_pixmap: types::GlxPixmap, num_attribs: types::Card32, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let mut request = types::CreatePixmapRequest {
            screen,
            fbconfig,
            pixmap,
            glx_pixmap,
            num_attribs,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pixmap(display: &mut impl Display, glx_pixmap: types::GlxPixmap) -> Result<Cookie<()>> {
        let mut request = types::DestroyPixmapRequest {
            glx_pixmap,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_new_context(display: &mut impl Display, context: types::GlxContext, fbconfig: types::Fbconfig, screen: types::Card32, render_type: types::Card32, share_list: types::GlxContext, is_direct: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::CreateNewContextRequest {
            context,
            fbconfig,
            screen,
            render_type,
            share_list,
            is_direct,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_context(display: &mut impl Display, context: types::GlxContext) -> Result<Cookie<types::QueryContextReply>> {
        let mut request = types::QueryContextRequest {
            context,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_make_context_current(display: &mut impl Display, old_context_tag: types::ContextTag, drawable: types::GlxDrawable, read_drawable: types::GlxDrawable, context: types::GlxContext) -> Result<Cookie<types::MakeContextCurrentReply>> {
        let mut request = types::MakeContextCurrentRequest {
            old_context_tag,
            drawable,
            read_drawable,
            context,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pbuffer(display: &mut impl Display, screen: types::Card32, fbconfig: types::Fbconfig, pbuffer: types::Pbuffer, num_attribs: types::Card32, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let mut request = types::CreatePbufferRequest {
            screen,
            fbconfig,
            pbuffer,
            num_attribs,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pbuffer(display: &mut impl Display, pbuffer: types::Pbuffer) -> Result<Cookie<()>> {
        let mut request = types::DestroyPbufferRequest {
            pbuffer,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_drawable_attributes(display: &mut impl Display, drawable: types::GlxDrawable) -> Result<Cookie<types::GetDrawableAttributesReply>> {
        let mut request = types::GetDrawableAttributesRequest {
            drawable,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_change_drawable_attributes(display: &mut impl Display, drawable: types::GlxDrawable, num_attribs: types::Card32, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let mut request = types::ChangeDrawableAttributesRequest {
            drawable,
            num_attribs,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_window(display: &mut impl Display, screen: types::Card32, fbconfig: types::Fbconfig, window: types::XprotoWindow, glx_window: types::GlxWindow, num_attribs: types::Card32, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let mut request = types::CreateWindowRequest {
            screen,
            fbconfig,
            window,
            glx_window,
            num_attribs,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_window(display: &mut impl Display, glxwindow: types::GlxWindow) -> Result<Cookie<()>> {
        let mut request = types::DeleteWindowRequest {
            glxwindow,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info_arb(display: &mut impl Display, major_version: types::Card32, minor_version: types::Card32, num_versions: types::Card32, gl_str_len: types::Card32, glx_str_len: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::SetClientInfoArbRequest {
            major_version,
            minor_version,
            num_versions,
            gl_str_len,
            glx_str_len,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_attribs_arb(display: &mut impl Display, context: types::GlxContext, fbconfig: types::Fbconfig, screen: types::Card32, share_list: types::GlxContext, is_direct: types::Bool, num_attribs: types::Card32, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let mut request = types::CreateContextAttribsArbRequest {
            context,
            fbconfig,
            screen,
            share_list,
            is_direct,
            num_attribs,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info2_arb(display: &mut impl Display, major_version: types::Card32, minor_version: types::Card32, num_versions: types::Card32, gl_str_len: types::Card32, glx_str_len: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::SetClientInfo2ArbRequest {
            major_version,
            minor_version,
            num_versions,
            gl_str_len,
            glx_str_len,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_new_list(display: &mut impl Display, context_tag: types::ContextTag, list: types::Card32, mode: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::NewListRequest {
            context_tag,
            list,
            mode,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_end_list(display: &mut impl Display, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let mut request = types::EndListRequest {
            context_tag,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_lists(display: &mut impl Display, context_tag: types::ContextTag, list: types::Card32, range: types::Int32) -> Result<Cookie<()>> {
        let mut request = types::DeleteListsRequest {
            context_tag,
            list,
            range,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_lists(display: &mut impl Display, context_tag: types::ContextTag, range: types::Int32) -> Result<Cookie<types::GenListsReply>> {
        let mut request = types::GenListsRequest {
            context_tag,
            range,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_feedback_buffer(display: &mut impl Display, context_tag: types::ContextTag, size: types::Int32, type_: types::Int32) -> Result<Cookie<()>> {
        let mut request = types::FeedbackBufferRequest {
            context_tag,
            size,
            type_,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_select_buffer(display: &mut impl Display, context_tag: types::ContextTag, size: types::Int32) -> Result<Cookie<()>> {
        let mut request = types::SelectBufferRequest {
            context_tag,
            size,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_render_mode(display: &mut impl Display, context_tag: types::ContextTag, mode: types::Card32) -> Result<Cookie<types::RenderModeReply>> {
        let mut request = types::RenderModeRequest {
            context_tag,
            mode,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_finish(display: &mut impl Display, context_tag: types::ContextTag) -> Result<Cookie<types::FinishReply>> {
        let mut request = types::FinishRequest {
            context_tag,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storef(display: &mut impl Display, context_tag: types::ContextTag, pname: types::Card32, datum: types::Float32) -> Result<Cookie<()>> {
        let mut request = types::PixelStorefRequest {
            context_tag,
            pname,
            datum,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storei(display: &mut impl Display, context_tag: types::ContextTag, pname: types::Card32, datum: types::Int32) -> Result<Cookie<()>> {
        let mut request = types::PixelStoreiRequest {
            context_tag,
            pname,
            datum,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_read_pixels(display: &mut impl Display, context_tag: types::ContextTag, x: types::Int32, y: types::Int32, width: types::Int32, height: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, lsb_first: types::Bool) -> Result<Cookie<types::ReadPixelsReply>> {
        let mut request = types::ReadPixelsRequest {
            context_tag,
            x,
            y,
            width,
            height,
            format,
            type_,
            swap_bytes,
            lsb_first,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_booleanv(display: &mut impl Display, context_tag: types::ContextTag, pname: types::Int32) -> Result<Cookie<types::GetBooleanvReply>> {
        let mut request = types::GetBooleanvRequest {
            context_tag,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_clip_plane(display: &mut impl Display, context_tag: types::ContextTag, plane: types::Int32) -> Result<Cookie<types::GetClipPlaneReply>> {
        let mut request = types::GetClipPlaneRequest {
            context_tag,
            plane,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_doublev(display: &mut impl Display, context_tag: types::ContextTag, pname: types::Card32) -> Result<Cookie<types::GetDoublevReply>> {
        let mut request = types::GetDoublevRequest {
            context_tag,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_error(display: &mut impl Display, context_tag: types::ContextTag) -> Result<Cookie<types::GetErrorReply>> {
        let mut request = types::GetErrorRequest {
            context_tag,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_floatv(display: &mut impl Display, context_tag: types::ContextTag, pname: types::Card32) -> Result<Cookie<types::GetFloatvReply>> {
        let mut request = types::GetFloatvRequest {
            context_tag,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_integerv(display: &mut impl Display, context_tag: types::ContextTag, pname: types::Card32) -> Result<Cookie<types::GetIntegervReply>> {
        let mut request = types::GetIntegervRequest {
            context_tag,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightfv(display: &mut impl Display, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetLightfvReply>> {
        let mut request = types::GetLightfvRequest {
            context_tag,
            light,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightiv(display: &mut impl Display, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetLightivReply>> {
        let mut request = types::GetLightivRequest {
            context_tag,
            light,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapdv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<Cookie<types::GetMapdvReply>> {
        let mut request = types::GetMapdvRequest {
            context_tag,
            target,
            query,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapfv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<Cookie<types::GetMapfvReply>> {
        let mut request = types::GetMapfvRequest {
            context_tag,
            target,
            query,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapiv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<Cookie<types::GetMapivReply>> {
        let mut request = types::GetMapivRequest {
            context_tag,
            target,
            query,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialfv(display: &mut impl Display, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetMaterialfvReply>> {
        let mut request = types::GetMaterialfvRequest {
            context_tag,
            face,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialiv(display: &mut impl Display, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetMaterialivReply>> {
        let mut request = types::GetMaterialivRequest {
            context_tag,
            face,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapfv(display: &mut impl Display, context_tag: types::ContextTag, map: types::Card32) -> Result<Cookie<types::GetPixelMapfvReply>> {
        let mut request = types::GetPixelMapfvRequest {
            context_tag,
            map,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapuiv(display: &mut impl Display, context_tag: types::ContextTag, map: types::Card32) -> Result<Cookie<types::GetPixelMapuivReply>> {
        let mut request = types::GetPixelMapuivRequest {
            context_tag,
            map,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapusv(display: &mut impl Display, context_tag: types::ContextTag, map: types::Card32) -> Result<Cookie<types::GetPixelMapusvReply>> {
        let mut request = types::GetPixelMapusvRequest {
            context_tag,
            map,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_polygon_stipple(display: &mut impl Display, context_tag: types::ContextTag, lsb_first: types::Bool) -> Result<Cookie<types::GetPolygonStippleReply>> {
        let mut request = types::GetPolygonStippleRequest {
            context_tag,
            lsb_first,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_string(display: &mut impl Display, context_tag: types::ContextTag, name: types::Card32) -> Result<Cookie<types::GetStringReply>> {
        let mut request = types::GetStringRequest {
            context_tag,
            name,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_envfv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetTexEnvfvReply>> {
        let mut request = types::GetTexEnvfvRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_enviv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetTexEnvivReply>> {
        let mut request = types::GetTexEnvivRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_gendv(display: &mut impl Display, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetTexGendvReply>> {
        let mut request = types::GetTexGendvRequest {
            context_tag,
            coord,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_genfv(display: &mut impl Display, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetTexGenfvReply>> {
        let mut request = types::GetTexGenfvRequest {
            context_tag,
            coord,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_geniv(display: &mut impl Display, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetTexGenivReply>> {
        let mut request = types::GetTexGenivRequest {
            context_tag,
            coord,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_image(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::GetTexImageReply>> {
        let mut request = types::GetTexImageRequest {
            context_tag,
            target,
            level,
            format,
            type_,
            swap_bytes,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameterfv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetTexParameterfvReply>> {
        let mut request = types::GetTexParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameteriv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetTexParameterivReply>> {
        let mut request = types::GetTexParameterivRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameterfv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> Result<Cookie<types::GetTexLevelParameterfvReply>> {
        let mut request = types::GetTexLevelParameterfvRequest {
            context_tag,
            target,
            level,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameteriv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> Result<Cookie<types::GetTexLevelParameterivReply>> {
        let mut request = types::GetTexLevelParameterivRequest {
            context_tag,
            target,
            level,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_enabled(display: &mut impl Display, context_tag: types::ContextTag, capability: types::Card32) -> Result<Cookie<types::IsEnabledReply>> {
        let mut request = types::IsEnabledRequest {
            context_tag,
            capability,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_list(display: &mut impl Display, context_tag: types::ContextTag, list: types::Card32) -> Result<Cookie<types::IsListReply>> {
        let mut request = types::IsListRequest {
            context_tag,
            list,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_flush(display: &mut impl Display, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let mut request = types::FlushRequest {
            context_tag,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_are_textures_resident(display: &mut impl Display, context_tag: types::ContextTag, n: types::Int32, textures: impl AsRef<[types::Card32]>) -> Result<Cookie<types::AreTexturesResidentReply>> {
        let mut request = types::AreTexturesResidentRequest {
            context_tag,
            n,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_textures(display: &mut impl Display, context_tag: types::ContextTag, n: types::Int32, textures: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let mut request = types::DeleteTexturesRequest {
            context_tag,
            n,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_textures(display: &mut impl Display, context_tag: types::ContextTag, n: types::Int32) -> Result<Cookie<types::GenTexturesReply>> {
        let mut request = types::GenTexturesRequest {
            context_tag,
            n,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_texture(display: &mut impl Display, context_tag: types::ContextTag, texture: types::Card32) -> Result<Cookie<types::IsTextureReply>> {
        let mut request = types::IsTextureRequest {
            context_tag,
            texture,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::GetColorTableReply>> {
        let mut request = types::GetColorTableRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameterfv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetColorTableParameterfvReply>> {
        let mut request = types::GetColorTableParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameteriv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetColorTableParameterivReply>> {
        let mut request = types::GetColorTableParameterivRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_filter(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::GetConvolutionFilterReply>> {
        let mut request = types::GetConvolutionFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameterfv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetConvolutionParameterfvReply>> {
        let mut request = types::GetConvolutionParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameteriv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetConvolutionParameterivReply>> {
        let mut request = types::GetConvolutionParameterivRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_separable_filter(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::GetSeparableFilterReply>> {
        let mut request = types::GetSeparableFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> Result<Cookie<types::GetHistogramReply>> {
        let mut request = types::GetHistogramRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameterfv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetHistogramParameterfvReply>> {
        let mut request = types::GetHistogramParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameteriv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetHistogramParameterivReply>> {
        let mut request = types::GetHistogramParameterivRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> Result<Cookie<types::GetMinmaxReply>> {
        let mut request = types::GetMinmaxRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameterfv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetMinmaxParameterfvReply>> {
        let mut request = types::GetMinmaxParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameteriv(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetMinmaxParameterivReply>> {
        let mut request = types::GetMinmaxParameterivRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_compressed_tex_image_arb(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, level: types::Int32) -> Result<Cookie<types::GetCompressedTexImageArbReply>> {
        let mut request = types::GetCompressedTexImageArbRequest {
            context_tag,
            target,
            level,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_queries_arb(display: &mut impl Display, context_tag: types::ContextTag, n: types::Int32, ids: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let mut request = types::DeleteQueriesArbRequest {
            context_tag,
            n,
            ids: Cow::Borrowed(ids.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_queries_arb(display: &mut impl Display, context_tag: types::ContextTag, n: types::Int32) -> Result<Cookie<types::GenQueriesArbReply>> {
        let mut request = types::GenQueriesArbRequest {
            context_tag,
            n,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_query_arb(display: &mut impl Display, context_tag: types::ContextTag, id: types::Card32) -> Result<Cookie<types::IsQueryArbReply>> {
        let mut request = types::IsQueryArbRequest {
            context_tag,
            id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_queryiv_arb(display: &mut impl Display, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetQueryivArbReply>> {
        let mut request = types::GetQueryivArbRequest {
            context_tag,
            target,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectiv_arb(display: &mut impl Display, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetQueryObjectivArbReply>> {
        let mut request = types::GetQueryObjectivArbRequest {
            context_tag,
            id,
            pname,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectuiv_arb(display: &mut impl Display, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> Result<Cookie<types::GetQueryObjectuivArbReply>> {
        let mut request = types::GetQueryObjectuivArbRequest {
            context_tag,
            id,
            pname,
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "present")]
    fn present_query_version(display: &mut impl Display, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            major_version,
            minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "present")]
    fn present_pixmap(display: &mut impl Display, window: types::Window, pixmap: types::Pixmap, serial: types::Card32, valid: types::Region, update: types::Region, x_off: types::Int16, y_off: types::Int16, target_crtc: types::Crtc, wait_fence: types::Fence, idle_fence: types::Fence, options: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64, notifies: impl AsRef<[types::Notify]>) -> Result<Cookie<()>> {
        let mut request = types::PixmapRequest {
            window,
            pixmap,
            serial,
            valid,
            update,
            x_off,
            y_off,
            target_crtc,
            wait_fence,
            idle_fence,
            options,
            target_msc,
            divisor,
            remainder,
            notifies: Cow::Borrowed(notifies.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "present")]
    fn present_notify_msc(display: &mut impl Display, window: types::Window, serial: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64) -> Result<Cookie<()>> {
        let mut request = types::NotifyMscRequest {
            window,
            serial,
            target_msc,
            divisor,
            remainder,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "present")]
    fn present_select_input(display: &mut impl Display, eid: types::Event, window: types::Window, event_mask: impl Into<types::EventMask>) -> Result<Cookie<()>> {
        let mut request = types::SelectInputRequest {
            eid,
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "present")]
    fn present_query_capabilities(display: &mut impl Display, target: types::Card32) -> Result<Cookie<types::QueryCapabilitiesReply>> {
        let mut request = types::QueryCapabilitiesRequest {
            target,
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "randr")]
    fn randr_query_version(display: &mut impl Display, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            major_version,
            minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_config(display: &mut impl Display, window: types::Window, timestamp: types::Timestamp, config_timestamp: types::Timestamp, size_id: types::Card16, rotation: impl Into<types::Rotation>, rate: types::Card16) -> Result<Cookie<types::SetScreenConfigReply>> {
        let mut request = types::SetScreenConfigRequest {
            window,
            timestamp,
            config_timestamp,
            size_id,
            rotation: Into::<u32>::into(rotation.into()) as _,
            rate,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_select_input(display: &mut impl Display, window: types::Window, enable: impl Into<types::NotifyMask>) -> Result<Cookie<()>> {
        let mut request = types::SelectInputRequest {
            window,
            enable: Into::<u32>::into(enable.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_info(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetScreenInfoReply>> {
        let mut request = types::GetScreenInfoRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_size_range(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetScreenSizeRangeReply>> {
        let mut request = types::GetScreenSizeRangeRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_size(display: &mut impl Display, window: types::Window, width: types::Card16, height: types::Card16, mm_width: types::Card32, mm_height: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::SetScreenSizeRequest {
            window,
            width,
            height,
            mm_width,
            mm_height,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetScreenResourcesReply>> {
        let mut request = types::GetScreenResourcesRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_info(display: &mut impl Display, output: types::Output, config_timestamp: types::Timestamp) -> Result<Cookie<types::GetOutputInfoReply>> {
        let mut request = types::GetOutputInfoRequest {
            output,
            config_timestamp,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_list_output_properties(display: &mut impl Display, output: types::Output) -> Result<Cookie<types::ListOutputPropertiesReply>> {
        let mut request = types::ListOutputPropertiesRequest {
            output,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_query_output_property(display: &mut impl Display, output: types::Output, property: types::Atom) -> Result<Cookie<types::QueryOutputPropertyReply>> {
        let mut request = types::QueryOutputPropertyRequest {
            output,
            property,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_output_property(display: &mut impl Display, output: types::Output, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> Result<Cookie<()>> {
        let mut request = types::ConfigureOutputPropertyRequest {
            output,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_change_output_property(display: &mut impl Display, output: types::Output, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::PropMode, num_units: types::Card32, data: impl AsRef<[types::Void]>) -> Result<Cookie<()>> {
        let mut request = types::ChangeOutputPropertyRequest {
            output,
            property,
            type_,
            format,
            mode,
            num_units,
            data: Cow::Borrowed(data.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_property(display: &mut impl Display, output: types::Output, property: types::Atom) -> Result<Cookie<()>> {
        let mut request = types::DeleteOutputPropertyRequest {
            output,
            property,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_property(display: &mut impl Display, output: types::Output, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> Result<Cookie<types::GetOutputPropertyReply>> {
        let mut request = types::GetOutputPropertyRequest {
            output,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
            delete,
            pending,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_create_mode(display: &mut impl Display, window: types::Window, mode_info: types::ModeInfo, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::CreateModeReply>> {
        let mut request = types::CreateModeRequest {
            window,
            mode_info,
            name: Cow::Borrowed(name.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_destroy_mode(display: &mut impl Display, mode: types::Mode) -> Result<Cookie<()>> {
        let mut request = types::DestroyModeRequest {
            mode,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_add_output_mode(display: &mut impl Display, output: types::Output, mode: types::Mode) -> Result<Cookie<()>> {
        let mut request = types::AddOutputModeRequest {
            output,
            mode,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_mode(display: &mut impl Display, output: types::Output, mode: types::Mode) -> Result<Cookie<()>> {
        let mut request = types::DeleteOutputModeRequest {
            output,
            mode,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_info(display: &mut impl Display, crtc: types::Crtc, config_timestamp: types::Timestamp) -> Result<Cookie<types::GetCrtcInfoReply>> {
        let mut request = types::GetCrtcInfoRequest {
            crtc,
            config_timestamp,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_config(display: &mut impl Display, crtc: types::Crtc, timestamp: types::Timestamp, config_timestamp: types::Timestamp, x: types::Int16, y: types::Int16, mode: types::Mode, rotation: impl Into<types::Rotation>, outputs: impl AsRef<[types::Output]>) -> Result<Cookie<types::SetCrtcConfigReply>> {
        let mut request = types::SetCrtcConfigRequest {
            crtc,
            timestamp,
            config_timestamp,
            x,
            y,
            mode,
            rotation: Into::<u32>::into(rotation.into()) as _,
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_size(display: &mut impl Display, crtc: types::Crtc) -> Result<Cookie<types::GetCrtcGammaSizeReply>> {
        let mut request = types::GetCrtcGammaSizeRequest {
            crtc,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma(display: &mut impl Display, crtc: types::Crtc) -> Result<Cookie<types::GetCrtcGammaReply>> {
        let mut request = types::GetCrtcGammaRequest {
            crtc,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_gamma(display: &mut impl Display, crtc: types::Crtc, size: types::Card16, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> Result<Cookie<()>> {
        let mut request = types::SetCrtcGammaRequest {
            crtc,
            size,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_current(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetScreenResourcesCurrentReply>> {
        let mut request = types::GetScreenResourcesCurrentRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_transform(display: &mut impl Display, crtc: types::Crtc, transform: types::Transform, filter_len: types::Card16, filter_name: impl AsRef<[types::Char]>, filter_params: impl AsRef<[types::Fixed]>) -> Result<Cookie<()>> {
        let mut request = types::SetCrtcTransformRequest {
            crtc,
            transform,
            filter_len,
            filter_name: Cow::Borrowed(filter_name.as_ref()),
            filter_params: Cow::Borrowed(filter_params.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_transform(display: &mut impl Display, crtc: types::Crtc) -> Result<Cookie<types::GetCrtcTransformReply>> {
        let mut request = types::GetCrtcTransformRequest {
            crtc,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_panning(display: &mut impl Display, crtc: types::Crtc) -> Result<Cookie<types::GetPanningReply>> {
        let mut request = types::GetPanningRequest {
            crtc,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_panning(display: &mut impl Display, crtc: types::Crtc, timestamp: types::Timestamp, left: types::Card16, top: types::Card16, width: types::Card16, height: types::Card16, track_left: types::Card16, track_top: types::Card16, track_width: types::Card16, track_height: types::Card16, border_left: types::Int16, border_top: types::Int16, border_right: types::Int16, border_bottom: types::Int16) -> Result<Cookie<types::SetPanningReply>> {
        let mut request = types::SetPanningRequest {
            crtc,
            timestamp,
            left,
            top,
            width,
            height,
            track_left,
            track_top,
            track_width,
            track_height,
            border_left,
            border_top,
            border_right,
            border_bottom,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_output_primary(display: &mut impl Display, window: types::Window, output: types::Output) -> Result<Cookie<()>> {
        let mut request = types::SetOutputPrimaryRequest {
            window,
            output,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_primary(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetOutputPrimaryReply>> {
        let mut request = types::GetOutputPrimaryRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_providers(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetProvidersReply>> {
        let mut request = types::GetProvidersRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_info(display: &mut impl Display, provider: types::Provider, config_timestamp: types::Timestamp) -> Result<Cookie<types::GetProviderInfoReply>> {
        let mut request = types::GetProviderInfoRequest {
            provider,
            config_timestamp,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_offload_sink(display: &mut impl Display, provider: types::Provider, sink_provider: types::Provider, config_timestamp: types::Timestamp) -> Result<Cookie<()>> {
        let mut request = types::SetProviderOffloadSinkRequest {
            provider,
            sink_provider,
            config_timestamp,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_output_source(display: &mut impl Display, provider: types::Provider, source_provider: types::Provider, config_timestamp: types::Timestamp) -> Result<Cookie<()>> {
        let mut request = types::SetProviderOutputSourceRequest {
            provider,
            source_provider,
            config_timestamp,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_list_provider_properties(display: &mut impl Display, provider: types::Provider) -> Result<Cookie<types::ListProviderPropertiesReply>> {
        let mut request = types::ListProviderPropertiesRequest {
            provider,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_query_provider_property(display: &mut impl Display, provider: types::Provider, property: types::Atom) -> Result<Cookie<types::QueryProviderPropertyReply>> {
        let mut request = types::QueryProviderPropertyRequest {
            provider,
            property,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_provider_property(display: &mut impl Display, provider: types::Provider, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> Result<Cookie<()>> {
        let mut request = types::ConfigureProviderPropertyRequest {
            provider,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_change_provider_property(display: &mut impl Display, provider: types::Provider, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::Card8, num_items: types::Card32, data: impl AsRef<[types::Void]>) -> Result<Cookie<()>> {
        let mut request = types::ChangeProviderPropertyRequest {
            provider,
            property,
            type_,
            format,
            mode,
            num_items,
            data: Cow::Borrowed(data.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_provider_property(display: &mut impl Display, provider: types::Provider, property: types::Atom) -> Result<Cookie<()>> {
        let mut request = types::DeleteProviderPropertyRequest {
            provider,
            property,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_property(display: &mut impl Display, provider: types::Provider, property: types::Atom, type_: types::Atom, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> Result<Cookie<types::GetProviderPropertyReply>> {
        let mut request = types::GetProviderPropertyRequest {
            provider,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_monitors(display: &mut impl Display, window: types::Window, get_active: types::Bool) -> Result<Cookie<types::GetMonitorsReply>> {
        let mut request = types::GetMonitorsRequest {
            window,
            get_active,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_monitor(display: &mut impl Display, window: types::Window, monitorinfo: types::MonitorInfo) -> Result<Cookie<()>> {
        let mut request = types::SetMonitorRequest {
            window,
            monitorinfo,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_monitor(display: &mut impl Display, window: types::Window, name: types::Atom) -> Result<Cookie<()>> {
        let mut request = types::DeleteMonitorRequest {
            window,
            name,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_create_lease(display: &mut impl Display, window: types::Window, lid: types::Lease, num_crtcs: types::Card16, num_outputs: types::Card16, crtcs: impl AsRef<[types::Crtc]>, outputs: impl AsRef<[types::Output]>) -> Result<Cookie<types::CreateLeaseReply>> {
        let mut request = types::CreateLeaseRequest {
            window,
            lid,
            num_crtcs,
            num_outputs,
            crtcs: Cow::Borrowed(crtcs.as_ref()),
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        display.send_reply_fd_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_free_lease(display: &mut impl Display, lid: types::Lease, terminate: types::Byte) -> Result<Cookie<()>> {
        let mut request = types::FreeLeaseRequest {
            lid,
            terminate,
        };
        display.send_void_request(request)
    }
    
    #[cfg(feature = "record")]
    fn record_query_version(display: &mut impl Display, major_version: types::Card16, minor_version: types::Card16) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            major_version,
            minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "record")]
    fn record_create_context(display: &mut impl Display, context: types::RecordContext, element_header: types::ElementHeader, num_client_specs: types::Card32, num_ranges: types::Card32, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> Result<Cookie<()>> {
        let mut request = types::CreateContextRequest {
            context,
            element_header,
            num_client_specs,
            num_ranges,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_register_clients(display: &mut impl Display, context: types::RecordContext, element_header: types::ElementHeader, num_client_specs: types::Card32, num_ranges: types::Card32, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> Result<Cookie<()>> {
        let mut request = types::RegisterClientsRequest {
            context,
            element_header,
            num_client_specs,
            num_ranges,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_unregister_clients(display: &mut impl Display, context: types::RecordContext, num_client_specs: types::Card32, client_specs: impl AsRef<[types::ClientSpec]>) -> Result<Cookie<()>> {
        let mut request = types::UnregisterClientsRequest {
            context,
            num_client_specs,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_get_context(display: &mut impl Display, context: types::RecordContext) -> Result<Cookie<types::GetContextReply>> {
        let mut request = types::GetContextRequest {
            context,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "record")]
    fn record_enable_context(display: &mut impl Display, context: types::RecordContext) -> Result<Cookie<types::EnableContextReply>> {
        let mut request = types::EnableContextRequest {
            context,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "record")]
    fn record_disable_context(display: &mut impl Display, context: types::RecordContext) -> Result<Cookie<()>> {
        let mut request = types::DisableContextRequest {
            context,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_free_context(display: &mut impl Display, context: types::RecordContext) -> Result<Cookie<()>> {
        let mut request = types::FreeContextRequest {
            context,
        };
        display.send_void_request(request)
    }
    
    #[cfg(feature = "render")]
    fn render_query_version(display: &mut impl Display, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_formats(display: &mut impl Display, ) -> Result<Cookie<types::QueryPictFormatsReply>> {
        let mut request = types::QueryPictFormatsRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_index_values(display: &mut impl Display, format: types::Pictformat) -> Result<Cookie<types::QueryPictIndexValuesReply>> {
        let mut request = types::QueryPictIndexValuesRequest {
            format,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_picture(display: &mut impl Display, pid: types::Picture, drawable: types::Drawable, format: types::Pictformat, value_mask: impl Into<types::Cp>, value_list: impl Borrow<types::CreatePictureAux>) -> Result<Cookie<()>> {
        let mut request = types::CreatePictureRequest {
            pid,
            drawable,
            format,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_change_picture(display: &mut impl Display, picture: types::Picture, value_mask: impl Into<types::Cp>, value_list: impl Borrow<types::ChangePictureAux>) -> Result<Cookie<()>> {
        let mut request = types::ChangePictureRequest {
            picture,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_clip_rectangles(display: &mut impl Display, picture: types::Picture, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let mut request = types::SetPictureClipRectanglesRequest {
            picture,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_free_picture(display: &mut impl Display, picture: types::Picture) -> Result<Cookie<()>> {
        let mut request = types::FreePictureRequest {
            picture,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite(display: &mut impl Display, op: types::PictOp, src: types::Picture, mask: impl Into<types::Picture>, dst: types::Picture, src_x: types::Int16, src_y: types::Int16, mask_x: types::Int16, mask_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::CompositeRequest {
            op,
            src,
            mask: Into::<u32>::into(mask.into()) as _,
            dst,
            src_x,
            src_y,
            mask_x,
            mask_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_trapezoids(display: &mut impl Display, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, traps: impl AsRef<[types::Trapezoid]>) -> Result<Cookie<()>> {
        let mut request = types::TrapezoidsRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_triangles(display: &mut impl Display, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, triangles: impl AsRef<[types::Triangle]>) -> Result<Cookie<()>> {
        let mut request = types::TrianglesRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            triangles: Cow::Borrowed(triangles.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_tri_strip(display: &mut impl Display, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> Result<Cookie<()>> {
        let mut request = types::TriStripRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_tri_fan(display: &mut impl Display, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> Result<Cookie<()>> {
        let mut request = types::TriFanRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_glyph_set(display: &mut impl Display, gsid: types::Glyphset, format: types::Pictformat) -> Result<Cookie<()>> {
        let mut request = types::CreateGlyphSetRequest {
            gsid,
            format,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_reference_glyph_set(display: &mut impl Display, gsid: types::Glyphset, existing: types::Glyphset) -> Result<Cookie<()>> {
        let mut request = types::ReferenceGlyphSetRequest {
            gsid,
            existing,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_free_glyph_set(display: &mut impl Display, glyphset: types::Glyphset) -> Result<Cookie<()>> {
        let mut request = types::FreeGlyphSetRequest {
            glyphset,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_add_glyphs(display: &mut impl Display, glyphset: types::Glyphset, glyphs_len: types::Card32, glyphids: impl AsRef<[types::Card32]>, glyphs: impl AsRef<[types::Glyphinfo]>, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let mut request = types::AddGlyphsRequest {
            glyphset,
            glyphs_len,
            glyphids: Cow::Borrowed(glyphids.as_ref()),
            glyphs: Cow::Borrowed(glyphs.as_ref()),
            data: Cow::Borrowed(data.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_free_glyphs(display: &mut impl Display, glyphset: types::Glyphset, glyphs: impl AsRef<[types::Glyph]>) -> Result<Cookie<()>> {
        let mut request = types::FreeGlyphsRequest {
            glyphset,
            glyphs: Cow::Borrowed(glyphs.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs8(display: &mut impl Display, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let mut request = types::CompositeGlyphs8Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs16(display: &mut impl Display, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let mut request = types::CompositeGlyphs16Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs32(display: &mut impl Display, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let mut request = types::CompositeGlyphs32Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_fill_rectangles(display: &mut impl Display, op: types::PictOp, dst: types::Picture, color: types::Color, rects: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let mut request = types::FillRectanglesRequest {
            op,
            dst,
            color,
            rects: Cow::Borrowed(rects.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_cursor(display: &mut impl Display, cid: types::Cursor, source: types::Picture, x: types::Card16, y: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::CreateCursorRequest {
            cid,
            source,
            x,
            y,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_transform(display: &mut impl Display, picture: types::Picture, transform: types::Transform) -> Result<Cookie<()>> {
        let mut request = types::SetPictureTransformRequest {
            picture,
            transform,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_query_filters(display: &mut impl Display, drawable: types::Drawable) -> Result<Cookie<types::QueryFiltersReply>> {
        let mut request = types::QueryFiltersRequest {
            drawable,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_filter(display: &mut impl Display, picture: types::Picture, filter_len: types::Card16, filter: impl AsRef<[types::Char]>, values: impl AsRef<[types::Fixed]>) -> Result<Cookie<()>> {
        let mut request = types::SetPictureFilterRequest {
            picture,
            filter_len,
            filter: Cow::Borrowed(filter.as_ref()),
            values: Cow::Borrowed(values.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_anim_cursor(display: &mut impl Display, cid: types::Cursor, cursors: impl AsRef<[types::Animcursorelt]>) -> Result<Cookie<()>> {
        let mut request = types::CreateAnimCursorRequest {
            cid,
            cursors: Cow::Borrowed(cursors.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_add_traps(display: &mut impl Display, picture: types::Picture, x_off: types::Int16, y_off: types::Int16, traps: impl AsRef<[types::Trap]>) -> Result<Cookie<()>> {
        let mut request = types::AddTrapsRequest {
            picture,
            x_off,
            y_off,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_solid_fill(display: &mut impl Display, picture: types::Picture, color: types::Color) -> Result<Cookie<()>> {
        let mut request = types::CreateSolidFillRequest {
            picture,
            color,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_linear_gradient(display: &mut impl Display, picture: types::Picture, p1: types::Pointfix, p2: types::Pointfix, num_stops: types::Card32, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<Cookie<()>> {
        let mut request = types::CreateLinearGradientRequest {
            picture,
            p1,
            p2,
            num_stops,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_radial_gradient(display: &mut impl Display, picture: types::Picture, inner: types::Pointfix, outer: types::Pointfix, inner_radius: types::Fixed, outer_radius: types::Fixed, num_stops: types::Card32, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<Cookie<()>> {
        let mut request = types::CreateRadialGradientRequest {
            picture,
            inner,
            outer,
            inner_radius,
            outer_radius,
            num_stops,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_conical_gradient(display: &mut impl Display, picture: types::Picture, center: types::Pointfix, angle: types::Fixed, num_stops: types::Card32, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<Cookie<()>> {
        let mut request = types::CreateConicalGradientRequest {
            picture,
            center,
            angle,
            num_stops,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        display.send_void_request(request)
    }
    
    #[cfg(feature = "res")]
    fn res_query_version(display: &mut impl Display, client_major: types::Card8, client_minor: types::Card8) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            client_major,
            client_minor,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_clients(display: &mut impl Display, ) -> Result<Cookie<types::QueryClientsReply>> {
        let mut request = types::QueryClientsRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_client_resources(display: &mut impl Display, xid: types::Card32) -> Result<Cookie<types::QueryClientResourcesReply>> {
        let mut request = types::QueryClientResourcesRequest {
            xid,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_client_pixmap_bytes(display: &mut impl Display, xid: types::Card32) -> Result<Cookie<types::QueryClientPixmapBytesReply>> {
        let mut request = types::QueryClientPixmapBytesRequest {
            xid,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_client_ids(display: &mut impl Display, num_specs: types::Card32, specs: impl AsRef<[types::ClientIdSpec]>) -> Result<Cookie<types::QueryClientIdsReply>> {
        let mut request = types::QueryClientIdsRequest {
            num_specs,
            specs: Cow::Borrowed(specs.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_resource_bytes(display: &mut impl Display, client: types::Card32, num_specs: types::Card32, specs: impl AsRef<[types::ResourceIdSpec]>) -> Result<Cookie<types::QueryResourceBytesReply>> {
        let mut request = types::QueryResourceBytesRequest {
            client,
            num_specs,
            specs: Cow::Borrowed(specs.as_ref()),
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "screensaver")]
    fn screensaver_query_version(display: &mut impl Display, client_major_version: types::Card8, client_minor_version: types::Card8) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_info(display: &mut impl Display, drawable: types::Drawable) -> Result<Cookie<types::QueryInfoReply>> {
        let mut request = types::QueryInfoRequest {
            drawable,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_select_input(display: &mut impl Display, drawable: types::Drawable, event_mask: impl Into<types::Event>) -> Result<Cookie<()>> {
        let mut request = types::SelectInputRequest {
            drawable,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_set_attributes(display: &mut impl Display, drawable: types::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, depth: types::Card8, visual: types::Visualid, value_mask: impl Into<types::Cw>, value_list: impl Borrow<types::SetAttributesAux>) -> Result<Cookie<()>> {
        let mut request = types::SetAttributesRequest {
            drawable,
            x,
            y,
            width,
            height,
            border_width,
            class,
            depth,
            visual,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_unset_attributes(display: &mut impl Display, drawable: types::Drawable) -> Result<Cookie<()>> {
        let mut request = types::UnsetAttributesRequest {
            drawable,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_suspend(display: &mut impl Display, suspend: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::SuspendRequest {
            suspend,
        };
        display.send_void_request(request)
    }
    
    #[cfg(feature = "shape")]
    fn shape_query_version(display: &mut impl Display, ) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_rectangles(display: &mut impl Display, operation: types::So, destination_kind: types::Sk, ordering: types::ClipOrdering, destination_window: types::Window, x_offset: types::Int16, y_offset: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let mut request = types::RectanglesRequest {
            operation,
            destination_kind,
            ordering,
            destination_window,
            x_offset,
            y_offset,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_mask(display: &mut impl Display, operation: types::So, destination_kind: types::Sk, destination_window: types::Window, x_offset: types::Int16, y_offset: types::Int16, source_bitmap: impl Into<types::Pixmap>) -> Result<Cookie<()>> {
        let mut request = types::MaskRequest {
            operation,
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
            source_bitmap: Into::<u32>::into(source_bitmap.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_combine(display: &mut impl Display, operation: types::So, destination_kind: types::Sk, source_kind: types::Sk, destination_window: types::Window, x_offset: types::Int16, y_offset: types::Int16, source_window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::CombineRequest {
            operation,
            destination_kind,
            source_kind,
            destination_window,
            x_offset,
            y_offset,
            source_window,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_offset(display: &mut impl Display, destination_kind: types::Sk, destination_window: types::Window, x_offset: types::Int16, y_offset: types::Int16) -> Result<Cookie<()>> {
        let mut request = types::OffsetRequest {
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_query_extents(display: &mut impl Display, destination_window: types::Window) -> Result<Cookie<types::QueryExtentsReply>> {
        let mut request = types::QueryExtentsRequest {
            destination_window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_select_input(display: &mut impl Display, destination_window: types::Window, enable: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::SelectInputRequest {
            destination_window,
            enable,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_input_selected(display: &mut impl Display, destination_window: types::Window) -> Result<Cookie<types::InputSelectedReply>> {
        let mut request = types::InputSelectedRequest {
            destination_window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_get_rectangles(display: &mut impl Display, window: types::Window, source_kind: types::Sk) -> Result<Cookie<types::GetRectanglesReply>> {
        let mut request = types::GetRectanglesRequest {
            window,
            source_kind,
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "shm")]
    fn shm_query_version(display: &mut impl Display, ) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_attach(display: &mut impl Display, shmseg: types::Seg, shmid: types::Card32, read_only: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::AttachRequest {
            shmseg,
            shmid,
            read_only,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_detach(display: &mut impl Display, shmseg: types::Seg) -> Result<Cookie<()>> {
        let mut request = types::DetachRequest {
            shmseg,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_put_image(display: &mut impl Display, drawable: types::Drawable, gc: types::Gcontext, total_width: types::Card16, total_height: types::Card16, src_x: types::Card16, src_y: types::Card16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, depth: types::Card8, format: types::Card8, send_event: types::Bool, shmseg: types::Seg, offset: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::PutImageRequest {
            drawable,
            gc,
            total_width,
            total_height,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            depth,
            format,
            send_event,
            shmseg,
            offset,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_get_image(display: &mut impl Display, drawable: types::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32, format: types::Card8, shmseg: types::Seg, offset: types::Card32) -> Result<Cookie<types::GetImageReply>> {
        let mut request = types::GetImageRequest {
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
            format,
            shmseg,
            offset,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_create_pixmap(display: &mut impl Display, pid: types::Pixmap, drawable: types::Drawable, width: types::Card16, height: types::Card16, depth: types::Card8, shmseg: types::Seg, offset: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::CreatePixmapRequest {
            pid,
            drawable,
            width,
            height,
            depth,
            shmseg,
            offset,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_attach_fd(display: &mut impl Display, shmseg: types::Seg, shm_fd: types::Fd, read_only: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::AttachFdRequest {
            shmseg,
            shm_fd,
            read_only,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_create_segment(display: &mut impl Display, shmseg: types::Seg, size: types::Card32, read_only: types::Bool) -> Result<Cookie<types::CreateSegmentReply>> {
        let mut request = types::CreateSegmentRequest {
            shmseg,
            size,
            read_only,
        };
        display.send_reply_fd_request(request)
    }
    
    #[cfg(feature = "sync")]
    fn sync_initialize(display: &mut impl Display, desired_major_version: types::Card8, desired_minor_version: types::Card8) -> Result<Cookie<types::InitializeReply>> {
        let mut request = types::InitializeRequest {
            desired_major_version,
            desired_minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_list_system_counters(display: &mut impl Display, ) -> Result<Cookie<types::ListSystemCountersReply>> {
        let mut request = types::ListSystemCountersRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_create_counter(display: &mut impl Display, id: types::Counter, initial_value: types::SyncInt64) -> Result<Cookie<()>> {
        let mut request = types::CreateCounterRequest {
            id,
            initial_value,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_counter(display: &mut impl Display, counter: types::Counter) -> Result<Cookie<()>> {
        let mut request = types::DestroyCounterRequest {
            counter,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_query_counter(display: &mut impl Display, counter: types::Counter) -> Result<Cookie<types::QueryCounterReply>> {
        let mut request = types::QueryCounterRequest {
            counter,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_await(display: &mut impl Display, wait_list: impl AsRef<[types::Waitcondition]>) -> Result<Cookie<()>> {
        let mut request = types::AwaitRequest {
            wait_list: Cow::Borrowed(wait_list.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_change_counter(display: &mut impl Display, counter: types::Counter, amount: types::SyncInt64) -> Result<Cookie<()>> {
        let mut request = types::ChangeCounterRequest {
            counter,
            amount,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_set_counter(display: &mut impl Display, counter: types::Counter, value: types::SyncInt64) -> Result<Cookie<()>> {
        let mut request = types::SetCounterRequest {
            counter,
            value,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_create_alarm(display: &mut impl Display, id: types::Alarm, value_mask: impl Into<types::Ca>, value_list: impl Borrow<types::CreateAlarmAux>) -> Result<Cookie<()>> {
        let mut request = types::CreateAlarmRequest {
            id,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_change_alarm(display: &mut impl Display, id: types::Alarm, value_mask: impl Into<types::Ca>, value_list: impl Borrow<types::ChangeAlarmAux>) -> Result<Cookie<()>> {
        let mut request = types::ChangeAlarmRequest {
            id,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_alarm(display: &mut impl Display, alarm: types::Alarm) -> Result<Cookie<()>> {
        let mut request = types::DestroyAlarmRequest {
            alarm,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_query_alarm(display: &mut impl Display, alarm: types::Alarm) -> Result<Cookie<types::QueryAlarmReply>> {
        let mut request = types::QueryAlarmRequest {
            alarm,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_set_priority(display: &mut impl Display, id: types::Card32, priority: types::Int32) -> Result<Cookie<()>> {
        let mut request = types::SetPriorityRequest {
            id,
            priority,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_get_priority(display: &mut impl Display, id: types::Card32) -> Result<Cookie<types::GetPriorityReply>> {
        let mut request = types::GetPriorityRequest {
            id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_create_fence(display: &mut impl Display, drawable: types::Drawable, fence: types::Fence, initially_triggered: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::CreateFenceRequest {
            drawable,
            fence,
            initially_triggered,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_trigger_fence(display: &mut impl Display, fence: types::Fence) -> Result<Cookie<()>> {
        let mut request = types::TriggerFenceRequest {
            fence,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_reset_fence(display: &mut impl Display, fence: types::Fence) -> Result<Cookie<()>> {
        let mut request = types::ResetFenceRequest {
            fence,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_fence(display: &mut impl Display, fence: types::Fence) -> Result<Cookie<()>> {
        let mut request = types::DestroyFenceRequest {
            fence,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_query_fence(display: &mut impl Display, fence: types::Fence) -> Result<Cookie<types::QueryFenceReply>> {
        let mut request = types::QueryFenceRequest {
            fence,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_await_fence(display: &mut impl Display, fence_list: impl AsRef<[types::Fence]>) -> Result<Cookie<()>> {
        let mut request = types::AwaitFenceRequest {
            fence_list: Cow::Borrowed(fence_list.as_ref()),
        };
        display.send_void_request(request)
    }
    
    #[cfg(feature = "xc_misc")]
    fn xc_misc_get_version(display: &mut impl Display, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::GetVersionReply>> {
        let mut request = types::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xc_misc")]
    fn xc_misc_get_xid_range(display: &mut impl Display, ) -> Result<Cookie<types::GetXidRangeReply>> {
        let mut request = types::GetXidRangeRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xc_misc")]
    fn xc_misc_get_xid_list(display: &mut impl Display, count: types::Card32) -> Result<Cookie<types::GetXidListReply>> {
        let mut request = types::GetXidListRequest {
            count,
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "xevie")]
    fn xevie_query_version(display: &mut impl Display, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_start(display: &mut impl Display, screen: types::Card32) -> Result<Cookie<types::StartReply>> {
        let mut request = types::StartRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_end(display: &mut impl Display, cmap: types::Card32) -> Result<Cookie<types::EndReply>> {
        let mut request = types::EndRequest {
            cmap,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_send(display: &mut impl Display, event: types::Event, data_type: types::Card32) -> Result<Cookie<types::SendReply>> {
        let mut request = types::SendRequest {
            event,
            data_type,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_select_input(display: &mut impl Display, event_mask: types::Card32) -> Result<Cookie<types::SelectInputReply>> {
        let mut request = types::SelectInputRequest {
            event_mask,
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_version(display: &mut impl Display, ) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_direct_rendering_capable(display: &mut impl Display, screen: types::Card32) -> Result<Cookie<types::QueryDirectRenderingCapableReply>> {
        let mut request = types::QueryDirectRenderingCapableRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_open_connection(display: &mut impl Display, screen: types::Card32) -> Result<Cookie<types::OpenConnectionReply>> {
        let mut request = types::OpenConnectionRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_close_connection(display: &mut impl Display, screen: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::CloseConnectionRequest {
            screen,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_client_driver_name(display: &mut impl Display, screen: types::Card32) -> Result<Cookie<types::GetClientDriverNameReply>> {
        let mut request = types::GetClientDriverNameRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_context(display: &mut impl Display, screen: types::Card32, visual: types::Card32, context: types::Card32) -> Result<Cookie<types::CreateContextReply>> {
        let mut request = types::CreateContextRequest {
            screen,
            visual,
            context,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_context(display: &mut impl Display, screen: types::Card32, context: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::DestroyContextRequest {
            screen,
            context,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_drawable(display: &mut impl Display, screen: types::Card32, drawable: types::Card32) -> Result<Cookie<types::CreateDrawableReply>> {
        let mut request = types::CreateDrawableRequest {
            screen,
            drawable,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_drawable(display: &mut impl Display, screen: types::Card32, drawable: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::DestroyDrawableRequest {
            screen,
            drawable,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_drawable_info(display: &mut impl Display, screen: types::Card32, drawable: types::Card32) -> Result<Cookie<types::GetDrawableInfoReply>> {
        let mut request = types::GetDrawableInfoRequest {
            screen,
            drawable,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_device_info(display: &mut impl Display, screen: types::Card32) -> Result<Cookie<types::GetDeviceInfoReply>> {
        let mut request = types::GetDeviceInfoRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_auth_connection(display: &mut impl Display, screen: types::Card32, magic: types::Card32) -> Result<Cookie<types::AuthConnectionReply>> {
        let mut request = types::AuthConnectionRequest {
            screen,
            magic,
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_query_version(display: &mut impl Display, ) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_mode_line(display: &mut impl Display, screen: types::Card16) -> Result<Cookie<types::GetModeLineReply>> {
        let mut request = types::GetModeLineRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_mod_mode_line(display: &mut impl Display, screen: types::Card32, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::ModeFlag>, privsize: types::Card32, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let mut request = types::ModModeLineRequest {
            screen,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            privsize,
            private: Cow::Borrowed(private.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_mode(display: &mut impl Display, screen: types::Card16, zoom: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::SwitchModeRequest {
            screen,
            zoom,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_monitor(display: &mut impl Display, screen: types::Card16) -> Result<Cookie<types::GetMonitorReply>> {
        let mut request = types::GetMonitorRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_lock_mode_switch(display: &mut impl Display, screen: types::Card16, lock: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::LockModeSwitchRequest {
            screen,
            lock,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_all_mode_lines(display: &mut impl Display, screen: types::Card16) -> Result<Cookie<types::GetAllModeLinesReply>> {
        let mut request = types::GetAllModeLinesRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_add_mode_line(display: &mut impl Display, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::ModeFlag>, privsize: types::Card32, after_dotclock: types::Dotclock, after_hdisplay: types::Card16, after_hsyncstart: types::Card16, after_hsyncend: types::Card16, after_htotal: types::Card16, after_hskew: types::Card16, after_vdisplay: types::Card16, after_vsyncstart: types::Card16, after_vsyncend: types::Card16, after_vtotal: types::Card16, after_flags: impl Into<types::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let mut request = types::AddModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            privsize,
            after_dotclock,
            after_hdisplay,
            after_hsyncstart,
            after_hsyncend,
            after_htotal,
            after_hskew,
            after_vdisplay,
            after_vsyncstart,
            after_vsyncend,
            after_vtotal,
            after_flags: Into::<u32>::into(after_flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_delete_mode_line(display: &mut impl Display, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::ModeFlag>, privsize: types::Card32, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let mut request = types::DeleteModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            privsize,
            private: Cow::Borrowed(private.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_validate_mode_line(display: &mut impl Display, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::ModeFlag>, privsize: types::Card32, private: impl AsRef<[types::Card8]>) -> Result<Cookie<types::ValidateModeLineReply>> {
        let mut request = types::ValidateModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            privsize,
            private: Cow::Borrowed(private.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_to_mode(display: &mut impl Display, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::ModeFlag>, privsize: types::Card32, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let mut request = types::SwitchToModeRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            privsize,
            private: Cow::Borrowed(private.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_view_port(display: &mut impl Display, screen: types::Card16) -> Result<Cookie<types::GetViewPortReply>> {
        let mut request = types::GetViewPortRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_view_port(display: &mut impl Display, screen: types::Card16, x: types::Card32, y: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::SetViewPortRequest {
            screen,
            x,
            y,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_dot_clocks(display: &mut impl Display, screen: types::Card16) -> Result<Cookie<types::GetDotClocksReply>> {
        let mut request = types::GetDotClocksRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_client_version(display: &mut impl Display, major: types::Card16, minor: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::SetClientVersionRequest {
            major,
            minor,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma(display: &mut impl Display, screen: types::Card16, red: types::Card32, green: types::Card32, blue: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::SetGammaRequest {
            screen,
            red,
            green,
            blue,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma(display: &mut impl Display, screen: types::Card16) -> Result<Cookie<types::GetGammaReply>> {
        let mut request = types::GetGammaRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp(display: &mut impl Display, screen: types::Card16, size: types::Card16) -> Result<Cookie<types::GetGammaRampReply>> {
        let mut request = types::GetGammaRampRequest {
            screen,
            size,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_ramp(display: &mut impl Display, screen: types::Card16, size: types::Card16, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> Result<Cookie<()>> {
        let mut request = types::SetGammaRampRequest {
            screen,
            size,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_size(display: &mut impl Display, screen: types::Card16) -> Result<Cookie<types::GetGammaRampSizeReply>> {
        let mut request = types::GetGammaRampSizeRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_permissions(display: &mut impl Display, screen: types::Card16) -> Result<Cookie<types::GetPermissionsReply>> {
        let mut request = types::GetPermissionsRequest {
            screen,
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "xfixes")]
    fn xfixes_query_version(display: &mut impl Display, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_save_set(display: &mut impl Display, mode: types::SaveSetMode, target: types::SaveSetTarget, map: types::SaveSetMapping, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::ChangeSaveSetRequest {
            mode,
            target,
            map,
            window,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_selection_input(display: &mut impl Display, window: types::Window, selection: types::Atom, event_mask: impl Into<types::SelectionEventMask>) -> Result<Cookie<()>> {
        let mut request = types::SelectSelectionInputRequest {
            window,
            selection,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_cursor_input(display: &mut impl Display, window: types::Window, event_mask: impl Into<types::CursorNotifyMask>) -> Result<Cookie<()>> {
        let mut request = types::SelectCursorInputRequest {
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image(display: &mut impl Display, ) -> Result<Cookie<types::GetCursorImageReply>> {
        let mut request = types::GetCursorImageRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region(display: &mut impl Display, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let mut request = types::CreateRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_bitmap(display: &mut impl Display, region: types::Region, bitmap: types::Pixmap) -> Result<Cookie<()>> {
        let mut request = types::CreateRegionFromBitmapRequest {
            region,
            bitmap,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_window(display: &mut impl Display, region: types::Region, window: types::Window, kind: types::Sk) -> Result<Cookie<()>> {
        let mut request = types::CreateRegionFromWindowRequest {
            region,
            window,
            kind,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_gc(display: &mut impl Display, region: types::Region, gc: types::Gcontext) -> Result<Cookie<()>> {
        let mut request = types::CreateRegionFromGcRequest {
            region,
            gc,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_picture(display: &mut impl Display, region: types::Region, picture: types::Picture) -> Result<Cookie<()>> {
        let mut request = types::CreateRegionFromPictureRequest {
            region,
            picture,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_destroy_region(display: &mut impl Display, region: types::Region) -> Result<Cookie<()>> {
        let mut request = types::DestroyRegionRequest {
            region,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_region(display: &mut impl Display, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let mut request = types::SetRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_copy_region(display: &mut impl Display, source: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let mut request = types::CopyRegionRequest {
            source,
            destination,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_union_region(display: &mut impl Display, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let mut request = types::UnionRegionRequest {
            source1,
            source2,
            destination,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_intersect_region(display: &mut impl Display, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let mut request = types::IntersectRegionRequest {
            source1,
            source2,
            destination,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_subtract_region(display: &mut impl Display, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let mut request = types::SubtractRegionRequest {
            source1,
            source2,
            destination,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_invert_region(display: &mut impl Display, source: types::Region, bounds: types::Rectangle, destination: types::Region) -> Result<Cookie<()>> {
        let mut request = types::InvertRegionRequest {
            source,
            bounds,
            destination,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_translate_region(display: &mut impl Display, region: types::Region, dx: types::Int16, dy: types::Int16) -> Result<Cookie<()>> {
        let mut request = types::TranslateRegionRequest {
            region,
            dx,
            dy,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_region_extents(display: &mut impl Display, source: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let mut request = types::RegionExtentsRequest {
            source,
            destination,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_fetch_region(display: &mut impl Display, region: types::Region) -> Result<Cookie<types::FetchRegionReply>> {
        let mut request = types::FetchRegionRequest {
            region,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_gc_clip_region(display: &mut impl Display, gc: types::Gcontext, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> Result<Cookie<()>> {
        let mut request = types::SetGcClipRegionRequest {
            gc,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_window_shape_region(display: &mut impl Display, dest: types::Window, dest_kind: types::Sk, x_offset: types::Int16, y_offset: types::Int16, region: impl Into<types::Region>) -> Result<Cookie<()>> {
        let mut request = types::SetWindowShapeRegionRequest {
            dest,
            dest_kind,
            x_offset,
            y_offset,
            region: Into::<u32>::into(region.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_picture_clip_region(display: &mut impl Display, picture: types::Picture, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> Result<Cookie<()>> {
        let mut request = types::SetPictureClipRegionRequest {
            picture,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_cursor_name(display: &mut impl Display, cursor: types::Cursor, nbytes: types::Card16, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::SetCursorNameRequest {
            cursor,
            nbytes,
            name: Cow::Borrowed(name.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_name(display: &mut impl Display, cursor: types::Cursor) -> Result<Cookie<types::GetCursorNameReply>> {
        let mut request = types::GetCursorNameRequest {
            cursor,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_and_name(display: &mut impl Display, ) -> Result<Cookie<types::GetCursorImageAndNameReply>> {
        let mut request = types::GetCursorImageAndNameRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor(display: &mut impl Display, source: types::Cursor, destination: types::Cursor) -> Result<Cookie<()>> {
        let mut request = types::ChangeCursorRequest {
            source,
            destination,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_by_name(display: &mut impl Display, src: types::Cursor, nbytes: types::Card16, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::ChangeCursorByNameRequest {
            src,
            nbytes,
            name: Cow::Borrowed(name.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_expand_region(display: &mut impl Display, source: types::Region, destination: types::Region, left: types::Card16, right: types::Card16, top: types::Card16, bottom: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::ExpandRegionRequest {
            source,
            destination,
            left,
            right,
            top,
            bottom,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_hide_cursor(display: &mut impl Display, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::HideCursorRequest {
            window,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_show_cursor(display: &mut impl Display, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::ShowCursorRequest {
            window,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_pointer_barrier(display: &mut impl Display, barrier: types::Barrier, window: types::Window, x1: types::Card16, y1: types::Card16, x2: types::Card16, y2: types::Card16, directions: impl Into<types::BarrierDirections>, num_devices: types::Card16, devices: impl AsRef<[types::Card16]>) -> Result<Cookie<()>> {
        let mut request = types::CreatePointerBarrierRequest {
            barrier,
            window,
            x1,
            y1,
            x2,
            y2,
            directions: Into::<u32>::into(directions.into()) as _,
            num_devices,
            devices: Cow::Borrowed(devices.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_delete_pointer_barrier(display: &mut impl Display, barrier: types::Barrier) -> Result<Cookie<()>> {
        let mut request = types::DeletePointerBarrierRequest {
            barrier,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_client_disconnect_mode(display: &mut impl Display, disconnect_mode: impl Into<types::ClientDisconnectFlags>) -> Result<Cookie<()>> {
        let mut request = types::SetClientDisconnectModeRequest {
            disconnect_mode: Into::<u32>::into(disconnect_mode.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_client_disconnect_mode(display: &mut impl Display, ) -> Result<Cookie<types::GetClientDisconnectModeReply>> {
        let mut request = types::GetClientDisconnectModeRequest {
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "xinerama")]
    fn xinerama_query_version(display: &mut impl Display, major: types::Card8, minor: types::Card8) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            major,
            minor,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_state(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetStateReply>> {
        let mut request = types::GetStateRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_count(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetScreenCountReply>> {
        let mut request = types::GetScreenCountRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_size(display: &mut impl Display, window: types::Window, screen: types::Card32) -> Result<Cookie<types::GetScreenSizeReply>> {
        let mut request = types::GetScreenSizeRequest {
            window,
            screen,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_is_active(display: &mut impl Display, ) -> Result<Cookie<types::IsActiveReply>> {
        let mut request = types::IsActiveRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_screens(display: &mut impl Display, ) -> Result<Cookie<types::QueryScreensReply>> {
        let mut request = types::QueryScreensRequest {
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "xinput")]
    fn xinput_get_extension_version(display: &mut impl Display, name_len: types::Card16, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::GetExtensionVersionReply>> {
        let mut request = types::GetExtensionVersionRequest {
            name_len,
            name: Cow::Borrowed(name.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_input_devices(display: &mut impl Display, ) -> Result<Cookie<types::ListInputDevicesReply>> {
        let mut request = types::ListInputDevicesRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_open_device(display: &mut impl Display, device_id: types::Card8) -> Result<Cookie<types::OpenDeviceReply>> {
        let mut request = types::OpenDeviceRequest {
            device_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_close_device(display: &mut impl Display, device_id: types::Card8) -> Result<Cookie<()>> {
        let mut request = types::CloseDeviceRequest {
            device_id,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_mode(display: &mut impl Display, device_id: types::Card8, mode: types::ValuatorMode) -> Result<Cookie<types::SetDeviceModeReply>> {
        let mut request = types::SetDeviceModeRequest {
            device_id,
            mode,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_select_extension_event(display: &mut impl Display, window: types::Window, num_classes: types::Card16, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let mut request = types::SelectExtensionEventRequest {
            window,
            num_classes,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_selected_extension_events(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetSelectedExtensionEventsReply>> {
        let mut request = types::GetSelectedExtensionEventsRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_dont_propagate_list(display: &mut impl Display, window: types::Window, num_classes: types::Card16, mode: types::PropagateMode, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let mut request = types::ChangeDeviceDontPropagateListRequest {
            window,
            num_classes,
            mode,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_dont_propagate_list(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetDeviceDontPropagateListReply>> {
        let mut request = types::GetDeviceDontPropagateListRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_motion_events(display: &mut impl Display, start: types::Timestamp, stop: impl Into<types::Time>, device_id: types::Card8) -> Result<Cookie<types::GetDeviceMotionEventsReply>> {
        let mut request = types::GetDeviceMotionEventsRequest {
            start,
            stop: Into::<u32>::into(stop.into()) as _,
            device_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_keyboard_device(display: &mut impl Display, device_id: types::Card8) -> Result<Cookie<types::ChangeKeyboardDeviceReply>> {
        let mut request = types::ChangeKeyboardDeviceRequest {
            device_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_pointer_device(display: &mut impl Display, x_axis: types::Card8, y_axis: types::Card8, device_id: types::Card8) -> Result<Cookie<types::ChangePointerDeviceReply>> {
        let mut request = types::ChangePointerDeviceRequest {
            x_axis,
            y_axis,
            device_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device(display: &mut impl Display, grab_window: types::Window, time: impl Into<types::Time>, num_classes: types::Card16, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, device_id: types::Card8, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<types::GrabDeviceReply>> {
        let mut request = types::GrabDeviceRequest {
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            num_classes,
            this_device_mode,
            other_device_mode,
            owner_events,
            device_id,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device(display: &mut impl Display, time: impl Into<types::Time>, device_id: types::Card8) -> Result<Cookie<()>> {
        let mut request = types::UngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            device_id,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_key(display: &mut impl Display, grab_window: types::Window, num_classes: types::Card16, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, grabbed_device: types::Card8, key: impl Into<types::Grab>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let mut request = types::GrabDeviceKeyRequest {
            grab_window,
            num_classes,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            grabbed_device,
            key: Into::<u32>::into(key.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_key(display: &mut impl Display, grab_window: types::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, key: impl Into<types::Grab>, grabbed_device: types::Card8) -> Result<Cookie<()>> {
        let mut request = types::UngrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            grabbed_device,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_button(display: &mut impl Display, grab_window: types::Window, grabbed_device: types::Card8, modifier_device: impl Into<types::ModifierDevice>, num_classes: types::Card16, modifiers: impl Into<types::ModMask>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, button: impl Into<types::Grab>, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let mut request = types::GrabDeviceButtonRequest {
            grab_window,
            grabbed_device,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            num_classes,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            this_device_mode,
            other_device_mode,
            button: Into::<u32>::into(button.into()) as _,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_button(display: &mut impl Display, grab_window: types::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, button: impl Into<types::Grab>, grabbed_device: types::Card8) -> Result<Cookie<()>> {
        let mut request = types::UngrabDeviceButtonRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            button: Into::<u32>::into(button.into()) as _,
            grabbed_device,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_allow_device_events(display: &mut impl Display, time: impl Into<types::Time>, mode: types::DeviceInputMode, device_id: types::Card8) -> Result<Cookie<()>> {
        let mut request = types::AllowDeviceEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            mode,
            device_id,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_focus(display: &mut impl Display, device_id: types::Card8) -> Result<Cookie<types::GetDeviceFocusReply>> {
        let mut request = types::GetDeviceFocusRequest {
            device_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_focus(display: &mut impl Display, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>, revert_to: types::InputFocus, device_id: types::Card8) -> Result<Cookie<()>> {
        let mut request = types::SetDeviceFocusRequest {
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            revert_to,
            device_id,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_feedback_control(display: &mut impl Display, device_id: types::Card8) -> Result<Cookie<types::GetFeedbackControlReply>> {
        let mut request = types::GetFeedbackControlRequest {
            device_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_feedback_control(display: &mut impl Display, mask: impl Into<types::ChangeFeedbackControlMask>, device_id: types::Card8, feedback_id: types::Card8, feedback: types::FeedbackCtl) -> Result<Cookie<()>> {
        let mut request = types::ChangeFeedbackControlRequest {
            mask: Into::<u32>::into(mask.into()) as _,
            device_id,
            feedback_id,
            feedback,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_key_mapping(display: &mut impl Display, device_id: types::Card8, first_keycode: types::KeyCode, count: types::Card8) -> Result<Cookie<types::GetDeviceKeyMappingReply>> {
        let mut request = types::GetDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            count,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_key_mapping(display: &mut impl Display, device_id: types::Card8, first_keycode: types::KeyCode, keysyms_per_keycode: types::Card8, keycode_count: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> Result<Cookie<()>> {
        let mut request = types::ChangeDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            keysyms_per_keycode,
            keycode_count,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_modifier_mapping(display: &mut impl Display, device_id: types::Card8) -> Result<Cookie<types::GetDeviceModifierMappingReply>> {
        let mut request = types::GetDeviceModifierMappingRequest {
            device_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_modifier_mapping(display: &mut impl Display, device_id: types::Card8, keycodes_per_modifier: types::Card8, keymaps: impl AsRef<[types::Card8]>) -> Result<Cookie<types::SetDeviceModifierMappingReply>> {
        let mut request = types::SetDeviceModifierMappingRequest {
            device_id,
            keycodes_per_modifier,
            keymaps: Cow::Borrowed(keymaps.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_button_mapping(display: &mut impl Display, device_id: types::Card8) -> Result<Cookie<types::GetDeviceButtonMappingReply>> {
        let mut request = types::GetDeviceButtonMappingRequest {
            device_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_button_mapping(display: &mut impl Display, device_id: types::Card8, map_size: types::Card8, map: impl AsRef<[types::Card8]>) -> Result<Cookie<types::SetDeviceButtonMappingReply>> {
        let mut request = types::SetDeviceButtonMappingRequest {
            device_id,
            map_size,
            map: Cow::Borrowed(map.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_query_device_state(display: &mut impl Display, device_id: types::Card8) -> Result<Cookie<types::QueryDeviceStateReply>> {
        let mut request = types::QueryDeviceStateRequest {
            device_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_device_bell(display: &mut impl Display, device_id: types::Card8, feedback_id: types::Card8, feedback_class: types::Card8, percent: types::Int8) -> Result<Cookie<()>> {
        let mut request = types::DeviceBellRequest {
            device_id,
            feedback_id,
            feedback_class,
            percent,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_valuators(display: &mut impl Display, device_id: types::Card8, first_valuator: types::Card8, num_valuators: types::Card8, valuators: impl AsRef<[types::Int32]>) -> Result<Cookie<types::SetDeviceValuatorsReply>> {
        let mut request = types::SetDeviceValuatorsRequest {
            device_id,
            first_valuator,
            num_valuators,
            valuators: Cow::Borrowed(valuators.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_control(display: &mut impl Display, control_id: types::DeviceControl, device_id: types::Card8) -> Result<Cookie<types::GetDeviceControlReply>> {
        let mut request = types::GetDeviceControlRequest {
            control_id,
            device_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_control(display: &mut impl Display, control_id: types::DeviceControl, device_id: types::Card8, control: types::DeviceCtl) -> Result<Cookie<types::ChangeDeviceControlReply>> {
        let mut request = types::ChangeDeviceControlRequest {
            control_id,
            device_id,
            control,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_device_properties(display: &mut impl Display, device_id: types::Card8) -> Result<Cookie<types::ListDevicePropertiesReply>> {
        let mut request = types::ListDevicePropertiesRequest {
            device_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_property(display: &mut impl Display, property: types::Atom, type_: types::Atom, device_id: types::Card8, format: types::PropertyFormat, mode: types::PropMode, num_items: types::Card32, value_list: impl Borrow<types::ChangeDevicePropertyAux>) -> Result<Cookie<()>> {
        let mut request = types::ChangeDevicePropertyRequest {
            property,
            type_,
            device_id,
            format,
            mode,
            num_items,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_delete_device_property(display: &mut impl Display, property: types::Atom, device_id: types::Card8) -> Result<Cookie<()>> {
        let mut request = types::DeleteDevicePropertyRequest {
            property,
            device_id,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_property(display: &mut impl Display, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32, device_id: types::Card8, delete: types::Bool) -> Result<Cookie<types::GetDevicePropertyReply>> {
        let mut request = types::GetDevicePropertyRequest {
            property,
            type_,
            offset,
            len,
            device_id,
            delete,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_pointer(display: &mut impl Display, window: types::Window, deviceid: impl Into<types::Device>) -> Result<Cookie<types::XiQueryPointerReply>> {
        let mut request = types::XiQueryPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_warp_pointer(display: &mut impl Display, src_win: types::Window, dst_win: types::Window, src_x: types::Fp1616, src_y: types::Fp1616, src_width: types::Card16, src_height: types::Card16, dst_x: types::Fp1616, dst_y: types::Fp1616, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let mut request = types::XiWarpPointerRequest {
            src_win,
            dst_win,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_cursor(display: &mut impl Display, window: types::Window, cursor: types::Cursor, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let mut request = types::XiChangeCursorRequest {
            window,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_hierarchy(display: &mut impl Display, num_changes: types::Card8, changes: impl AsRef<[types::HierarchyChange]>) -> Result<Cookie<()>> {
        let mut request = types::XiChangeHierarchyRequest {
            num_changes,
            changes: Cow::Borrowed(changes.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_client_pointer(display: &mut impl Display, window: types::Window, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let mut request = types::XiSetClientPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_client_pointer(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::XiGetClientPointerReply>> {
        let mut request = types::XiGetClientPointerRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_select_events(display: &mut impl Display, window: types::Window, num_mask: types::Card16, masks: impl AsRef<[types::EventMask]>) -> Result<Cookie<()>> {
        let mut request = types::XiSelectEventsRequest {
            window,
            num_mask,
            masks: Cow::Borrowed(masks.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_version(display: &mut impl Display, major_version: types::Card16, minor_version: types::Card16) -> Result<Cookie<types::XiQueryVersionReply>> {
        let mut request = types::XiQueryVersionRequest {
            major_version,
            minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_device(display: &mut impl Display, deviceid: impl Into<types::Device>) -> Result<Cookie<types::XiQueryDeviceReply>> {
        let mut request = types::XiQueryDeviceRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_focus(display: &mut impl Display, window: types::Window, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let mut request = types::XiSetFocusRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_focus(display: &mut impl Display, deviceid: impl Into<types::Device>) -> Result<Cookie<types::XiGetFocusReply>> {
        let mut request = types::XiGetFocusRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_grab_device(display: &mut impl Display, window: types::Window, time: impl Into<types::Time>, cursor: types::Cursor, deviceid: impl Into<types::Device>, mode: types::GrabMode, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask_len: types::Card16, mask: impl AsRef<[types::Card32]>) -> Result<Cookie<types::XiGrabDeviceReply>> {
        let mut request = types::XiGrabDeviceRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            paired_device_mode,
            owner_events,
            mask_len,
            mask: Cow::Borrowed(mask.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_ungrab_device(display: &mut impl Display, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let mut request = types::XiUngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_allow_events(display: &mut impl Display, time: impl Into<types::Time>, deviceid: impl Into<types::Device>, event_mode: types::EventMode, touchid: types::Card32, grab_window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::XiAllowEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            event_mode,
            touchid,
            grab_window,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_grab_device(display: &mut impl Display, time: impl Into<types::Time>, grab_window: types::Window, cursor: types::Cursor, detail: types::Card32, deviceid: impl Into<types::Device>, num_modifiers: types::Card16, mask_len: types::Card16, grab_type: types::GrabType, grab_mode: types::GrabMode22, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask: impl AsRef<[types::Card32]>, modifiers: impl AsRef<[types::Card32]>) -> Result<Cookie<types::XiPassiveGrabDeviceReply>> {
        let mut request = types::XiPassiveGrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            grab_window,
            cursor,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            num_modifiers,
            mask_len,
            grab_type,
            grab_mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_ungrab_device(display: &mut impl Display, grab_window: types::Window, detail: types::Card32, deviceid: impl Into<types::Device>, num_modifiers: types::Card16, grab_type: types::GrabType, modifiers: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let mut request = types::XiPassiveUngrabDeviceRequest {
            grab_window,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            num_modifiers,
            grab_type,
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_list_properties(display: &mut impl Display, deviceid: impl Into<types::Device>) -> Result<Cookie<types::XiListPropertiesReply>> {
        let mut request = types::XiListPropertiesRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_property(display: &mut impl Display, deviceid: impl Into<types::Device>, mode: types::PropMode, format: types::PropertyFormat, property: types::Atom, type_: types::Atom, num_items: types::Card32, value_list: impl Borrow<types::XiChangePropertyAux>) -> Result<Cookie<()>> {
        let mut request = types::XiChangePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            format,
            property,
            type_,
            num_items,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_delete_property(display: &mut impl Display, deviceid: impl Into<types::Device>, property: types::Atom) -> Result<Cookie<()>> {
        let mut request = types::XiDeletePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            property,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_property(display: &mut impl Display, deviceid: impl Into<types::Device>, delete: types::Bool, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32) -> Result<Cookie<types::XiGetPropertyReply>> {
        let mut request = types::XiGetPropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            delete,
            property,
            type_,
            offset,
            len,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_selected_events(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::XiGetSelectedEventsReply>> {
        let mut request = types::XiGetSelectedEventsRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_barrier_release_pointer(display: &mut impl Display, num_barriers: types::Card32, barriers: impl AsRef<[types::BarrierReleasePointerInfo]>) -> Result<Cookie<()>> {
        let mut request = types::XiBarrierReleasePointerRequest {
            num_barriers,
            barriers: Cow::Borrowed(barriers.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_send_extension_event(display: &mut impl Display, destination: types::Window, device_id: types::Card8, propagate: types::Bool, num_classes: types::Card16, num_events: types::Card8, events: impl AsRef<[types::EventForSend]>, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let mut request = types::SendExtensionEventRequest {
            destination,
            device_id,
            propagate,
            num_classes,
            num_events,
            events: Cow::Borrowed(events.as_ref()),
            classes: Cow::Borrowed(classes.as_ref()),
        };
        display.send_void_request(request)
    }
    
    #[cfg(feature = "xkb")]
    fn xkb_use_extension(display: &mut impl Display, wanted_major: types::Card16, wanted_minor: types::Card16) -> Result<Cookie<types::UseExtensionReply>> {
        let mut request = types::UseExtensionRequest {
            wanted_major,
            wanted_minor,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_select_events(display: &mut impl Display, device_spec: types::DeviceSpec, affect_which: impl Into<types::EventType>, clear: impl Into<types::EventType>, select_all: impl Into<types::EventType>, affect_map: impl Into<types::MapPart>, map: impl Into<types::MapPart>, value_list: impl Borrow<types::SelectEventsAux>) -> Result<Cookie<()>> {
        let mut request = types::SelectEventsRequest {
            device_spec,
            affect_which: Into::<u32>::into(affect_which.into()) as _,
            clear: Into::<u32>::into(clear.into()) as _,
            select_all: Into::<u32>::into(select_all.into()) as _,
            affect_map: Into::<u32>::into(affect_map.into()) as _,
            map: Into::<u32>::into(map.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_bell(display: &mut impl Display, device_spec: types::DeviceSpec, bell_class: types::BellClassSpec, bell_id: types::IdSpec, percent: types::Int8, force_sound: types::Bool, event_only: types::Bool, pitch: types::Int16, duration: types::Int16, name: types::Atom, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::BellRequest {
            device_spec,
            bell_class,
            bell_id,
            percent,
            force_sound,
            event_only,
            pitch,
            duration,
            name,
            window,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_state(display: &mut impl Display, device_spec: types::DeviceSpec) -> Result<Cookie<types::GetStateReply>> {
        let mut request = types::GetStateRequest {
            device_spec,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_latch_lock_state(display: &mut impl Display, device_spec: types::DeviceSpec, affect_mod_locks: impl Into<types::ModMask>, mod_locks: impl Into<types::ModMask>, lock_group: types::Bool, group_lock: types::Group, affect_mod_latches: impl Into<types::ModMask>, latch_group: types::Bool, group_latch: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::LatchLockStateRequest {
            device_spec,
            affect_mod_locks: Into::<u32>::into(affect_mod_locks.into()) as _,
            mod_locks: Into::<u32>::into(mod_locks.into()) as _,
            lock_group,
            group_lock,
            affect_mod_latches: Into::<u32>::into(affect_mod_latches.into()) as _,
            latch_group,
            group_latch,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_controls(display: &mut impl Display, device_spec: types::DeviceSpec) -> Result<Cookie<types::GetControlsReply>> {
        let mut request = types::GetControlsRequest {
            device_spec,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_controls(display: &mut impl Display, device_spec: types::DeviceSpec, affect_internal_real_mods: impl Into<types::ModMask>, internal_real_mods: impl Into<types::ModMask>, affect_ignore_lock_real_mods: impl Into<types::ModMask>, ignore_lock_real_mods: impl Into<types::ModMask>, affect_internal_virtual_mods: impl Into<types::VMod>, internal_virtual_mods: impl Into<types::VMod>, affect_ignore_lock_virtual_mods: impl Into<types::VMod>, ignore_lock_virtual_mods: impl Into<types::VMod>, mouse_keys_dflt_btn: types::Card8, groups_wrap: types::Card8, access_x_options: impl Into<types::AxOption>, affect_enabled_controls: impl Into<types::BoolCtrl>, enabled_controls: impl Into<types::BoolCtrl>, change_controls: impl Into<types::Control>, repeat_delay: types::Card16, repeat_interval: types::Card16, slow_keys_delay: types::Card16, debounce_delay: types::Card16, mouse_keys_delay: types::Card16, mouse_keys_interval: types::Card16, mouse_keys_time_to_max: types::Card16, mouse_keys_max_speed: types::Card16, mouse_keys_curve: types::Int16, access_x_timeout: types::Card16, access_x_timeout_mask: impl Into<types::BoolCtrl>, access_x_timeout_values: impl Into<types::BoolCtrl>, access_x_timeout_options_mask: impl Into<types::AxOption>, access_x_timeout_options_values: impl Into<types::AxOption>, per_key_repeat: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let mut request = types::SetControlsRequest {
            device_spec,
            affect_internal_real_mods: Into::<u32>::into(affect_internal_real_mods.into()) as _,
            internal_real_mods: Into::<u32>::into(internal_real_mods.into()) as _,
            affect_ignore_lock_real_mods: Into::<u32>::into(affect_ignore_lock_real_mods.into()) as _,
            ignore_lock_real_mods: Into::<u32>::into(ignore_lock_real_mods.into()) as _,
            affect_internal_virtual_mods: Into::<u32>::into(affect_internal_virtual_mods.into()) as _,
            internal_virtual_mods: Into::<u32>::into(internal_virtual_mods.into()) as _,
            affect_ignore_lock_virtual_mods: Into::<u32>::into(affect_ignore_lock_virtual_mods.into()) as _,
            ignore_lock_virtual_mods: Into::<u32>::into(ignore_lock_virtual_mods.into()) as _,
            mouse_keys_dflt_btn,
            groups_wrap,
            access_x_options: Into::<u32>::into(access_x_options.into()) as _,
            affect_enabled_controls: Into::<u32>::into(affect_enabled_controls.into()) as _,
            enabled_controls: Into::<u32>::into(enabled_controls.into()) as _,
            change_controls: Into::<u32>::into(change_controls.into()) as _,
            repeat_delay,
            repeat_interval,
            slow_keys_delay,
            debounce_delay,
            mouse_keys_delay,
            mouse_keys_interval,
            mouse_keys_time_to_max,
            mouse_keys_max_speed,
            mouse_keys_curve,
            access_x_timeout,
            access_x_timeout_mask: Into::<u32>::into(access_x_timeout_mask.into()) as _,
            access_x_timeout_values: Into::<u32>::into(access_x_timeout_values.into()) as _,
            access_x_timeout_options_mask: Into::<u32>::into(access_x_timeout_options_mask.into()) as _,
            access_x_timeout_options_values: Into::<u32>::into(access_x_timeout_options_values.into()) as _,
            per_key_repeat: Cow::Borrowed(per_key_repeat.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_map(display: &mut impl Display, device_spec: types::DeviceSpec, full: impl Into<types::MapPart>, partial: impl Into<types::MapPart>, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, first_key_action: types::Keycode, n_key_actions: types::Card8, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, virtual_mods: impl Into<types::VMod>, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8) -> Result<Cookie<types::GetMapReply>> {
        let mut request = types::GetMapRequest {
            device_spec,
            full: Into::<u32>::into(full.into()) as _,
            partial: Into::<u32>::into(partial.into()) as _,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            first_key_action,
            n_key_actions,
            first_key_behavior,
            n_key_behaviors,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_key_explicit,
            n_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_map(display: &mut impl Display, device_spec: types::DeviceSpec, present: impl Into<types::MapPart>, flags: impl Into<types::SetMapFlags>, min_key_code: types::Keycode, max_key_code: types::Keycode, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, total_syms: types::Card16, first_key_action: types::Keycode, n_key_actions: types::Card8, total_actions: types::Card16, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, total_key_behaviors: types::Card8, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, total_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, total_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8, total_v_mod_map_keys: types::Card8, virtual_mods: impl Into<types::VMod>, value_list: impl Borrow<types::SetMapAux>) -> Result<Cookie<()>> {
        let mut request = types::SetMapRequest {
            device_spec,
            present: Into::<u32>::into(present.into()) as _,
            flags: Into::<u32>::into(flags.into()) as _,
            min_key_code,
            max_key_code,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            total_syms,
            first_key_action,
            n_key_actions,
            total_actions,
            first_key_behavior,
            n_key_behaviors,
            total_key_behaviors,
            first_key_explicit,
            n_key_explicit,
            total_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            total_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
            total_v_mod_map_keys,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_compat_map(display: &mut impl Display, device_spec: types::DeviceSpec, groups: impl Into<types::SetOfGroup>, get_all_si: types::Bool, first_si: types::Card16, n_si: types::Card16) -> Result<Cookie<types::GetCompatMapReply>> {
        let mut request = types::GetCompatMapRequest {
            device_spec,
            groups: Into::<u32>::into(groups.into()) as _,
            get_all_si,
            first_si,
            n_si,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_compat_map(display: &mut impl Display, device_spec: types::DeviceSpec, recompute_actions: types::Bool, truncate_si: types::Bool, groups: impl Into<types::SetOfGroup>, first_si: types::Card16, n_si: types::Card16, si: impl AsRef<[types::SymInterpret]>, group_maps: impl AsRef<[types::ModDef]>) -> Result<Cookie<()>> {
        let mut request = types::SetCompatMapRequest {
            device_spec,
            recompute_actions,
            truncate_si,
            groups: Into::<u32>::into(groups.into()) as _,
            first_si,
            n_si,
            si: Cow::Borrowed(si.as_ref()),
            group_maps: Cow::Borrowed(group_maps.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_state(display: &mut impl Display, device_spec: types::DeviceSpec) -> Result<Cookie<types::GetIndicatorStateReply>> {
        let mut request = types::GetIndicatorStateRequest {
            device_spec,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_map(display: &mut impl Display, device_spec: types::DeviceSpec, which: types::Card32) -> Result<Cookie<types::GetIndicatorMapReply>> {
        let mut request = types::GetIndicatorMapRequest {
            device_spec,
            which,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_indicator_map(display: &mut impl Display, device_spec: types::DeviceSpec, which: types::Card32, maps: impl AsRef<[types::IndicatorMap]>) -> Result<Cookie<()>> {
        let mut request = types::SetIndicatorMapRequest {
            device_spec,
            which,
            maps: Cow::Borrowed(maps.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_named_indicator(display: &mut impl Display, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::Id>, indicator: types::Atom) -> Result<Cookie<types::GetNamedIndicatorReply>> {
        let mut request = types::GetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_named_indicator(display: &mut impl Display, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::Id>, indicator: types::Atom, set_state: types::Bool, on: types::Bool, set_map: types::Bool, create_map: types::Bool, map_flags: impl Into<types::ImFlag>, map_which_groups: impl Into<types::ImGroupsWhich>, map_groups: impl Into<types::SetOfGroups>, map_which_mods: impl Into<types::ImModsWhich>, map_real_mods: impl Into<types::ModMask>, map_vmods: impl Into<types::VMod>, map_ctrls: impl Into<types::BoolCtrl>) -> Result<Cookie<()>> {
        let mut request = types::SetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
            set_state,
            on,
            set_map,
            create_map,
            map_flags: Into::<u32>::into(map_flags.into()) as _,
            map_which_groups: Into::<u32>::into(map_which_groups.into()) as _,
            map_groups: Into::<u32>::into(map_groups.into()) as _,
            map_which_mods: Into::<u32>::into(map_which_mods.into()) as _,
            map_real_mods: Into::<u32>::into(map_real_mods.into()) as _,
            map_vmods: Into::<u32>::into(map_vmods.into()) as _,
            map_ctrls: Into::<u32>::into(map_ctrls.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_names(display: &mut impl Display, device_spec: types::DeviceSpec, which: impl Into<types::NameDetail>) -> Result<Cookie<types::GetNamesReply>> {
        let mut request = types::GetNamesRequest {
            device_spec,
            which: Into::<u32>::into(which.into()) as _,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_names(display: &mut impl Display, device_spec: types::DeviceSpec, virtual_mods: impl Into<types::VMod>, which: impl Into<types::NameDetail>, first_type: types::Card8, n_types: types::Card8, first_kt_levelt: types::Card8, n_kt_levels: types::Card8, indicators: types::Card32, group_names: impl Into<types::SetOfGroup>, n_radio_groups: types::Card8, first_key: types::Keycode, n_keys: types::Card8, n_key_aliases: types::Card8, total_kt_level_names: types::Card16, value_list: impl Borrow<types::SetNamesAux>) -> Result<Cookie<()>> {
        let mut request = types::SetNamesRequest {
            device_spec,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            which: Into::<u32>::into(which.into()) as _,
            first_type,
            n_types,
            first_kt_levelt,
            n_kt_levels,
            indicators,
            group_names: Into::<u32>::into(group_names.into()) as _,
            n_radio_groups,
            first_key,
            n_keys,
            n_key_aliases,
            total_kt_level_names,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_per_client_flags(display: &mut impl Display, device_spec: types::DeviceSpec, change: impl Into<types::PerClientFlag>, value: impl Into<types::PerClientFlag>, ctrls_to_change: impl Into<types::BoolCtrl>, auto_ctrls: impl Into<types::BoolCtrl>, auto_ctrls_values: impl Into<types::BoolCtrl>) -> Result<Cookie<types::PerClientFlagsReply>> {
        let mut request = types::PerClientFlagsRequest {
            device_spec,
            change: Into::<u32>::into(change.into()) as _,
            value: Into::<u32>::into(value.into()) as _,
            ctrls_to_change: Into::<u32>::into(ctrls_to_change.into()) as _,
            auto_ctrls: Into::<u32>::into(auto_ctrls.into()) as _,
            auto_ctrls_values: Into::<u32>::into(auto_ctrls_values.into()) as _,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_list_components(display: &mut impl Display, device_spec: types::DeviceSpec, max_names: types::Card16) -> Result<Cookie<types::ListComponentsReply>> {
        let mut request = types::ListComponentsRequest {
            device_spec,
            max_names,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_kbd_by_name(display: &mut impl Display, device_spec: types::DeviceSpec, need: impl Into<types::GbnDetail>, want: impl Into<types::GbnDetail>, load: types::Bool) -> Result<Cookie<types::GetKbdByNameReply>> {
        let mut request = types::GetKbdByNameRequest {
            device_spec,
            need: Into::<u32>::into(need.into()) as _,
            want: Into::<u32>::into(want.into()) as _,
            load,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_device_info(display: &mut impl Display, device_spec: types::DeviceSpec, wanted: impl Into<types::XiFeature>, all_buttons: types::Bool, first_button: types::Card8, n_buttons: types::Card8, led_class: types::LedClass, led_id: impl Into<types::Id>) -> Result<Cookie<types::GetDeviceInfoReply>> {
        let mut request = types::GetDeviceInfoRequest {
            device_spec,
            wanted: Into::<u32>::into(wanted.into()) as _,
            all_buttons,
            first_button,
            n_buttons,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_device_info(display: &mut impl Display, device_spec: types::DeviceSpec, first_btn: types::Card8, n_btns: types::Card8, change: impl Into<types::XiFeature>, n_device_led_f_bs: types::Card16, btn_actions: impl AsRef<[types::Action]>, leds: impl AsRef<[types::DeviceLedInfo]>) -> Result<Cookie<()>> {
        let mut request = types::SetDeviceInfoRequest {
            device_spec,
            first_btn,
            n_btns,
            change: Into::<u32>::into(change.into()) as _,
            n_device_led_f_bs,
            btn_actions: Cow::Borrowed(btn_actions.as_ref()),
            leds: Cow::Borrowed(leds.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_debugging_flags(display: &mut impl Display, msg_length: types::Card16, affect_flags: types::Card32, flags: types::Card32, affect_ctrls: types::Card32, ctrls: types::Card32, message: impl AsRef<[types::String8]>) -> Result<Cookie<types::SetDebuggingFlagsReply>> {
        let mut request = types::SetDebuggingFlagsRequest {
            msg_length,
            affect_flags,
            flags,
            affect_ctrls,
            ctrls,
            message: Cow::Borrowed(message.as_ref()),
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "xprint")]
    fn xprint_print_query_version(display: &mut impl Display, ) -> Result<Cookie<types::PrintQueryVersionReply>> {
        let mut request = types::PrintQueryVersionRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_printer_list(display: &mut impl Display, printer_name_len: types::Card32, locale_len: types::Card32, printer_name: impl AsRef<[types::String8]>, locale: impl AsRef<[types::String8]>) -> Result<Cookie<types::PrintGetPrinterListReply>> {
        let mut request = types::PrintGetPrinterListRequest {
            printer_name_len,
            locale_len,
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_rehash_printer_list(display: &mut impl Display, ) -> Result<Cookie<()>> {
        let mut request = types::PrintRehashPrinterListRequest {
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_create_context(display: &mut impl Display, context_id: types::Card32, printer_name_len: types::Card32, locale_len: types::Card32, printer_name: impl AsRef<[types::String8]>, locale: impl AsRef<[types::String8]>) -> Result<Cookie<()>> {
        let mut request = types::CreateContextRequest {
            context_id,
            printer_name_len,
            locale_len,
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_context(display: &mut impl Display, context: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::PrintSetContextRequest {
            context,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_context(display: &mut impl Display, ) -> Result<Cookie<types::PrintGetContextReply>> {
        let mut request = types::PrintGetContextRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_destroy_context(display: &mut impl Display, context: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::PrintDestroyContextRequest {
            context,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_screen_of_context(display: &mut impl Display, ) -> Result<Cookie<types::PrintGetScreenOfContextReply>> {
        let mut request = types::PrintGetScreenOfContextRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_job(display: &mut impl Display, output_mode: types::Card8) -> Result<Cookie<()>> {
        let mut request = types::PrintStartJobRequest {
            output_mode,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_job(display: &mut impl Display, cancel: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::PrintEndJobRequest {
            cancel,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_doc(display: &mut impl Display, driver_mode: types::Card8) -> Result<Cookie<()>> {
        let mut request = types::PrintStartDocRequest {
            driver_mode,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_doc(display: &mut impl Display, cancel: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::PrintEndDocRequest {
            cancel,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_put_document_data(display: &mut impl Display, drawable: types::Drawable, len_data: types::Card32, len_fmt: types::Card16, len_options: types::Card16, data: impl AsRef<[types::Byte]>, doc_format: impl AsRef<[types::String8]>, options: impl AsRef<[types::String8]>) -> Result<Cookie<()>> {
        let mut request = types::PrintPutDocumentDataRequest {
            drawable,
            len_data,
            len_fmt,
            len_options,
            data: Cow::Borrowed(data.as_ref()),
            doc_format: Cow::Borrowed(doc_format.as_ref()),
            options: Cow::Borrowed(options.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_document_data(display: &mut impl Display, context: types::Pcontext, max_bytes: types::Card32) -> Result<Cookie<types::PrintGetDocumentDataReply>> {
        let mut request = types::PrintGetDocumentDataRequest {
            context,
            max_bytes,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_page(display: &mut impl Display, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::PrintStartPageRequest {
            window,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_page(display: &mut impl Display, cancel: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::PrintEndPageRequest {
            cancel,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_select_input(display: &mut impl Display, context: types::Pcontext, event_mask: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::PrintSelectInputRequest {
            context,
            event_mask,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_input_selected(display: &mut impl Display, context: types::Pcontext) -> Result<Cookie<types::PrintInputSelectedReply>> {
        let mut request = types::PrintInputSelectedRequest {
            context,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_attributes(display: &mut impl Display, context: types::Pcontext, pool: types::Card8) -> Result<Cookie<types::PrintGetAttributesReply>> {
        let mut request = types::PrintGetAttributesRequest {
            context,
            pool,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_one_attributes(display: &mut impl Display, context: types::Pcontext, name_len: types::Card32, pool: types::Card8, name: impl AsRef<[types::String8]>) -> Result<Cookie<types::PrintGetOneAttributesReply>> {
        let mut request = types::PrintGetOneAttributesRequest {
            context,
            name_len,
            pool,
            name: Cow::Borrowed(name.as_ref()),
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_attributes(display: &mut impl Display, context: types::Pcontext, string_len: types::Card32, pool: types::Card8, rule: types::Card8, attributes: impl AsRef<[types::String8]>) -> Result<Cookie<()>> {
        let mut request = types::PrintSetAttributesRequest {
            context,
            string_len,
            pool,
            rule,
            attributes: Cow::Borrowed(attributes.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_page_dimensions(display: &mut impl Display, context: types::Pcontext) -> Result<Cookie<types::PrintGetPageDimensionsReply>> {
        let mut request = types::PrintGetPageDimensionsRequest {
            context,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_screens(display: &mut impl Display, ) -> Result<Cookie<types::PrintQueryScreensReply>> {
        let mut request = types::PrintQueryScreensRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_image_resolution(display: &mut impl Display, context: types::Pcontext, image_resolution: types::Card16) -> Result<Cookie<types::PrintSetImageResolutionReply>> {
        let mut request = types::PrintSetImageResolutionRequest {
            context,
            image_resolution,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_image_resolution(display: &mut impl Display, context: types::Pcontext) -> Result<Cookie<types::PrintGetImageResolutionReply>> {
        let mut request = types::PrintGetImageResolutionRequest {
            context,
        };
        display.send_reply_request(request)
    }
    
    fn create_window(display: &mut impl Display, depth: types::Card8, wid: types::Window, parent: types::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, visual: types::Visualid, value_mask: impl Into<types::Cw>, value_list: impl Borrow<types::CreateWindowAux>) -> Result<Cookie<()>> {
        let mut request = types::CreateWindowRequest {
            depth,
            wid,
            parent,
            x,
            y,
            width,
            height,
            border_width,
            class,
            visual,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    fn change_window_attributes(display: &mut impl Display, window: types::Window, value_mask: impl Into<types::Cw>, value_list: impl Borrow<types::ChangeWindowAttributesAux>) -> Result<Cookie<()>> {
        let mut request = types::ChangeWindowAttributesRequest {
            window,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    fn get_window_attributes(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetWindowAttributesReply>> {
        let mut request = types::GetWindowAttributesRequest {
            window,
        };
        display.send_reply_request(request)
    }
    fn destroy_window(display: &mut impl Display, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::DestroyWindowRequest {
            window,
        };
        display.send_void_request(request)
    }
    fn destroy_subwindows(display: &mut impl Display, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::DestroySubwindowsRequest {
            window,
        };
        display.send_void_request(request)
    }
    fn change_save_set(display: &mut impl Display, mode: types::SetMode, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::ChangeSaveSetRequest {
            mode,
            window,
        };
        display.send_void_request(request)
    }
    fn reparent_window(display: &mut impl Display, window: types::Window, parent: types::Window, x: types::Int16, y: types::Int16) -> Result<Cookie<()>> {
        let mut request = types::ReparentWindowRequest {
            window,
            parent,
            x,
            y,
        };
        display.send_void_request(request)
    }
    fn map_window(display: &mut impl Display, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::MapWindowRequest {
            window,
        };
        display.send_void_request(request)
    }
    fn map_subwindows(display: &mut impl Display, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::MapSubwindowsRequest {
            window,
        };
        display.send_void_request(request)
    }
    fn unmap_window(display: &mut impl Display, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::UnmapWindowRequest {
            window,
        };
        display.send_void_request(request)
    }
    fn unmap_subwindows(display: &mut impl Display, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::UnmapSubwindowsRequest {
            window,
        };
        display.send_void_request(request)
    }
    fn configure_window(display: &mut impl Display, window: types::Window, value_mask: impl Into<types::ConfigWindow>, value_list: impl Borrow<types::ConfigureWindowAux>) -> Result<Cookie<()>> {
        let mut request = types::ConfigureWindowRequest {
            window,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    fn circulate_window(display: &mut impl Display, direction: types::Circulate, window: types::Window) -> Result<Cookie<()>> {
        let mut request = types::CirculateWindowRequest {
            direction,
            window,
        };
        display.send_void_request(request)
    }
    fn get_geometry(display: &mut impl Display, drawable: types::Drawable) -> Result<Cookie<types::GetGeometryReply>> {
        let mut request = types::GetGeometryRequest {
            drawable,
        };
        display.send_reply_request(request)
    }
    fn query_tree(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::QueryTreeReply>> {
        let mut request = types::QueryTreeRequest {
            window,
        };
        display.send_reply_request(request)
    }
    fn intern_atom(display: &mut impl Display, only_if_exists: types::Bool, name_len: types::Card16, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::InternAtomReply>> {
        let mut request = types::InternAtomRequest {
            only_if_exists,
            name_len,
            name: Cow::Borrowed(name.as_ref()),
        };
        display.send_reply_request(request)
    }
    fn get_atom_name(display: &mut impl Display, atom: types::Atom) -> Result<Cookie<types::GetAtomNameReply>> {
        let mut request = types::GetAtomNameRequest {
            atom,
        };
        display.send_reply_request(request)
    }
    fn change_property(display: &mut impl Display, mode: types::PropMode, window: types::Window, property: types::Atom, type_: types::Atom, format: types::Card8, data_len: types::Card32, data: impl AsRef<[types::Void]>) -> Result<Cookie<()>> {
        let mut request = types::ChangePropertyRequest {
            mode,
            window,
            property,
            type_,
            format,
            data_len,
            data: Cow::Borrowed(data.as_ref()),
        };
        display.send_void_request(request)
    }
    fn delete_property(display: &mut impl Display, window: types::Window, property: types::Atom) -> Result<Cookie<()>> {
        let mut request = types::DeletePropertyRequest {
            window,
            property,
        };
        display.send_void_request(request)
    }
    fn get_property(display: &mut impl Display, delete: types::Bool, window: types::Window, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32) -> Result<Cookie<types::GetPropertyReply>> {
        let mut request = types::GetPropertyRequest {
            delete,
            window,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
        };
        display.send_reply_request(request)
    }
    fn list_properties(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::ListPropertiesReply>> {
        let mut request = types::ListPropertiesRequest {
            window,
        };
        display.send_reply_request(request)
    }
    fn set_selection_owner(display: &mut impl Display, owner: impl Into<types::Window>, selection: types::Atom, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let mut request = types::SetSelectionOwnerRequest {
            owner: Into::<u32>::into(owner.into()) as _,
            selection,
            time: Into::<u32>::into(time.into()) as _,
        };
        display.send_void_request(request)
    }
    fn get_selection_owner(display: &mut impl Display, selection: types::Atom) -> Result<Cookie<types::GetSelectionOwnerReply>> {
        let mut request = types::GetSelectionOwnerRequest {
            selection,
        };
        display.send_reply_request(request)
    }
    fn convert_selection(display: &mut impl Display, requestor: types::Window, selection: types::Atom, target: types::Atom, property: impl Into<types::Atom>, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let mut request = types::ConvertSelectionRequest {
            requestor,
            selection,
            target,
            property: Into::<u32>::into(property.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        display.send_void_request(request)
    }
    fn send_event(display: &mut impl Display, propagate: types::Bool, destination: impl Into<types::SendEventDest>, event_mask: impl Into<types::EventMask>, event: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::SendEventRequest {
            propagate,
            destination: Into::<u32>::into(destination.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            event: Cow::Borrowed(event.as_ref()),
        };
        display.send_void_request(request)
    }
    fn grab_pointer(display: &mut impl Display, owner_events: types::Bool, grab_window: types::Window, event_mask: impl Into<types::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::Window>, cursor: impl Into<types::Cursor>, time: impl Into<types::Time>) -> Result<Cookie<types::GrabPointerReply>> {
        let mut request = types::GrabPointerRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        display.send_reply_request(request)
    }
    fn ungrab_pointer(display: &mut impl Display, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let mut request = types::UngrabPointerRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        display.send_void_request(request)
    }
    fn grab_button(display: &mut impl Display, owner_events: types::Bool, grab_window: types::Window, event_mask: impl Into<types::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::Window>, cursor: impl Into<types::Cursor>, button: types::ButtonIndex, modifiers: impl Into<types::ModMask>) -> Result<Cookie<()>> {
        let mut request = types::GrabButtonRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            button,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        display.send_void_request(request)
    }
    fn ungrab_button(display: &mut impl Display, button: types::ButtonIndex, grab_window: types::Window, modifiers: impl Into<types::ModMask>) -> Result<Cookie<()>> {
        let mut request = types::UngrabButtonRequest {
            button,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        display.send_void_request(request)
    }
    fn change_active_pointer_grab(display: &mut impl Display, cursor: impl Into<types::Cursor>, time: impl Into<types::Time>, event_mask: impl Into<types::EventMask>) -> Result<Cookie<()>> {
        let mut request = types::ChangeActivePointerGrabRequest {
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        display.send_void_request(request)
    }
    fn grab_keyboard(display: &mut impl Display, owner_events: types::Bool, grab_window: types::Window, time: impl Into<types::Time>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> Result<Cookie<types::GrabKeyboardReply>> {
        let mut request = types::GrabKeyboardRequest {
            owner_events,
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        display.send_reply_request(request)
    }
    fn ungrab_keyboard(display: &mut impl Display, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let mut request = types::UngrabKeyboardRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        display.send_void_request(request)
    }
    fn grab_key(display: &mut impl Display, owner_events: types::Bool, grab_window: types::Window, modifiers: impl Into<types::ModMask>, key: impl Into<types::Grab>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> Result<Cookie<()>> {
        let mut request = types::GrabKeyRequest {
            owner_events,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        display.send_void_request(request)
    }
    fn ungrab_key(display: &mut impl Display, key: impl Into<types::Grab>, grab_window: types::Window, modifiers: impl Into<types::ModMask>) -> Result<Cookie<()>> {
        let mut request = types::UngrabKeyRequest {
            key: Into::<u32>::into(key.into()) as _,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        display.send_void_request(request)
    }
    fn allow_events(display: &mut impl Display, mode: types::Allow, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let mut request = types::AllowEventsRequest {
            mode,
            time: Into::<u32>::into(time.into()) as _,
        };
        display.send_void_request(request)
    }
    fn grab_server(display: &mut impl Display, ) -> Result<Cookie<()>> {
        let mut request = types::GrabServerRequest {
        };
        display.send_void_request(request)
    }
    fn ungrab_server(display: &mut impl Display, ) -> Result<Cookie<()>> {
        let mut request = types::UngrabServerRequest {
        };
        display.send_void_request(request)
    }
    fn query_pointer(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::QueryPointerReply>> {
        let mut request = types::QueryPointerRequest {
            window,
        };
        display.send_reply_request(request)
    }
    fn get_motion_events(display: &mut impl Display, window: types::Window, start: impl Into<types::Time>, stop: impl Into<types::Time>) -> Result<Cookie<types::GetMotionEventsReply>> {
        let mut request = types::GetMotionEventsRequest {
            window,
            start: Into::<u32>::into(start.into()) as _,
            stop: Into::<u32>::into(stop.into()) as _,
        };
        display.send_reply_request(request)
    }
    fn translate_coordinates(display: &mut impl Display, src_window: types::Window, dst_window: types::Window, src_x: types::Int16, src_y: types::Int16) -> Result<Cookie<types::TranslateCoordinatesReply>> {
        let mut request = types::TranslateCoordinatesRequest {
            src_window,
            dst_window,
            src_x,
            src_y,
        };
        display.send_reply_request(request)
    }
    fn warp_pointer(display: &mut impl Display, src_window: impl Into<types::Window>, dst_window: impl Into<types::Window>, src_x: types::Int16, src_y: types::Int16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16) -> Result<Cookie<()>> {
        let mut request = types::WarpPointerRequest {
            src_window: Into::<u32>::into(src_window.into()) as _,
            dst_window: Into::<u32>::into(dst_window.into()) as _,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
        };
        display.send_void_request(request)
    }
    fn set_input_focus(display: &mut impl Display, revert_to: types::InputFocus, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let mut request = types::SetInputFocusRequest {
            revert_to,
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        display.send_void_request(request)
    }
    fn get_input_focus(display: &mut impl Display, ) -> Result<Cookie<types::GetInputFocusReply>> {
        let mut request = types::GetInputFocusRequest {
        };
        display.send_reply_request(request)
    }
    fn query_keymap(display: &mut impl Display, ) -> Result<Cookie<types::QueryKeymapReply>> {
        let mut request = types::QueryKeymapRequest {
        };
        display.send_reply_request(request)
    }
    fn open_font(display: &mut impl Display, fid: types::Font, name_len: types::Card16, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::OpenFontRequest {
            fid,
            name_len,
            name: Cow::Borrowed(name.as_ref()),
        };
        display.send_void_request(request)
    }
    fn close_font(display: &mut impl Display, font: types::Font) -> Result<Cookie<()>> {
        let mut request = types::CloseFontRequest {
            font,
        };
        display.send_void_request(request)
    }
    fn query_font(display: &mut impl Display, font: types::Fontable) -> Result<Cookie<types::QueryFontReply>> {
        let mut request = types::QueryFontRequest {
            font,
        };
        display.send_reply_request(request)
    }
    fn query_text_extents(display: &mut impl Display, font: types::Fontable, string: impl AsRef<[types::Char2b]>) -> Result<Cookie<types::QueryTextExtentsReply>> {
        let mut request = types::QueryTextExtentsRequest {
            font,
            string: Cow::Borrowed(string.as_ref()),
        };
        display.send_reply_request(request)
    }
    fn list_fonts(display: &mut impl Display, max_names: types::Card16, pattern_len: types::Card16, pattern: impl AsRef<[types::Char]>) -> Result<Cookie<types::ListFontsReply>> {
        let mut request = types::ListFontsRequest {
            max_names,
            pattern_len,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        display.send_reply_request(request)
    }
    fn list_fonts_with_info(display: &mut impl Display, max_names: types::Card16, pattern_len: types::Card16, pattern: impl AsRef<[types::Char]>) -> Result<Cookie<types::ListFontsWithInfoReply>> {
        let mut request = types::ListFontsWithInfoRequest {
            max_names,
            pattern_len,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        display.send_reply_request(request)
    }
    fn set_font_path(display: &mut impl Display, font_qty: types::Card16, font: impl AsRef<[types::Str]>) -> Result<Cookie<()>> {
        let mut request = types::SetFontPathRequest {
            font_qty,
            font: Cow::Borrowed(font.as_ref()),
        };
        display.send_void_request(request)
    }
    fn get_font_path(display: &mut impl Display, ) -> Result<Cookie<types::GetFontPathReply>> {
        let mut request = types::GetFontPathRequest {
        };
        display.send_reply_request(request)
    }
    fn create_pixmap(display: &mut impl Display, depth: types::Card8, pid: types::Pixmap, drawable: types::Drawable, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::CreatePixmapRequest {
            depth,
            pid,
            drawable,
            width,
            height,
        };
        display.send_void_request(request)
    }
    fn free_pixmap(display: &mut impl Display, pixmap: types::Pixmap) -> Result<Cookie<()>> {
        let mut request = types::FreePixmapRequest {
            pixmap,
        };
        display.send_void_request(request)
    }
    fn create_gc(display: &mut impl Display, cid: types::Gcontext, drawable: types::Drawable, value_mask: impl Into<types::Gc>, value_list: impl Borrow<types::CreateGcAux>) -> Result<Cookie<()>> {
        let mut request = types::CreateGcRequest {
            cid,
            drawable,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    fn change_gc(display: &mut impl Display, gc: types::Gcontext, value_mask: impl Into<types::Gc>, value_list: impl Borrow<types::ChangeGcAux>) -> Result<Cookie<()>> {
        let mut request = types::ChangeGcRequest {
            gc,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    fn copy_gc(display: &mut impl Display, src_gc: types::Gcontext, dst_gc: types::Gcontext, value_mask: impl Into<types::Gc>) -> Result<Cookie<()>> {
        let mut request = types::CopyGcRequest {
            src_gc,
            dst_gc,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
        };
        display.send_void_request(request)
    }
    fn set_dashes(display: &mut impl Display, gc: types::Gcontext, dash_offset: types::Card16, dashes_len: types::Card16, dashes: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let mut request = types::SetDashesRequest {
            gc,
            dash_offset,
            dashes_len,
            dashes: Cow::Borrowed(dashes.as_ref()),
        };
        display.send_void_request(request)
    }
    fn set_clip_rectangles(display: &mut impl Display, ordering: types::ClipOrdering, gc: types::Gcontext, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let mut request = types::SetClipRectanglesRequest {
            ordering,
            gc,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        display.send_void_request(request)
    }
    fn free_gc(display: &mut impl Display, gc: types::Gcontext) -> Result<Cookie<()>> {
        let mut request = types::FreeGcRequest {
            gc,
        };
        display.send_void_request(request)
    }
    fn clear_area(display: &mut impl Display, exposures: types::Bool, window: types::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::ClearAreaRequest {
            exposures,
            window,
            x,
            y,
            width,
            height,
        };
        display.send_void_request(request)
    }
    fn copy_area(display: &mut impl Display, src_drawable: types::Drawable, dst_drawable: types::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::CopyAreaRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        display.send_void_request(request)
    }
    fn copy_plane(display: &mut impl Display, src_drawable: types::Drawable, dst_drawable: types::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16, bit_plane: types::Card32) -> Result<Cookie<()>> {
        let mut request = types::CopyPlaneRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
            bit_plane,
        };
        display.send_void_request(request)
    }
    fn poly_point(display: &mut impl Display, coordinate_mode: types::CoordMode, drawable: types::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> Result<Cookie<()>> {
        let mut request = types::PolyPointRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        display.send_void_request(request)
    }
    fn poly_line(display: &mut impl Display, coordinate_mode: types::CoordMode, drawable: types::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> Result<Cookie<()>> {
        let mut request = types::PolyLineRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        display.send_void_request(request)
    }
    fn poly_segment(display: &mut impl Display, drawable: types::Drawable, gc: types::Gcontext, segments: impl AsRef<[types::Segment]>) -> Result<Cookie<()>> {
        let mut request = types::PolySegmentRequest {
            drawable,
            gc,
            segments: Cow::Borrowed(segments.as_ref()),
        };
        display.send_void_request(request)
    }
    fn poly_rectangle(display: &mut impl Display, drawable: types::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let mut request = types::PolyRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        display.send_void_request(request)
    }
    fn poly_arc(display: &mut impl Display, drawable: types::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> Result<Cookie<()>> {
        let mut request = types::PolyArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        display.send_void_request(request)
    }
    fn fill_poly(display: &mut impl Display, drawable: types::Drawable, gc: types::Gcontext, shape: types::PolyShape, coordinate_mode: types::CoordMode, points: impl AsRef<[types::Point]>) -> Result<Cookie<()>> {
        let mut request = types::FillPolyRequest {
            drawable,
            gc,
            shape,
            coordinate_mode,
            points: Cow::Borrowed(points.as_ref()),
        };
        display.send_void_request(request)
    }
    fn poly_fill_rectangle(display: &mut impl Display, drawable: types::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let mut request = types::PolyFillRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        display.send_void_request(request)
    }
    fn poly_fill_arc(display: &mut impl Display, drawable: types::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> Result<Cookie<()>> {
        let mut request = types::PolyFillArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        display.send_void_request(request)
    }
    fn put_image(display: &mut impl Display, format: types::ImageFormat, drawable: types::Drawable, gc: types::Gcontext, width: types::Card16, height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, left_pad: types::Card8, depth: types::Card8, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let mut request = types::PutImageRequest {
            format,
            drawable,
            gc,
            width,
            height,
            dst_x,
            dst_y,
            left_pad,
            depth,
            data: Cow::Borrowed(data.as_ref()),
        };
        display.send_void_request(request)
    }
    fn get_image(display: &mut impl Display, format: types::ImageFormat, drawable: types::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32) -> Result<Cookie<types::GetImageReply>> {
        let mut request = types::GetImageRequest {
            format,
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
        };
        display.send_reply_request(request)
    }
    fn poly_text8(display: &mut impl Display, drawable: types::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let mut request = types::PolyText8Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        display.send_void_request(request)
    }
    fn poly_text16(display: &mut impl Display, drawable: types::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let mut request = types::PolyText16Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        display.send_void_request(request)
    }
    fn image_text8(display: &mut impl Display, string_len: types::Byte, drawable: types::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::ImageText8Request {
            string_len,
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        display.send_void_request(request)
    }
    fn image_text16(display: &mut impl Display, string_len: types::Byte, drawable: types::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char2b]>) -> Result<Cookie<()>> {
        let mut request = types::ImageText16Request {
            string_len,
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        display.send_void_request(request)
    }
    fn create_colormap(display: &mut impl Display, alloc: types::ColormapAlloc, mid: types::Colormap, window: types::Window, visual: types::Visualid) -> Result<Cookie<()>> {
        let mut request = types::CreateColormapRequest {
            alloc,
            mid,
            window,
            visual,
        };
        display.send_void_request(request)
    }
    fn free_colormap(display: &mut impl Display, cmap: types::Colormap) -> Result<Cookie<()>> {
        let mut request = types::FreeColormapRequest {
            cmap,
        };
        display.send_void_request(request)
    }
    fn copy_colormap_and_free(display: &mut impl Display, mid: types::Colormap, src_cmap: types::Colormap) -> Result<Cookie<()>> {
        let mut request = types::CopyColormapAndFreeRequest {
            mid,
            src_cmap,
        };
        display.send_void_request(request)
    }
    fn install_colormap(display: &mut impl Display, cmap: types::Colormap) -> Result<Cookie<()>> {
        let mut request = types::InstallColormapRequest {
            cmap,
        };
        display.send_void_request(request)
    }
    fn uninstall_colormap(display: &mut impl Display, cmap: types::Colormap) -> Result<Cookie<()>> {
        let mut request = types::UninstallColormapRequest {
            cmap,
        };
        display.send_void_request(request)
    }
    fn list_installed_colormaps(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::ListInstalledColormapsReply>> {
        let mut request = types::ListInstalledColormapsRequest {
            window,
        };
        display.send_reply_request(request)
    }
    fn alloc_color(display: &mut impl Display, cmap: types::Colormap, red: types::Card16, green: types::Card16, blue: types::Card16) -> Result<Cookie<types::AllocColorReply>> {
        let mut request = types::AllocColorRequest {
            cmap,
            red,
            green,
            blue,
        };
        display.send_reply_request(request)
    }
    fn alloc_named_color(display: &mut impl Display, cmap: types::Colormap, name_len: types::Card16, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::AllocNamedColorReply>> {
        let mut request = types::AllocNamedColorRequest {
            cmap,
            name_len,
            name: Cow::Borrowed(name.as_ref()),
        };
        display.send_reply_request(request)
    }
    fn alloc_color_cells(display: &mut impl Display, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, planes: types::Card16) -> Result<Cookie<types::AllocColorCellsReply>> {
        let mut request = types::AllocColorCellsRequest {
            contiguous,
            cmap,
            colors,
            planes,
        };
        display.send_reply_request(request)
    }
    fn alloc_color_planes(display: &mut impl Display, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, reds: types::Card16, greens: types::Card16, blues: types::Card16) -> Result<Cookie<types::AllocColorPlanesReply>> {
        let mut request = types::AllocColorPlanesRequest {
            contiguous,
            cmap,
            colors,
            reds,
            greens,
            blues,
        };
        display.send_reply_request(request)
    }
    fn free_colors(display: &mut impl Display, cmap: types::Colormap, plane_mask: types::Card32, pixels: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let mut request = types::FreeColorsRequest {
            cmap,
            plane_mask,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        display.send_void_request(request)
    }
    fn store_colors(display: &mut impl Display, cmap: types::Colormap, items: impl AsRef<[types::Coloritem]>) -> Result<Cookie<()>> {
        let mut request = types::StoreColorsRequest {
            cmap,
            items: Cow::Borrowed(items.as_ref()),
        };
        display.send_void_request(request)
    }
    fn store_named_color(display: &mut impl Display, flags: impl Into<types::ColorFlag>, cmap: types::Colormap, pixel: types::Card32, name_len: types::Card16, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::StoreNamedColorRequest {
            flags: Into::<u32>::into(flags.into()) as _,
            cmap,
            pixel,
            name_len,
            name: Cow::Borrowed(name.as_ref()),
        };
        display.send_void_request(request)
    }
    fn query_colors(display: &mut impl Display, cmap: types::Colormap, pixels: impl AsRef<[types::Card32]>) -> Result<Cookie<types::QueryColorsReply>> {
        let mut request = types::QueryColorsRequest {
            cmap,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        display.send_reply_request(request)
    }
    fn lookup_color(display: &mut impl Display, cmap: types::Colormap, name_len: types::Card16, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::LookupColorReply>> {
        let mut request = types::LookupColorRequest {
            cmap,
            name_len,
            name: Cow::Borrowed(name.as_ref()),
        };
        display.send_reply_request(request)
    }
    fn create_cursor(display: &mut impl Display, cid: types::Cursor, source: types::Pixmap, mask: impl Into<types::Pixmap>, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16, x: types::Card16, y: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::CreateCursorRequest {
            cid,
            source,
            mask: Into::<u32>::into(mask.into()) as _,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
            x,
            y,
        };
        display.send_void_request(request)
    }
    fn create_glyph_cursor(display: &mut impl Display, cid: types::Cursor, source_font: types::Font, mask_font: impl Into<types::Font>, source_char: types::Card16, mask_char: types::Card16, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::CreateGlyphCursorRequest {
            cid,
            source_font,
            mask_font: Into::<u32>::into(mask_font.into()) as _,
            source_char,
            mask_char,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        display.send_void_request(request)
    }
    fn free_cursor(display: &mut impl Display, cursor: types::Cursor) -> Result<Cookie<()>> {
        let mut request = types::FreeCursorRequest {
            cursor,
        };
        display.send_void_request(request)
    }
    fn recolor_cursor(display: &mut impl Display, cursor: types::Cursor, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::RecolorCursorRequest {
            cursor,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        display.send_void_request(request)
    }
    fn query_best_size(display: &mut impl Display, class: types::QueryShapeOf, drawable: types::Drawable, width: types::Card16, height: types::Card16) -> Result<Cookie<types::QueryBestSizeReply>> {
        let mut request = types::QueryBestSizeRequest {
            class,
            drawable,
            width,
            height,
        };
        display.send_reply_request(request)
    }
    fn query_extension(display: &mut impl Display, name_len: types::Card16, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::QueryExtensionReply>> {
        let mut request = types::QueryExtensionRequest {
            name_len,
            name: Cow::Borrowed(name.as_ref()),
        };
        display.send_reply_request(request)
    }
    fn list_extensions(display: &mut impl Display, ) -> Result<Cookie<types::ListExtensionsReply>> {
        let mut request = types::ListExtensionsRequest {
        };
        display.send_reply_request(request)
    }
    fn change_keyboard_mapping(display: &mut impl Display, keycode_count: types::Card8, first_keycode: types::Keycode, keysyms_per_keycode: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> Result<Cookie<()>> {
        let mut request = types::ChangeKeyboardMappingRequest {
            keycode_count,
            first_keycode,
            keysyms_per_keycode,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        display.send_void_request(request)
    }
    fn get_keyboard_mapping(display: &mut impl Display, first_keycode: types::Keycode, count: types::Card8) -> Result<Cookie<types::GetKeyboardMappingReply>> {
        let mut request = types::GetKeyboardMappingRequest {
            first_keycode,
            count,
        };
        display.send_reply_request(request)
    }
    fn change_keyboard_control(display: &mut impl Display, value_mask: impl Into<types::Kb>, value_list: impl Borrow<types::ChangeKeyboardControlAux>) -> Result<Cookie<()>> {
        let mut request = types::ChangeKeyboardControlRequest {
            value_mask: Into::<u32>::into(value_mask.into()) as _,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        display.send_void_request(request)
    }
    fn get_keyboard_control(display: &mut impl Display, ) -> Result<Cookie<types::GetKeyboardControlReply>> {
        let mut request = types::GetKeyboardControlRequest {
        };
        display.send_reply_request(request)
    }
    fn bell(display: &mut impl Display, percent: types::Int8) -> Result<Cookie<()>> {
        let mut request = types::BellRequest {
            percent,
        };
        display.send_void_request(request)
    }
    fn change_pointer_control(display: &mut impl Display, acceleration_numerator: types::Int16, acceleration_denominator: types::Int16, threshold: types::Int16, do_acceleration: types::Bool, do_threshold: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::ChangePointerControlRequest {
            acceleration_numerator,
            acceleration_denominator,
            threshold,
            do_acceleration,
            do_threshold,
        };
        display.send_void_request(request)
    }
    fn get_pointer_control(display: &mut impl Display, ) -> Result<Cookie<types::GetPointerControlReply>> {
        let mut request = types::GetPointerControlRequest {
        };
        display.send_reply_request(request)
    }
    fn set_screen_saver(display: &mut impl Display, timeout: types::Int16, interval: types::Int16, prefer_blanking: types::Blanking, allow_exposures: types::Exposures) -> Result<Cookie<()>> {
        let mut request = types::SetScreenSaverRequest {
            timeout,
            interval,
            prefer_blanking,
            allow_exposures,
        };
        display.send_void_request(request)
    }
    fn get_screen_saver(display: &mut impl Display, ) -> Result<Cookie<types::GetScreenSaverReply>> {
        let mut request = types::GetScreenSaverRequest {
        };
        display.send_reply_request(request)
    }
    fn change_hosts(display: &mut impl Display, mode: types::HostMode, family: types::Family, address_len: types::Card16, address: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let mut request = types::ChangeHostsRequest {
            mode,
            family,
            address_len,
            address: Cow::Borrowed(address.as_ref()),
        };
        display.send_void_request(request)
    }
    fn list_hosts(display: &mut impl Display, ) -> Result<Cookie<types::ListHostsReply>> {
        let mut request = types::ListHostsRequest {
        };
        display.send_reply_request(request)
    }
    fn set_access_control(display: &mut impl Display, mode: types::AccessControl) -> Result<Cookie<()>> {
        let mut request = types::SetAccessControlRequest {
            mode,
        };
        display.send_void_request(request)
    }
    fn set_close_down_mode(display: &mut impl Display, mode: types::CloseDown) -> Result<Cookie<()>> {
        let mut request = types::SetCloseDownModeRequest {
            mode,
        };
        display.send_void_request(request)
    }
    fn kill_client(display: &mut impl Display, resource: impl Into<types::Kill>) -> Result<Cookie<()>> {
        let mut request = types::KillClientRequest {
            resource: Into::<u32>::into(resource.into()) as _,
        };
        display.send_void_request(request)
    }
    fn rotate_properties(display: &mut impl Display, window: types::Window, atoms_len: types::Card16, delta: types::Int16, atoms: impl AsRef<[types::Atom]>) -> Result<Cookie<()>> {
        let mut request = types::RotatePropertiesRequest {
            window,
            atoms_len,
            delta,
            atoms: Cow::Borrowed(atoms.as_ref()),
        };
        display.send_void_request(request)
    }
    fn force_screen_saver(display: &mut impl Display, mode: types::ScreenSaver) -> Result<Cookie<()>> {
        let mut request = types::ForceScreenSaverRequest {
            mode,
        };
        display.send_void_request(request)
    }
    fn set_pointer_mapping(display: &mut impl Display, map_len: types::Card8, map: impl AsRef<[types::Card8]>) -> Result<Cookie<types::SetPointerMappingReply>> {
        let mut request = types::SetPointerMappingRequest {
            map_len,
            map: Cow::Borrowed(map.as_ref()),
        };
        display.send_reply_request(request)
    }
    fn get_pointer_mapping(display: &mut impl Display, ) -> Result<Cookie<types::GetPointerMappingReply>> {
        let mut request = types::GetPointerMappingRequest {
        };
        display.send_reply_request(request)
    }
    fn set_modifier_mapping(display: &mut impl Display, keycodes_per_modifier: types::Card8, keycodes: impl AsRef<[types::Keycode]>) -> Result<Cookie<types::SetModifierMappingReply>> {
        let mut request = types::SetModifierMappingRequest {
            keycodes_per_modifier,
            keycodes: Cow::Borrowed(keycodes.as_ref()),
        };
        display.send_reply_request(request)
    }
    fn get_modifier_mapping(display: &mut impl Display, ) -> Result<Cookie<types::GetModifierMappingReply>> {
        let mut request = types::GetModifierMappingRequest {
        };
        display.send_reply_request(request)
    }
    fn no_operation(display: &mut impl Display, ) -> Result<Cookie<()>> {
        let mut request = types::NoOperationRequest {
        };
        display.send_void_request(request)
    }
    
    #[cfg(feature = "xselinux")]
    fn xselinux_query_version(display: &mut impl Display, client_major: types::Card8, client_minor: types::Card8) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
            client_major,
            client_minor,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_create_context(display: &mut impl Display, context_len: types::Card32, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::SetDeviceCreateContextRequest {
            context_len,
            context: Cow::Borrowed(context.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_create_context(display: &mut impl Display, ) -> Result<Cookie<types::GetDeviceCreateContextReply>> {
        let mut request = types::GetDeviceCreateContextRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_context(display: &mut impl Display, device: types::Card32, context_len: types::Card32, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::SetDeviceContextRequest {
            device,
            context_len,
            context: Cow::Borrowed(context.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_context(display: &mut impl Display, device: types::Card32) -> Result<Cookie<types::GetDeviceContextReply>> {
        let mut request = types::GetDeviceContextRequest {
            device,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_window_create_context(display: &mut impl Display, context_len: types::Card32, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::SetWindowCreateContextRequest {
            context_len,
            context: Cow::Borrowed(context.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_create_context(display: &mut impl Display, ) -> Result<Cookie<types::GetWindowCreateContextReply>> {
        let mut request = types::GetWindowCreateContextRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_context(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::GetWindowContextReply>> {
        let mut request = types::GetWindowContextRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_create_context(display: &mut impl Display, context_len: types::Card32, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::SetPropertyCreateContextRequest {
            context_len,
            context: Cow::Borrowed(context.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_create_context(display: &mut impl Display, ) -> Result<Cookie<types::GetPropertyCreateContextReply>> {
        let mut request = types::GetPropertyCreateContextRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_use_context(display: &mut impl Display, context_len: types::Card32, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::SetPropertyUseContextRequest {
            context_len,
            context: Cow::Borrowed(context.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_use_context(display: &mut impl Display, ) -> Result<Cookie<types::GetPropertyUseContextReply>> {
        let mut request = types::GetPropertyUseContextRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_context(display: &mut impl Display, window: types::Window, property: types::Atom) -> Result<Cookie<types::GetPropertyContextReply>> {
        let mut request = types::GetPropertyContextRequest {
            window,
            property,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_data_context(display: &mut impl Display, window: types::Window, property: types::Atom) -> Result<Cookie<types::GetPropertyDataContextReply>> {
        let mut request = types::GetPropertyDataContextRequest {
            window,
            property,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_properties(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::ListPropertiesReply>> {
        let mut request = types::ListPropertiesRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_create_context(display: &mut impl Display, context_len: types::Card32, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::SetSelectionCreateContextRequest {
            context_len,
            context: Cow::Borrowed(context.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_create_context(display: &mut impl Display, ) -> Result<Cookie<types::GetSelectionCreateContextReply>> {
        let mut request = types::GetSelectionCreateContextRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_use_context(display: &mut impl Display, context_len: types::Card32, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let mut request = types::SetSelectionUseContextRequest {
            context_len,
            context: Cow::Borrowed(context.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_use_context(display: &mut impl Display, ) -> Result<Cookie<types::GetSelectionUseContextReply>> {
        let mut request = types::GetSelectionUseContextRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_context(display: &mut impl Display, selection: types::Atom) -> Result<Cookie<types::GetSelectionContextReply>> {
        let mut request = types::GetSelectionContextRequest {
            selection,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_data_context(display: &mut impl Display, selection: types::Atom) -> Result<Cookie<types::GetSelectionDataContextReply>> {
        let mut request = types::GetSelectionDataContextRequest {
            selection,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_selections(display: &mut impl Display, ) -> Result<Cookie<types::ListSelectionsReply>> {
        let mut request = types::ListSelectionsRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_client_context(display: &mut impl Display, resource: types::Card32) -> Result<Cookie<types::GetClientContextReply>> {
        let mut request = types::GetClientContextRequest {
            resource,
        };
        display.send_reply_request(request)
    }
    
    #[cfg(feature = "xtest")]
    fn xtest_get_version(display: &mut impl Display, major_version: types::Card8, minor_version: types::Card16) -> Result<Cookie<types::GetVersionReply>> {
        let mut request = types::GetVersionRequest {
            major_version,
            minor_version,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xtest")]
    fn xtest_compare_cursor(display: &mut impl Display, window: types::Window, cursor: types::Cursor) -> Result<Cookie<types::CompareCursorReply>> {
        let mut request = types::CompareCursorRequest {
            window,
            cursor,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xtest")]
    fn xtest_fake_input(display: &mut impl Display, type_: types::Byte, detail: types::Byte, time: types::Card32, root: types::Window, root_x: types::Int16, root_y: types::Int16, deviceid: types::Card8) -> Result<Cookie<()>> {
        let mut request = types::FakeInputRequest {
            type_,
            detail,
            time,
            root,
            root_x,
            root_y,
            deviceid,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xtest")]
    fn xtest_grab_control(display: &mut impl Display, impervious: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::GrabControlRequest {
            impervious,
        };
        display.send_void_request(request)
    }
    
    #[cfg(feature = "xv")]
    fn xv_query_extension(display: &mut impl Display, ) -> Result<Cookie<types::QueryExtensionReply>> {
        let mut request = types::QueryExtensionRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_adaptors(display: &mut impl Display, window: types::Window) -> Result<Cookie<types::QueryAdaptorsReply>> {
        let mut request = types::QueryAdaptorsRequest {
            window,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_encodings(display: &mut impl Display, port: types::Port) -> Result<Cookie<types::QueryEncodingsReply>> {
        let mut request = types::QueryEncodingsRequest {
            port,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_grab_port(display: &mut impl Display, port: types::Port, time: impl Into<types::Time>) -> Result<Cookie<types::GrabPortReply>> {
        let mut request = types::GrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_ungrab_port(display: &mut impl Display, port: types::Port, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let mut request = types::UngrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_put_video(display: &mut impl Display, port: types::Port, drawable: types::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::PutVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_put_still(display: &mut impl Display, port: types::Port, drawable: types::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::PutStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_get_video(display: &mut impl Display, port: types::Port, drawable: types::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::GetVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_get_still(display: &mut impl Display, port: types::Port, drawable: types::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let mut request = types::GetStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_stop_video(display: &mut impl Display, port: types::Port, drawable: types::Drawable) -> Result<Cookie<()>> {
        let mut request = types::StopVideoRequest {
            port,
            drawable,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_select_video_notify(display: &mut impl Display, drawable: types::Drawable, onoff: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::SelectVideoNotifyRequest {
            drawable,
            onoff,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_select_port_notify(display: &mut impl Display, port: types::Port, onoff: types::Bool) -> Result<Cookie<()>> {
        let mut request = types::SelectPortNotifyRequest {
            port,
            onoff,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_best_size(display: &mut impl Display, port: types::Port, vid_w: types::Card16, vid_h: types::Card16, drw_w: types::Card16, drw_h: types::Card16, motion: types::Bool) -> Result<Cookie<types::QueryBestSizeReply>> {
        let mut request = types::QueryBestSizeRequest {
            port,
            vid_w,
            vid_h,
            drw_w,
            drw_h,
            motion,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_set_port_attribute(display: &mut impl Display, port: types::Port, attribute: types::Atom, value: types::Int32) -> Result<Cookie<()>> {
        let mut request = types::SetPortAttributeRequest {
            port,
            attribute,
            value,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_get_port_attribute(display: &mut impl Display, port: types::Port, attribute: types::Atom) -> Result<Cookie<types::GetPortAttributeReply>> {
        let mut request = types::GetPortAttributeRequest {
            port,
            attribute,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_port_attributes(display: &mut impl Display, port: types::Port) -> Result<Cookie<types::QueryPortAttributesReply>> {
        let mut request = types::QueryPortAttributesRequest {
            port,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_list_image_formats(display: &mut impl Display, port: types::Port) -> Result<Cookie<types::ListImageFormatsReply>> {
        let mut request = types::ListImageFormatsRequest {
            port,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_image_attributes(display: &mut impl Display, port: types::Port, id: types::Card32, width: types::Card16, height: types::Card16) -> Result<Cookie<types::QueryImageAttributesReply>> {
        let mut request = types::QueryImageAttributesRequest {
            port,
            id,
            width,
            height,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_put_image(display: &mut impl Display, port: types::Port, drawable: types::Drawable, gc: types::Gcontext, id: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, data: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let mut request = types::PutImageRequest {
            port,
            drawable,
            gc,
            id,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            data: Cow::Borrowed(data.as_ref()),
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_shm_put_image(display: &mut impl Display, port: types::Port, drawable: types::Drawable, gc: types::Gcontext, shmseg: types::Seg, id: types::Card32, offset: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, send_event: types::Card8) -> Result<Cookie<()>> {
        let mut request = types::ShmPutImageRequest {
            port,
            drawable,
            gc,
            shmseg,
            id,
            offset,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            send_event,
        };
        display.send_void_request(request)
    }
    
    #[cfg(feature = "xvmc")]
    fn xvmc_query_version(display: &mut impl Display, ) -> Result<Cookie<types::QueryVersionReply>> {
        let mut request = types::QueryVersionRequest {
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_surface_types(display: &mut impl Display, port_id: types::Port) -> Result<Cookie<types::ListSurfaceTypesReply>> {
        let mut request = types::ListSurfaceTypesRequest {
            port_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_context(display: &mut impl Display, context_id: types::Context, port_id: types::Port, surface_id: types::Surface, width: types::Card16, height: types::Card16, flags: types::Card32) -> Result<Cookie<types::CreateContextReply>> {
        let mut request = types::CreateContextRequest {
            context_id,
            port_id,
            surface_id,
            width,
            height,
            flags,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_context(display: &mut impl Display, context_id: types::Context) -> Result<Cookie<()>> {
        let mut request = types::DestroyContextRequest {
            context_id,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_surface(display: &mut impl Display, surface_id: types::Surface, context_id: types::Context) -> Result<Cookie<types::CreateSurfaceReply>> {
        let mut request = types::CreateSurfaceRequest {
            surface_id,
            context_id,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_surface(display: &mut impl Display, surface_id: types::Surface) -> Result<Cookie<()>> {
        let mut request = types::DestroySurfaceRequest {
            surface_id,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_subpicture(display: &mut impl Display, subpicture_id: types::Subpicture, context: types::Context, xvimage_id: types::Card32, width: types::Card16, height: types::Card16) -> Result<Cookie<types::CreateSubpictureReply>> {
        let mut request = types::CreateSubpictureRequest {
            subpicture_id,
            context,
            xvimage_id,
            width,
            height,
        };
        display.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_subpicture(display: &mut impl Display, subpicture_id: types::Subpicture) -> Result<Cookie<()>> {
        let mut request = types::DestroySubpictureRequest {
            subpicture_id,
        };
        display.send_void_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_subpicture_types(display: &mut impl Display, port_id: types::Port, surface_id: types::Surface) -> Result<Cookie<types::ListSubpictureTypesReply>> {
        let mut request = types::ListSubpictureTypesRequest {
            port_id,
            surface_id,
        };
        display.send_reply_request(request)
    }
    
}

#[cfg(feature = "async")]
pub trait AsyncDisplayFunctionsExt {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    }

impl<D: Display + ?Sized> DisplayFunctionsExt for D {}

#[cfg(feature = "async")]
impl<D: AsyncDisplay + ?Sized> AsyncDisplayFunctionsExt for D {}

mod types {
    pub(crate) type Card8 = u8;
    pub(crate) type Card16 = u16;
    pub(crate) type Card32 = u32;
    pub(crate) type Bool = bool;
    pub(crate) type Char = u8;
    pub(crate) type Byte = u8;
    pub(crate) type Int8 = i8;
    pub(crate) type Int16 = i16;
    pub(crate) type Int32 = i32;
    pub(crate) type Float = f32;
    pub(crate) type Double = f64;

    pub(crate) use crate::Fd;
    pub(crate) use crate::protocol::bigreq::*;
    #[cfg(feature = "composite")]
    pub(crate) use crate::protocol::composite::*;
    #[cfg(feature = "damage")]
    pub(crate) use crate::protocol::damage::*;
    #[cfg(feature = "dpms")]
    pub(crate) use crate::protocol::dpms::*;
    #[cfg(feature = "dri2")]
    pub(crate) use crate::protocol::dri2::*;
    #[cfg(feature = "dri3")]
    pub(crate) use crate::protocol::dri3::*;
    #[cfg(feature = "ge")]
    pub(crate) use crate::protocol::ge::*;
    #[cfg(feature = "glx")]
    pub(crate) use crate::protocol::glx::*;
    #[cfg(feature = "present")]
    pub(crate) use crate::protocol::present::*;
    #[cfg(feature = "randr")]
    pub(crate) use crate::protocol::randr::*;
    #[cfg(feature = "record")]
    pub(crate) use crate::protocol::record::*;
    #[cfg(feature = "render")]
    pub(crate) use crate::protocol::render::*;
    #[cfg(feature = "res")]
    pub(crate) use crate::protocol::res::*;
    #[cfg(feature = "screensaver")]
    pub(crate) use crate::protocol::screensaver::*;
    #[cfg(feature = "shape")]
    pub(crate) use crate::protocol::shape::*;
    #[cfg(feature = "shm")]
    pub(crate) use crate::protocol::shm::*;
    #[cfg(feature = "sync")]
    pub(crate) use crate::protocol::sync::*;
    #[cfg(feature = "xc_misc")]
    pub(crate) use crate::protocol::xc_misc::*;
    #[cfg(feature = "xevie")]
    pub(crate) use crate::protocol::xevie::*;
    #[cfg(feature = "xf86dri")]
    pub(crate) use crate::protocol::xf86dri::*;
    #[cfg(feature = "xf86vidmode")]
    pub(crate) use crate::protocol::xf86vidmode::*;
    #[cfg(feature = "xfixes")]
    pub(crate) use crate::protocol::xfixes::*;
    #[cfg(feature = "xinerama")]
    pub(crate) use crate::protocol::xinerama::*;
    #[cfg(feature = "xinput")]
    pub(crate) use crate::protocol::xinput::*;
    #[cfg(feature = "xkb")]
    pub(crate) use crate::protocol::xkb::*;
    #[cfg(feature = "xprint")]
    pub(crate) use crate::protocol::xprint::*;
    pub(crate) use crate::protocol::xproto::*;
    #[cfg(feature = "xselinux")]
    pub(crate) use crate::protocol::xselinux::*;
    #[cfg(feature = "xtest")]
    pub(crate) use crate::protocol::xtest::*;
    #[cfg(feature = "xv")]
    pub(crate) use crate::protocol::xv::*;
    #[cfg(feature = "xvmc")]
    pub(crate) use crate::protocol::xvmc::*;
}