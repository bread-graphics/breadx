
// This file is automatically generated by the `breadx-generator` crate.
// Do not edit this file directly.

//! Contains automatically generated items.

use crate::{Result, display::{Cookie, Display, DisplayExt}};
use alloc::borrow::Cow;
use alloc::vec::Vec;
use core::borrow::Borrow;

cfg_async! {
    use crate::display::AsyncDisplay;
}

pub trait DisplayFunctionsExt : Display {
    fn bigreq_enable(&mut self, ) -> Result<Cookie<types::bigreq::EnableReply>> {
        let request = types::bigreq::EnableRequest {
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "composite")]
    fn composite_query_version(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::composite::QueryVersionReply>> {
        let request = types::composite::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_window(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let request = types::composite::RedirectWindowRequest {
            window,
            update,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_subwindows(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let request = types::composite::RedirectSubwindowsRequest {
            window,
            update,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_window(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let request = types::composite::UnredirectWindowRequest {
            window,
            update,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_subwindows(&mut self, window: types::xproto::Window, update: types::Redirect) -> Result<Cookie<()>> {
        let request = types::composite::UnredirectSubwindowsRequest {
            window,
            update,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_create_region_from_border_clip(&mut self, region: types::Region, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::composite::CreateRegionFromBorderClipRequest {
            region,
            window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_name_window_pixmap(&mut self, window: types::xproto::Window, pixmap: types::xproto::Pixmap) -> Result<Cookie<()>> {
        let request = types::composite::NameWindowPixmapRequest {
            window,
            pixmap,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_get_overlay_window(&mut self, window: types::xproto::Window) -> Result<Cookie<types::composite::GetOverlayWindowReply>> {
        let request = types::composite::GetOverlayWindowRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_release_overlay_window(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::composite::ReleaseOverlayWindowRequest {
            window,
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "damage")]
    fn damage_query_version(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::damage::QueryVersionReply>> {
        let request = types::damage::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_create(&mut self, damage: types::Damage, drawable: types::xproto::Drawable, level: types::ReportLevel) -> Result<Cookie<()>> {
        let request = types::damage::CreateRequest {
            damage,
            drawable,
            level,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_destroy(&mut self, damage: types::Damage) -> Result<Cookie<()>> {
        let request = types::damage::DestroyRequest {
            damage,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_subtract(&mut self, damage: types::Damage, repair: impl Into<types::Region>, parts: impl Into<types::Region>) -> Result<Cookie<()>> {
        let request = types::damage::SubtractRequest {
            damage,
            repair: Into::<u32>::into(repair.into()) as _,
            parts: Into::<u32>::into(parts.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_add(&mut self, drawable: types::xproto::Drawable, region: types::Region) -> Result<Cookie<()>> {
        let request = types::damage::AddRequest {
            drawable,
            region,
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "dpms")]
    fn dpms_get_version(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::dpms::GetVersionReply>> {
        let request = types::dpms::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_capable(&mut self, ) -> Result<Cookie<types::dpms::CapableReply>> {
        let request = types::dpms::CapableRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_timeouts(&mut self, ) -> Result<Cookie<types::dpms::GetTimeoutsReply>> {
        let request = types::dpms::GetTimeoutsRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_set_timeouts(&mut self, standby_timeout: types::Card16, suspend_timeout: types::Card16, off_timeout: types::Card16) -> Result<Cookie<()>> {
        let request = types::dpms::SetTimeoutsRequest {
            standby_timeout,
            suspend_timeout,
            off_timeout,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_enable(&mut self, ) -> Result<Cookie<()>> {
        let request = types::dpms::EnableRequest {
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_disable(&mut self, ) -> Result<Cookie<()>> {
        let request = types::dpms::DisableRequest {
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_force_level(&mut self, power_level: types::DPMSMode) -> Result<Cookie<()>> {
        let request = types::dpms::ForceLevelRequest {
            power_level,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_info(&mut self, ) -> Result<Cookie<types::dpms::InfoReply>> {
        let request = types::dpms::InfoRequest {
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "dri2")]
    fn dri2_query_version(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::dri2::QueryVersionReply>> {
        let request = types::dri2::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_connect(&mut self, window: types::xproto::Window, driver_type: types::DriverType) -> Result<Cookie<types::dri2::ConnectReply>> {
        let request = types::dri2::ConnectRequest {
            window,
            driver_type,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_authenticate(&mut self, window: types::xproto::Window, magic: types::Card32) -> Result<Cookie<types::dri2::AuthenticateReply>> {
        let request = types::dri2::AuthenticateRequest {
            window,
            magic,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_create_drawable(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<()>> {
        let request = types::dri2::CreateDrawableRequest {
            drawable,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_destroy_drawable(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<()>> {
        let request = types::dri2::DestroyDrawableRequest {
            drawable,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_copy_region(&mut self, drawable: types::xproto::Drawable, region: types::Card32, dest: types::Card32, src: types::Card32) -> Result<Cookie<types::dri2::CopyRegionReply>> {
        let request = types::dri2::CopyRegionRequest {
            drawable,
            region,
            dest,
            src,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_buffers(&mut self, drawable: types::xproto::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> Result<Cookie<types::dri2::SwapBuffersReply>> {
        let request = types::dri2::SwapBuffersRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_msc(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<types::dri2::GetMSCReply>> {
        let request = types::dri2::GetMSCRequest {
            drawable,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_msc(&mut self, drawable: types::xproto::Drawable, target_msc_hi: types::Card32, target_msc_lo: types::Card32, divisor_hi: types::Card32, divisor_lo: types::Card32, remainder_hi: types::Card32, remainder_lo: types::Card32) -> Result<Cookie<types::dri2::WaitMSCReply>> {
        let request = types::dri2::WaitMSCRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_sbc(&mut self, drawable: types::xproto::Drawable, target_sbc_hi: types::Card32, target_sbc_lo: types::Card32) -> Result<Cookie<types::dri2::WaitSBCReply>> {
        let request = types::dri2::WaitSBCRequest {
            drawable,
            target_sbc_hi,
            target_sbc_lo,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_interval(&mut self, drawable: types::xproto::Drawable, interval: types::Card32) -> Result<Cookie<()>> {
        let request = types::dri2::SwapIntervalRequest {
            drawable,
            interval,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_param(&mut self, drawable: types::xproto::Drawable, param: types::Card32) -> Result<Cookie<types::dri2::GetParamReply>> {
        let request = types::dri2::GetParamRequest {
            drawable,
            param,
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "dri3")]
    fn dri3_query_version(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::dri3::QueryVersionReply>> {
        let request = types::dri3::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_open(&mut self, drawable: types::xproto::Drawable, provider: types::Card32) -> Result<Cookie<types::dri3::OpenReply>> {
        let request = types::dri3::OpenRequest {
            drawable,
            provider,
        };
        self.send_reply_fd_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffer(&mut self, pixmap: types::xproto::Pixmap, drawable: types::xproto::Drawable, size: types::Card32, width: types::Card16, height: types::Card16, stride: types::Card16, depth: types::Card8, bpp: types::Card8, pixmap_fd: types::Fd) -> Result<Cookie<()>> {
        let request = types::dri3::PixmapFromBufferRequest {
            pixmap,
            drawable,
            size,
            width,
            height,
            stride,
            depth,
            bpp,
            pixmap_fd,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffer_from_pixmap(&mut self, pixmap: types::xproto::Pixmap) -> Result<Cookie<types::dri3::BufferFromPixmapReply>> {
        let request = types::dri3::BufferFromPixmapRequest {
            pixmap,
        };
        self.send_reply_fd_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fence_from_fd(&mut self, drawable: types::xproto::Drawable, fence: types::Card32, initially_triggered: types::Bool, fence_fd: types::Fd) -> Result<Cookie<()>> {
        let request = types::dri3::FenceFromFDRequest {
            drawable,
            fence,
            initially_triggered,
            fence_fd,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fd_from_fence(&mut self, drawable: types::xproto::Drawable, fence: types::Card32) -> Result<Cookie<types::dri3::FDFromFenceReply>> {
        let request = types::dri3::FDFromFenceRequest {
            drawable,
            fence,
        };
        self.send_reply_fd_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_get_supported_modifiers(&mut self, window: types::Card32, depth: types::Card8, bpp: types::Card8) -> Result<Cookie<types::dri3::GetSupportedModifiersReply>> {
        let request = types::dri3::GetSupportedModifiersRequest {
            window,
            depth,
            bpp,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffers(&mut self, pixmap: types::xproto::Pixmap, window: types::xproto::Window, width: types::Card16, height: types::Card16, stride0: types::Card32, offset0: types::Card32, stride1: types::Card32, offset1: types::Card32, stride2: types::Card32, offset2: types::Card32, stride3: types::Card32, offset3: types::Card32, depth: types::Card8, bpp: types::Card8, modifier: types::Card64, buffers: Vec<types::Fd>) -> Result<Cookie<()>> {
        let request = types::dri3::PixmapFromBuffersRequest {
            pixmap,
            window,
            width,
            height,
            stride0,
            offset0,
            stride1,
            offset1,
            stride2,
            offset2,
            stride3,
            offset3,
            depth,
            bpp,
            modifier,
            buffers,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffers_from_pixmap(&mut self, pixmap: types::xproto::Pixmap) -> Result<Cookie<types::dri3::BuffersFromPixmapReply>> {
        let request = types::dri3::BuffersFromPixmapRequest {
            pixmap,
        };
        self.send_reply_fd_request(request)
    }
    
    fn ge_query_version(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::ge::QueryVersionReply>> {
        let request = types::ge::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "glx")]
    fn glx_render(&mut self, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let request = types::glx::RenderRequest {
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_render_large(&mut self, context_tag: types::ContextTag, request_num: types::Card16, request_total: types::Card16, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let request = types::glx::RenderLargeRequest {
            context_tag,
            request_num,
            request_total,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context(&mut self, context: types::glx::Context, visual: types::Visualid, screen: types::Card32, share_list: types::glx::Context, is_direct: types::Bool) -> Result<Cookie<()>> {
        let request = types::glx::CreateContextRequest {
            context,
            visual,
            screen,
            share_list,
            is_direct,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_context(&mut self, context: types::glx::Context) -> Result<Cookie<()>> {
        let request = types::glx::DestroyContextRequest {
            context,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_make_current(&mut self, drawable: types::glx::Drawable, context: types::glx::Context, old_context_tag: types::ContextTag) -> Result<Cookie<types::glx::MakeCurrentReply>> {
        let request = types::glx::MakeCurrentRequest {
            drawable,
            context,
            old_context_tag,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_direct(&mut self, context: types::glx::Context) -> Result<Cookie<types::glx::IsDirectReply>> {
        let request = types::glx::IsDirectRequest {
            context,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_version(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::glx::QueryVersionReply>> {
        let request = types::glx::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_gl(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let request = types::glx::WaitGLRequest {
            context_tag,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_x(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let request = types::glx::WaitXRequest {
            context_tag,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_copy_context(&mut self, src: types::glx::Context, dest: types::glx::Context, mask: types::Card32, src_context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let request = types::glx::CopyContextRequest {
            src,
            dest,
            mask,
            src_context_tag,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_swap_buffers(&mut self, context_tag: types::ContextTag, drawable: types::glx::Drawable) -> Result<Cookie<()>> {
        let request = types::glx::SwapBuffersRequest {
            context_tag,
            drawable,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_use_x_font(&mut self, context_tag: types::ContextTag, font: types::Font, first: types::Card32, count: types::Card32, list_base: types::Card32) -> Result<Cookie<()>> {
        let request = types::glx::UseXFontRequest {
            context_tag,
            font,
            first,
            count,
            list_base,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_glx_pixmap(&mut self, screen: types::Card32, visual: types::Visualid, pixmap: types::xproto::Pixmap, glx_pixmap: types::glx::Pixmap) -> Result<Cookie<()>> {
        let request = types::glx::CreateGLXPixmapRequest {
            screen,
            visual,
            pixmap,
            glx_pixmap,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_visual_configs(&mut self, screen: types::Card32) -> Result<Cookie<types::glx::GetVisualConfigsReply>> {
        let request = types::glx::GetVisualConfigsRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_glx_pixmap(&mut self, glx_pixmap: types::glx::Pixmap) -> Result<Cookie<()>> {
        let request = types::glx::DestroyGLXPixmapRequest {
            glx_pixmap,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private(&mut self, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let request = types::glx::VendorPrivateRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_with_reply(&mut self, vendor_code: types::Card32, context_tag: types::ContextTag, data: impl AsRef<[types::Byte]>) -> Result<Cookie<types::glx::VendorPrivateWithReplyReply>> {
        let request = types::glx::VendorPrivateWithReplyRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_extensions_string(&mut self, screen: types::Card32) -> Result<Cookie<types::glx::QueryExtensionsStringReply>> {
        let request = types::glx::QueryExtensionsStringRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_server_string(&mut self, screen: types::Card32, name: types::Card32) -> Result<Cookie<types::glx::QueryServerStringReply>> {
        let request = types::glx::QueryServerStringRequest {
            screen,
            name,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_client_info(&mut self, major_version: types::Card32, minor_version: types::Card32, string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::glx::ClientInfoRequest {
            major_version,
            minor_version,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_fb_configs(&mut self, screen: types::Card32) -> Result<Cookie<types::glx::GetFBConfigsReply>> {
        let request = types::glx::GetFBConfigsRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pixmap(&mut self, screen: types::Card32, fbconfig: types::Fbconfig, pixmap: types::xproto::Pixmap, glx_pixmap: types::glx::Pixmap, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let request = types::glx::CreatePixmapRequest {
            screen,
            fbconfig,
            pixmap,
            glx_pixmap,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pixmap(&mut self, glx_pixmap: types::glx::Pixmap) -> Result<Cookie<()>> {
        let request = types::glx::DestroyPixmapRequest {
            glx_pixmap,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_new_context(&mut self, context: types::glx::Context, fbconfig: types::Fbconfig, screen: types::Card32, render_type: types::Card32, share_list: types::glx::Context, is_direct: types::Bool) -> Result<Cookie<()>> {
        let request = types::glx::CreateNewContextRequest {
            context,
            fbconfig,
            screen,
            render_type,
            share_list,
            is_direct,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_context(&mut self, context: types::glx::Context) -> Result<Cookie<types::glx::QueryContextReply>> {
        let request = types::glx::QueryContextRequest {
            context,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_make_context_current(&mut self, old_context_tag: types::ContextTag, drawable: types::glx::Drawable, read_drawable: types::glx::Drawable, context: types::glx::Context) -> Result<Cookie<types::glx::MakeContextCurrentReply>> {
        let request = types::glx::MakeContextCurrentRequest {
            old_context_tag,
            drawable,
            read_drawable,
            context,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pbuffer(&mut self, screen: types::Card32, fbconfig: types::Fbconfig, pbuffer: types::Pbuffer, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let request = types::glx::CreatePbufferRequest {
            screen,
            fbconfig,
            pbuffer,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pbuffer(&mut self, pbuffer: types::Pbuffer) -> Result<Cookie<()>> {
        let request = types::glx::DestroyPbufferRequest {
            pbuffer,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_drawable_attributes(&mut self, drawable: types::glx::Drawable) -> Result<Cookie<types::glx::GetDrawableAttributesReply>> {
        let request = types::glx::GetDrawableAttributesRequest {
            drawable,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_change_drawable_attributes(&mut self, drawable: types::glx::Drawable, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let request = types::glx::ChangeDrawableAttributesRequest {
            drawable,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_window(&mut self, screen: types::Card32, fbconfig: types::Fbconfig, window: types::xproto::Window, glx_window: types::glx::Window, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let request = types::glx::CreateWindowRequest {
            screen,
            fbconfig,
            window,
            glx_window,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_window(&mut self, glxwindow: types::glx::Window) -> Result<Cookie<()>> {
        let request = types::glx::DeleteWindowRequest {
            glxwindow,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info_arb(&mut self, major_version: types::Card32, minor_version: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::glx::SetClientInfoARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_attribs_arb(&mut self, context: types::glx::Context, fbconfig: types::Fbconfig, screen: types::Card32, share_list: types::glx::Context, is_direct: types::Bool, attribs: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let request = types::glx::CreateContextAttribsARBRequest {
            context,
            fbconfig,
            screen,
            share_list,
            is_direct,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info2_arb(&mut self, major_version: types::Card32, minor_version: types::Card32, gl_versions: impl AsRef<[types::Card32]>, gl_extension_string: impl AsRef<[types::Char]>, glx_extension_string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::glx::SetClientInfo2ARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_new_list(&mut self, context_tag: types::ContextTag, list: types::Card32, mode: types::Card32) -> Result<Cookie<()>> {
        let request = types::glx::NewListRequest {
            context_tag,
            list,
            mode,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_end_list(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let request = types::glx::EndListRequest {
            context_tag,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_lists(&mut self, context_tag: types::ContextTag, list: types::Card32, range: types::Int32) -> Result<Cookie<()>> {
        let request = types::glx::DeleteListsRequest {
            context_tag,
            list,
            range,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_lists(&mut self, context_tag: types::ContextTag, range: types::Int32) -> Result<Cookie<types::glx::GenListsReply>> {
        let request = types::glx::GenListsRequest {
            context_tag,
            range,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_feedback_buffer(&mut self, context_tag: types::ContextTag, size: types::Int32, type_: types::Int32) -> Result<Cookie<()>> {
        let request = types::glx::FeedbackBufferRequest {
            context_tag,
            size,
            type_,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_select_buffer(&mut self, context_tag: types::ContextTag, size: types::Int32) -> Result<Cookie<()>> {
        let request = types::glx::SelectBufferRequest {
            context_tag,
            size,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_render_mode(&mut self, context_tag: types::ContextTag, mode: types::Card32) -> Result<Cookie<types::glx::RenderModeReply>> {
        let request = types::glx::RenderModeRequest {
            context_tag,
            mode,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_finish(&mut self, context_tag: types::ContextTag) -> Result<Cookie<types::glx::FinishReply>> {
        let request = types::glx::FinishRequest {
            context_tag,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storef(&mut self, context_tag: types::ContextTag, pname: types::Card32, datum: types::Float32) -> Result<Cookie<()>> {
        let request = types::glx::PixelStorefRequest {
            context_tag,
            pname,
            datum,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storei(&mut self, context_tag: types::ContextTag, pname: types::Card32, datum: types::Int32) -> Result<Cookie<()>> {
        let request = types::glx::PixelStoreiRequest {
            context_tag,
            pname,
            datum,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_read_pixels(&mut self, context_tag: types::ContextTag, x: types::Int32, y: types::Int32, width: types::Int32, height: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, lsb_first: types::Bool) -> Result<Cookie<types::glx::ReadPixelsReply>> {
        let request = types::glx::ReadPixelsRequest {
            context_tag,
            x,
            y,
            width,
            height,
            format,
            type_,
            swap_bytes,
            lsb_first,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_booleanv(&mut self, context_tag: types::ContextTag, pname: types::Int32) -> Result<Cookie<types::glx::GetBooleanvReply>> {
        let request = types::glx::GetBooleanvRequest {
            context_tag,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_clip_plane(&mut self, context_tag: types::ContextTag, plane: types::Int32) -> Result<Cookie<types::glx::GetClipPlaneReply>> {
        let request = types::glx::GetClipPlaneRequest {
            context_tag,
            plane,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_doublev(&mut self, context_tag: types::ContextTag, pname: types::Card32) -> Result<Cookie<types::glx::GetDoublevReply>> {
        let request = types::glx::GetDoublevRequest {
            context_tag,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_error(&mut self, context_tag: types::ContextTag) -> Result<Cookie<types::glx::GetErrorReply>> {
        let request = types::glx::GetErrorRequest {
            context_tag,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_floatv(&mut self, context_tag: types::ContextTag, pname: types::Card32) -> Result<Cookie<types::glx::GetFloatvReply>> {
        let request = types::glx::GetFloatvRequest {
            context_tag,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_integerv(&mut self, context_tag: types::ContextTag, pname: types::Card32) -> Result<Cookie<types::glx::GetIntegervReply>> {
        let request = types::glx::GetIntegervRequest {
            context_tag,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightfv(&mut self, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetLightfvReply>> {
        let request = types::glx::GetLightfvRequest {
            context_tag,
            light,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightiv(&mut self, context_tag: types::ContextTag, light: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetLightivReply>> {
        let request = types::glx::GetLightivRequest {
            context_tag,
            light,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapdv(&mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<Cookie<types::glx::GetMapdvReply>> {
        let request = types::glx::GetMapdvRequest {
            context_tag,
            target,
            query,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapfv(&mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<Cookie<types::glx::GetMapfvReply>> {
        let request = types::glx::GetMapfvRequest {
            context_tag,
            target,
            query,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapiv(&mut self, context_tag: types::ContextTag, target: types::Card32, query: types::Card32) -> Result<Cookie<types::glx::GetMapivReply>> {
        let request = types::glx::GetMapivRequest {
            context_tag,
            target,
            query,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialfv(&mut self, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetMaterialfvReply>> {
        let request = types::glx::GetMaterialfvRequest {
            context_tag,
            face,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialiv(&mut self, context_tag: types::ContextTag, face: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetMaterialivReply>> {
        let request = types::glx::GetMaterialivRequest {
            context_tag,
            face,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapfv(&mut self, context_tag: types::ContextTag, map: types::Card32) -> Result<Cookie<types::glx::GetPixelMapfvReply>> {
        let request = types::glx::GetPixelMapfvRequest {
            context_tag,
            map,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapuiv(&mut self, context_tag: types::ContextTag, map: types::Card32) -> Result<Cookie<types::glx::GetPixelMapuivReply>> {
        let request = types::glx::GetPixelMapuivRequest {
            context_tag,
            map,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapusv(&mut self, context_tag: types::ContextTag, map: types::Card32) -> Result<Cookie<types::glx::GetPixelMapusvReply>> {
        let request = types::glx::GetPixelMapusvRequest {
            context_tag,
            map,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_polygon_stipple(&mut self, context_tag: types::ContextTag, lsb_first: types::Bool) -> Result<Cookie<types::glx::GetPolygonStippleReply>> {
        let request = types::glx::GetPolygonStippleRequest {
            context_tag,
            lsb_first,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_string(&mut self, context_tag: types::ContextTag, name: types::Card32) -> Result<Cookie<types::glx::GetStringReply>> {
        let request = types::glx::GetStringRequest {
            context_tag,
            name,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_envfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexEnvfvReply>> {
        let request = types::glx::GetTexEnvfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_enviv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexEnvivReply>> {
        let request = types::glx::GetTexEnvivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_gendv(&mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexGendvReply>> {
        let request = types::glx::GetTexGendvRequest {
            context_tag,
            coord,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_genfv(&mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexGenfvReply>> {
        let request = types::glx::GetTexGenfvRequest {
            context_tag,
            coord,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_geniv(&mut self, context_tag: types::ContextTag, coord: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexGenivReply>> {
        let request = types::glx::GetTexGenivRequest {
            context_tag,
            coord,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_image(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::glx::GetTexImageReply>> {
        let request = types::glx::GetTexImageRequest {
            context_tag,
            target,
            level,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexParameterfvReply>> {
        let request = types::glx::GetTexParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexParameterivReply>> {
        let request = types::glx::GetTexParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexLevelParameterfvReply>> {
        let request = types::glx::GetTexLevelParameterfvRequest {
            context_tag,
            target,
            level,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32, pname: types::Card32) -> Result<Cookie<types::glx::GetTexLevelParameterivReply>> {
        let request = types::glx::GetTexLevelParameterivRequest {
            context_tag,
            target,
            level,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_enabled(&mut self, context_tag: types::ContextTag, capability: types::Card32) -> Result<Cookie<types::glx::IsEnabledReply>> {
        let request = types::glx::IsEnabledRequest {
            context_tag,
            capability,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_list(&mut self, context_tag: types::ContextTag, list: types::Card32) -> Result<Cookie<types::glx::IsListReply>> {
        let request = types::glx::IsListRequest {
            context_tag,
            list,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_flush(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let request = types::glx::FlushRequest {
            context_tag,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_are_textures_resident(&mut self, context_tag: types::ContextTag, textures: impl AsRef<[types::Card32]>) -> Result<Cookie<types::glx::AreTexturesResidentReply>> {
        let request = types::glx::AreTexturesResidentRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_textures(&mut self, context_tag: types::ContextTag, textures: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let request = types::glx::DeleteTexturesRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_textures(&mut self, context_tag: types::ContextTag, n: types::Int32) -> Result<Cookie<types::glx::GenTexturesReply>> {
        let request = types::glx::GenTexturesRequest {
            context_tag,
            n,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_texture(&mut self, context_tag: types::ContextTag, texture: types::Card32) -> Result<Cookie<types::glx::IsTextureReply>> {
        let request = types::glx::IsTextureRequest {
            context_tag,
            texture,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::glx::GetColorTableReply>> {
        let request = types::glx::GetColorTableRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetColorTableParameterfvReply>> {
        let request = types::glx::GetColorTableParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetColorTableParameterivReply>> {
        let request = types::glx::GetColorTableParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_filter(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::glx::GetConvolutionFilterReply>> {
        let request = types::glx::GetConvolutionFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetConvolutionParameterfvReply>> {
        let request = types::glx::GetConvolutionParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetConvolutionParameterivReply>> {
        let request = types::glx::GetConvolutionParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_separable_filter(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool) -> Result<Cookie<types::glx::GetSeparableFilterReply>> {
        let request = types::glx::GetSeparableFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> Result<Cookie<types::glx::GetHistogramReply>> {
        let request = types::glx::GetHistogramRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetHistogramParameterfvReply>> {
        let request = types::glx::GetHistogramParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetHistogramParameterivReply>> {
        let request = types::glx::GetHistogramParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax(&mut self, context_tag: types::ContextTag, target: types::Card32, format: types::Card32, type_: types::Card32, swap_bytes: types::Bool, reset: types::Bool) -> Result<Cookie<types::glx::GetMinmaxReply>> {
        let request = types::glx::GetMinmaxRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameterfv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetMinmaxParameterfvReply>> {
        let request = types::glx::GetMinmaxParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameteriv(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetMinmaxParameterivReply>> {
        let request = types::glx::GetMinmaxParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_compressed_tex_image_arb(&mut self, context_tag: types::ContextTag, target: types::Card32, level: types::Int32) -> Result<Cookie<types::glx::GetCompressedTexImageARBReply>> {
        let request = types::glx::GetCompressedTexImageARBRequest {
            context_tag,
            target,
            level,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_queries_arb(&mut self, context_tag: types::ContextTag, ids: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let request = types::glx::DeleteQueriesARBRequest {
            context_tag,
            ids: Cow::Borrowed(ids.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_queries_arb(&mut self, context_tag: types::ContextTag, n: types::Int32) -> Result<Cookie<types::glx::GenQueriesARBReply>> {
        let request = types::glx::GenQueriesARBRequest {
            context_tag,
            n,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_query_arb(&mut self, context_tag: types::ContextTag, id: types::Card32) -> Result<Cookie<types::glx::IsQueryARBReply>> {
        let request = types::glx::IsQueryARBRequest {
            context_tag,
            id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_queryiv_arb(&mut self, context_tag: types::ContextTag, target: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetQueryivARBReply>> {
        let request = types::glx::GetQueryivARBRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectiv_arb(&mut self, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetQueryObjectivARBReply>> {
        let request = types::glx::GetQueryObjectivARBRequest {
            context_tag,
            id,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectuiv_arb(&mut self, context_tag: types::ContextTag, id: types::Card32, pname: types::Card32) -> Result<Cookie<types::glx::GetQueryObjectuivARBReply>> {
        let request = types::glx::GetQueryObjectuivARBRequest {
            context_tag,
            id,
            pname,
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "present")]
    fn present_query_version(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::present::QueryVersionReply>> {
        let request = types::present::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "present")]
    fn present_pixmap(&mut self, window: types::xproto::Window, pixmap: types::xproto::Pixmap, serial: types::Card32, valid: types::Region, update: types::Region, x_off: types::Int16, y_off: types::Int16, target_crtc: types::Crtc, wait_fence: types::Fence, idle_fence: types::Fence, options: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64, notifies: impl AsRef<[types::present::Notify]>) -> Result<Cookie<()>> {
        let request = types::present::PixmapRequest {
            window,
            pixmap,
            serial,
            valid,
            update,
            x_off,
            y_off,
            target_crtc,
            wait_fence,
            idle_fence,
            options,
            target_msc,
            divisor,
            remainder,
            notifies: Cow::Borrowed(notifies.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "present")]
    fn present_notify_msc(&mut self, window: types::xproto::Window, serial: types::Card32, target_msc: types::Card64, divisor: types::Card64, remainder: types::Card64) -> Result<Cookie<()>> {
        let request = types::present::NotifyMSCRequest {
            window,
            serial,
            target_msc,
            divisor,
            remainder,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "present")]
    fn present_select_input(&mut self, eid: types::present::Event, window: types::xproto::Window, event_mask: impl Into<types::present::EventMask>) -> Result<Cookie<()>> {
        let request = types::present::SelectInputRequest {
            eid,
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "present")]
    fn present_query_capabilities(&mut self, target: types::Card32) -> Result<Cookie<types::present::QueryCapabilitiesReply>> {
        let request = types::present::QueryCapabilitiesRequest {
            target,
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "randr")]
    fn randr_query_version(&mut self, major_version: types::Card32, minor_version: types::Card32) -> Result<Cookie<types::randr::QueryVersionReply>> {
        let request = types::randr::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_config(&mut self, window: types::xproto::Window, timestamp: types::Timestamp, config_timestamp: types::Timestamp, size_id: types::Card16, rotation: impl Into<types::Rotation>, rate: types::Card16) -> Result<Cookie<types::randr::SetScreenConfigReply>> {
        let request = types::randr::SetScreenConfigRequest {
            window,
            timestamp,
            config_timestamp,
            size_id,
            rotation: Into::<u32>::into(rotation.into()) as _,
            rate,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_select_input(&mut self, window: types::xproto::Window, enable: impl Into<types::NotifyMask>) -> Result<Cookie<()>> {
        let request = types::randr::SelectInputRequest {
            window,
            enable: Into::<u32>::into(enable.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_info(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetScreenInfoReply>> {
        let request = types::randr::GetScreenInfoRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_size_range(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetScreenSizeRangeReply>> {
        let request = types::randr::GetScreenSizeRangeRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_size(&mut self, window: types::xproto::Window, width: types::Card16, height: types::Card16, mm_width: types::Card32, mm_height: types::Card32) -> Result<Cookie<()>> {
        let request = types::randr::SetScreenSizeRequest {
            window,
            width,
            height,
            mm_width,
            mm_height,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetScreenResourcesReply>> {
        let request = types::randr::GetScreenResourcesRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_info(&mut self, output: types::Output, config_timestamp: types::Timestamp) -> Result<Cookie<types::randr::GetOutputInfoReply>> {
        let request = types::randr::GetOutputInfoRequest {
            output,
            config_timestamp,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_list_output_properties(&mut self, output: types::Output) -> Result<Cookie<types::randr::ListOutputPropertiesReply>> {
        let request = types::randr::ListOutputPropertiesRequest {
            output,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_query_output_property(&mut self, output: types::Output, property: types::Atom) -> Result<Cookie<types::randr::QueryOutputPropertyReply>> {
        let request = types::randr::QueryOutputPropertyRequest {
            output,
            property,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_output_property(&mut self, output: types::Output, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> Result<Cookie<()>> {
        let request = types::randr::ConfigureOutputPropertyRequest {
            output,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_change_output_property(&mut self, output: types::Output, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::PropMode, num_units: types::Card32, data: impl AsRef<[types::Void]>) -> Result<Cookie<()>> {
        let request = types::randr::ChangeOutputPropertyRequest {
            output,
            property,
            type_,
            format,
            mode,
            num_units,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_property(&mut self, output: types::Output, property: types::Atom) -> Result<Cookie<()>> {
        let request = types::randr::DeleteOutputPropertyRequest {
            output,
            property,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_property(&mut self, output: types::Output, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> Result<Cookie<types::randr::GetOutputPropertyReply>> {
        let request = types::randr::GetOutputPropertyRequest {
            output,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
            delete,
            pending,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_create_mode(&mut self, window: types::xproto::Window, mode_info: types::randr::ModeInfo, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::randr::CreateModeReply>> {
        let request = types::randr::CreateModeRequest {
            window,
            mode_info,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_destroy_mode(&mut self, mode: types::Mode) -> Result<Cookie<()>> {
        let request = types::randr::DestroyModeRequest {
            mode,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_add_output_mode(&mut self, output: types::Output, mode: types::Mode) -> Result<Cookie<()>> {
        let request = types::randr::AddOutputModeRequest {
            output,
            mode,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_mode(&mut self, output: types::Output, mode: types::Mode) -> Result<Cookie<()>> {
        let request = types::randr::DeleteOutputModeRequest {
            output,
            mode,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_info(&mut self, crtc: types::Crtc, config_timestamp: types::Timestamp) -> Result<Cookie<types::randr::GetCrtcInfoReply>> {
        let request = types::randr::GetCrtcInfoRequest {
            crtc,
            config_timestamp,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_config(&mut self, crtc: types::Crtc, timestamp: types::Timestamp, config_timestamp: types::Timestamp, x: types::Int16, y: types::Int16, mode: types::Mode, rotation: impl Into<types::Rotation>, outputs: impl AsRef<[types::Output]>) -> Result<Cookie<types::randr::SetCrtcConfigReply>> {
        let request = types::randr::SetCrtcConfigRequest {
            crtc,
            timestamp,
            config_timestamp,
            x,
            y,
            mode,
            rotation: Into::<u32>::into(rotation.into()) as _,
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_size(&mut self, crtc: types::Crtc) -> Result<Cookie<types::randr::GetCrtcGammaSizeReply>> {
        let request = types::randr::GetCrtcGammaSizeRequest {
            crtc,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma(&mut self, crtc: types::Crtc) -> Result<Cookie<types::randr::GetCrtcGammaReply>> {
        let request = types::randr::GetCrtcGammaRequest {
            crtc,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_gamma(&mut self, crtc: types::Crtc, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> Result<Cookie<()>> {
        let request = types::randr::SetCrtcGammaRequest {
            crtc,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_current(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetScreenResourcesCurrentReply>> {
        let request = types::randr::GetScreenResourcesCurrentRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_transform(&mut self, crtc: types::Crtc, transform: types::render::Transform, filter_name: impl AsRef<[types::Char]>, filter_params: impl AsRef<[types::Fixed]>) -> Result<Cookie<()>> {
        let request = types::randr::SetCrtcTransformRequest {
            crtc,
            transform,
            filter_name: Cow::Borrowed(filter_name.as_ref()),
            filter_params: Cow::Borrowed(filter_params.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_transform(&mut self, crtc: types::Crtc) -> Result<Cookie<types::randr::GetCrtcTransformReply>> {
        let request = types::randr::GetCrtcTransformRequest {
            crtc,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_panning(&mut self, crtc: types::Crtc) -> Result<Cookie<types::randr::GetPanningReply>> {
        let request = types::randr::GetPanningRequest {
            crtc,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_panning(&mut self, crtc: types::Crtc, timestamp: types::Timestamp, left: types::Card16, top: types::Card16, width: types::Card16, height: types::Card16, track_left: types::Card16, track_top: types::Card16, track_width: types::Card16, track_height: types::Card16, border_left: types::Int16, border_top: types::Int16, border_right: types::Int16, border_bottom: types::Int16) -> Result<Cookie<types::randr::SetPanningReply>> {
        let request = types::randr::SetPanningRequest {
            crtc,
            timestamp,
            left,
            top,
            width,
            height,
            track_left,
            track_top,
            track_width,
            track_height,
            border_left,
            border_top,
            border_right,
            border_bottom,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_output_primary(&mut self, window: types::xproto::Window, output: types::Output) -> Result<Cookie<()>> {
        let request = types::randr::SetOutputPrimaryRequest {
            window,
            output,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_primary(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetOutputPrimaryReply>> {
        let request = types::randr::GetOutputPrimaryRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_providers(&mut self, window: types::xproto::Window) -> Result<Cookie<types::randr::GetProvidersReply>> {
        let request = types::randr::GetProvidersRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_info(&mut self, provider: types::Provider, config_timestamp: types::Timestamp) -> Result<Cookie<types::randr::GetProviderInfoReply>> {
        let request = types::randr::GetProviderInfoRequest {
            provider,
            config_timestamp,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_offload_sink(&mut self, provider: types::Provider, sink_provider: types::Provider, config_timestamp: types::Timestamp) -> Result<Cookie<()>> {
        let request = types::randr::SetProviderOffloadSinkRequest {
            provider,
            sink_provider,
            config_timestamp,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_output_source(&mut self, provider: types::Provider, source_provider: types::Provider, config_timestamp: types::Timestamp) -> Result<Cookie<()>> {
        let request = types::randr::SetProviderOutputSourceRequest {
            provider,
            source_provider,
            config_timestamp,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_list_provider_properties(&mut self, provider: types::Provider) -> Result<Cookie<types::randr::ListProviderPropertiesReply>> {
        let request = types::randr::ListProviderPropertiesRequest {
            provider,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_query_provider_property(&mut self, provider: types::Provider, property: types::Atom) -> Result<Cookie<types::randr::QueryProviderPropertyReply>> {
        let request = types::randr::QueryProviderPropertyRequest {
            provider,
            property,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_provider_property(&mut self, provider: types::Provider, property: types::Atom, pending: types::Bool, range: types::Bool, values: impl AsRef<[types::Int32]>) -> Result<Cookie<()>> {
        let request = types::randr::ConfigureProviderPropertyRequest {
            provider,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_change_provider_property(&mut self, provider: types::Provider, property: types::Atom, type_: types::Atom, format: types::Card8, mode: types::Card8, num_items: types::Card32, data: impl AsRef<[types::Void]>) -> Result<Cookie<()>> {
        let request = types::randr::ChangeProviderPropertyRequest {
            provider,
            property,
            type_,
            format,
            mode,
            num_items,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_provider_property(&mut self, provider: types::Provider, property: types::Atom) -> Result<Cookie<()>> {
        let request = types::randr::DeleteProviderPropertyRequest {
            provider,
            property,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_property(&mut self, provider: types::Provider, property: types::Atom, type_: types::Atom, long_offset: types::Card32, long_length: types::Card32, delete: types::Bool, pending: types::Bool) -> Result<Cookie<types::randr::GetProviderPropertyReply>> {
        let request = types::randr::GetProviderPropertyRequest {
            provider,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_monitors(&mut self, window: types::xproto::Window, get_active: types::Bool) -> Result<Cookie<types::randr::GetMonitorsReply>> {
        let request = types::randr::GetMonitorsRequest {
            window,
            get_active,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_monitor(&mut self, window: types::xproto::Window, monitorinfo: types::MonitorInfo) -> Result<Cookie<()>> {
        let request = types::randr::SetMonitorRequest {
            window,
            monitorinfo,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_monitor(&mut self, window: types::xproto::Window, name: types::Atom) -> Result<Cookie<()>> {
        let request = types::randr::DeleteMonitorRequest {
            window,
            name,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_create_lease(&mut self, window: types::xproto::Window, lid: types::Lease, crtcs: impl AsRef<[types::Crtc]>, outputs: impl AsRef<[types::Output]>) -> Result<Cookie<types::randr::CreateLeaseReply>> {
        let request = types::randr::CreateLeaseRequest {
            window,
            lid,
            crtcs: Cow::Borrowed(crtcs.as_ref()),
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        self.send_reply_fd_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_free_lease(&mut self, lid: types::Lease, terminate: types::Byte) -> Result<Cookie<()>> {
        let request = types::randr::FreeLeaseRequest {
            lid,
            terminate,
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "record")]
    fn record_query_version(&mut self, major_version: types::Card16, minor_version: types::Card16) -> Result<Cookie<types::record::QueryVersionReply>> {
        let request = types::record::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "record")]
    fn record_create_context(&mut self, context: types::record::Context, element_header: types::ElementHeader, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> Result<Cookie<()>> {
        let request = types::record::CreateContextRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_register_clients(&mut self, context: types::record::Context, element_header: types::ElementHeader, client_specs: impl AsRef<[types::ClientSpec]>, ranges: impl AsRef<[types::Range]>) -> Result<Cookie<()>> {
        let request = types::record::RegisterClientsRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_unregister_clients(&mut self, context: types::record::Context, client_specs: impl AsRef<[types::ClientSpec]>) -> Result<Cookie<()>> {
        let request = types::record::UnregisterClientsRequest {
            context,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_get_context(&mut self, context: types::record::Context) -> Result<Cookie<types::record::GetContextReply>> {
        let request = types::record::GetContextRequest {
            context,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "record")]
    fn record_enable_context(&mut self, context: types::record::Context) -> Result<Cookie<types::record::EnableContextReply>> {
        let request = types::record::EnableContextRequest {
            context,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "record")]
    fn record_disable_context(&mut self, context: types::record::Context) -> Result<Cookie<()>> {
        let request = types::record::DisableContextRequest {
            context,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_free_context(&mut self, context: types::record::Context) -> Result<Cookie<()>> {
        let request = types::record::FreeContextRequest {
            context,
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "render")]
    fn render_query_version(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::render::QueryVersionReply>> {
        let request = types::render::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_formats(&mut self, ) -> Result<Cookie<types::render::QueryPictFormatsReply>> {
        let request = types::render::QueryPictFormatsRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_index_values(&mut self, format: types::Pictformat) -> Result<Cookie<types::render::QueryPictIndexValuesReply>> {
        let request = types::render::QueryPictIndexValuesRequest {
            format,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_picture(&mut self, pid: types::Picture, drawable: types::xproto::Drawable, format: types::Pictformat, value_list: impl Borrow<types::render::CreatePictureAux>) -> Result<Cookie<()>> {
        let request = types::render::CreatePictureRequest {
            pid,
            drawable,
            format,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_change_picture(&mut self, picture: types::Picture, value_list: impl Borrow<types::render::ChangePictureAux>) -> Result<Cookie<()>> {
        let request = types::render::ChangePictureRequest {
            picture,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_clip_rectangles(&mut self, picture: types::Picture, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let request = types::render::SetPictureClipRectanglesRequest {
            picture,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_free_picture(&mut self, picture: types::Picture) -> Result<Cookie<()>> {
        let request = types::render::FreePictureRequest {
            picture,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite(&mut self, op: types::PictOp, src: types::Picture, mask: impl Into<types::Picture>, dst: types::Picture, src_x: types::Int16, src_y: types::Int16, mask_x: types::Int16, mask_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let request = types::render::CompositeRequest {
            op,
            src,
            mask: Into::<u32>::into(mask.into()) as _,
            dst,
            src_x,
            src_y,
            mask_x,
            mask_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_trapezoids(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, traps: impl AsRef<[types::Trapezoid]>) -> Result<Cookie<()>> {
        let request = types::render::TrapezoidsRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_triangles(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, triangles: impl AsRef<[types::Triangle]>) -> Result<Cookie<()>> {
        let request = types::render::TrianglesRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            triangles: Cow::Borrowed(triangles.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_tri_strip(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> Result<Cookie<()>> {
        let request = types::render::TriStripRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_tri_fan(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, src_x: types::Int16, src_y: types::Int16, points: impl AsRef<[types::Pointfix]>) -> Result<Cookie<()>> {
        let request = types::render::TriFanRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_glyph_set(&mut self, gsid: types::Glyphset, format: types::Pictformat) -> Result<Cookie<()>> {
        let request = types::render::CreateGlyphSetRequest {
            gsid,
            format,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_reference_glyph_set(&mut self, gsid: types::Glyphset, existing: types::Glyphset) -> Result<Cookie<()>> {
        let request = types::render::ReferenceGlyphSetRequest {
            gsid,
            existing,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_free_glyph_set(&mut self, glyphset: types::Glyphset) -> Result<Cookie<()>> {
        let request = types::render::FreeGlyphSetRequest {
            glyphset,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_add_glyphs(&mut self, glyphset: types::Glyphset, glyphids: impl AsRef<[types::Card32]>, glyphs: impl AsRef<[types::Glyphinfo]>, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let request = types::render::AddGlyphsRequest {
            glyphset,
            glyphids: Cow::Borrowed(glyphids.as_ref()),
            glyphs: Cow::Borrowed(glyphs.as_ref()),
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_free_glyphs(&mut self, glyphset: types::Glyphset, glyphs: impl AsRef<[types::Glyph]>) -> Result<Cookie<()>> {
        let request = types::render::FreeGlyphsRequest {
            glyphset,
            glyphs: Cow::Borrowed(glyphs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs8(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let request = types::render::CompositeGlyphs8Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs16(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let request = types::render::CompositeGlyphs16Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs32(&mut self, op: types::PictOp, src: types::Picture, dst: types::Picture, mask_format: types::Pictformat, glyphset: types::Glyphset, src_x: types::Int16, src_y: types::Int16, glyphcmds: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let request = types::render::CompositeGlyphs32Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_fill_rectangles(&mut self, op: types::PictOp, dst: types::Picture, color: types::Color, rects: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let request = types::render::FillRectanglesRequest {
            op,
            dst,
            color,
            rects: Cow::Borrowed(rects.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_cursor(&mut self, cid: types::xproto::Cursor, source: types::Picture, x: types::Card16, y: types::Card16) -> Result<Cookie<()>> {
        let request = types::render::CreateCursorRequest {
            cid,
            source,
            x,
            y,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_transform(&mut self, picture: types::Picture, transform: types::render::Transform) -> Result<Cookie<()>> {
        let request = types::render::SetPictureTransformRequest {
            picture,
            transform,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_query_filters(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<types::render::QueryFiltersReply>> {
        let request = types::render::QueryFiltersRequest {
            drawable,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_filter(&mut self, picture: types::Picture, filter: impl AsRef<[types::Char]>, values: impl AsRef<[types::Fixed]>) -> Result<Cookie<()>> {
        let request = types::render::SetPictureFilterRequest {
            picture,
            filter: Cow::Borrowed(filter.as_ref()),
            values: Cow::Borrowed(values.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_anim_cursor(&mut self, cid: types::xproto::Cursor, cursors: impl AsRef<[types::Animcursorelt]>) -> Result<Cookie<()>> {
        let request = types::render::CreateAnimCursorRequest {
            cid,
            cursors: Cow::Borrowed(cursors.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_add_traps(&mut self, picture: types::Picture, x_off: types::Int16, y_off: types::Int16, traps: impl AsRef<[types::Trap]>) -> Result<Cookie<()>> {
        let request = types::render::AddTrapsRequest {
            picture,
            x_off,
            y_off,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_solid_fill(&mut self, picture: types::Picture, color: types::Color) -> Result<Cookie<()>> {
        let request = types::render::CreateSolidFillRequest {
            picture,
            color,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_linear_gradient(&mut self, picture: types::Picture, p1: types::Pointfix, p2: types::Pointfix, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<Cookie<()>> {
        let request = types::render::CreateLinearGradientRequest {
            picture,
            p1,
            p2,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_radial_gradient(&mut self, picture: types::Picture, inner: types::Pointfix, outer: types::Pointfix, inner_radius: types::Fixed, outer_radius: types::Fixed, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<Cookie<()>> {
        let request = types::render::CreateRadialGradientRequest {
            picture,
            inner,
            outer,
            inner_radius,
            outer_radius,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_conical_gradient(&mut self, picture: types::Picture, center: types::Pointfix, angle: types::Fixed, stops: impl AsRef<[types::Fixed]>, colors: impl AsRef<[types::Color]>) -> Result<Cookie<()>> {
        let request = types::render::CreateConicalGradientRequest {
            picture,
            center,
            angle,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "res")]
    fn res_query_version(&mut self, client_major: types::Card8, client_minor: types::Card8) -> Result<Cookie<types::res::QueryVersionReply>> {
        let request = types::res::QueryVersionRequest {
            client_major,
            client_minor,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_clients(&mut self, ) -> Result<Cookie<types::res::QueryClientsReply>> {
        let request = types::res::QueryClientsRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_client_resources(&mut self, xid: types::Card32) -> Result<Cookie<types::res::QueryClientResourcesReply>> {
        let request = types::res::QueryClientResourcesRequest {
            xid,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_client_pixmap_bytes(&mut self, xid: types::Card32) -> Result<Cookie<types::res::QueryClientPixmapBytesReply>> {
        let request = types::res::QueryClientPixmapBytesRequest {
            xid,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_client_ids(&mut self, specs: impl AsRef<[types::ClientIdSpec]>) -> Result<Cookie<types::res::QueryClientIdsReply>> {
        let request = types::res::QueryClientIdsRequest {
            specs: Cow::Borrowed(specs.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_resource_bytes(&mut self, client: types::Card32, specs: impl AsRef<[types::ResourceIdSpec]>) -> Result<Cookie<types::res::QueryResourceBytesReply>> {
        let request = types::res::QueryResourceBytesRequest {
            client,
            specs: Cow::Borrowed(specs.as_ref()),
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "screensaver")]
    fn screensaver_query_version(&mut self, client_major_version: types::Card8, client_minor_version: types::Card8) -> Result<Cookie<types::screensaver::QueryVersionReply>> {
        let request = types::screensaver::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_info(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<types::screensaver::QueryInfoReply>> {
        let request = types::screensaver::QueryInfoRequest {
            drawable,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_select_input(&mut self, drawable: types::xproto::Drawable, event_mask: impl Into<types::screensaver::Event>) -> Result<Cookie<()>> {
        let request = types::screensaver::SelectInputRequest {
            drawable,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_set_attributes(&mut self, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, depth: types::Card8, visual: types::Visualid, value_list: impl Borrow<types::screensaver::SetAttributesAux>) -> Result<Cookie<()>> {
        let request = types::screensaver::SetAttributesRequest {
            drawable,
            x,
            y,
            width,
            height,
            border_width,
            class,
            depth,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_unset_attributes(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<()>> {
        let request = types::screensaver::UnsetAttributesRequest {
            drawable,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_suspend(&mut self, suspend: types::Card32) -> Result<Cookie<()>> {
        let request = types::screensaver::SuspendRequest {
            suspend,
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "shape")]
    fn shape_query_version(&mut self, ) -> Result<Cookie<types::shape::QueryVersionReply>> {
        let request = types::shape::QueryVersionRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_rectangles(&mut self, operation: types::SO, destination_kind: types::SK, ordering: types::ClipOrdering, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let request = types::shape::RectanglesRequest {
            operation,
            destination_kind,
            ordering,
            destination_window,
            x_offset,
            y_offset,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_mask(&mut self, operation: types::SO, destination_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, source_bitmap: impl Into<types::xproto::Pixmap>) -> Result<Cookie<()>> {
        let request = types::shape::MaskRequest {
            operation,
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
            source_bitmap: Into::<u32>::into(source_bitmap.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_combine(&mut self, operation: types::SO, destination_kind: types::SK, source_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16, source_window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::shape::CombineRequest {
            operation,
            destination_kind,
            source_kind,
            destination_window,
            x_offset,
            y_offset,
            source_window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_offset(&mut self, destination_kind: types::SK, destination_window: types::xproto::Window, x_offset: types::Int16, y_offset: types::Int16) -> Result<Cookie<()>> {
        let request = types::shape::OffsetRequest {
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_query_extents(&mut self, destination_window: types::xproto::Window) -> Result<Cookie<types::shape::QueryExtentsReply>> {
        let request = types::shape::QueryExtentsRequest {
            destination_window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_select_input(&mut self, destination_window: types::xproto::Window, enable: types::Bool) -> Result<Cookie<()>> {
        let request = types::shape::SelectInputRequest {
            destination_window,
            enable,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_input_selected(&mut self, destination_window: types::xproto::Window) -> Result<Cookie<types::shape::InputSelectedReply>> {
        let request = types::shape::InputSelectedRequest {
            destination_window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_get_rectangles(&mut self, window: types::xproto::Window, source_kind: types::SK) -> Result<Cookie<types::shape::GetRectanglesReply>> {
        let request = types::shape::GetRectanglesRequest {
            window,
            source_kind,
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "shm")]
    fn shm_query_version(&mut self, ) -> Result<Cookie<types::shm::QueryVersionReply>> {
        let request = types::shm::QueryVersionRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_attach(&mut self, shmseg: types::Seg, shmid: types::Card32, read_only: types::Bool) -> Result<Cookie<()>> {
        let request = types::shm::AttachRequest {
            shmseg,
            shmid,
            read_only,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_detach(&mut self, shmseg: types::Seg) -> Result<Cookie<()>> {
        let request = types::shm::DetachRequest {
            shmseg,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_put_image(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, total_width: types::Card16, total_height: types::Card16, src_x: types::Card16, src_y: types::Card16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, depth: types::Card8, format: types::Card8, send_event: types::Bool, shmseg: types::Seg, offset: types::Card32) -> Result<Cookie<()>> {
        let request = types::shm::PutImageRequest {
            drawable,
            gc,
            total_width,
            total_height,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            depth,
            format,
            send_event,
            shmseg,
            offset,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_get_image(&mut self, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32, format: types::Card8, shmseg: types::Seg, offset: types::Card32) -> Result<Cookie<types::shm::GetImageReply>> {
        let request = types::shm::GetImageRequest {
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
            format,
            shmseg,
            offset,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_create_pixmap(&mut self, pid: types::xproto::Pixmap, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16, depth: types::Card8, shmseg: types::Seg, offset: types::Card32) -> Result<Cookie<()>> {
        let request = types::shm::CreatePixmapRequest {
            pid,
            drawable,
            width,
            height,
            depth,
            shmseg,
            offset,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_attach_fd(&mut self, shmseg: types::Seg, shm_fd: types::Fd, read_only: types::Bool) -> Result<Cookie<()>> {
        let request = types::shm::AttachFdRequest {
            shmseg,
            shm_fd,
            read_only,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_create_segment(&mut self, shmseg: types::Seg, size: types::Card32, read_only: types::Bool) -> Result<Cookie<types::shm::CreateSegmentReply>> {
        let request = types::shm::CreateSegmentRequest {
            shmseg,
            size,
            read_only,
        };
        self.send_reply_fd_request(request)
    }
    
    #[cfg(feature = "sync")]
    fn sync_initialize(&mut self, desired_major_version: types::Card8, desired_minor_version: types::Card8) -> Result<Cookie<types::sync::InitializeReply>> {
        let request = types::sync::InitializeRequest {
            desired_major_version,
            desired_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_list_system_counters(&mut self, ) -> Result<Cookie<types::sync::ListSystemCountersReply>> {
        let request = types::sync::ListSystemCountersRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_create_counter(&mut self, id: types::Counter, initial_value: types::sync::Int64) -> Result<Cookie<()>> {
        let request = types::sync::CreateCounterRequest {
            id,
            initial_value,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_counter(&mut self, counter: types::Counter) -> Result<Cookie<()>> {
        let request = types::sync::DestroyCounterRequest {
            counter,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_query_counter(&mut self, counter: types::Counter) -> Result<Cookie<types::sync::QueryCounterReply>> {
        let request = types::sync::QueryCounterRequest {
            counter,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_await(&mut self, wait_list: impl AsRef<[types::Waitcondition]>) -> Result<Cookie<()>> {
        let request = types::sync::AwaitRequest {
            wait_list: Cow::Borrowed(wait_list.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_change_counter(&mut self, counter: types::Counter, amount: types::sync::Int64) -> Result<Cookie<()>> {
        let request = types::sync::ChangeCounterRequest {
            counter,
            amount,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_set_counter(&mut self, counter: types::Counter, value: types::sync::Int64) -> Result<Cookie<()>> {
        let request = types::sync::SetCounterRequest {
            counter,
            value,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_create_alarm(&mut self, id: types::Alarm, value_list: impl Borrow<types::sync::CreateAlarmAux>) -> Result<Cookie<()>> {
        let request = types::sync::CreateAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_change_alarm(&mut self, id: types::Alarm, value_list: impl Borrow<types::sync::ChangeAlarmAux>) -> Result<Cookie<()>> {
        let request = types::sync::ChangeAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_alarm(&mut self, alarm: types::Alarm) -> Result<Cookie<()>> {
        let request = types::sync::DestroyAlarmRequest {
            alarm,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_query_alarm(&mut self, alarm: types::Alarm) -> Result<Cookie<types::sync::QueryAlarmReply>> {
        let request = types::sync::QueryAlarmRequest {
            alarm,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_set_priority(&mut self, id: types::Card32, priority: types::Int32) -> Result<Cookie<()>> {
        let request = types::sync::SetPriorityRequest {
            id,
            priority,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_get_priority(&mut self, id: types::Card32) -> Result<Cookie<types::sync::GetPriorityReply>> {
        let request = types::sync::GetPriorityRequest {
            id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_create_fence(&mut self, drawable: types::xproto::Drawable, fence: types::Fence, initially_triggered: types::Bool) -> Result<Cookie<()>> {
        let request = types::sync::CreateFenceRequest {
            drawable,
            fence,
            initially_triggered,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_trigger_fence(&mut self, fence: types::Fence) -> Result<Cookie<()>> {
        let request = types::sync::TriggerFenceRequest {
            fence,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_reset_fence(&mut self, fence: types::Fence) -> Result<Cookie<()>> {
        let request = types::sync::ResetFenceRequest {
            fence,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_fence(&mut self, fence: types::Fence) -> Result<Cookie<()>> {
        let request = types::sync::DestroyFenceRequest {
            fence,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_query_fence(&mut self, fence: types::Fence) -> Result<Cookie<types::sync::QueryFenceReply>> {
        let request = types::sync::QueryFenceRequest {
            fence,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_await_fence(&mut self, fence_list: impl AsRef<[types::Fence]>) -> Result<Cookie<()>> {
        let request = types::sync::AwaitFenceRequest {
            fence_list: Cow::Borrowed(fence_list.as_ref()),
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "xc_misc")]
    fn xc_misc_get_version(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::xc_misc::GetVersionReply>> {
        let request = types::xc_misc::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xc_misc")]
    fn xc_misc_get_xid_range(&mut self, ) -> Result<Cookie<types::xc_misc::GetXIDRangeReply>> {
        let request = types::xc_misc::GetXIDRangeRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xc_misc")]
    fn xc_misc_get_xid_list(&mut self, count: types::Card32) -> Result<Cookie<types::xc_misc::GetXIDListReply>> {
        let request = types::xc_misc::GetXIDListRequest {
            count,
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "xevie")]
    fn xevie_query_version(&mut self, client_major_version: types::Card16, client_minor_version: types::Card16) -> Result<Cookie<types::xevie::QueryVersionReply>> {
        let request = types::xevie::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_start(&mut self, screen: types::Card32) -> Result<Cookie<types::xevie::StartReply>> {
        let request = types::xevie::StartRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_end(&mut self, cmap: types::Card32) -> Result<Cookie<types::xevie::EndReply>> {
        let request = types::xevie::EndRequest {
            cmap,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_send(&mut self, event: types::xevie::Event, data_type: types::Card32) -> Result<Cookie<types::xevie::SendReply>> {
        let request = types::xevie::SendRequest {
            event,
            data_type,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_select_input(&mut self, event_mask: types::Card32) -> Result<Cookie<types::xevie::SelectInputReply>> {
        let request = types::xevie::SelectInputRequest {
            event_mask,
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_version(&mut self, ) -> Result<Cookie<types::xf86dri::QueryVersionReply>> {
        let request = types::xf86dri::QueryVersionRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_direct_rendering_capable(&mut self, screen: types::Card32) -> Result<Cookie<types::xf86dri::QueryDirectRenderingCapableReply>> {
        let request = types::xf86dri::QueryDirectRenderingCapableRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_open_connection(&mut self, screen: types::Card32) -> Result<Cookie<types::xf86dri::OpenConnectionReply>> {
        let request = types::xf86dri::OpenConnectionRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_close_connection(&mut self, screen: types::Card32) -> Result<Cookie<()>> {
        let request = types::xf86dri::CloseConnectionRequest {
            screen,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_client_driver_name(&mut self, screen: types::Card32) -> Result<Cookie<types::xf86dri::GetClientDriverNameReply>> {
        let request = types::xf86dri::GetClientDriverNameRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_context(&mut self, screen: types::Card32, visual: types::Card32, context: types::Card32) -> Result<Cookie<types::xf86dri::CreateContextReply>> {
        let request = types::xf86dri::CreateContextRequest {
            screen,
            visual,
            context,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_context(&mut self, screen: types::Card32, context: types::Card32) -> Result<Cookie<()>> {
        let request = types::xf86dri::DestroyContextRequest {
            screen,
            context,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_drawable(&mut self, screen: types::Card32, drawable: types::Card32) -> Result<Cookie<types::xf86dri::CreateDrawableReply>> {
        let request = types::xf86dri::CreateDrawableRequest {
            screen,
            drawable,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_drawable(&mut self, screen: types::Card32, drawable: types::Card32) -> Result<Cookie<()>> {
        let request = types::xf86dri::DestroyDrawableRequest {
            screen,
            drawable,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_drawable_info(&mut self, screen: types::Card32, drawable: types::Card32) -> Result<Cookie<types::xf86dri::GetDrawableInfoReply>> {
        let request = types::xf86dri::GetDrawableInfoRequest {
            screen,
            drawable,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_device_info(&mut self, screen: types::Card32) -> Result<Cookie<types::xf86dri::GetDeviceInfoReply>> {
        let request = types::xf86dri::GetDeviceInfoRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_auth_connection(&mut self, screen: types::Card32, magic: types::Card32) -> Result<Cookie<types::xf86dri::AuthConnectionReply>> {
        let request = types::xf86dri::AuthConnectionRequest {
            screen,
            magic,
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_query_version(&mut self, ) -> Result<Cookie<types::xf86vidmode::QueryVersionReply>> {
        let request = types::xf86vidmode::QueryVersionRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_mode_line(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetModeLineReply>> {
        let request = types::xf86vidmode::GetModeLineRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_mod_mode_line(&mut self, screen: types::Card32, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let request = types::xf86vidmode::ModModeLineRequest {
            screen,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_mode(&mut self, screen: types::Card16, zoom: types::Card16) -> Result<Cookie<()>> {
        let request = types::xf86vidmode::SwitchModeRequest {
            screen,
            zoom,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_monitor(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetMonitorReply>> {
        let request = types::xf86vidmode::GetMonitorRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_lock_mode_switch(&mut self, screen: types::Card16, lock: types::Card16) -> Result<Cookie<()>> {
        let request = types::xf86vidmode::LockModeSwitchRequest {
            screen,
            lock,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_all_mode_lines(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetAllModeLinesReply>> {
        let request = types::xf86vidmode::GetAllModeLinesRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_add_mode_line(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, after_dotclock: types::Dotclock, after_hdisplay: types::Card16, after_hsyncstart: types::Card16, after_hsyncend: types::Card16, after_htotal: types::Card16, after_hskew: types::Card16, after_vdisplay: types::Card16, after_vsyncstart: types::Card16, after_vsyncend: types::Card16, after_vtotal: types::Card16, after_flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let request = types::xf86vidmode::AddModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            after_dotclock,
            after_hdisplay,
            after_hsyncstart,
            after_hsyncend,
            after_htotal,
            after_hskew,
            after_vdisplay,
            after_vsyncstart,
            after_vsyncend,
            after_vtotal,
            after_flags: Into::<u32>::into(after_flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_delete_mode_line(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let request = types::xf86vidmode::DeleteModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_validate_mode_line(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<Cookie<types::xf86vidmode::ValidateModeLineReply>> {
        let request = types::xf86vidmode::ValidateModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_to_mode(&mut self, screen: types::Card32, dotclock: types::Dotclock, hdisplay: types::Card16, hsyncstart: types::Card16, hsyncend: types::Card16, htotal: types::Card16, hskew: types::Card16, vdisplay: types::Card16, vsyncstart: types::Card16, vsyncend: types::Card16, vtotal: types::Card16, flags: impl Into<types::xf86vidmode::ModeFlag>, private: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let request = types::xf86vidmode::SwitchToModeRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_view_port(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetViewPortReply>> {
        let request = types::xf86vidmode::GetViewPortRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_view_port(&mut self, screen: types::Card16, x: types::Card32, y: types::Card32) -> Result<Cookie<()>> {
        let request = types::xf86vidmode::SetViewPortRequest {
            screen,
            x,
            y,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_dot_clocks(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetDotClocksReply>> {
        let request = types::xf86vidmode::GetDotClocksRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_client_version(&mut self, major: types::Card16, minor: types::Card16) -> Result<Cookie<()>> {
        let request = types::xf86vidmode::SetClientVersionRequest {
            major,
            minor,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma(&mut self, screen: types::Card16, red: types::Card32, green: types::Card32, blue: types::Card32) -> Result<Cookie<()>> {
        let request = types::xf86vidmode::SetGammaRequest {
            screen,
            red,
            green,
            blue,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetGammaReply>> {
        let request = types::xf86vidmode::GetGammaRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp(&mut self, screen: types::Card16, size: types::Card16) -> Result<Cookie<types::xf86vidmode::GetGammaRampReply>> {
        let request = types::xf86vidmode::GetGammaRampRequest {
            screen,
            size,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_ramp(&mut self, screen: types::Card16, size: types::Card16, red: impl AsRef<[types::Card16]>, green: impl AsRef<[types::Card16]>, blue: impl AsRef<[types::Card16]>) -> Result<Cookie<()>> {
        let request = types::xf86vidmode::SetGammaRampRequest {
            screen,
            size,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_size(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetGammaRampSizeReply>> {
        let request = types::xf86vidmode::GetGammaRampSizeRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_permissions(&mut self, screen: types::Card16) -> Result<Cookie<types::xf86vidmode::GetPermissionsReply>> {
        let request = types::xf86vidmode::GetPermissionsRequest {
            screen,
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "xfixes")]
    fn xfixes_query_version(&mut self, client_major_version: types::Card32, client_minor_version: types::Card32) -> Result<Cookie<types::xfixes::QueryVersionReply>> {
        let request = types::xfixes::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_save_set(&mut self, mode: types::SaveSetMode, target: types::SaveSetTarget, map: types::SaveSetMapping, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xfixes::ChangeSaveSetRequest {
            mode,
            target,
            map,
            window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_selection_input(&mut self, window: types::xproto::Window, selection: types::Atom, event_mask: impl Into<types::SelectionEventMask>) -> Result<Cookie<()>> {
        let request = types::xfixes::SelectSelectionInputRequest {
            window,
            selection,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_cursor_input(&mut self, window: types::xproto::Window, event_mask: impl Into<types::CursorNotifyMask>) -> Result<Cookie<()>> {
        let request = types::xfixes::SelectCursorInputRequest {
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image(&mut self, ) -> Result<Cookie<types::xfixes::GetCursorImageReply>> {
        let request = types::xfixes::GetCursorImageRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region(&mut self, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let request = types::xfixes::CreateRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_bitmap(&mut self, region: types::Region, bitmap: types::xproto::Pixmap) -> Result<Cookie<()>> {
        let request = types::xfixes::CreateRegionFromBitmapRequest {
            region,
            bitmap,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_window(&mut self, region: types::Region, window: types::xproto::Window, kind: types::SK) -> Result<Cookie<()>> {
        let request = types::xfixes::CreateRegionFromWindowRequest {
            region,
            window,
            kind,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_gc(&mut self, region: types::Region, gc: types::Gcontext) -> Result<Cookie<()>> {
        let request = types::xfixes::CreateRegionFromGCRequest {
            region,
            gc,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_picture(&mut self, region: types::Region, picture: types::Picture) -> Result<Cookie<()>> {
        let request = types::xfixes::CreateRegionFromPictureRequest {
            region,
            picture,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_destroy_region(&mut self, region: types::Region) -> Result<Cookie<()>> {
        let request = types::xfixes::DestroyRegionRequest {
            region,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_region(&mut self, region: types::Region, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let request = types::xfixes::SetRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_copy_region(&mut self, source: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let request = types::xfixes::CopyRegionRequest {
            source,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_union_region(&mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let request = types::xfixes::UnionRegionRequest {
            source1,
            source2,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_intersect_region(&mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let request = types::xfixes::IntersectRegionRequest {
            source1,
            source2,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_subtract_region(&mut self, source1: types::Region, source2: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let request = types::xfixes::SubtractRegionRequest {
            source1,
            source2,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_invert_region(&mut self, source: types::Region, bounds: types::Rectangle, destination: types::Region) -> Result<Cookie<()>> {
        let request = types::xfixes::InvertRegionRequest {
            source,
            bounds,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_translate_region(&mut self, region: types::Region, dx: types::Int16, dy: types::Int16) -> Result<Cookie<()>> {
        let request = types::xfixes::TranslateRegionRequest {
            region,
            dx,
            dy,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_region_extents(&mut self, source: types::Region, destination: types::Region) -> Result<Cookie<()>> {
        let request = types::xfixes::RegionExtentsRequest {
            source,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_fetch_region(&mut self, region: types::Region) -> Result<Cookie<types::xfixes::FetchRegionReply>> {
        let request = types::xfixes::FetchRegionRequest {
            region,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_gc_clip_region(&mut self, gc: types::Gcontext, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> Result<Cookie<()>> {
        let request = types::xfixes::SetGCClipRegionRequest {
            gc,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_window_shape_region(&mut self, dest: types::xproto::Window, dest_kind: types::SK, x_offset: types::Int16, y_offset: types::Int16, region: impl Into<types::Region>) -> Result<Cookie<()>> {
        let request = types::xfixes::SetWindowShapeRegionRequest {
            dest,
            dest_kind,
            x_offset,
            y_offset,
            region: Into::<u32>::into(region.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_picture_clip_region(&mut self, picture: types::Picture, region: impl Into<types::Region>, x_origin: types::Int16, y_origin: types::Int16) -> Result<Cookie<()>> {
        let request = types::xfixes::SetPictureClipRegionRequest {
            picture,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_cursor_name(&mut self, cursor: types::xproto::Cursor, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xfixes::SetCursorNameRequest {
            cursor,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_name(&mut self, cursor: types::xproto::Cursor) -> Result<Cookie<types::xfixes::GetCursorNameReply>> {
        let request = types::xfixes::GetCursorNameRequest {
            cursor,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_and_name(&mut self, ) -> Result<Cookie<types::xfixes::GetCursorImageAndNameReply>> {
        let request = types::xfixes::GetCursorImageAndNameRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor(&mut self, source: types::xproto::Cursor, destination: types::xproto::Cursor) -> Result<Cookie<()>> {
        let request = types::xfixes::ChangeCursorRequest {
            source,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_by_name(&mut self, src: types::xproto::Cursor, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xfixes::ChangeCursorByNameRequest {
            src,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_expand_region(&mut self, source: types::Region, destination: types::Region, left: types::Card16, right: types::Card16, top: types::Card16, bottom: types::Card16) -> Result<Cookie<()>> {
        let request = types::xfixes::ExpandRegionRequest {
            source,
            destination,
            left,
            right,
            top,
            bottom,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_hide_cursor(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xfixes::HideCursorRequest {
            window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_show_cursor(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xfixes::ShowCursorRequest {
            window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_pointer_barrier(&mut self, barrier: types::Barrier, window: types::xproto::Window, x1: types::Card16, y1: types::Card16, x2: types::Card16, y2: types::Card16, directions: impl Into<types::BarrierDirections>, devices: impl AsRef<[types::Card16]>) -> Result<Cookie<()>> {
        let request = types::xfixes::CreatePointerBarrierRequest {
            barrier,
            window,
            x1,
            y1,
            x2,
            y2,
            directions: Into::<u32>::into(directions.into()) as _,
            devices: Cow::Borrowed(devices.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_delete_pointer_barrier(&mut self, barrier: types::Barrier) -> Result<Cookie<()>> {
        let request = types::xfixes::DeletePointerBarrierRequest {
            barrier,
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "xinerama")]
    fn xinerama_query_version(&mut self, major: types::Card8, minor: types::Card8) -> Result<Cookie<types::xinerama::QueryVersionReply>> {
        let request = types::xinerama::QueryVersionRequest {
            major,
            minor,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_state(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinerama::GetStateReply>> {
        let request = types::xinerama::GetStateRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_count(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinerama::GetScreenCountReply>> {
        let request = types::xinerama::GetScreenCountRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_size(&mut self, window: types::xproto::Window, screen: types::Card32) -> Result<Cookie<types::xinerama::GetScreenSizeReply>> {
        let request = types::xinerama::GetScreenSizeRequest {
            window,
            screen,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_is_active(&mut self, ) -> Result<Cookie<types::xinerama::IsActiveReply>> {
        let request = types::xinerama::IsActiveRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_screens(&mut self, ) -> Result<Cookie<types::xinerama::QueryScreensReply>> {
        let request = types::xinerama::QueryScreensRequest {
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "xinput")]
    fn xinput_get_extension_version(&mut self, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::xinput::GetExtensionVersionReply>> {
        let request = types::xinput::GetExtensionVersionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_input_devices(&mut self, ) -> Result<Cookie<types::xinput::ListInputDevicesReply>> {
        let request = types::xinput::ListInputDevicesRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_open_device(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::OpenDeviceReply>> {
        let request = types::xinput::OpenDeviceRequest {
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_close_device(&mut self, device_id: types::Card8) -> Result<Cookie<()>> {
        let request = types::xinput::CloseDeviceRequest {
            device_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_mode(&mut self, device_id: types::Card8, mode: types::ValuatorMode) -> Result<Cookie<types::xinput::SetDeviceModeReply>> {
        let request = types::xinput::SetDeviceModeRequest {
            device_id,
            mode,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_select_extension_event(&mut self, window: types::xproto::Window, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let request = types::xinput::SelectExtensionEventRequest {
            window,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_selected_extension_events(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinput::GetSelectedExtensionEventsReply>> {
        let request = types::xinput::GetSelectedExtensionEventsRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_dont_propagate_list(&mut self, window: types::xproto::Window, mode: types::PropagateMode, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let request = types::xinput::ChangeDeviceDontPropagateListRequest {
            window,
            mode,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_dont_propagate_list(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinput::GetDeviceDontPropagateListReply>> {
        let request = types::xinput::GetDeviceDontPropagateListRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_motion_events(&mut self, start: types::Timestamp, stop: impl Into<types::Time>, device_id: types::Card8) -> Result<Cookie<types::xinput::GetDeviceMotionEventsReply>> {
        let request = types::xinput::GetDeviceMotionEventsRequest {
            start,
            stop: Into::<u32>::into(stop.into()) as _,
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_keyboard_device(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::ChangeKeyboardDeviceReply>> {
        let request = types::xinput::ChangeKeyboardDeviceRequest {
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_pointer_device(&mut self, x_axis: types::Card8, y_axis: types::Card8, device_id: types::Card8) -> Result<Cookie<types::xinput::ChangePointerDeviceReply>> {
        let request = types::xinput::ChangePointerDeviceRequest {
            x_axis,
            y_axis,
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device(&mut self, grab_window: types::xproto::Window, time: impl Into<types::Time>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, device_id: types::Card8, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<types::xinput::GrabDeviceReply>> {
        let request = types::xinput::GrabDeviceRequest {
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            device_id,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device(&mut self, time: impl Into<types::Time>, device_id: types::Card8) -> Result<Cookie<()>> {
        let request = types::xinput::UngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            device_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_key(&mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, grabbed_device: types::Card8, key: impl Into<types::Grab>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let request = types::xinput::GrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            grabbed_device,
            key: Into::<u32>::into(key.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_key(&mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, key: impl Into<types::Grab>, grabbed_device: types::Card8) -> Result<Cookie<()>> {
        let request = types::xinput::UngrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            grabbed_device,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_button(&mut self, grab_window: types::xproto::Window, grabbed_device: types::Card8, modifier_device: impl Into<types::ModifierDevice>, modifiers: impl Into<types::ModMask>, this_device_mode: types::GrabMode, other_device_mode: types::GrabMode, button: impl Into<types::Grab>, owner_events: types::Bool, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let request = types::xinput::GrabDeviceButtonRequest {
            grab_window,
            grabbed_device,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            this_device_mode,
            other_device_mode,
            button: Into::<u32>::into(button.into()) as _,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_button(&mut self, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, modifier_device: impl Into<types::ModifierDevice>, button: impl Into<types::Grab>, grabbed_device: types::Card8) -> Result<Cookie<()>> {
        let request = types::xinput::UngrabDeviceButtonRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            button: Into::<u32>::into(button.into()) as _,
            grabbed_device,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_allow_device_events(&mut self, time: impl Into<types::Time>, mode: types::DeviceInputMode, device_id: types::Card8) -> Result<Cookie<()>> {
        let request = types::xinput::AllowDeviceEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            mode,
            device_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_focus(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::GetDeviceFocusReply>> {
        let request = types::xinput::GetDeviceFocusRequest {
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_focus(&mut self, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>, revert_to: types::InputFocus, device_id: types::Card8) -> Result<Cookie<()>> {
        let request = types::xinput::SetDeviceFocusRequest {
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            revert_to,
            device_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_feedback_control(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::GetFeedbackControlReply>> {
        let request = types::xinput::GetFeedbackControlRequest {
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_feedback_control(&mut self, mask: impl Into<types::ChangeFeedbackControlMask>, device_id: types::Card8, feedback_id: types::Card8, feedback: types::FeedbackCtl) -> Result<Cookie<()>> {
        let request = types::xinput::ChangeFeedbackControlRequest {
            mask: Into::<u32>::into(mask.into()) as _,
            device_id,
            feedback_id,
            feedback,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_key_mapping(&mut self, device_id: types::Card8, first_keycode: types::KeyCode, count: types::Card8) -> Result<Cookie<types::xinput::GetDeviceKeyMappingReply>> {
        let request = types::xinput::GetDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            count,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_key_mapping(&mut self, device_id: types::Card8, first_keycode: types::KeyCode, keysyms_per_keycode: types::Card8, keycode_count: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> Result<Cookie<()>> {
        let request = types::xinput::ChangeDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            keysyms_per_keycode,
            keycode_count,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_modifier_mapping(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::GetDeviceModifierMappingReply>> {
        let request = types::xinput::GetDeviceModifierMappingRequest {
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_modifier_mapping(&mut self, device_id: types::Card8, keymaps: impl AsRef<[types::Card8]>) -> Result<Cookie<types::xinput::SetDeviceModifierMappingReply>> {
        let request = types::xinput::SetDeviceModifierMappingRequest {
            device_id,
            keymaps: Cow::Borrowed(keymaps.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_button_mapping(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::GetDeviceButtonMappingReply>> {
        let request = types::xinput::GetDeviceButtonMappingRequest {
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_button_mapping(&mut self, device_id: types::Card8, map: impl AsRef<[types::Card8]>) -> Result<Cookie<types::xinput::SetDeviceButtonMappingReply>> {
        let request = types::xinput::SetDeviceButtonMappingRequest {
            device_id,
            map: Cow::Borrowed(map.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_query_device_state(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::QueryDeviceStateReply>> {
        let request = types::xinput::QueryDeviceStateRequest {
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_device_bell(&mut self, device_id: types::Card8, feedback_id: types::Card8, feedback_class: types::Card8, percent: types::Int8) -> Result<Cookie<()>> {
        let request = types::xinput::DeviceBellRequest {
            device_id,
            feedback_id,
            feedback_class,
            percent,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_valuators(&mut self, device_id: types::Card8, first_valuator: types::Card8, valuators: impl AsRef<[types::Int32]>) -> Result<Cookie<types::xinput::SetDeviceValuatorsReply>> {
        let request = types::xinput::SetDeviceValuatorsRequest {
            device_id,
            first_valuator,
            valuators: Cow::Borrowed(valuators.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_control(&mut self, control_id: types::DeviceControl, device_id: types::Card8) -> Result<Cookie<types::xinput::GetDeviceControlReply>> {
        let request = types::xinput::GetDeviceControlRequest {
            control_id,
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_control(&mut self, control_id: types::DeviceControl, device_id: types::Card8, control: types::DeviceCtl) -> Result<Cookie<types::xinput::ChangeDeviceControlReply>> {
        let request = types::xinput::ChangeDeviceControlRequest {
            control_id,
            device_id,
            control,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_device_properties(&mut self, device_id: types::Card8) -> Result<Cookie<types::xinput::ListDevicePropertiesReply>> {
        let request = types::xinput::ListDevicePropertiesRequest {
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_property(&mut self, property: types::Atom, type_: types::Atom, device_id: types::Card8, mode: types::PropMode, num_items: types::Card32, items: impl Borrow<types::xinput::ChangeDevicePropertyAux>) -> Result<Cookie<()>> {
        let request = types::xinput::ChangeDevicePropertyRequest {
            property,
            type_,
            device_id,
            mode,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_delete_device_property(&mut self, property: types::Atom, device_id: types::Card8) -> Result<Cookie<()>> {
        let request = types::xinput::DeleteDevicePropertyRequest {
            property,
            device_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_property(&mut self, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32, device_id: types::Card8, delete: types::Bool) -> Result<Cookie<types::xinput::GetDevicePropertyReply>> {
        let request = types::xinput::GetDevicePropertyRequest {
            property,
            type_,
            offset,
            len,
            device_id,
            delete,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_pointer(&mut self, window: types::xproto::Window, deviceid: impl Into<types::Device>) -> Result<Cookie<types::xinput::XIQueryPointerReply>> {
        let request = types::xinput::XIQueryPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_warp_pointer(&mut self, src_win: types::xproto::Window, dst_win: types::xproto::Window, src_x: types::Fp1616, src_y: types::Fp1616, src_width: types::Card16, src_height: types::Card16, dst_x: types::Fp1616, dst_y: types::Fp1616, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let request = types::xinput::XIWarpPointerRequest {
            src_win,
            dst_win,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_cursor(&mut self, window: types::xproto::Window, cursor: types::xproto::Cursor, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let request = types::xinput::XIChangeCursorRequest {
            window,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_hierarchy(&mut self, changes: impl AsRef<[types::HierarchyChange]>) -> Result<Cookie<()>> {
        let request = types::xinput::XIChangeHierarchyRequest {
            changes: Cow::Borrowed(changes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_client_pointer(&mut self, window: types::xproto::Window, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let request = types::xinput::XISetClientPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_client_pointer(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinput::XIGetClientPointerReply>> {
        let request = types::xinput::XIGetClientPointerRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_select_events(&mut self, window: types::xproto::Window, masks: impl AsRef<[types::xinput::EventMask]>) -> Result<Cookie<()>> {
        let request = types::xinput::XISelectEventsRequest {
            window,
            masks: Cow::Borrowed(masks.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_version(&mut self, major_version: types::Card16, minor_version: types::Card16) -> Result<Cookie<types::xinput::XIQueryVersionReply>> {
        let request = types::xinput::XIQueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_device(&mut self, deviceid: impl Into<types::Device>) -> Result<Cookie<types::xinput::XIQueryDeviceReply>> {
        let request = types::xinput::XIQueryDeviceRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_focus(&mut self, window: types::xproto::Window, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let request = types::xinput::XISetFocusRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_focus(&mut self, deviceid: impl Into<types::Device>) -> Result<Cookie<types::xinput::XIGetFocusReply>> {
        let request = types::xinput::XIGetFocusRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_grab_device(&mut self, window: types::xproto::Window, time: impl Into<types::Time>, cursor: types::xproto::Cursor, deviceid: impl Into<types::Device>, mode: types::GrabMode, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask: impl AsRef<[types::Card32]>) -> Result<Cookie<types::xinput::XIGrabDeviceReply>> {
        let request = types::xinput::XIGrabDeviceRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_ungrab_device(&mut self, time: impl Into<types::Time>, deviceid: impl Into<types::Device>) -> Result<Cookie<()>> {
        let request = types::xinput::XIUngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_allow_events(&mut self, time: impl Into<types::Time>, deviceid: impl Into<types::Device>, event_mode: types::EventMode, touchid: types::Card32, grab_window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xinput::XIAllowEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            event_mode,
            touchid,
            grab_window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_grab_device(&mut self, time: impl Into<types::Time>, grab_window: types::xproto::Window, cursor: types::xproto::Cursor, detail: types::Card32, deviceid: impl Into<types::Device>, grab_type: types::GrabType, grab_mode: types::GrabMode22, paired_device_mode: types::GrabMode, owner_events: types::GrabOwner, mask: impl AsRef<[types::Card32]>, modifiers: impl AsRef<[types::Card32]>) -> Result<Cookie<types::xinput::XIPassiveGrabDeviceReply>> {
        let request = types::xinput::XIPassiveGrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            grab_window,
            cursor,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            grab_mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_ungrab_device(&mut self, grab_window: types::xproto::Window, detail: types::Card32, deviceid: impl Into<types::Device>, grab_type: types::GrabType, modifiers: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let request = types::xinput::XIPassiveUngrabDeviceRequest {
            grab_window,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_list_properties(&mut self, deviceid: impl Into<types::Device>) -> Result<Cookie<types::xinput::XIListPropertiesReply>> {
        let request = types::xinput::XIListPropertiesRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_property(&mut self, deviceid: impl Into<types::Device>, mode: types::PropMode, property: types::Atom, type_: types::Atom, num_items: types::Card32, items: impl Borrow<types::xinput::XIChangePropertyAux>) -> Result<Cookie<()>> {
        let request = types::xinput::XIChangePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            property,
            type_,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_delete_property(&mut self, deviceid: impl Into<types::Device>, property: types::Atom) -> Result<Cookie<()>> {
        let request = types::xinput::XIDeletePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            property,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_property(&mut self, deviceid: impl Into<types::Device>, delete: types::Bool, property: types::Atom, type_: types::Atom, offset: types::Card32, len: types::Card32) -> Result<Cookie<types::xinput::XIGetPropertyReply>> {
        let request = types::xinput::XIGetPropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            delete,
            property,
            type_,
            offset,
            len,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_selected_events(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xinput::XIGetSelectedEventsReply>> {
        let request = types::xinput::XIGetSelectedEventsRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_barrier_release_pointer(&mut self, barriers: impl AsRef<[types::BarrierReleasePointerInfo]>) -> Result<Cookie<()>> {
        let request = types::xinput::XIBarrierReleasePointerRequest {
            barriers: Cow::Borrowed(barriers.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_send_extension_event(&mut self, destination: types::xproto::Window, device_id: types::Card8, propagate: types::Bool, events: impl AsRef<[types::EventForSend]>, classes: impl AsRef<[types::EventClass]>) -> Result<Cookie<()>> {
        let request = types::xinput::SendExtensionEventRequest {
            destination,
            device_id,
            propagate,
            events: Cow::Borrowed(events.as_ref()),
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "xkb")]
    fn xkb_use_extension(&mut self, wanted_major: types::Card16, wanted_minor: types::Card16) -> Result<Cookie<types::xkb::UseExtensionReply>> {
        let request = types::xkb::UseExtensionRequest {
            wanted_major,
            wanted_minor,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_select_events(&mut self, device_spec: types::DeviceSpec, clear: impl Into<types::xkb::EventType>, select_all: impl Into<types::xkb::EventType>, affect_map: impl Into<types::MapPart>, map: impl Into<types::MapPart>, details: impl Borrow<types::xkb::SelectEventsAux>) -> Result<Cookie<()>> {
        let request = types::xkb::SelectEventsRequest {
            device_spec,
            clear: Into::<u32>::into(clear.into()) as _,
            select_all: Into::<u32>::into(select_all.into()) as _,
            affect_map: Into::<u32>::into(affect_map.into()) as _,
            map: Into::<u32>::into(map.into()) as _,
            details: Cow::Borrowed(details.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_bell(&mut self, device_spec: types::DeviceSpec, bell_class: types::BellClassSpec, bell_id: types::IDSpec, percent: types::Int8, force_sound: types::Bool, event_only: types::Bool, pitch: types::Int16, duration: types::Int16, name: types::Atom, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xkb::BellRequest {
            device_spec,
            bell_class,
            bell_id,
            percent,
            force_sound,
            event_only,
            pitch,
            duration,
            name,
            window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_state(&mut self, device_spec: types::DeviceSpec) -> Result<Cookie<types::xkb::GetStateReply>> {
        let request = types::xkb::GetStateRequest {
            device_spec,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_latch_lock_state(&mut self, device_spec: types::DeviceSpec, affect_mod_locks: impl Into<types::ModMask>, mod_locks: impl Into<types::ModMask>, lock_group: types::Bool, group_lock: types::Group, affect_mod_latches: impl Into<types::ModMask>, latch_group: types::Bool, group_latch: types::Card16) -> Result<Cookie<()>> {
        let request = types::xkb::LatchLockStateRequest {
            device_spec,
            affect_mod_locks: Into::<u32>::into(affect_mod_locks.into()) as _,
            mod_locks: Into::<u32>::into(mod_locks.into()) as _,
            lock_group,
            group_lock,
            affect_mod_latches: Into::<u32>::into(affect_mod_latches.into()) as _,
            latch_group,
            group_latch,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_controls(&mut self, device_spec: types::DeviceSpec) -> Result<Cookie<types::xkb::GetControlsReply>> {
        let request = types::xkb::GetControlsRequest {
            device_spec,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_controls(&mut self, device_spec: types::DeviceSpec, affect_internal_real_mods: impl Into<types::ModMask>, internal_real_mods: impl Into<types::ModMask>, affect_ignore_lock_real_mods: impl Into<types::ModMask>, ignore_lock_real_mods: impl Into<types::ModMask>, affect_internal_virtual_mods: impl Into<types::VMod>, internal_virtual_mods: impl Into<types::VMod>, affect_ignore_lock_virtual_mods: impl Into<types::VMod>, ignore_lock_virtual_mods: impl Into<types::VMod>, mouse_keys_dflt_btn: types::Card8, groups_wrap: types::Card8, access_x_options: impl Into<types::AXOption>, affect_enabled_controls: impl Into<types::BoolCtrl>, enabled_controls: impl Into<types::BoolCtrl>, change_controls: impl Into<types::Control>, repeat_delay: types::Card16, repeat_interval: types::Card16, slow_keys_delay: types::Card16, debounce_delay: types::Card16, mouse_keys_delay: types::Card16, mouse_keys_interval: types::Card16, mouse_keys_time_to_max: types::Card16, mouse_keys_max_speed: types::Card16, mouse_keys_curve: types::Int16, access_x_timeout: types::Card16, access_x_timeout_mask: impl Into<types::BoolCtrl>, access_x_timeout_values: impl Into<types::BoolCtrl>, access_x_timeout_options_mask: impl Into<types::AXOption>, access_x_timeout_options_values: impl Into<types::AXOption>, per_key_repeat: impl Borrow<[types::Card8; 32]>) -> Result<Cookie<()>> {
        let request = types::xkb::SetControlsRequest {
            device_spec,
            affect_internal_real_mods: Into::<u32>::into(affect_internal_real_mods.into()) as _,
            internal_real_mods: Into::<u32>::into(internal_real_mods.into()) as _,
            affect_ignore_lock_real_mods: Into::<u32>::into(affect_ignore_lock_real_mods.into()) as _,
            ignore_lock_real_mods: Into::<u32>::into(ignore_lock_real_mods.into()) as _,
            affect_internal_virtual_mods: Into::<u32>::into(affect_internal_virtual_mods.into()) as _,
            internal_virtual_mods: Into::<u32>::into(internal_virtual_mods.into()) as _,
            affect_ignore_lock_virtual_mods: Into::<u32>::into(affect_ignore_lock_virtual_mods.into()) as _,
            ignore_lock_virtual_mods: Into::<u32>::into(ignore_lock_virtual_mods.into()) as _,
            mouse_keys_dflt_btn,
            groups_wrap,
            access_x_options: Into::<u32>::into(access_x_options.into()) as _,
            affect_enabled_controls: Into::<u32>::into(affect_enabled_controls.into()) as _,
            enabled_controls: Into::<u32>::into(enabled_controls.into()) as _,
            change_controls: Into::<u32>::into(change_controls.into()) as _,
            repeat_delay,
            repeat_interval,
            slow_keys_delay,
            debounce_delay,
            mouse_keys_delay,
            mouse_keys_interval,
            mouse_keys_time_to_max,
            mouse_keys_max_speed,
            mouse_keys_curve,
            access_x_timeout,
            access_x_timeout_mask: Into::<u32>::into(access_x_timeout_mask.into()) as _,
            access_x_timeout_values: Into::<u32>::into(access_x_timeout_values.into()) as _,
            access_x_timeout_options_mask: Into::<u32>::into(access_x_timeout_options_mask.into()) as _,
            access_x_timeout_options_values: Into::<u32>::into(access_x_timeout_options_values.into()) as _,
            per_key_repeat: Cow::Borrowed(per_key_repeat.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_map(&mut self, device_spec: types::DeviceSpec, full: impl Into<types::MapPart>, partial: impl Into<types::MapPart>, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, first_key_action: types::Keycode, n_key_actions: types::Card8, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, virtual_mods: impl Into<types::VMod>, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8) -> Result<Cookie<types::xkb::GetMapReply>> {
        let request = types::xkb::GetMapRequest {
            device_spec,
            full: Into::<u32>::into(full.into()) as _,
            partial: Into::<u32>::into(partial.into()) as _,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            first_key_action,
            n_key_actions,
            first_key_behavior,
            n_key_behaviors,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_key_explicit,
            n_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_map(&mut self, device_spec: types::DeviceSpec, flags: impl Into<types::SetMapFlags>, min_key_code: types::Keycode, max_key_code: types::Keycode, first_type: types::Card8, n_types: types::Card8, first_key_sym: types::Keycode, n_key_syms: types::Card8, total_syms: types::Card16, first_key_action: types::Keycode, n_key_actions: types::Card8, total_actions: types::Card16, first_key_behavior: types::Keycode, n_key_behaviors: types::Card8, total_key_behaviors: types::Card8, first_key_explicit: types::Keycode, n_key_explicit: types::Card8, total_key_explicit: types::Card8, first_mod_map_key: types::Keycode, n_mod_map_keys: types::Card8, total_mod_map_keys: types::Card8, first_v_mod_map_key: types::Keycode, n_v_mod_map_keys: types::Card8, total_v_mod_map_keys: types::Card8, virtual_mods: impl Into<types::VMod>, values: impl Borrow<types::xkb::SetMapAux>) -> Result<Cookie<()>> {
        let request = types::xkb::SetMapRequest {
            device_spec,
            flags: Into::<u32>::into(flags.into()) as _,
            min_key_code,
            max_key_code,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            total_syms,
            first_key_action,
            n_key_actions,
            total_actions,
            first_key_behavior,
            n_key_behaviors,
            total_key_behaviors,
            first_key_explicit,
            n_key_explicit,
            total_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            total_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
            total_v_mod_map_keys,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            values: Cow::Borrowed(values.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_compat_map(&mut self, device_spec: types::DeviceSpec, groups: impl Into<types::SetOfGroup>, get_all_si: types::Bool, first_si: types::Card16, n_si: types::Card16) -> Result<Cookie<types::xkb::GetCompatMapReply>> {
        let request = types::xkb::GetCompatMapRequest {
            device_spec,
            groups: Into::<u32>::into(groups.into()) as _,
            get_all_si,
            first_si,
            n_si,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_compat_map(&mut self, device_spec: types::DeviceSpec, recompute_actions: types::Bool, truncate_si: types::Bool, groups: impl Into<types::SetOfGroup>, first_si: types::Card16, si: impl AsRef<[types::SymInterpret]>, group_maps: impl AsRef<[types::ModDef]>) -> Result<Cookie<()>> {
        let request = types::xkb::SetCompatMapRequest {
            device_spec,
            recompute_actions,
            truncate_si,
            groups: Into::<u32>::into(groups.into()) as _,
            first_si,
            si: Cow::Borrowed(si.as_ref()),
            group_maps: Cow::Borrowed(group_maps.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_state(&mut self, device_spec: types::DeviceSpec) -> Result<Cookie<types::xkb::GetIndicatorStateReply>> {
        let request = types::xkb::GetIndicatorStateRequest {
            device_spec,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_map(&mut self, device_spec: types::DeviceSpec, which: types::Card32) -> Result<Cookie<types::xkb::GetIndicatorMapReply>> {
        let request = types::xkb::GetIndicatorMapRequest {
            device_spec,
            which,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_indicator_map(&mut self, device_spec: types::DeviceSpec, which: types::Card32, maps: impl AsRef<[types::IndicatorMap]>) -> Result<Cookie<()>> {
        let request = types::xkb::SetIndicatorMapRequest {
            device_spec,
            which,
            maps: Cow::Borrowed(maps.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_named_indicator(&mut self, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::ID>, indicator: types::Atom) -> Result<Cookie<types::xkb::GetNamedIndicatorReply>> {
        let request = types::xkb::GetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_named_indicator(&mut self, device_spec: types::DeviceSpec, led_class: types::LedClass, led_id: impl Into<types::ID>, indicator: types::Atom, set_state: types::Bool, on: types::Bool, set_map: types::Bool, create_map: types::Bool, map_flags: impl Into<types::IMFlag>, map_which_groups: impl Into<types::IMGroupsWhich>, map_groups: impl Into<types::SetOfGroups>, map_which_mods: impl Into<types::IMModsWhich>, map_real_mods: impl Into<types::ModMask>, map_vmods: impl Into<types::VMod>, map_ctrls: impl Into<types::BoolCtrl>) -> Result<Cookie<()>> {
        let request = types::xkb::SetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
            set_state,
            on,
            set_map,
            create_map,
            map_flags: Into::<u32>::into(map_flags.into()) as _,
            map_which_groups: Into::<u32>::into(map_which_groups.into()) as _,
            map_groups: Into::<u32>::into(map_groups.into()) as _,
            map_which_mods: Into::<u32>::into(map_which_mods.into()) as _,
            map_real_mods: Into::<u32>::into(map_real_mods.into()) as _,
            map_vmods: Into::<u32>::into(map_vmods.into()) as _,
            map_ctrls: Into::<u32>::into(map_ctrls.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_names(&mut self, device_spec: types::DeviceSpec, which: impl Into<types::NameDetail>) -> Result<Cookie<types::xkb::GetNamesReply>> {
        let request = types::xkb::GetNamesRequest {
            device_spec,
            which: Into::<u32>::into(which.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_names(&mut self, device_spec: types::DeviceSpec, virtual_mods: impl Into<types::VMod>, first_type: types::Card8, n_types: types::Card8, first_kt_levelt: types::Card8, n_kt_levels: types::Card8, indicators: types::Card32, group_names: impl Into<types::SetOfGroup>, n_radio_groups: types::Card8, first_key: types::Keycode, n_keys: types::Card8, n_key_aliases: types::Card8, total_kt_level_names: types::Card16, values: impl Borrow<types::xkb::SetNamesAux>) -> Result<Cookie<()>> {
        let request = types::xkb::SetNamesRequest {
            device_spec,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_type,
            n_types,
            first_kt_levelt,
            n_kt_levels,
            indicators,
            group_names: Into::<u32>::into(group_names.into()) as _,
            n_radio_groups,
            first_key,
            n_keys,
            n_key_aliases,
            total_kt_level_names,
            values: Cow::Borrowed(values.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_per_client_flags(&mut self, device_spec: types::DeviceSpec, change: impl Into<types::PerClientFlag>, value: impl Into<types::PerClientFlag>, ctrls_to_change: impl Into<types::BoolCtrl>, auto_ctrls: impl Into<types::BoolCtrl>, auto_ctrls_values: impl Into<types::BoolCtrl>) -> Result<Cookie<types::xkb::PerClientFlagsReply>> {
        let request = types::xkb::PerClientFlagsRequest {
            device_spec,
            change: Into::<u32>::into(change.into()) as _,
            value: Into::<u32>::into(value.into()) as _,
            ctrls_to_change: Into::<u32>::into(ctrls_to_change.into()) as _,
            auto_ctrls: Into::<u32>::into(auto_ctrls.into()) as _,
            auto_ctrls_values: Into::<u32>::into(auto_ctrls_values.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_list_components(&mut self, device_spec: types::DeviceSpec, max_names: types::Card16) -> Result<Cookie<types::xkb::ListComponentsReply>> {
        let request = types::xkb::ListComponentsRequest {
            device_spec,
            max_names,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_kbd_by_name(&mut self, device_spec: types::DeviceSpec, need: impl Into<types::GBNDetail>, want: impl Into<types::GBNDetail>, load: types::Bool) -> Result<Cookie<types::xkb::GetKbdByNameReply>> {
        let request = types::xkb::GetKbdByNameRequest {
            device_spec,
            need: Into::<u32>::into(need.into()) as _,
            want: Into::<u32>::into(want.into()) as _,
            load,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_device_info(&mut self, device_spec: types::DeviceSpec, wanted: impl Into<types::XIFeature>, all_buttons: types::Bool, first_button: types::Card8, n_buttons: types::Card8, led_class: types::LedClass, led_id: impl Into<types::ID>) -> Result<Cookie<types::xkb::GetDeviceInfoReply>> {
        let request = types::xkb::GetDeviceInfoRequest {
            device_spec,
            wanted: Into::<u32>::into(wanted.into()) as _,
            all_buttons,
            first_button,
            n_buttons,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_device_info(&mut self, device_spec: types::DeviceSpec, first_btn: types::Card8, change: impl Into<types::XIFeature>, btn_actions: impl AsRef<[types::Action]>, leds: impl AsRef<[types::DeviceLedInfo]>) -> Result<Cookie<()>> {
        let request = types::xkb::SetDeviceInfoRequest {
            device_spec,
            first_btn,
            change: Into::<u32>::into(change.into()) as _,
            btn_actions: Cow::Borrowed(btn_actions.as_ref()),
            leds: Cow::Borrowed(leds.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_debugging_flags(&mut self, affect_flags: types::Card32, flags: types::Card32, affect_ctrls: types::Card32, ctrls: types::Card32, message: impl AsRef<[types::xkb::String8]>) -> Result<Cookie<types::xkb::SetDebuggingFlagsReply>> {
        let request = types::xkb::SetDebuggingFlagsRequest {
            affect_flags,
            flags,
            affect_ctrls,
            ctrls,
            message: Cow::Borrowed(message.as_ref()),
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "xprint")]
    fn xprint_print_query_version(&mut self, ) -> Result<Cookie<types::xprint::PrintQueryVersionReply>> {
        let request = types::xprint::PrintQueryVersionRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_printer_list(&mut self, printer_name: impl AsRef<[types::xprint::String8]>, locale: impl AsRef<[types::xprint::String8]>) -> Result<Cookie<types::xprint::PrintGetPrinterListReply>> {
        let request = types::xprint::PrintGetPrinterListRequest {
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_rehash_printer_list(&mut self, ) -> Result<Cookie<()>> {
        let request = types::xprint::PrintRehashPrinterListRequest {
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_create_context(&mut self, context_id: types::Card32, printer_name: impl AsRef<[types::xprint::String8]>, locale: impl AsRef<[types::xprint::String8]>) -> Result<Cookie<()>> {
        let request = types::xprint::CreateContextRequest {
            context_id,
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_context(&mut self, context: types::Card32) -> Result<Cookie<()>> {
        let request = types::xprint::PrintSetContextRequest {
            context,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_context(&mut self, ) -> Result<Cookie<types::xprint::PrintGetContextReply>> {
        let request = types::xprint::PrintGetContextRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_destroy_context(&mut self, context: types::Card32) -> Result<Cookie<()>> {
        let request = types::xprint::PrintDestroyContextRequest {
            context,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_screen_of_context(&mut self, ) -> Result<Cookie<types::xprint::PrintGetScreenOfContextReply>> {
        let request = types::xprint::PrintGetScreenOfContextRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_job(&mut self, output_mode: types::Card8) -> Result<Cookie<()>> {
        let request = types::xprint::PrintStartJobRequest {
            output_mode,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_job(&mut self, cancel: types::Bool) -> Result<Cookie<()>> {
        let request = types::xprint::PrintEndJobRequest {
            cancel,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_doc(&mut self, driver_mode: types::Card8) -> Result<Cookie<()>> {
        let request = types::xprint::PrintStartDocRequest {
            driver_mode,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_doc(&mut self, cancel: types::Bool) -> Result<Cookie<()>> {
        let request = types::xprint::PrintEndDocRequest {
            cancel,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_put_document_data(&mut self, drawable: types::xproto::Drawable, data: impl AsRef<[types::Byte]>, doc_format: impl AsRef<[types::xprint::String8]>, options: impl AsRef<[types::xprint::String8]>) -> Result<Cookie<()>> {
        let request = types::xprint::PrintPutDocumentDataRequest {
            drawable,
            data: Cow::Borrowed(data.as_ref()),
            doc_format: Cow::Borrowed(doc_format.as_ref()),
            options: Cow::Borrowed(options.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_document_data(&mut self, context: types::Pcontext, max_bytes: types::Card32) -> Result<Cookie<types::xprint::PrintGetDocumentDataReply>> {
        let request = types::xprint::PrintGetDocumentDataRequest {
            context,
            max_bytes,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_page(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xprint::PrintStartPageRequest {
            window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_page(&mut self, cancel: types::Bool) -> Result<Cookie<()>> {
        let request = types::xprint::PrintEndPageRequest {
            cancel,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_select_input(&mut self, context: types::Pcontext, event_mask: types::Card32) -> Result<Cookie<()>> {
        let request = types::xprint::PrintSelectInputRequest {
            context,
            event_mask,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_input_selected(&mut self, context: types::Pcontext) -> Result<Cookie<types::xprint::PrintInputSelectedReply>> {
        let request = types::xprint::PrintInputSelectedRequest {
            context,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_attributes(&mut self, context: types::Pcontext, pool: types::Card8) -> Result<Cookie<types::xprint::PrintGetAttributesReply>> {
        let request = types::xprint::PrintGetAttributesRequest {
            context,
            pool,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_one_attributes(&mut self, context: types::Pcontext, pool: types::Card8, name: impl AsRef<[types::xprint::String8]>) -> Result<Cookie<types::xprint::PrintGetOneAttributesReply>> {
        let request = types::xprint::PrintGetOneAttributesRequest {
            context,
            pool,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_attributes(&mut self, context: types::Pcontext, string_len: types::Card32, pool: types::Card8, rule: types::Card8, attributes: impl AsRef<[types::xprint::String8]>) -> Result<Cookie<()>> {
        let request = types::xprint::PrintSetAttributesRequest {
            context,
            string_len,
            pool,
            rule,
            attributes: Cow::Borrowed(attributes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_page_dimensions(&mut self, context: types::Pcontext) -> Result<Cookie<types::xprint::PrintGetPageDimensionsReply>> {
        let request = types::xprint::PrintGetPageDimensionsRequest {
            context,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_screens(&mut self, ) -> Result<Cookie<types::xprint::PrintQueryScreensReply>> {
        let request = types::xprint::PrintQueryScreensRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_image_resolution(&mut self, context: types::Pcontext, image_resolution: types::Card16) -> Result<Cookie<types::xprint::PrintSetImageResolutionReply>> {
        let request = types::xprint::PrintSetImageResolutionRequest {
            context,
            image_resolution,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_image_resolution(&mut self, context: types::Pcontext) -> Result<Cookie<types::xprint::PrintGetImageResolutionReply>> {
        let request = types::xprint::PrintGetImageResolutionRequest {
            context,
        };
        self.send_reply_request(request)
    }
    
    fn create_window(&mut self, depth: types::Card8, wid: types::xproto::Window, parent: types::xproto::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, border_width: types::Card16, class: types::WindowClass, visual: types::Visualid, value_list: impl Borrow<types::xproto::CreateWindowAux>) -> Result<Cookie<()>> {
        let request = types::xproto::CreateWindowRequest {
            depth,
            wid,
            parent,
            x,
            y,
            width,
            height,
            border_width,
            class,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn change_window_attributes(&mut self, window: types::xproto::Window, value_list: impl Borrow<types::xproto::ChangeWindowAttributesAux>) -> Result<Cookie<()>> {
        let request = types::xproto::ChangeWindowAttributesRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn get_window_attributes(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xproto::GetWindowAttributesReply>> {
        let request = types::xproto::GetWindowAttributesRequest {
            window,
        };
        self.send_reply_request(request)
    }
    fn destroy_window(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xproto::DestroyWindowRequest {
            window,
        };
        self.send_void_request(request)
    }
    fn destroy_subwindows(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xproto::DestroySubwindowsRequest {
            window,
        };
        self.send_void_request(request)
    }
    fn change_save_set(&mut self, mode: types::SetMode, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xproto::ChangeSaveSetRequest {
            mode,
            window,
        };
        self.send_void_request(request)
    }
    fn reparent_window(&mut self, window: types::xproto::Window, parent: types::xproto::Window, x: types::Int16, y: types::Int16) -> Result<Cookie<()>> {
        let request = types::xproto::ReparentWindowRequest {
            window,
            parent,
            x,
            y,
        };
        self.send_void_request(request)
    }
    fn map_window(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xproto::MapWindowRequest {
            window,
        };
        self.send_void_request(request)
    }
    fn map_subwindows(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xproto::MapSubwindowsRequest {
            window,
        };
        self.send_void_request(request)
    }
    fn unmap_window(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xproto::UnmapWindowRequest {
            window,
        };
        self.send_void_request(request)
    }
    fn unmap_subwindows(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xproto::UnmapSubwindowsRequest {
            window,
        };
        self.send_void_request(request)
    }
    fn configure_window(&mut self, window: types::xproto::Window, value_list: impl Borrow<types::xproto::ConfigureWindowAux>) -> Result<Cookie<()>> {
        let request = types::xproto::ConfigureWindowRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn circulate_window(&mut self, direction: types::Circulate, window: types::xproto::Window) -> Result<Cookie<()>> {
        let request = types::xproto::CirculateWindowRequest {
            direction,
            window,
        };
        self.send_void_request(request)
    }
    fn get_geometry(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<types::xproto::GetGeometryReply>> {
        let request = types::xproto::GetGeometryRequest {
            drawable,
        };
        self.send_reply_request(request)
    }
    fn query_tree(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xproto::QueryTreeReply>> {
        let request = types::xproto::QueryTreeRequest {
            window,
        };
        self.send_reply_request(request)
    }
    fn intern_atom(&mut self, only_if_exists: types::Bool, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::InternAtomReply>> {
        let request = types::xproto::InternAtomRequest {
            only_if_exists,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn get_atom_name(&mut self, atom: types::Atom) -> Result<Cookie<types::xproto::GetAtomNameReply>> {
        let request = types::xproto::GetAtomNameRequest {
            atom,
        };
        self.send_reply_request(request)
    }
    fn change_property(&mut self, mode: types::PropMode, window: types::xproto::Window, property: types::Atom, type_: types::Atom, format: types::Card8, data_len: types::Card32, data: impl AsRef<[types::Void]>) -> Result<Cookie<()>> {
        let request = types::xproto::ChangePropertyRequest {
            mode,
            window,
            property,
            type_,
            format,
            data_len,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    fn delete_property(&mut self, window: types::xproto::Window, property: types::Atom) -> Result<Cookie<()>> {
        let request = types::xproto::DeletePropertyRequest {
            window,
            property,
        };
        self.send_void_request(request)
    }
    fn get_property(&mut self, delete: types::Bool, window: types::xproto::Window, property: types::Atom, type_: impl Into<types::GetPropertyType>, long_offset: types::Card32, long_length: types::Card32) -> Result<Cookie<types::xproto::GetPropertyReply>> {
        let request = types::xproto::GetPropertyRequest {
            delete,
            window,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
        };
        self.send_reply_request(request)
    }
    fn list_properties(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xproto::ListPropertiesReply>> {
        let request = types::xproto::ListPropertiesRequest {
            window,
        };
        self.send_reply_request(request)
    }
    fn set_selection_owner(&mut self, owner: impl Into<types::xproto::Window>, selection: types::Atom, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let request = types::xproto::SetSelectionOwnerRequest {
            owner: Into::<u32>::into(owner.into()) as _,
            selection,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn get_selection_owner(&mut self, selection: types::Atom) -> Result<Cookie<types::xproto::GetSelectionOwnerReply>> {
        let request = types::xproto::GetSelectionOwnerRequest {
            selection,
        };
        self.send_reply_request(request)
    }
    fn convert_selection(&mut self, requestor: types::xproto::Window, selection: types::Atom, target: types::Atom, property: impl Into<types::Atom>, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let request = types::xproto::ConvertSelectionRequest {
            requestor,
            selection,
            target,
            property: Into::<u32>::into(property.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn send_event(&mut self, propagate: types::Bool, destination: impl Into<types::SendEventDest>, event_mask: impl Into<types::xproto::EventMask>, event: impl Borrow<[types::Char; 32]>) -> Result<Cookie<()>> {
        let request = types::xproto::SendEventRequest {
            propagate,
            destination: Into::<u32>::into(destination.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            event: Cow::Borrowed(event.borrow()),
        };
        self.send_void_request(request)
    }
    fn grab_pointer(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, event_mask: impl Into<types::xproto::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::xproto::Window>, cursor: impl Into<types::xproto::Cursor>, time: impl Into<types::Time>) -> Result<Cookie<types::xproto::GrabPointerReply>> {
        let request = types::xproto::GrabPointerRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_reply_request(request)
    }
    fn ungrab_pointer(&mut self, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let request = types::xproto::UngrabPointerRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn grab_button(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, event_mask: impl Into<types::xproto::EventMask>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode, confine_to: impl Into<types::xproto::Window>, cursor: impl Into<types::xproto::Cursor>, button: types::ButtonIndex, modifiers: impl Into<types::ModMask>) -> Result<Cookie<()>> {
        let request = types::xproto::GrabButtonRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            button,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        self.send_void_request(request)
    }
    fn ungrab_button(&mut self, button: types::ButtonIndex, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>) -> Result<Cookie<()>> {
        let request = types::xproto::UngrabButtonRequest {
            button,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        self.send_void_request(request)
    }
    fn change_active_pointer_grab(&mut self, cursor: impl Into<types::xproto::Cursor>, time: impl Into<types::Time>, event_mask: impl Into<types::xproto::EventMask>) -> Result<Cookie<()>> {
        let request = types::xproto::ChangeActivePointerGrabRequest {
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    fn grab_keyboard(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, time: impl Into<types::Time>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> Result<Cookie<types::xproto::GrabKeyboardReply>> {
        let request = types::xproto::GrabKeyboardRequest {
            owner_events,
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        self.send_reply_request(request)
    }
    fn ungrab_keyboard(&mut self, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let request = types::xproto::UngrabKeyboardRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn grab_key(&mut self, owner_events: types::Bool, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>, key: impl Into<types::Grab>, pointer_mode: types::GrabMode, keyboard_mode: types::GrabMode) -> Result<Cookie<()>> {
        let request = types::xproto::GrabKeyRequest {
            owner_events,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        self.send_void_request(request)
    }
    fn ungrab_key(&mut self, key: impl Into<types::Grab>, grab_window: types::xproto::Window, modifiers: impl Into<types::ModMask>) -> Result<Cookie<()>> {
        let request = types::xproto::UngrabKeyRequest {
            key: Into::<u32>::into(key.into()) as _,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        self.send_void_request(request)
    }
    fn allow_events(&mut self, mode: types::Allow, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let request = types::xproto::AllowEventsRequest {
            mode,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn grab_server(&mut self, ) -> Result<Cookie<()>> {
        let request = types::xproto::GrabServerRequest {
        };
        self.send_void_request(request)
    }
    fn ungrab_server(&mut self, ) -> Result<Cookie<()>> {
        let request = types::xproto::UngrabServerRequest {
        };
        self.send_void_request(request)
    }
    fn query_pointer(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xproto::QueryPointerReply>> {
        let request = types::xproto::QueryPointerRequest {
            window,
        };
        self.send_reply_request(request)
    }
    fn get_motion_events(&mut self, window: types::xproto::Window, start: impl Into<types::Time>, stop: impl Into<types::Time>) -> Result<Cookie<types::xproto::GetMotionEventsReply>> {
        let request = types::xproto::GetMotionEventsRequest {
            window,
            start: Into::<u32>::into(start.into()) as _,
            stop: Into::<u32>::into(stop.into()) as _,
        };
        self.send_reply_request(request)
    }
    fn translate_coordinates(&mut self, src_window: types::xproto::Window, dst_window: types::xproto::Window, src_x: types::Int16, src_y: types::Int16) -> Result<Cookie<types::xproto::TranslateCoordinatesReply>> {
        let request = types::xproto::TranslateCoordinatesRequest {
            src_window,
            dst_window,
            src_x,
            src_y,
        };
        self.send_reply_request(request)
    }
    fn warp_pointer(&mut self, src_window: impl Into<types::xproto::Window>, dst_window: impl Into<types::xproto::Window>, src_x: types::Int16, src_y: types::Int16, src_width: types::Card16, src_height: types::Card16, dst_x: types::Int16, dst_y: types::Int16) -> Result<Cookie<()>> {
        let request = types::xproto::WarpPointerRequest {
            src_window: Into::<u32>::into(src_window.into()) as _,
            dst_window: Into::<u32>::into(dst_window.into()) as _,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
        };
        self.send_void_request(request)
    }
    fn set_input_focus(&mut self, revert_to: types::InputFocus, focus: impl Into<types::InputFocus>, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let request = types::xproto::SetInputFocusRequest {
            revert_to,
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn get_input_focus(&mut self, ) -> Result<Cookie<types::xproto::GetInputFocusReply>> {
        let request = types::xproto::GetInputFocusRequest {
        };
        self.send_reply_request(request)
    }
    fn query_keymap(&mut self, ) -> Result<Cookie<types::xproto::QueryKeymapReply>> {
        let request = types::xproto::QueryKeymapRequest {
        };
        self.send_reply_request(request)
    }
    fn open_font(&mut self, fid: types::Font, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xproto::OpenFontRequest {
            fid,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request)
    }
    fn close_font(&mut self, font: types::Font) -> Result<Cookie<()>> {
        let request = types::xproto::CloseFontRequest {
            font,
        };
        self.send_void_request(request)
    }
    fn query_font(&mut self, font: types::Fontable) -> Result<Cookie<types::xproto::QueryFontReply>> {
        let request = types::xproto::QueryFontRequest {
            font,
        };
        self.send_reply_request(request)
    }
    fn query_text_extents(&mut self, font: types::Fontable, string: impl AsRef<[types::Char2b]>) -> Result<Cookie<types::xproto::QueryTextExtentsReply>> {
        let request = types::xproto::QueryTextExtentsRequest {
            font,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn list_fonts(&mut self, max_names: types::Card16, pattern: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::ListFontsReply>> {
        let request = types::xproto::ListFontsRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn list_fonts_with_info(&mut self, max_names: types::Card16, pattern: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::ListFontsWithInfoReply>> {
        let request = types::xproto::ListFontsWithInfoRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn set_font_path(&mut self, font: impl AsRef<[types::Str]>) -> Result<Cookie<()>> {
        let request = types::xproto::SetFontPathRequest {
            font: Cow::Borrowed(font.as_ref()),
        };
        self.send_void_request(request)
    }
    fn get_font_path(&mut self, ) -> Result<Cookie<types::xproto::GetFontPathReply>> {
        let request = types::xproto::GetFontPathRequest {
        };
        self.send_reply_request(request)
    }
    fn create_pixmap(&mut self, depth: types::Card8, pid: types::xproto::Pixmap, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let request = types::xproto::CreatePixmapRequest {
            depth,
            pid,
            drawable,
            width,
            height,
        };
        self.send_void_request(request)
    }
    fn free_pixmap(&mut self, pixmap: types::xproto::Pixmap) -> Result<Cookie<()>> {
        let request = types::xproto::FreePixmapRequest {
            pixmap,
        };
        self.send_void_request(request)
    }
    fn create_gc(&mut self, cid: types::Gcontext, drawable: types::xproto::Drawable, value_list: impl Borrow<types::xproto::CreateGCAux>) -> Result<Cookie<()>> {
        let request = types::xproto::CreateGCRequest {
            cid,
            drawable,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn change_gc(&mut self, gc: types::Gcontext, value_list: impl Borrow<types::xproto::ChangeGCAux>) -> Result<Cookie<()>> {
        let request = types::xproto::ChangeGCRequest {
            gc,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn copy_gc(&mut self, src_gc: types::Gcontext, dst_gc: types::Gcontext, value_mask: impl Into<types::xproto::GC>) -> Result<Cookie<()>> {
        let request = types::xproto::CopyGCRequest {
            src_gc,
            dst_gc,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    fn set_dashes(&mut self, gc: types::Gcontext, dash_offset: types::Card16, dashes: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let request = types::xproto::SetDashesRequest {
            gc,
            dash_offset,
            dashes: Cow::Borrowed(dashes.as_ref()),
        };
        self.send_void_request(request)
    }
    fn set_clip_rectangles(&mut self, ordering: types::ClipOrdering, gc: types::Gcontext, clip_x_origin: types::Int16, clip_y_origin: types::Int16, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let request = types::xproto::SetClipRectanglesRequest {
            ordering,
            gc,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    fn free_gc(&mut self, gc: types::Gcontext) -> Result<Cookie<()>> {
        let request = types::xproto::FreeGCRequest {
            gc,
        };
        self.send_void_request(request)
    }
    fn clear_area(&mut self, exposures: types::Bool, window: types::xproto::Window, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let request = types::xproto::ClearAreaRequest {
            exposures,
            window,
            x,
            y,
            width,
            height,
        };
        self.send_void_request(request)
    }
    fn copy_area(&mut self, src_drawable: types::xproto::Drawable, dst_drawable: types::xproto::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16) -> Result<Cookie<()>> {
        let request = types::xproto::CopyAreaRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        self.send_void_request(request)
    }
    fn copy_plane(&mut self, src_drawable: types::xproto::Drawable, dst_drawable: types::xproto::Drawable, gc: types::Gcontext, src_x: types::Int16, src_y: types::Int16, dst_x: types::Int16, dst_y: types::Int16, width: types::Card16, height: types::Card16, bit_plane: types::Card32) -> Result<Cookie<()>> {
        let request = types::xproto::CopyPlaneRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
            bit_plane,
        };
        self.send_void_request(request)
    }
    fn poly_point(&mut self, coordinate_mode: types::CoordMode, drawable: types::xproto::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> Result<Cookie<()>> {
        let request = types::xproto::PolyPointRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_line(&mut self, coordinate_mode: types::CoordMode, drawable: types::xproto::Drawable, gc: types::Gcontext, points: impl AsRef<[types::Point]>) -> Result<Cookie<()>> {
        let request = types::xproto::PolyLineRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_segment(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, segments: impl AsRef<[types::Segment]>) -> Result<Cookie<()>> {
        let request = types::xproto::PolySegmentRequest {
            drawable,
            gc,
            segments: Cow::Borrowed(segments.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_rectangle(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let request = types::xproto::PolyRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_arc(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> Result<Cookie<()>> {
        let request = types::xproto::PolyArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        self.send_void_request(request)
    }
    fn fill_poly(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, shape: types::PolyShape, coordinate_mode: types::CoordMode, points: impl AsRef<[types::Point]>) -> Result<Cookie<()>> {
        let request = types::xproto::FillPolyRequest {
            drawable,
            gc,
            shape,
            coordinate_mode,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_fill_rectangle(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, rectangles: impl AsRef<[types::Rectangle]>) -> Result<Cookie<()>> {
        let request = types::xproto::PolyFillRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_fill_arc(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, arcs: impl AsRef<[types::Arc]>) -> Result<Cookie<()>> {
        let request = types::xproto::PolyFillArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        self.send_void_request(request)
    }
    fn put_image(&mut self, format: types::ImageFormat, drawable: types::xproto::Drawable, gc: types::Gcontext, width: types::Card16, height: types::Card16, dst_x: types::Int16, dst_y: types::Int16, left_pad: types::Card8, depth: types::Card8, data: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let request = types::xproto::PutImageRequest {
            format,
            drawable,
            gc,
            width,
            height,
            dst_x,
            dst_y,
            left_pad,
            depth,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    fn get_image(&mut self, format: types::ImageFormat, drawable: types::xproto::Drawable, x: types::Int16, y: types::Int16, width: types::Card16, height: types::Card16, plane_mask: types::Card32) -> Result<Cookie<types::xproto::GetImageReply>> {
        let request = types::xproto::GetImageRequest {
            format,
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
        };
        self.send_reply_request(request)
    }
    fn poly_text8(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let request = types::xproto::PolyText8Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_text16(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, items: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let request = types::xproto::PolyText16Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        self.send_void_request(request)
    }
    fn image_text8(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xproto::ImageText8Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_void_request(request)
    }
    fn image_text16(&mut self, drawable: types::xproto::Drawable, gc: types::Gcontext, x: types::Int16, y: types::Int16, string: impl AsRef<[types::Char2b]>) -> Result<Cookie<()>> {
        let request = types::xproto::ImageText16Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_void_request(request)
    }
    fn create_colormap(&mut self, alloc: types::ColormapAlloc, mid: types::Colormap, window: types::xproto::Window, visual: types::Visualid) -> Result<Cookie<()>> {
        let request = types::xproto::CreateColormapRequest {
            alloc,
            mid,
            window,
            visual,
        };
        self.send_void_request(request)
    }
    fn free_colormap(&mut self, cmap: types::Colormap) -> Result<Cookie<()>> {
        let request = types::xproto::FreeColormapRequest {
            cmap,
        };
        self.send_void_request(request)
    }
    fn copy_colormap_and_free(&mut self, mid: types::Colormap, src_cmap: types::Colormap) -> Result<Cookie<()>> {
        let request = types::xproto::CopyColormapAndFreeRequest {
            mid,
            src_cmap,
        };
        self.send_void_request(request)
    }
    fn install_colormap(&mut self, cmap: types::Colormap) -> Result<Cookie<()>> {
        let request = types::xproto::InstallColormapRequest {
            cmap,
        };
        self.send_void_request(request)
    }
    fn uninstall_colormap(&mut self, cmap: types::Colormap) -> Result<Cookie<()>> {
        let request = types::xproto::UninstallColormapRequest {
            cmap,
        };
        self.send_void_request(request)
    }
    fn list_installed_colormaps(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xproto::ListInstalledColormapsReply>> {
        let request = types::xproto::ListInstalledColormapsRequest {
            window,
        };
        self.send_reply_request(request)
    }
    fn alloc_color(&mut self, cmap: types::Colormap, red: types::Card16, green: types::Card16, blue: types::Card16) -> Result<Cookie<types::xproto::AllocColorReply>> {
        let request = types::xproto::AllocColorRequest {
            cmap,
            red,
            green,
            blue,
        };
        self.send_reply_request(request)
    }
    fn alloc_named_color(&mut self, cmap: types::Colormap, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::AllocNamedColorReply>> {
        let request = types::xproto::AllocNamedColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn alloc_color_cells(&mut self, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, planes: types::Card16) -> Result<Cookie<types::xproto::AllocColorCellsReply>> {
        let request = types::xproto::AllocColorCellsRequest {
            contiguous,
            cmap,
            colors,
            planes,
        };
        self.send_reply_request(request)
    }
    fn alloc_color_planes(&mut self, contiguous: types::Bool, cmap: types::Colormap, colors: types::Card16, reds: types::Card16, greens: types::Card16, blues: types::Card16) -> Result<Cookie<types::xproto::AllocColorPlanesReply>> {
        let request = types::xproto::AllocColorPlanesRequest {
            contiguous,
            cmap,
            colors,
            reds,
            greens,
            blues,
        };
        self.send_reply_request(request)
    }
    fn free_colors(&mut self, cmap: types::Colormap, plane_mask: types::Card32, pixels: impl AsRef<[types::Card32]>) -> Result<Cookie<()>> {
        let request = types::xproto::FreeColorsRequest {
            cmap,
            plane_mask,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        self.send_void_request(request)
    }
    fn store_colors(&mut self, cmap: types::Colormap, items: impl AsRef<[types::Coloritem]>) -> Result<Cookie<()>> {
        let request = types::xproto::StoreColorsRequest {
            cmap,
            items: Cow::Borrowed(items.as_ref()),
        };
        self.send_void_request(request)
    }
    fn store_named_color(&mut self, flags: impl Into<types::ColorFlag>, cmap: types::Colormap, pixel: types::Card32, name: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xproto::StoreNamedColorRequest {
            flags: Into::<u32>::into(flags.into()) as _,
            cmap,
            pixel,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request)
    }
    fn query_colors(&mut self, cmap: types::Colormap, pixels: impl AsRef<[types::Card32]>) -> Result<Cookie<types::xproto::QueryColorsReply>> {
        let request = types::xproto::QueryColorsRequest {
            cmap,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn lookup_color(&mut self, cmap: types::Colormap, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::LookupColorReply>> {
        let request = types::xproto::LookupColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn create_cursor(&mut self, cid: types::xproto::Cursor, source: types::xproto::Pixmap, mask: impl Into<types::xproto::Pixmap>, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16, x: types::Card16, y: types::Card16) -> Result<Cookie<()>> {
        let request = types::xproto::CreateCursorRequest {
            cid,
            source,
            mask: Into::<u32>::into(mask.into()) as _,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
            x,
            y,
        };
        self.send_void_request(request)
    }
    fn create_glyph_cursor(&mut self, cid: types::xproto::Cursor, source_font: types::Font, mask_font: impl Into<types::Font>, source_char: types::Card16, mask_char: types::Card16, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> Result<Cookie<()>> {
        let request = types::xproto::CreateGlyphCursorRequest {
            cid,
            source_font,
            mask_font: Into::<u32>::into(mask_font.into()) as _,
            source_char,
            mask_char,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        self.send_void_request(request)
    }
    fn free_cursor(&mut self, cursor: types::xproto::Cursor) -> Result<Cookie<()>> {
        let request = types::xproto::FreeCursorRequest {
            cursor,
        };
        self.send_void_request(request)
    }
    fn recolor_cursor(&mut self, cursor: types::xproto::Cursor, fore_red: types::Card16, fore_green: types::Card16, fore_blue: types::Card16, back_red: types::Card16, back_green: types::Card16, back_blue: types::Card16) -> Result<Cookie<()>> {
        let request = types::xproto::RecolorCursorRequest {
            cursor,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        self.send_void_request(request)
    }
    fn query_best_size(&mut self, class: types::QueryShapeOf, drawable: types::xproto::Drawable, width: types::Card16, height: types::Card16) -> Result<Cookie<types::xproto::QueryBestSizeReply>> {
        let request = types::xproto::QueryBestSizeRequest {
            class,
            drawable,
            width,
            height,
        };
        self.send_reply_request(request)
    }
    fn query_extension(&mut self, name: impl AsRef<[types::Char]>) -> Result<Cookie<types::xproto::QueryExtensionReply>> {
        let request = types::xproto::QueryExtensionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn list_extensions(&mut self, ) -> Result<Cookie<types::xproto::ListExtensionsReply>> {
        let request = types::xproto::ListExtensionsRequest {
        };
        self.send_reply_request(request)
    }
    fn change_keyboard_mapping(&mut self, keycode_count: types::Card8, first_keycode: types::Keycode, keysyms_per_keycode: types::Card8, keysyms: impl AsRef<[types::Keysym]>) -> Result<Cookie<()>> {
        let request = types::xproto::ChangeKeyboardMappingRequest {
            keycode_count,
            first_keycode,
            keysyms_per_keycode,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        self.send_void_request(request)
    }
    fn get_keyboard_mapping(&mut self, first_keycode: types::Keycode, count: types::Card8) -> Result<Cookie<types::xproto::GetKeyboardMappingReply>> {
        let request = types::xproto::GetKeyboardMappingRequest {
            first_keycode,
            count,
        };
        self.send_reply_request(request)
    }
    fn change_keyboard_control(&mut self, value_list: impl Borrow<types::xproto::ChangeKeyboardControlAux>) -> Result<Cookie<()>> {
        let request = types::xproto::ChangeKeyboardControlRequest {
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn get_keyboard_control(&mut self, ) -> Result<Cookie<types::xproto::GetKeyboardControlReply>> {
        let request = types::xproto::GetKeyboardControlRequest {
        };
        self.send_reply_request(request)
    }
    fn bell(&mut self, percent: types::Int8) -> Result<Cookie<()>> {
        let request = types::xproto::BellRequest {
            percent,
        };
        self.send_void_request(request)
    }
    fn change_pointer_control(&mut self, acceleration_numerator: types::Int16, acceleration_denominator: types::Int16, threshold: types::Int16, do_acceleration: types::Bool, do_threshold: types::Bool) -> Result<Cookie<()>> {
        let request = types::xproto::ChangePointerControlRequest {
            acceleration_numerator,
            acceleration_denominator,
            threshold,
            do_acceleration,
            do_threshold,
        };
        self.send_void_request(request)
    }
    fn get_pointer_control(&mut self, ) -> Result<Cookie<types::xproto::GetPointerControlReply>> {
        let request = types::xproto::GetPointerControlRequest {
        };
        self.send_reply_request(request)
    }
    fn set_screen_saver(&mut self, timeout: types::Int16, interval: types::Int16, prefer_blanking: types::Blanking, allow_exposures: types::Exposures) -> Result<Cookie<()>> {
        let request = types::xproto::SetScreenSaverRequest {
            timeout,
            interval,
            prefer_blanking,
            allow_exposures,
        };
        self.send_void_request(request)
    }
    fn get_screen_saver(&mut self, ) -> Result<Cookie<types::xproto::GetScreenSaverReply>> {
        let request = types::xproto::GetScreenSaverRequest {
        };
        self.send_reply_request(request)
    }
    fn change_hosts(&mut self, mode: types::HostMode, family: types::Family, address: impl AsRef<[types::Byte]>) -> Result<Cookie<()>> {
        let request = types::xproto::ChangeHostsRequest {
            mode,
            family,
            address: Cow::Borrowed(address.as_ref()),
        };
        self.send_void_request(request)
    }
    fn list_hosts(&mut self, ) -> Result<Cookie<types::xproto::ListHostsReply>> {
        let request = types::xproto::ListHostsRequest {
        };
        self.send_reply_request(request)
    }
    fn set_access_control(&mut self, mode: types::AccessControl) -> Result<Cookie<()>> {
        let request = types::xproto::SetAccessControlRequest {
            mode,
        };
        self.send_void_request(request)
    }
    fn set_close_down_mode(&mut self, mode: types::CloseDown) -> Result<Cookie<()>> {
        let request = types::xproto::SetCloseDownModeRequest {
            mode,
        };
        self.send_void_request(request)
    }
    fn kill_client(&mut self, resource: impl Into<types::Kill>) -> Result<Cookie<()>> {
        let request = types::xproto::KillClientRequest {
            resource: Into::<u32>::into(resource.into()) as _,
        };
        self.send_void_request(request)
    }
    fn rotate_properties(&mut self, window: types::xproto::Window, delta: types::Int16, atoms: impl AsRef<[types::Atom]>) -> Result<Cookie<()>> {
        let request = types::xproto::RotatePropertiesRequest {
            window,
            delta,
            atoms: Cow::Borrowed(atoms.as_ref()),
        };
        self.send_void_request(request)
    }
    fn force_screen_saver(&mut self, mode: types::ScreenSaver) -> Result<Cookie<()>> {
        let request = types::xproto::ForceScreenSaverRequest {
            mode,
        };
        self.send_void_request(request)
    }
    fn set_pointer_mapping(&mut self, map: impl AsRef<[types::Card8]>) -> Result<Cookie<types::xproto::SetPointerMappingReply>> {
        let request = types::xproto::SetPointerMappingRequest {
            map: Cow::Borrowed(map.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn get_pointer_mapping(&mut self, ) -> Result<Cookie<types::xproto::GetPointerMappingReply>> {
        let request = types::xproto::GetPointerMappingRequest {
        };
        self.send_reply_request(request)
    }
    fn set_modifier_mapping(&mut self, keycodes: impl AsRef<[types::Keycode]>) -> Result<Cookie<types::xproto::SetModifierMappingReply>> {
        let request = types::xproto::SetModifierMappingRequest {
            keycodes: Cow::Borrowed(keycodes.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn get_modifier_mapping(&mut self, ) -> Result<Cookie<types::xproto::GetModifierMappingReply>> {
        let request = types::xproto::GetModifierMappingRequest {
        };
        self.send_reply_request(request)
    }
    fn no_operation(&mut self, ) -> Result<Cookie<()>> {
        let request = types::xproto::NoOperationRequest {
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "xselinux")]
    fn xselinux_query_version(&mut self, client_major: types::Card8, client_minor: types::Card8) -> Result<Cookie<types::xselinux::QueryVersionReply>> {
        let request = types::xselinux::QueryVersionRequest {
            client_major,
            client_minor,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_create_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xselinux::SetDeviceCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_create_context(&mut self, ) -> Result<Cookie<types::xselinux::GetDeviceCreateContextReply>> {
        let request = types::xselinux::GetDeviceCreateContextRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_context(&mut self, device: types::Card32, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xselinux::SetDeviceContextRequest {
            device,
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_context(&mut self, device: types::Card32) -> Result<Cookie<types::xselinux::GetDeviceContextReply>> {
        let request = types::xselinux::GetDeviceContextRequest {
            device,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_window_create_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xselinux::SetWindowCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_create_context(&mut self, ) -> Result<Cookie<types::xselinux::GetWindowCreateContextReply>> {
        let request = types::xselinux::GetWindowCreateContextRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_context(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xselinux::GetWindowContextReply>> {
        let request = types::xselinux::GetWindowContextRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_create_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xselinux::SetPropertyCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_create_context(&mut self, ) -> Result<Cookie<types::xselinux::GetPropertyCreateContextReply>> {
        let request = types::xselinux::GetPropertyCreateContextRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_use_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xselinux::SetPropertyUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_use_context(&mut self, ) -> Result<Cookie<types::xselinux::GetPropertyUseContextReply>> {
        let request = types::xselinux::GetPropertyUseContextRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_context(&mut self, window: types::xproto::Window, property: types::Atom) -> Result<Cookie<types::xselinux::GetPropertyContextReply>> {
        let request = types::xselinux::GetPropertyContextRequest {
            window,
            property,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_data_context(&mut self, window: types::xproto::Window, property: types::Atom) -> Result<Cookie<types::xselinux::GetPropertyDataContextReply>> {
        let request = types::xselinux::GetPropertyDataContextRequest {
            window,
            property,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_properties(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xselinux::ListPropertiesReply>> {
        let request = types::xselinux::ListPropertiesRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_create_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xselinux::SetSelectionCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_create_context(&mut self, ) -> Result<Cookie<types::xselinux::GetSelectionCreateContextReply>> {
        let request = types::xselinux::GetSelectionCreateContextRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_use_context(&mut self, context: impl AsRef<[types::Char]>) -> Result<Cookie<()>> {
        let request = types::xselinux::SetSelectionUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_use_context(&mut self, ) -> Result<Cookie<types::xselinux::GetSelectionUseContextReply>> {
        let request = types::xselinux::GetSelectionUseContextRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_context(&mut self, selection: types::Atom) -> Result<Cookie<types::xselinux::GetSelectionContextReply>> {
        let request = types::xselinux::GetSelectionContextRequest {
            selection,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_data_context(&mut self, selection: types::Atom) -> Result<Cookie<types::xselinux::GetSelectionDataContextReply>> {
        let request = types::xselinux::GetSelectionDataContextRequest {
            selection,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_selections(&mut self, ) -> Result<Cookie<types::xselinux::ListSelectionsReply>> {
        let request = types::xselinux::ListSelectionsRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_client_context(&mut self, resource: types::Card32) -> Result<Cookie<types::xselinux::GetClientContextReply>> {
        let request = types::xselinux::GetClientContextRequest {
            resource,
        };
        self.send_reply_request(request)
    }
    
    #[cfg(feature = "xtest")]
    fn xtest_get_version(&mut self, major_version: types::Card8, minor_version: types::Card16) -> Result<Cookie<types::xtest::GetVersionReply>> {
        let request = types::xtest::GetVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xtest")]
    fn xtest_compare_cursor(&mut self, window: types::xproto::Window, cursor: types::xproto::Cursor) -> Result<Cookie<types::xtest::CompareCursorReply>> {
        let request = types::xtest::CompareCursorRequest {
            window,
            cursor,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xtest")]
    fn xtest_fake_input(&mut self, type_: types::Byte, detail: types::Byte, time: types::Card32, root: types::xproto::Window, root_x: types::Int16, root_y: types::Int16, deviceid: types::Card8) -> Result<Cookie<()>> {
        let request = types::xtest::FakeInputRequest {
            type_,
            detail,
            time,
            root,
            root_x,
            root_y,
            deviceid,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xtest")]
    fn xtest_grab_control(&mut self, impervious: types::Bool) -> Result<Cookie<()>> {
        let request = types::xtest::GrabControlRequest {
            impervious,
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "xv")]
    fn xv_query_extension(&mut self, ) -> Result<Cookie<types::xv::QueryExtensionReply>> {
        let request = types::xv::QueryExtensionRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_adaptors(&mut self, window: types::xproto::Window) -> Result<Cookie<types::xv::QueryAdaptorsReply>> {
        let request = types::xv::QueryAdaptorsRequest {
            window,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_encodings(&mut self, port: types::Port) -> Result<Cookie<types::xv::QueryEncodingsReply>> {
        let request = types::xv::QueryEncodingsRequest {
            port,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_grab_port(&mut self, port: types::Port, time: impl Into<types::Time>) -> Result<Cookie<types::xv::GrabPortReply>> {
        let request = types::xv::GrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_ungrab_port(&mut self, port: types::Port, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let request = types::xv::UngrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_put_video(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let request = types::xv::PutVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_put_still(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let request = types::xv::PutStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_get_video(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let request = types::xv::GetVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_get_still(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, vid_x: types::Int16, vid_y: types::Int16, vid_w: types::Card16, vid_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16) -> Result<Cookie<()>> {
        let request = types::xv::GetStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_stop_video(&mut self, port: types::Port, drawable: types::xproto::Drawable) -> Result<Cookie<()>> {
        let request = types::xv::StopVideoRequest {
            port,
            drawable,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_select_video_notify(&mut self, drawable: types::xproto::Drawable, onoff: types::Bool) -> Result<Cookie<()>> {
        let request = types::xv::SelectVideoNotifyRequest {
            drawable,
            onoff,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_select_port_notify(&mut self, port: types::Port, onoff: types::Bool) -> Result<Cookie<()>> {
        let request = types::xv::SelectPortNotifyRequest {
            port,
            onoff,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_best_size(&mut self, port: types::Port, vid_w: types::Card16, vid_h: types::Card16, drw_w: types::Card16, drw_h: types::Card16, motion: types::Bool) -> Result<Cookie<types::xv::QueryBestSizeReply>> {
        let request = types::xv::QueryBestSizeRequest {
            port,
            vid_w,
            vid_h,
            drw_w,
            drw_h,
            motion,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_set_port_attribute(&mut self, port: types::Port, attribute: types::Atom, value: types::Int32) -> Result<Cookie<()>> {
        let request = types::xv::SetPortAttributeRequest {
            port,
            attribute,
            value,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_get_port_attribute(&mut self, port: types::Port, attribute: types::Atom) -> Result<Cookie<types::xv::GetPortAttributeReply>> {
        let request = types::xv::GetPortAttributeRequest {
            port,
            attribute,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_port_attributes(&mut self, port: types::Port) -> Result<Cookie<types::xv::QueryPortAttributesReply>> {
        let request = types::xv::QueryPortAttributesRequest {
            port,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_list_image_formats(&mut self, port: types::Port) -> Result<Cookie<types::xv::ListImageFormatsReply>> {
        let request = types::xv::ListImageFormatsRequest {
            port,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_image_attributes(&mut self, port: types::Port, id: types::Card32, width: types::Card16, height: types::Card16) -> Result<Cookie<types::xv::QueryImageAttributesReply>> {
        let request = types::xv::QueryImageAttributesRequest {
            port,
            id,
            width,
            height,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_put_image(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, id: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, data: impl AsRef<[types::Card8]>) -> Result<Cookie<()>> {
        let request = types::xv::PutImageRequest {
            port,
            drawable,
            gc,
            id,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_shm_put_image(&mut self, port: types::Port, drawable: types::xproto::Drawable, gc: types::Gcontext, shmseg: types::Seg, id: types::Card32, offset: types::Card32, src_x: types::Int16, src_y: types::Int16, src_w: types::Card16, src_h: types::Card16, drw_x: types::Int16, drw_y: types::Int16, drw_w: types::Card16, drw_h: types::Card16, width: types::Card16, height: types::Card16, send_event: types::Card8) -> Result<Cookie<()>> {
        let request = types::xv::ShmPutImageRequest {
            port,
            drawable,
            gc,
            shmseg,
            id,
            offset,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            send_event,
        };
        self.send_void_request(request)
    }
    
    #[cfg(feature = "xvmc")]
    fn xvmc_query_version(&mut self, ) -> Result<Cookie<types::xvmc::QueryVersionReply>> {
        let request = types::xvmc::QueryVersionRequest {
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_surface_types(&mut self, port_id: types::Port) -> Result<Cookie<types::xvmc::ListSurfaceTypesReply>> {
        let request = types::xvmc::ListSurfaceTypesRequest {
            port_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_context(&mut self, context_id: types::xvmc::Context, port_id: types::Port, surface_id: types::Surface, width: types::Card16, height: types::Card16, flags: types::Card32) -> Result<Cookie<types::xvmc::CreateContextReply>> {
        let request = types::xvmc::CreateContextRequest {
            context_id,
            port_id,
            surface_id,
            width,
            height,
            flags,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_context(&mut self, context_id: types::xvmc::Context) -> Result<Cookie<()>> {
        let request = types::xvmc::DestroyContextRequest {
            context_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_surface(&mut self, surface_id: types::Surface, context_id: types::xvmc::Context) -> Result<Cookie<types::xvmc::CreateSurfaceReply>> {
        let request = types::xvmc::CreateSurfaceRequest {
            surface_id,
            context_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_surface(&mut self, surface_id: types::Surface) -> Result<Cookie<()>> {
        let request = types::xvmc::DestroySurfaceRequest {
            surface_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_subpicture(&mut self, subpicture_id: types::Subpicture, context: types::xvmc::Context, xvimage_id: types::Card32, width: types::Card16, height: types::Card16) -> Result<Cookie<types::xvmc::CreateSubpictureReply>> {
        let request = types::xvmc::CreateSubpictureRequest {
            subpicture_id,
            context,
            xvimage_id,
            width,
            height,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_subpicture(&mut self, subpicture_id: types::Subpicture) -> Result<Cookie<()>> {
        let request = types::xvmc::DestroySubpictureRequest {
            subpicture_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_subpicture_types(&mut self, port_id: types::Port, surface_id: types::Surface) -> Result<Cookie<types::xvmc::ListSubpictureTypesReply>> {
        let request = types::xvmc::ListSubpictureTypesRequest {
            port_id,
            surface_id,
        };
        self.send_reply_request(request)
    }
    
}

#[cfg(feature = "async")]
pub trait AsyncDisplayFunctionsExt : AsyncDisplay {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    }

impl<D: Display + ?Sized> DisplayFunctionsExt for D {}

#[cfg(feature = "async")]
impl<D: AsyncDisplay + ?Sized> AsyncDisplayFunctionsExt for D {}

#[allow(dead_code, unused_imports)]
mod types {
    pub(crate) type Card8 = u8;
    pub(crate) type Card16 = u16;
    pub(crate) type Card32 = u32;
    pub(crate) type Card64 = u64;
    pub(crate) type Bool = bool;
    pub(crate) type Char = u8;
    pub(crate) type Byte = u8;
    pub(crate) type Int8 = i8;
    pub(crate) type Int16 = i16;
    pub(crate) type Int32 = i32;
    pub(crate) type Float = f32;
    pub(crate) type Double = f64;
    pub(crate) type Void = u8;

    pub(crate) use crate::Fd;
    pub(crate) use crate::protocol::bigreq::{self, *};
    #[cfg(feature = "composite")]
    pub(crate) use crate::protocol::composite::{self, *};
    #[cfg(feature = "damage")]
    pub(crate) use crate::protocol::damage::{self, *};
    #[cfg(feature = "dpms")]
    pub(crate) use crate::protocol::dpms::{self, *};
    #[cfg(feature = "dri2")]
    pub(crate) use crate::protocol::dri2::{self, *};
    #[cfg(feature = "dri3")]
    pub(crate) use crate::protocol::dri3::{self, *};
    pub(crate) use crate::protocol::ge::{self, *};
    #[cfg(feature = "glx")]
    pub(crate) use crate::protocol::glx::{self, *};
    #[cfg(feature = "present")]
    pub(crate) use crate::protocol::present::{self, *};
    #[cfg(feature = "randr")]
    pub(crate) use crate::protocol::randr::{self, *};
    #[cfg(feature = "record")]
    pub(crate) use crate::protocol::record::{self, *};
    #[cfg(feature = "render")]
    pub(crate) use crate::protocol::render::{self, *};
    #[cfg(feature = "res")]
    pub(crate) use crate::protocol::res::{self, *};
    #[cfg(feature = "screensaver")]
    pub(crate) use crate::protocol::screensaver::{self, *};
    #[cfg(feature = "shape")]
    pub(crate) use crate::protocol::shape::{self, *};
    #[cfg(feature = "shm")]
    pub(crate) use crate::protocol::shm::{self, *};
    #[cfg(feature = "sync")]
    pub(crate) use crate::protocol::sync::{self, *};
    #[cfg(feature = "xc_misc")]
    pub(crate) use crate::protocol::xc_misc::{self, *};
    #[cfg(feature = "xevie")]
    pub(crate) use crate::protocol::xevie::{self, *};
    #[cfg(feature = "xf86dri")]
    pub(crate) use crate::protocol::xf86dri::{self, *};
    #[cfg(feature = "xf86vidmode")]
    pub(crate) use crate::protocol::xf86vidmode::{self, *};
    #[cfg(feature = "xfixes")]
    pub(crate) use crate::protocol::xfixes::{self, *};
    #[cfg(feature = "xinerama")]
    pub(crate) use crate::protocol::xinerama::{self, *};
    #[cfg(feature = "xinput")]
    pub(crate) use crate::protocol::xinput::{self, *};
    #[cfg(feature = "xkb")]
    pub(crate) use crate::protocol::xkb::{self, *};
    #[cfg(feature = "xprint")]
    pub(crate) use crate::protocol::xprint::{self, *};
    pub(crate) use crate::protocol::xproto::{self, *};
    #[cfg(feature = "xselinux")]
    pub(crate) use crate::protocol::xselinux::{self, *};
    #[cfg(feature = "xtest")]
    pub(crate) use crate::protocol::xtest::{self, *};
    #[cfg(feature = "xv")]
    pub(crate) use crate::protocol::xv::{self, *};
    #[cfg(feature = "xvmc")]
    pub(crate) use crate::protocol::xvmc::{self, *};
}