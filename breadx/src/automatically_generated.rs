// This file is automatically generated by the `breadx-generator` crate.
// Do not edit this file directly.

//! Contains automatically generated items.

use crate::{
    display::{Cookie, Display, DisplayExt},
    Result,
};
use __private::Sealed;
use alloc::borrow::Cow;
#[allow(unused_imports)]
use alloc::vec::Vec;
use core::borrow::Borrow;

cfg_async! {
    use crate::{display::{AsyncDisplay, AsyncDisplayExt}, futures};
    use tracing_futures::{Instrument, Instrumented};
    use __private::Sealed2;
}

pub trait DisplayFunctionsExt: Display + Sealed {
    fn bigreq_enable(&mut self) -> Result<Cookie<types::bigreq::EnableReply>> {
        let span = tracing::info_span!("bigreq_enable",);
        let _enter = span.enter();
        let request = types::bigreq::EnableRequest {};
        self.send_reply_request(request)
    }
    fn bigreq_enable_immediate(&mut self) -> Result<types::bigreq::EnableReply> {
        let cookie = self.bigreq_enable()?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "composite")]
    fn composite_query_version(
        &mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Result<Cookie<types::composite::QueryVersionReply>> {
        let span = tracing::info_span!(
            "composite_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::composite::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_query_version_immediate(
        &mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Result<types::composite::QueryVersionReply> {
        let cookie = self.composite_query_version(client_major_version, client_minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_window(
        &mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_redirect_window",
            window = ?window,
            update = ?update,
        );
        let _enter = span.enter();
        let request = types::composite::RedirectWindowRequest { window, update };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_window_checked(
        &mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Result<()> {
        let cookie = self.composite_redirect_window(window, update)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_subwindows(
        &mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_redirect_subwindows",
            window = ?window,
            update = ?update,
        );
        let _enter = span.enter();
        let request = types::composite::RedirectSubwindowsRequest { window, update };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_subwindows_checked(
        &mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Result<()> {
        let cookie = self.composite_redirect_subwindows(window, update)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_window(
        &mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_unredirect_window",
            window = ?window,
            update = ?update,
        );
        let _enter = span.enter();
        let request = types::composite::UnredirectWindowRequest { window, update };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_window_checked(
        &mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Result<()> {
        let cookie = self.composite_unredirect_window(window, update)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_subwindows(
        &mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_unredirect_subwindows",
            window = ?window,
            update = ?update,
        );
        let _enter = span.enter();
        let request = types::composite::UnredirectSubwindowsRequest { window, update };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_subwindows_checked(
        &mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Result<()> {
        let cookie = self.composite_unredirect_subwindows(window, update)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_create_region_from_border_clip(
        &mut self,
        region: types::Region,
        window: types::xproto::Window,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_create_region_from_border_clip",
            region = ?region,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::composite::CreateRegionFromBorderClipRequest { region, window };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_create_region_from_border_clip_checked(
        &mut self,
        region: types::Region,
        window: types::xproto::Window,
    ) -> Result<()> {
        let cookie = self.composite_create_region_from_border_clip(region, window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_name_window_pixmap(
        &mut self,
        window: types::xproto::Window,
        pixmap: types::xproto::Pixmap,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_name_window_pixmap",
            window = ?window,
            pixmap = ?pixmap,
        );
        let _enter = span.enter();
        let request = types::composite::NameWindowPixmapRequest { window, pixmap };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_name_window_pixmap_checked(
        &mut self,
        window: types::xproto::Window,
        pixmap: types::xproto::Pixmap,
    ) -> Result<()> {
        let cookie = self.composite_name_window_pixmap(window, pixmap)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_get_overlay_window(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::composite::GetOverlayWindowReply>> {
        let span = tracing::info_span!(
            "composite_get_overlay_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::composite::GetOverlayWindowRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_get_overlay_window_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::composite::GetOverlayWindowReply> {
        let cookie = self.composite_get_overlay_window(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "composite")]
    fn composite_release_overlay_window(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "composite_release_overlay_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::composite::ReleaseOverlayWindowRequest { window };
        self.send_void_request(request)
    }
    #[cfg(feature = "composite")]
    fn composite_release_overlay_window_checked(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<()> {
        let cookie = self.composite_release_overlay_window(window)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "damage")]
    fn damage_query_version(
        &mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Result<Cookie<types::damage::QueryVersionReply>> {
        let span = tracing::info_span!(
            "damage_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::damage::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_query_version_immediate(
        &mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Result<types::damage::QueryVersionReply> {
        let cookie = self.damage_query_version(client_major_version, client_minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "damage")]
    fn damage_create(
        &mut self,
        damage: types::Damage,
        drawable: types::xproto::Drawable,
        level: types::ReportLevel,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "damage_create",
            damage = ?damage,
            drawable = ?drawable,
            level = ?level,
        );
        let _enter = span.enter();
        let request = types::damage::CreateRequest {
            damage,
            drawable,
            level,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_create_checked(
        &mut self,
        damage: types::Damage,
        drawable: types::xproto::Drawable,
        level: types::ReportLevel,
    ) -> Result<()> {
        let cookie = self.damage_create(damage, drawable, level)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "damage")]
    fn damage_destroy(&mut self, damage: types::Damage) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "damage_destroy",
            damage = ?damage,
        );
        let _enter = span.enter();
        let request = types::damage::DestroyRequest { damage };
        self.send_void_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_destroy_checked(&mut self, damage: types::Damage) -> Result<()> {
        let cookie = self.damage_destroy(damage)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "damage")]
    fn damage_subtract(
        &mut self,
        damage: types::Damage,
        repair: impl Into<types::Region>,
        parts: impl Into<types::Region>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "damage_subtract",
            damage = ?damage,
        );
        let _enter = span.enter();
        let request = types::damage::SubtractRequest {
            damage,
            repair: Into::<u32>::into(repair.into()) as _,
            parts: Into::<u32>::into(parts.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_subtract_checked(
        &mut self,
        damage: types::Damage,
        repair: impl Into<types::Region>,
        parts: impl Into<types::Region>,
    ) -> Result<()> {
        let cookie = self.damage_subtract(damage, repair, parts)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "damage")]
    fn damage_add(
        &mut self,
        drawable: types::xproto::Drawable,
        region: types::Region,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "damage_add",
            drawable = ?drawable,
            region = ?region,
        );
        let _enter = span.enter();
        let request = types::damage::AddRequest { drawable, region };
        self.send_void_request(request)
    }
    #[cfg(feature = "damage")]
    fn damage_add_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        region: types::Region,
    ) -> Result<()> {
        let cookie = self.damage_add(drawable, region)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "dpms")]
    fn dpms_get_version(
        &mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Result<Cookie<types::dpms::GetVersionReply>> {
        let span = tracing::info_span!(
            "dpms_get_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::dpms::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_version_immediate(
        &mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Result<types::dpms::GetVersionReply> {
        let cookie = self.dpms_get_version(client_major_version, client_minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_capable(&mut self) -> Result<Cookie<types::dpms::CapableReply>> {
        let span = tracing::info_span!("dpms_capable",);
        let _enter = span.enter();
        let request = types::dpms::CapableRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_capable_immediate(&mut self) -> Result<types::dpms::CapableReply> {
        let cookie = self.dpms_capable()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_timeouts(&mut self) -> Result<Cookie<types::dpms::GetTimeoutsReply>> {
        let span = tracing::info_span!("dpms_get_timeouts",);
        let _enter = span.enter();
        let request = types::dpms::GetTimeoutsRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_timeouts_immediate(&mut self) -> Result<types::dpms::GetTimeoutsReply> {
        let cookie = self.dpms_get_timeouts()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_set_timeouts(
        &mut self,
        standby_timeout: types::Card16,
        suspend_timeout: types::Card16,
        off_timeout: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dpms_set_timeouts",
            standby_timeout = ?standby_timeout,
            suspend_timeout = ?suspend_timeout,
            off_timeout = ?off_timeout,
        );
        let _enter = span.enter();
        let request = types::dpms::SetTimeoutsRequest {
            standby_timeout,
            suspend_timeout,
            off_timeout,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_set_timeouts_checked(
        &mut self,
        standby_timeout: types::Card16,
        suspend_timeout: types::Card16,
        off_timeout: types::Card16,
    ) -> Result<()> {
        let cookie = self.dpms_set_timeouts(standby_timeout, suspend_timeout, off_timeout)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_enable(&mut self) -> Result<Cookie<()>> {
        let span = tracing::info_span!("dpms_enable",);
        let _enter = span.enter();
        let request = types::dpms::EnableRequest {};
        self.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_enable_checked(&mut self) -> Result<()> {
        let cookie = self.dpms_enable()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_disable(&mut self) -> Result<Cookie<()>> {
        let span = tracing::info_span!("dpms_disable",);
        let _enter = span.enter();
        let request = types::dpms::DisableRequest {};
        self.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_disable_checked(&mut self) -> Result<()> {
        let cookie = self.dpms_disable()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_force_level(&mut self, power_level: types::DPMSMode) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dpms_force_level",
            power_level = ?power_level,
        );
        let _enter = span.enter();
        let request = types::dpms::ForceLevelRequest { power_level };
        self.send_void_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_force_level_checked(&mut self, power_level: types::DPMSMode) -> Result<()> {
        let cookie = self.dpms_force_level(power_level)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dpms")]
    fn dpms_info(&mut self) -> Result<Cookie<types::dpms::InfoReply>> {
        let span = tracing::info_span!("dpms_info",);
        let _enter = span.enter();
        let request = types::dpms::InfoRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "dpms")]
    fn dpms_info_immediate(&mut self) -> Result<types::dpms::InfoReply> {
        let cookie = self.dpms_info()?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "dri2")]
    fn dri2_query_version(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Result<Cookie<types::dri2::QueryVersionReply>> {
        let span = tracing::info_span!(
            "dri2_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::dri2::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_query_version_immediate(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Result<types::dri2::QueryVersionReply> {
        let cookie = self.dri2_query_version(major_version, minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_connect(
        &mut self,
        window: types::xproto::Window,
        driver_type: types::DriverType,
    ) -> Result<Cookie<types::dri2::ConnectReply>> {
        let span = tracing::info_span!(
            "dri2_connect",
            window = ?window,
            driver_type = ?driver_type,
        );
        let _enter = span.enter();
        let request = types::dri2::ConnectRequest {
            window,
            driver_type,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_connect_immediate(
        &mut self,
        window: types::xproto::Window,
        driver_type: types::DriverType,
    ) -> Result<types::dri2::ConnectReply> {
        let cookie = self.dri2_connect(window, driver_type)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_authenticate(
        &mut self,
        window: types::xproto::Window,
        magic: types::Card32,
    ) -> Result<Cookie<types::dri2::AuthenticateReply>> {
        let span = tracing::info_span!(
            "dri2_authenticate",
            window = ?window,
            magic = ?magic,
        );
        let _enter = span.enter();
        let request = types::dri2::AuthenticateRequest { window, magic };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_authenticate_immediate(
        &mut self,
        window: types::xproto::Window,
        magic: types::Card32,
    ) -> Result<types::dri2::AuthenticateReply> {
        let cookie = self.dri2_authenticate(window, magic)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_create_drawable(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri2_create_drawable",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::dri2::CreateDrawableRequest { drawable };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_create_drawable_checked(&mut self, drawable: types::xproto::Drawable) -> Result<()> {
        let cookie = self.dri2_create_drawable(drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_destroy_drawable(&mut self, drawable: types::xproto::Drawable) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri2_destroy_drawable",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::dri2::DestroyDrawableRequest { drawable };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_destroy_drawable_checked(&mut self, drawable: types::xproto::Drawable) -> Result<()> {
        let cookie = self.dri2_destroy_drawable(drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_copy_region(
        &mut self,
        drawable: types::xproto::Drawable,
        region: types::Card32,
        dest: types::Card32,
        src: types::Card32,
    ) -> Result<Cookie<types::dri2::CopyRegionReply>> {
        let span = tracing::info_span!(
            "dri2_copy_region",
            drawable = ?drawable,
            region = ?region,
            dest = ?dest,
            src = ?src,
        );
        let _enter = span.enter();
        let request = types::dri2::CopyRegionRequest {
            drawable,
            region,
            dest,
            src,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_copy_region_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
        region: types::Card32,
        dest: types::Card32,
        src: types::Card32,
    ) -> Result<types::dri2::CopyRegionReply> {
        let cookie = self.dri2_copy_region(drawable, region, dest, src)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_buffers(
        &mut self,
        drawable: types::xproto::Drawable,
        target_msc_hi: types::Card32,
        target_msc_lo: types::Card32,
        divisor_hi: types::Card32,
        divisor_lo: types::Card32,
        remainder_hi: types::Card32,
        remainder_lo: types::Card32,
    ) -> Result<Cookie<types::dri2::SwapBuffersReply>> {
        let span = tracing::info_span!(
            "dri2_swap_buffers",
            drawable = ?drawable,
            target_msc_hi = ?target_msc_hi,
            target_msc_lo = ?target_msc_lo,
            divisor_hi = ?divisor_hi,
            divisor_lo = ?divisor_lo,
            remainder_hi = ?remainder_hi,
            remainder_lo = ?remainder_lo,
        );
        let _enter = span.enter();
        let request = types::dri2::SwapBuffersRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_buffers_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
        target_msc_hi: types::Card32,
        target_msc_lo: types::Card32,
        divisor_hi: types::Card32,
        divisor_lo: types::Card32,
        remainder_hi: types::Card32,
        remainder_lo: types::Card32,
    ) -> Result<types::dri2::SwapBuffersReply> {
        let cookie = self.dri2_swap_buffers(
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_msc(
        &mut self,
        drawable: types::xproto::Drawable,
    ) -> Result<Cookie<types::dri2::GetMSCReply>> {
        let span = tracing::info_span!(
            "dri2_get_msc",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::dri2::GetMSCRequest { drawable };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_msc_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
    ) -> Result<types::dri2::GetMSCReply> {
        let cookie = self.dri2_get_msc(drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_msc(
        &mut self,
        drawable: types::xproto::Drawable,
        target_msc_hi: types::Card32,
        target_msc_lo: types::Card32,
        divisor_hi: types::Card32,
        divisor_lo: types::Card32,
        remainder_hi: types::Card32,
        remainder_lo: types::Card32,
    ) -> Result<Cookie<types::dri2::WaitMSCReply>> {
        let span = tracing::info_span!(
            "dri2_wait_msc",
            drawable = ?drawable,
            target_msc_hi = ?target_msc_hi,
            target_msc_lo = ?target_msc_lo,
            divisor_hi = ?divisor_hi,
            divisor_lo = ?divisor_lo,
            remainder_hi = ?remainder_hi,
            remainder_lo = ?remainder_lo,
        );
        let _enter = span.enter();
        let request = types::dri2::WaitMSCRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_msc_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
        target_msc_hi: types::Card32,
        target_msc_lo: types::Card32,
        divisor_hi: types::Card32,
        divisor_lo: types::Card32,
        remainder_hi: types::Card32,
        remainder_lo: types::Card32,
    ) -> Result<types::dri2::WaitMSCReply> {
        let cookie = self.dri2_wait_msc(
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_sbc(
        &mut self,
        drawable: types::xproto::Drawable,
        target_sbc_hi: types::Card32,
        target_sbc_lo: types::Card32,
    ) -> Result<Cookie<types::dri2::WaitSBCReply>> {
        let span = tracing::info_span!(
            "dri2_wait_sbc",
            drawable = ?drawable,
            target_sbc_hi = ?target_sbc_hi,
            target_sbc_lo = ?target_sbc_lo,
        );
        let _enter = span.enter();
        let request = types::dri2::WaitSBCRequest {
            drawable,
            target_sbc_hi,
            target_sbc_lo,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_sbc_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
        target_sbc_hi: types::Card32,
        target_sbc_lo: types::Card32,
    ) -> Result<types::dri2::WaitSBCReply> {
        let cookie = self.dri2_wait_sbc(drawable, target_sbc_hi, target_sbc_lo)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_interval(
        &mut self,
        drawable: types::xproto::Drawable,
        interval: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri2_swap_interval",
            drawable = ?drawable,
            interval = ?interval,
        );
        let _enter = span.enter();
        let request = types::dri2::SwapIntervalRequest { drawable, interval };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_interval_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        interval: types::Card32,
    ) -> Result<()> {
        let cookie = self.dri2_swap_interval(drawable, interval)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_param(
        &mut self,
        drawable: types::xproto::Drawable,
        param: types::Card32,
    ) -> Result<Cookie<types::dri2::GetParamReply>> {
        let span = tracing::info_span!(
            "dri2_get_param",
            drawable = ?drawable,
            param = ?param,
        );
        let _enter = span.enter();
        let request = types::dri2::GetParamRequest { drawable, param };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_param_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
        param: types::Card32,
    ) -> Result<types::dri2::GetParamReply> {
        let cookie = self.dri2_get_param(drawable, param)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "dri3")]
    fn dri3_query_version(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Result<Cookie<types::dri3::QueryVersionReply>> {
        let span = tracing::info_span!(
            "dri3_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::dri3::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_query_version_immediate(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Result<types::dri3::QueryVersionReply> {
        let cookie = self.dri3_query_version(major_version, minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_open(
        &mut self,
        drawable: types::xproto::Drawable,
        provider: types::Card32,
    ) -> Result<Cookie<types::dri3::OpenReply>> {
        let span = tracing::info_span!(
            "dri3_open",
            drawable = ?drawable,
            provider = ?provider,
        );
        let _enter = span.enter();
        let request = types::dri3::OpenRequest { drawable, provider };
        self.send_reply_fd_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_open_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
        provider: types::Card32,
    ) -> Result<types::dri3::OpenReply> {
        let cookie = self.dri3_open(drawable, provider)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffer(
        &mut self,
        pixmap: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        size: types::Card32,
        width: types::Card16,
        height: types::Card16,
        stride: types::Card16,
        depth: types::Card8,
        bpp: types::Card8,
        pixmap_fd: types::Fd,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri3_pixmap_from_buffer",
            pixmap = ?pixmap,
            drawable = ?drawable,
            size = ?size,
            width = ?width,
            height = ?height,
            stride = ?stride,
            depth = ?depth,
            bpp = ?bpp,
            pixmap_fd = ?pixmap_fd,
        );
        let _enter = span.enter();
        let request = types::dri3::PixmapFromBufferRequest {
            pixmap,
            drawable,
            size,
            width,
            height,
            stride,
            depth,
            bpp,
            pixmap_fd,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffer_checked(
        &mut self,
        pixmap: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        size: types::Card32,
        width: types::Card16,
        height: types::Card16,
        stride: types::Card16,
        depth: types::Card8,
        bpp: types::Card8,
        pixmap_fd: types::Fd,
    ) -> Result<()> {
        let cookie = self.dri3_pixmap_from_buffer(
            pixmap, drawable, size, width, height, stride, depth, bpp, pixmap_fd,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffer_from_pixmap(
        &mut self,
        pixmap: types::xproto::Pixmap,
    ) -> Result<Cookie<types::dri3::BufferFromPixmapReply>> {
        let span = tracing::info_span!(
            "dri3_buffer_from_pixmap",
            pixmap = ?pixmap,
        );
        let _enter = span.enter();
        let request = types::dri3::BufferFromPixmapRequest { pixmap };
        self.send_reply_fd_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffer_from_pixmap_immediate(
        &mut self,
        pixmap: types::xproto::Pixmap,
    ) -> Result<types::dri3::BufferFromPixmapReply> {
        let cookie = self.dri3_buffer_from_pixmap(pixmap)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fence_from_fd(
        &mut self,
        drawable: types::xproto::Drawable,
        fence: types::Card32,
        initially_triggered: types::Bool,
        fence_fd: types::Fd,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri3_fence_from_fd",
            drawable = ?drawable,
            fence = ?fence,
            initially_triggered = ?initially_triggered,
            fence_fd = ?fence_fd,
        );
        let _enter = span.enter();
        let request = types::dri3::FenceFromFDRequest {
            drawable,
            fence,
            initially_triggered,
            fence_fd,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fence_from_fd_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        fence: types::Card32,
        initially_triggered: types::Bool,
        fence_fd: types::Fd,
    ) -> Result<()> {
        let cookie = self.dri3_fence_from_fd(drawable, fence, initially_triggered, fence_fd)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fd_from_fence(
        &mut self,
        drawable: types::xproto::Drawable,
        fence: types::Card32,
    ) -> Result<Cookie<types::dri3::FDFromFenceReply>> {
        let span = tracing::info_span!(
            "dri3_fd_from_fence",
            drawable = ?drawable,
            fence = ?fence,
        );
        let _enter = span.enter();
        let request = types::dri3::FDFromFenceRequest { drawable, fence };
        self.send_reply_fd_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fd_from_fence_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
        fence: types::Card32,
    ) -> Result<types::dri3::FDFromFenceReply> {
        let cookie = self.dri3_fd_from_fence(drawable, fence)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_get_supported_modifiers(
        &mut self,
        window: types::Card32,
        depth: types::Card8,
        bpp: types::Card8,
    ) -> Result<Cookie<types::dri3::GetSupportedModifiersReply>> {
        let span = tracing::info_span!(
            "dri3_get_supported_modifiers",
            window = ?window,
            depth = ?depth,
            bpp = ?bpp,
        );
        let _enter = span.enter();
        let request = types::dri3::GetSupportedModifiersRequest { window, depth, bpp };
        self.send_reply_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_get_supported_modifiers_immediate(
        &mut self,
        window: types::Card32,
        depth: types::Card8,
        bpp: types::Card8,
    ) -> Result<types::dri3::GetSupportedModifiersReply> {
        let cookie = self.dri3_get_supported_modifiers(window, depth, bpp)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffers(
        &mut self,
        pixmap: types::xproto::Pixmap,
        window: types::xproto::Window,
        width: types::Card16,
        height: types::Card16,
        stride0: types::Card32,
        offset0: types::Card32,
        stride1: types::Card32,
        offset1: types::Card32,
        stride2: types::Card32,
        offset2: types::Card32,
        stride3: types::Card32,
        offset3: types::Card32,
        depth: types::Card8,
        bpp: types::Card8,
        modifier: types::Card64,
        buffers: Vec<types::Fd>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "dri3_pixmap_from_buffers",
            pixmap = ?pixmap,
            window = ?window,
            width = ?width,
            height = ?height,
            stride0 = ?stride0,
            offset0 = ?offset0,
            stride1 = ?stride1,
            offset1 = ?offset1,
            stride2 = ?stride2,
            offset2 = ?offset2,
            stride3 = ?stride3,
            offset3 = ?offset3,
            depth = ?depth,
            bpp = ?bpp,
            modifier = ?modifier,
        );
        let _enter = span.enter();
        let request = types::dri3::PixmapFromBuffersRequest {
            pixmap,
            window,
            width,
            height,
            stride0,
            offset0,
            stride1,
            offset1,
            stride2,
            offset2,
            stride3,
            offset3,
            depth,
            bpp,
            modifier,
            buffers,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffers_checked(
        &mut self,
        pixmap: types::xproto::Pixmap,
        window: types::xproto::Window,
        width: types::Card16,
        height: types::Card16,
        stride0: types::Card32,
        offset0: types::Card32,
        stride1: types::Card32,
        offset1: types::Card32,
        stride2: types::Card32,
        offset2: types::Card32,
        stride3: types::Card32,
        offset3: types::Card32,
        depth: types::Card8,
        bpp: types::Card8,
        modifier: types::Card64,
        buffers: Vec<types::Fd>,
    ) -> Result<()> {
        let cookie = self.dri3_pixmap_from_buffers(
            pixmap, window, width, height, stride0, offset0, stride1, offset1, stride2, offset2,
            stride3, offset3, depth, bpp, modifier, buffers,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffers_from_pixmap(
        &mut self,
        pixmap: types::xproto::Pixmap,
    ) -> Result<Cookie<types::dri3::BuffersFromPixmapReply>> {
        let span = tracing::info_span!(
            "dri3_buffers_from_pixmap",
            pixmap = ?pixmap,
        );
        let _enter = span.enter();
        let request = types::dri3::BuffersFromPixmapRequest { pixmap };
        self.send_reply_fd_request(request)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffers_from_pixmap_immediate(
        &mut self,
        pixmap: types::xproto::Pixmap,
    ) -> Result<types::dri3::BuffersFromPixmapReply> {
        let cookie = self.dri3_buffers_from_pixmap(pixmap)?;
        self.wait_for_reply(cookie)
    }

    fn ge_query_version(
        &mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Result<Cookie<types::ge::QueryVersionReply>> {
        let span = tracing::info_span!(
            "ge_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::ge::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    fn ge_query_version_immediate(
        &mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Result<types::ge::QueryVersionReply> {
        let cookie = self.ge_query_version(client_major_version, client_minor_version)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "glx")]
    fn glx_render(
        &mut self,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_render",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::RenderRequest {
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_render_checked(
        &mut self,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<()> {
        let cookie = self.glx_render(context_tag, data)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_render_large(
        &mut self,
        context_tag: types::ContextTag,
        request_num: types::Card16,
        request_total: types::Card16,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_render_large",
            context_tag = ?context_tag,
            request_num = ?request_num,
            request_total = ?request_total,
        );
        let _enter = span.enter();
        let request = types::glx::RenderLargeRequest {
            context_tag,
            request_num,
            request_total,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_render_large_checked(
        &mut self,
        context_tag: types::ContextTag,
        request_num: types::Card16,
        request_total: types::Card16,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<()> {
        let cookie = self.glx_render_large(context_tag, request_num, request_total, data)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context(
        &mut self,
        context: types::glx::Context,
        visual: types::Visualid,
        screen: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_context",
            context = ?context,
            visual = ?visual,
            screen = ?screen,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let _enter = span.enter();
        let request = types::glx::CreateContextRequest {
            context,
            visual,
            screen,
            share_list,
            is_direct,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_checked(
        &mut self,
        context: types::glx::Context,
        visual: types::Visualid,
        screen: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
    ) -> Result<()> {
        let cookie = self.glx_create_context(context, visual, screen, share_list, is_direct)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_context(&mut self, context: types::glx::Context) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_destroy_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::glx::DestroyContextRequest { context };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_context_checked(&mut self, context: types::glx::Context) -> Result<()> {
        let cookie = self.glx_destroy_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_make_current(
        &mut self,
        drawable: types::glx::Drawable,
        context: types::glx::Context,
        old_context_tag: types::ContextTag,
    ) -> Result<Cookie<types::glx::MakeCurrentReply>> {
        let span = tracing::info_span!(
            "glx_make_current",
            drawable = ?drawable,
            context = ?context,
            old_context_tag = ?old_context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::MakeCurrentRequest {
            drawable,
            context,
            old_context_tag,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_make_current_immediate(
        &mut self,
        drawable: types::glx::Drawable,
        context: types::glx::Context,
        old_context_tag: types::ContextTag,
    ) -> Result<types::glx::MakeCurrentReply> {
        let cookie = self.glx_make_current(drawable, context, old_context_tag)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_is_direct(
        &mut self,
        context: types::glx::Context,
    ) -> Result<Cookie<types::glx::IsDirectReply>> {
        let span = tracing::info_span!(
            "glx_is_direct",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::glx::IsDirectRequest { context };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_direct_immediate(
        &mut self,
        context: types::glx::Context,
    ) -> Result<types::glx::IsDirectReply> {
        let cookie = self.glx_is_direct(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_query_version(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Result<Cookie<types::glx::QueryVersionReply>> {
        let span = tracing::info_span!(
            "glx_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::glx::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_version_immediate(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Result<types::glx::QueryVersionReply> {
        let cookie = self.glx_query_version(major_version, minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_gl(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_wait_gl",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::WaitGLRequest { context_tag };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_gl_checked(&mut self, context_tag: types::ContextTag) -> Result<()> {
        let cookie = self.glx_wait_gl(context_tag)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_x(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_wait_x",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::WaitXRequest { context_tag };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_x_checked(&mut self, context_tag: types::ContextTag) -> Result<()> {
        let cookie = self.glx_wait_x(context_tag)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_copy_context(
        &mut self,
        src: types::glx::Context,
        dest: types::glx::Context,
        mask: types::Card32,
        src_context_tag: types::ContextTag,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_copy_context",
            src = ?src,
            dest = ?dest,
            mask = ?mask,
            src_context_tag = ?src_context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::CopyContextRequest {
            src,
            dest,
            mask,
            src_context_tag,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_copy_context_checked(
        &mut self,
        src: types::glx::Context,
        dest: types::glx::Context,
        mask: types::Card32,
        src_context_tag: types::ContextTag,
    ) -> Result<()> {
        let cookie = self.glx_copy_context(src, dest, mask, src_context_tag)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_swap_buffers(
        &mut self,
        context_tag: types::ContextTag,
        drawable: types::glx::Drawable,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_swap_buffers",
            context_tag = ?context_tag,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::glx::SwapBuffersRequest {
            context_tag,
            drawable,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_swap_buffers_checked(
        &mut self,
        context_tag: types::ContextTag,
        drawable: types::glx::Drawable,
    ) -> Result<()> {
        let cookie = self.glx_swap_buffers(context_tag, drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_use_x_font(
        &mut self,
        context_tag: types::ContextTag,
        font: types::Font,
        first: types::Card32,
        count: types::Card32,
        list_base: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_use_x_font",
            context_tag = ?context_tag,
            font = ?font,
            first = ?first,
            count = ?count,
            list_base = ?list_base,
        );
        let _enter = span.enter();
        let request = types::glx::UseXFontRequest {
            context_tag,
            font,
            first,
            count,
            list_base,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_use_x_font_checked(
        &mut self,
        context_tag: types::ContextTag,
        font: types::Font,
        first: types::Card32,
        count: types::Card32,
        list_base: types::Card32,
    ) -> Result<()> {
        let cookie = self.glx_use_x_font(context_tag, font, first, count, list_base)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_glx_pixmap(
        &mut self,
        screen: types::Card32,
        visual: types::Visualid,
        pixmap: types::xproto::Pixmap,
        glx_pixmap: types::glx::Pixmap,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_glx_pixmap",
            screen = ?screen,
            visual = ?visual,
            pixmap = ?pixmap,
            glx_pixmap = ?glx_pixmap,
        );
        let _enter = span.enter();
        let request = types::glx::CreateGLXPixmapRequest {
            screen,
            visual,
            pixmap,
            glx_pixmap,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_glx_pixmap_checked(
        &mut self,
        screen: types::Card32,
        visual: types::Visualid,
        pixmap: types::xproto::Pixmap,
        glx_pixmap: types::glx::Pixmap,
    ) -> Result<()> {
        let cookie = self.glx_create_glx_pixmap(screen, visual, pixmap, glx_pixmap)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_visual_configs(
        &mut self,
        screen: types::Card32,
    ) -> Result<Cookie<types::glx::GetVisualConfigsReply>> {
        let span = tracing::info_span!(
            "glx_get_visual_configs",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::glx::GetVisualConfigsRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_visual_configs_immediate(
        &mut self,
        screen: types::Card32,
    ) -> Result<types::glx::GetVisualConfigsReply> {
        let cookie = self.glx_get_visual_configs(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_glx_pixmap(&mut self, glx_pixmap: types::glx::Pixmap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_destroy_glx_pixmap",
            glx_pixmap = ?glx_pixmap,
        );
        let _enter = span.enter();
        let request = types::glx::DestroyGLXPixmapRequest { glx_pixmap };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_glx_pixmap_checked(&mut self, glx_pixmap: types::glx::Pixmap) -> Result<()> {
        let cookie = self.glx_destroy_glx_pixmap(glx_pixmap)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private(
        &mut self,
        vendor_code: types::Card32,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_vendor_private",
            vendor_code = ?vendor_code,
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::VendorPrivateRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_checked(
        &mut self,
        vendor_code: types::Card32,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<()> {
        let cookie = self.glx_vendor_private(vendor_code, context_tag, data)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_with_reply(
        &mut self,
        vendor_code: types::Card32,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<types::glx::VendorPrivateWithReplyReply>> {
        let span = tracing::info_span!(
            "glx_vendor_private_with_reply",
            vendor_code = ?vendor_code,
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::VendorPrivateWithReplyRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_with_reply_immediate(
        &mut self,
        vendor_code: types::Card32,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<types::glx::VendorPrivateWithReplyReply> {
        let cookie = self.glx_vendor_private_with_reply(vendor_code, context_tag, data)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_query_extensions_string(
        &mut self,
        screen: types::Card32,
    ) -> Result<Cookie<types::glx::QueryExtensionsStringReply>> {
        let span = tracing::info_span!(
            "glx_query_extensions_string",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::glx::QueryExtensionsStringRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_extensions_string_immediate(
        &mut self,
        screen: types::Card32,
    ) -> Result<types::glx::QueryExtensionsStringReply> {
        let cookie = self.glx_query_extensions_string(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_query_server_string(
        &mut self,
        screen: types::Card32,
        name: types::Card32,
    ) -> Result<Cookie<types::glx::QueryServerStringReply>> {
        let span = tracing::info_span!(
            "glx_query_server_string",
            screen = ?screen,
            name = ?name,
        );
        let _enter = span.enter();
        let request = types::glx::QueryServerStringRequest { screen, name };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_server_string_immediate(
        &mut self,
        screen: types::Card32,
        name: types::Card32,
    ) -> Result<types::glx::QueryServerStringReply> {
        let cookie = self.glx_query_server_string(screen, name)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_client_info(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        string: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_client_info",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::glx::ClientInfoRequest {
            major_version,
            minor_version,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_client_info_checked(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        string: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.glx_client_info(major_version, minor_version, string)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_fb_configs(
        &mut self,
        screen: types::Card32,
    ) -> Result<Cookie<types::glx::GetFBConfigsReply>> {
        let span = tracing::info_span!(
            "glx_get_fb_configs",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::glx::GetFBConfigsRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_fb_configs_immediate(
        &mut self,
        screen: types::Card32,
    ) -> Result<types::glx::GetFBConfigsReply> {
        let cookie = self.glx_get_fb_configs(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pixmap(
        &mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        pixmap: types::xproto::Pixmap,
        glx_pixmap: types::glx::Pixmap,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_pixmap",
            screen = ?screen,
            fbconfig = ?fbconfig,
            pixmap = ?pixmap,
            glx_pixmap = ?glx_pixmap,
        );
        let _enter = span.enter();
        let request = types::glx::CreatePixmapRequest {
            screen,
            fbconfig,
            pixmap,
            glx_pixmap,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pixmap_checked(
        &mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        pixmap: types::xproto::Pixmap,
        glx_pixmap: types::glx::Pixmap,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Result<()> {
        let cookie = self.glx_create_pixmap(screen, fbconfig, pixmap, glx_pixmap, attribs)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pixmap(&mut self, glx_pixmap: types::glx::Pixmap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_destroy_pixmap",
            glx_pixmap = ?glx_pixmap,
        );
        let _enter = span.enter();
        let request = types::glx::DestroyPixmapRequest { glx_pixmap };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pixmap_checked(&mut self, glx_pixmap: types::glx::Pixmap) -> Result<()> {
        let cookie = self.glx_destroy_pixmap(glx_pixmap)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_new_context(
        &mut self,
        context: types::glx::Context,
        fbconfig: types::Fbconfig,
        screen: types::Card32,
        render_type: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_new_context",
            context = ?context,
            fbconfig = ?fbconfig,
            screen = ?screen,
            render_type = ?render_type,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let _enter = span.enter();
        let request = types::glx::CreateNewContextRequest {
            context,
            fbconfig,
            screen,
            render_type,
            share_list,
            is_direct,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_new_context_checked(
        &mut self,
        context: types::glx::Context,
        fbconfig: types::Fbconfig,
        screen: types::Card32,
        render_type: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
    ) -> Result<()> {
        let cookie = self.glx_create_new_context(
            context,
            fbconfig,
            screen,
            render_type,
            share_list,
            is_direct,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_query_context(
        &mut self,
        context: types::glx::Context,
    ) -> Result<Cookie<types::glx::QueryContextReply>> {
        let span = tracing::info_span!(
            "glx_query_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::glx::QueryContextRequest { context };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_query_context_immediate(
        &mut self,
        context: types::glx::Context,
    ) -> Result<types::glx::QueryContextReply> {
        let cookie = self.glx_query_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_make_context_current(
        &mut self,
        old_context_tag: types::ContextTag,
        drawable: types::glx::Drawable,
        read_drawable: types::glx::Drawable,
        context: types::glx::Context,
    ) -> Result<Cookie<types::glx::MakeContextCurrentReply>> {
        let span = tracing::info_span!(
            "glx_make_context_current",
            old_context_tag = ?old_context_tag,
            drawable = ?drawable,
            read_drawable = ?read_drawable,
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::glx::MakeContextCurrentRequest {
            old_context_tag,
            drawable,
            read_drawable,
            context,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_make_context_current_immediate(
        &mut self,
        old_context_tag: types::ContextTag,
        drawable: types::glx::Drawable,
        read_drawable: types::glx::Drawable,
        context: types::glx::Context,
    ) -> Result<types::glx::MakeContextCurrentReply> {
        let cookie =
            self.glx_make_context_current(old_context_tag, drawable, read_drawable, context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pbuffer(
        &mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        pbuffer: types::Pbuffer,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_pbuffer",
            screen = ?screen,
            fbconfig = ?fbconfig,
            pbuffer = ?pbuffer,
        );
        let _enter = span.enter();
        let request = types::glx::CreatePbufferRequest {
            screen,
            fbconfig,
            pbuffer,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pbuffer_checked(
        &mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        pbuffer: types::Pbuffer,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Result<()> {
        let cookie = self.glx_create_pbuffer(screen, fbconfig, pbuffer, attribs)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pbuffer(&mut self, pbuffer: types::Pbuffer) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_destroy_pbuffer",
            pbuffer = ?pbuffer,
        );
        let _enter = span.enter();
        let request = types::glx::DestroyPbufferRequest { pbuffer };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pbuffer_checked(&mut self, pbuffer: types::Pbuffer) -> Result<()> {
        let cookie = self.glx_destroy_pbuffer(pbuffer)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_drawable_attributes(
        &mut self,
        drawable: types::glx::Drawable,
    ) -> Result<Cookie<types::glx::GetDrawableAttributesReply>> {
        let span = tracing::info_span!(
            "glx_get_drawable_attributes",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::glx::GetDrawableAttributesRequest { drawable };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_drawable_attributes_immediate(
        &mut self,
        drawable: types::glx::Drawable,
    ) -> Result<types::glx::GetDrawableAttributesReply> {
        let cookie = self.glx_get_drawable_attributes(drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_change_drawable_attributes(
        &mut self,
        drawable: types::glx::Drawable,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_change_drawable_attributes",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::glx::ChangeDrawableAttributesRequest {
            drawable,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_change_drawable_attributes_checked(
        &mut self,
        drawable: types::glx::Drawable,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Result<()> {
        let cookie = self.glx_change_drawable_attributes(drawable, attribs)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_window(
        &mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        window: types::xproto::Window,
        glx_window: types::glx::Window,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_window",
            screen = ?screen,
            fbconfig = ?fbconfig,
            window = ?window,
            glx_window = ?glx_window,
        );
        let _enter = span.enter();
        let request = types::glx::CreateWindowRequest {
            screen,
            fbconfig,
            window,
            glx_window,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_window_checked(
        &mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        window: types::xproto::Window,
        glx_window: types::glx::Window,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Result<()> {
        let cookie = self.glx_create_window(screen, fbconfig, window, glx_window, attribs)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_window(&mut self, glxwindow: types::glx::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_delete_window",
            glxwindow = ?glxwindow,
        );
        let _enter = span.enter();
        let request = types::glx::DeleteWindowRequest { glxwindow };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_window_checked(&mut self, glxwindow: types::glx::Window) -> Result<()> {
        let cookie = self.glx_delete_window(glxwindow)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info_arb(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        gl_versions: impl AsRef<[types::Card32]>,
        gl_extension_string: impl AsRef<[types::Char]>,
        glx_extension_string: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_set_client_info_arb",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::glx::SetClientInfoARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info_arb_checked(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        gl_versions: impl AsRef<[types::Card32]>,
        gl_extension_string: impl AsRef<[types::Char]>,
        glx_extension_string: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.glx_set_client_info_arb(
            major_version,
            minor_version,
            gl_versions,
            gl_extension_string,
            glx_extension_string,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_attribs_arb(
        &mut self,
        context: types::glx::Context,
        fbconfig: types::Fbconfig,
        screen: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_create_context_attribs_arb",
            context = ?context,
            fbconfig = ?fbconfig,
            screen = ?screen,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let _enter = span.enter();
        let request = types::glx::CreateContextAttribsARBRequest {
            context,
            fbconfig,
            screen,
            share_list,
            is_direct,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_attribs_arb_checked(
        &mut self,
        context: types::glx::Context,
        fbconfig: types::Fbconfig,
        screen: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Result<()> {
        let cookie = self.glx_create_context_attribs_arb(
            context, fbconfig, screen, share_list, is_direct, attribs,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info2_arb(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        gl_versions: impl AsRef<[types::Card32]>,
        gl_extension_string: impl AsRef<[types::Char]>,
        glx_extension_string: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_set_client_info2_arb",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::glx::SetClientInfo2ARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info2_arb_checked(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        gl_versions: impl AsRef<[types::Card32]>,
        gl_extension_string: impl AsRef<[types::Char]>,
        glx_extension_string: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.glx_set_client_info2_arb(
            major_version,
            minor_version,
            gl_versions,
            gl_extension_string,
            glx_extension_string,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_new_list(
        &mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
        mode: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_new_list",
            context_tag = ?context_tag,
            list = ?list,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::glx::NewListRequest {
            context_tag,
            list,
            mode,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_new_list_checked(
        &mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
        mode: types::Card32,
    ) -> Result<()> {
        let cookie = self.glx_new_list(context_tag, list, mode)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_end_list(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_end_list",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::EndListRequest { context_tag };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_end_list_checked(&mut self, context_tag: types::ContextTag) -> Result<()> {
        let cookie = self.glx_end_list(context_tag)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_lists(
        &mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
        range: types::Int32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_delete_lists",
            context_tag = ?context_tag,
            list = ?list,
            range = ?range,
        );
        let _enter = span.enter();
        let request = types::glx::DeleteListsRequest {
            context_tag,
            list,
            range,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_lists_checked(
        &mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
        range: types::Int32,
    ) -> Result<()> {
        let cookie = self.glx_delete_lists(context_tag, list, range)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_lists(
        &mut self,
        context_tag: types::ContextTag,
        range: types::Int32,
    ) -> Result<Cookie<types::glx::GenListsReply>> {
        let span = tracing::info_span!(
            "glx_gen_lists",
            context_tag = ?context_tag,
            range = ?range,
        );
        let _enter = span.enter();
        let request = types::glx::GenListsRequest { context_tag, range };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_lists_immediate(
        &mut self,
        context_tag: types::ContextTag,
        range: types::Int32,
    ) -> Result<types::glx::GenListsReply> {
        let cookie = self.glx_gen_lists(context_tag, range)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_feedback_buffer(
        &mut self,
        context_tag: types::ContextTag,
        size: types::Int32,
        type_: types::Int32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_feedback_buffer",
            context_tag = ?context_tag,
            size = ?size,
            type_ = ?type_,
        );
        let _enter = span.enter();
        let request = types::glx::FeedbackBufferRequest {
            context_tag,
            size,
            type_,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_feedback_buffer_checked(
        &mut self,
        context_tag: types::ContextTag,
        size: types::Int32,
        type_: types::Int32,
    ) -> Result<()> {
        let cookie = self.glx_feedback_buffer(context_tag, size, type_)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_select_buffer(
        &mut self,
        context_tag: types::ContextTag,
        size: types::Int32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_select_buffer",
            context_tag = ?context_tag,
            size = ?size,
        );
        let _enter = span.enter();
        let request = types::glx::SelectBufferRequest { context_tag, size };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_select_buffer_checked(
        &mut self,
        context_tag: types::ContextTag,
        size: types::Int32,
    ) -> Result<()> {
        let cookie = self.glx_select_buffer(context_tag, size)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_render_mode(
        &mut self,
        context_tag: types::ContextTag,
        mode: types::Card32,
    ) -> Result<Cookie<types::glx::RenderModeReply>> {
        let span = tracing::info_span!(
            "glx_render_mode",
            context_tag = ?context_tag,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::glx::RenderModeRequest { context_tag, mode };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_render_mode_immediate(
        &mut self,
        context_tag: types::ContextTag,
        mode: types::Card32,
    ) -> Result<types::glx::RenderModeReply> {
        let cookie = self.glx_render_mode(context_tag, mode)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_finish(
        &mut self,
        context_tag: types::ContextTag,
    ) -> Result<Cookie<types::glx::FinishReply>> {
        let span = tracing::info_span!(
            "glx_finish",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::FinishRequest { context_tag };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_finish_immediate(
        &mut self,
        context_tag: types::ContextTag,
    ) -> Result<types::glx::FinishReply> {
        let cookie = self.glx_finish(context_tag)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storef(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
        datum: types::Float32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_pixel_storef",
            context_tag = ?context_tag,
            pname = ?pname,
            datum = ?datum,
        );
        let _enter = span.enter();
        let request = types::glx::PixelStorefRequest {
            context_tag,
            pname,
            datum,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storef_checked(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
        datum: types::Float32,
    ) -> Result<()> {
        let cookie = self.glx_pixel_storef(context_tag, pname, datum)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storei(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
        datum: types::Int32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_pixel_storei",
            context_tag = ?context_tag,
            pname = ?pname,
            datum = ?datum,
        );
        let _enter = span.enter();
        let request = types::glx::PixelStoreiRequest {
            context_tag,
            pname,
            datum,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storei_checked(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
        datum: types::Int32,
    ) -> Result<()> {
        let cookie = self.glx_pixel_storei(context_tag, pname, datum)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_read_pixels(
        &mut self,
        context_tag: types::ContextTag,
        x: types::Int32,
        y: types::Int32,
        width: types::Int32,
        height: types::Int32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        lsb_first: types::Bool,
    ) -> Result<Cookie<types::glx::ReadPixelsReply>> {
        let span = tracing::info_span!(
            "glx_read_pixels",
            context_tag = ?context_tag,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            lsb_first = ?lsb_first,
        );
        let _enter = span.enter();
        let request = types::glx::ReadPixelsRequest {
            context_tag,
            x,
            y,
            width,
            height,
            format,
            type_,
            swap_bytes,
            lsb_first,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_read_pixels_immediate(
        &mut self,
        context_tag: types::ContextTag,
        x: types::Int32,
        y: types::Int32,
        width: types::Int32,
        height: types::Int32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        lsb_first: types::Bool,
    ) -> Result<types::glx::ReadPixelsReply> {
        let cookie = self.glx_read_pixels(
            context_tag,
            x,
            y,
            width,
            height,
            format,
            type_,
            swap_bytes,
            lsb_first,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_booleanv(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Int32,
    ) -> Result<Cookie<types::glx::GetBooleanvReply>> {
        let span = tracing::info_span!(
            "glx_get_booleanv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetBooleanvRequest { context_tag, pname };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_booleanv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Int32,
    ) -> Result<types::glx::GetBooleanvReply> {
        let cookie = self.glx_get_booleanv(context_tag, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_clip_plane(
        &mut self,
        context_tag: types::ContextTag,
        plane: types::Int32,
    ) -> Result<Cookie<types::glx::GetClipPlaneReply>> {
        let span = tracing::info_span!(
            "glx_get_clip_plane",
            context_tag = ?context_tag,
            plane = ?plane,
        );
        let _enter = span.enter();
        let request = types::glx::GetClipPlaneRequest { context_tag, plane };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_clip_plane_immediate(
        &mut self,
        context_tag: types::ContextTag,
        plane: types::Int32,
    ) -> Result<types::glx::GetClipPlaneReply> {
        let cookie = self.glx_get_clip_plane(context_tag, plane)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_doublev(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetDoublevReply>> {
        let span = tracing::info_span!(
            "glx_get_doublev",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetDoublevRequest { context_tag, pname };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_doublev_immediate(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Result<types::glx::GetDoublevReply> {
        let cookie = self.glx_get_doublev(context_tag, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_error(
        &mut self,
        context_tag: types::ContextTag,
    ) -> Result<Cookie<types::glx::GetErrorReply>> {
        let span = tracing::info_span!(
            "glx_get_error",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::GetErrorRequest { context_tag };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_error_immediate(
        &mut self,
        context_tag: types::ContextTag,
    ) -> Result<types::glx::GetErrorReply> {
        let cookie = self.glx_get_error(context_tag)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_floatv(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetFloatvReply>> {
        let span = tracing::info_span!(
            "glx_get_floatv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetFloatvRequest { context_tag, pname };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_floatv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Result<types::glx::GetFloatvReply> {
        let cookie = self.glx_get_floatv(context_tag, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_integerv(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetIntegervReply>> {
        let span = tracing::info_span!(
            "glx_get_integerv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetIntegervRequest { context_tag, pname };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_integerv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Result<types::glx::GetIntegervReply> {
        let cookie = self.glx_get_integerv(context_tag, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightfv(
        &mut self,
        context_tag: types::ContextTag,
        light: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetLightfvReply>> {
        let span = tracing::info_span!(
            "glx_get_lightfv",
            context_tag = ?context_tag,
            light = ?light,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetLightfvRequest {
            context_tag,
            light,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        light: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetLightfvReply> {
        let cookie = self.glx_get_lightfv(context_tag, light, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightiv(
        &mut self,
        context_tag: types::ContextTag,
        light: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetLightivReply>> {
        let span = tracing::info_span!(
            "glx_get_lightiv",
            context_tag = ?context_tag,
            light = ?light,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetLightivRequest {
            context_tag,
            light,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightiv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        light: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetLightivReply> {
        let cookie = self.glx_get_lightiv(context_tag, light, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapdv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Result<Cookie<types::glx::GetMapdvReply>> {
        let span = tracing::info_span!(
            "glx_get_mapdv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let _enter = span.enter();
        let request = types::glx::GetMapdvRequest {
            context_tag,
            target,
            query,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapdv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Result<types::glx::GetMapdvReply> {
        let cookie = self.glx_get_mapdv(context_tag, target, query)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapfv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Result<Cookie<types::glx::GetMapfvReply>> {
        let span = tracing::info_span!(
            "glx_get_mapfv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let _enter = span.enter();
        let request = types::glx::GetMapfvRequest {
            context_tag,
            target,
            query,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Result<types::glx::GetMapfvReply> {
        let cookie = self.glx_get_mapfv(context_tag, target, query)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapiv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Result<Cookie<types::glx::GetMapivReply>> {
        let span = tracing::info_span!(
            "glx_get_mapiv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let _enter = span.enter();
        let request = types::glx::GetMapivRequest {
            context_tag,
            target,
            query,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapiv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Result<types::glx::GetMapivReply> {
        let cookie = self.glx_get_mapiv(context_tag, target, query)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialfv(
        &mut self,
        context_tag: types::ContextTag,
        face: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetMaterialfvReply>> {
        let span = tracing::info_span!(
            "glx_get_materialfv",
            context_tag = ?context_tag,
            face = ?face,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetMaterialfvRequest {
            context_tag,
            face,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        face: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetMaterialfvReply> {
        let cookie = self.glx_get_materialfv(context_tag, face, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialiv(
        &mut self,
        context_tag: types::ContextTag,
        face: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetMaterialivReply>> {
        let span = tracing::info_span!(
            "glx_get_materialiv",
            context_tag = ?context_tag,
            face = ?face,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetMaterialivRequest {
            context_tag,
            face,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialiv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        face: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetMaterialivReply> {
        let cookie = self.glx_get_materialiv(context_tag, face, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapfv(
        &mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Result<Cookie<types::glx::GetPixelMapfvReply>> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapfv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let _enter = span.enter();
        let request = types::glx::GetPixelMapfvRequest { context_tag, map };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Result<types::glx::GetPixelMapfvReply> {
        let cookie = self.glx_get_pixel_mapfv(context_tag, map)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapuiv(
        &mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Result<Cookie<types::glx::GetPixelMapuivReply>> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapuiv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let _enter = span.enter();
        let request = types::glx::GetPixelMapuivRequest { context_tag, map };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapuiv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Result<types::glx::GetPixelMapuivReply> {
        let cookie = self.glx_get_pixel_mapuiv(context_tag, map)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapusv(
        &mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Result<Cookie<types::glx::GetPixelMapusvReply>> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapusv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let _enter = span.enter();
        let request = types::glx::GetPixelMapusvRequest { context_tag, map };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapusv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Result<types::glx::GetPixelMapusvReply> {
        let cookie = self.glx_get_pixel_mapusv(context_tag, map)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_polygon_stipple(
        &mut self,
        context_tag: types::ContextTag,
        lsb_first: types::Bool,
    ) -> Result<Cookie<types::glx::GetPolygonStippleReply>> {
        let span = tracing::info_span!(
            "glx_get_polygon_stipple",
            context_tag = ?context_tag,
            lsb_first = ?lsb_first,
        );
        let _enter = span.enter();
        let request = types::glx::GetPolygonStippleRequest {
            context_tag,
            lsb_first,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_polygon_stipple_immediate(
        &mut self,
        context_tag: types::ContextTag,
        lsb_first: types::Bool,
    ) -> Result<types::glx::GetPolygonStippleReply> {
        let cookie = self.glx_get_polygon_stipple(context_tag, lsb_first)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_string(
        &mut self,
        context_tag: types::ContextTag,
        name: types::Card32,
    ) -> Result<Cookie<types::glx::GetStringReply>> {
        let span = tracing::info_span!(
            "glx_get_string",
            context_tag = ?context_tag,
            name = ?name,
        );
        let _enter = span.enter();
        let request = types::glx::GetStringRequest { context_tag, name };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_string_immediate(
        &mut self,
        context_tag: types::ContextTag,
        name: types::Card32,
    ) -> Result<types::glx::GetStringReply> {
        let cookie = self.glx_get_string(context_tag, name)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_envfv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetTexEnvfvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_envfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexEnvfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_envfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetTexEnvfvReply> {
        let cookie = self.glx_get_tex_envfv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_enviv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetTexEnvivReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_enviv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexEnvivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_enviv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetTexEnvivReply> {
        let cookie = self.glx_get_tex_enviv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_gendv(
        &mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetTexGendvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_gendv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexGendvRequest {
            context_tag,
            coord,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_gendv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetTexGendvReply> {
        let cookie = self.glx_get_tex_gendv(context_tag, coord, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_genfv(
        &mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetTexGenfvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_genfv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexGenfvRequest {
            context_tag,
            coord,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_genfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetTexGenfvReply> {
        let cookie = self.glx_get_tex_genfv(context_tag, coord, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_geniv(
        &mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetTexGenivReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_geniv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexGenivRequest {
            context_tag,
            coord,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_geniv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetTexGenivReply> {
        let cookie = self.glx_get_tex_geniv(context_tag, coord, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_image(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Result<Cookie<types::glx::GetTexImageReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_image",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexImageRequest {
            context_tag,
            target,
            level,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_image_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Result<types::glx::GetTexImageReply> {
        let cookie =
            self.glx_get_tex_image(context_tag, target, level, format, type_, swap_bytes)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameterfv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetTexParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameterfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetTexParameterfvReply> {
        let cookie = self.glx_get_tex_parameterfv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameteriv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetTexParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameteriv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetTexParameterivReply> {
        let cookie = self.glx_get_tex_parameteriv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameterfv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetTexLevelParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_level_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexLevelParameterfvRequest {
            context_tag,
            target,
            level,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameterfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        pname: types::Card32,
    ) -> Result<types::glx::GetTexLevelParameterfvReply> {
        let cookie = self.glx_get_tex_level_parameterfv(context_tag, target, level, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameteriv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetTexLevelParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_level_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetTexLevelParameterivRequest {
            context_tag,
            target,
            level,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameteriv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        pname: types::Card32,
    ) -> Result<types::glx::GetTexLevelParameterivReply> {
        let cookie = self.glx_get_tex_level_parameteriv(context_tag, target, level, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_is_enabled(
        &mut self,
        context_tag: types::ContextTag,
        capability: types::Card32,
    ) -> Result<Cookie<types::glx::IsEnabledReply>> {
        let span = tracing::info_span!(
            "glx_is_enabled",
            context_tag = ?context_tag,
            capability = ?capability,
        );
        let _enter = span.enter();
        let request = types::glx::IsEnabledRequest {
            context_tag,
            capability,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_enabled_immediate(
        &mut self,
        context_tag: types::ContextTag,
        capability: types::Card32,
    ) -> Result<types::glx::IsEnabledReply> {
        let cookie = self.glx_is_enabled(context_tag, capability)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_is_list(
        &mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
    ) -> Result<Cookie<types::glx::IsListReply>> {
        let span = tracing::info_span!(
            "glx_is_list",
            context_tag = ?context_tag,
            list = ?list,
        );
        let _enter = span.enter();
        let request = types::glx::IsListRequest { context_tag, list };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_list_immediate(
        &mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
    ) -> Result<types::glx::IsListReply> {
        let cookie = self.glx_is_list(context_tag, list)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_flush(&mut self, context_tag: types::ContextTag) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_flush",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::FlushRequest { context_tag };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_flush_checked(&mut self, context_tag: types::ContextTag) -> Result<()> {
        let cookie = self.glx_flush(context_tag)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_are_textures_resident(
        &mut self,
        context_tag: types::ContextTag,
        textures: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<types::glx::AreTexturesResidentReply>> {
        let span = tracing::info_span!(
            "glx_are_textures_resident",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::AreTexturesResidentRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_are_textures_resident_immediate(
        &mut self,
        context_tag: types::ContextTag,
        textures: impl AsRef<[types::Card32]>,
    ) -> Result<types::glx::AreTexturesResidentReply> {
        let cookie = self.glx_are_textures_resident(context_tag, textures)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_textures(
        &mut self,
        context_tag: types::ContextTag,
        textures: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_delete_textures",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::DeleteTexturesRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_textures_checked(
        &mut self,
        context_tag: types::ContextTag,
        textures: impl AsRef<[types::Card32]>,
    ) -> Result<()> {
        let cookie = self.glx_delete_textures(context_tag, textures)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_textures(
        &mut self,
        context_tag: types::ContextTag,
        n: types::Int32,
    ) -> Result<Cookie<types::glx::GenTexturesReply>> {
        let span = tracing::info_span!(
            "glx_gen_textures",
            context_tag = ?context_tag,
            n = ?n,
        );
        let _enter = span.enter();
        let request = types::glx::GenTexturesRequest { context_tag, n };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_textures_immediate(
        &mut self,
        context_tag: types::ContextTag,
        n: types::Int32,
    ) -> Result<types::glx::GenTexturesReply> {
        let cookie = self.glx_gen_textures(context_tag, n)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_is_texture(
        &mut self,
        context_tag: types::ContextTag,
        texture: types::Card32,
    ) -> Result<Cookie<types::glx::IsTextureReply>> {
        let span = tracing::info_span!(
            "glx_is_texture",
            context_tag = ?context_tag,
            texture = ?texture,
        );
        let _enter = span.enter();
        let request = types::glx::IsTextureRequest {
            context_tag,
            texture,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_texture_immediate(
        &mut self,
        context_tag: types::ContextTag,
        texture: types::Card32,
    ) -> Result<types::glx::IsTextureReply> {
        let cookie = self.glx_is_texture(context_tag, texture)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Result<Cookie<types::glx::GetColorTableReply>> {
        let span = tracing::info_span!(
            "glx_get_color_table",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let _enter = span.enter();
        let request = types::glx::GetColorTableRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Result<types::glx::GetColorTableReply> {
        let cookie = self.glx_get_color_table(context_tag, target, format, type_, swap_bytes)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameterfv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetColorTableParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_color_table_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetColorTableParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameterfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetColorTableParameterfvReply> {
        let cookie = self.glx_get_color_table_parameterfv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameteriv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetColorTableParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_color_table_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetColorTableParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameteriv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetColorTableParameterivReply> {
        let cookie = self.glx_get_color_table_parameteriv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_filter(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Result<Cookie<types::glx::GetConvolutionFilterReply>> {
        let span = tracing::info_span!(
            "glx_get_convolution_filter",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let _enter = span.enter();
        let request = types::glx::GetConvolutionFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_filter_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Result<types::glx::GetConvolutionFilterReply> {
        let cookie =
            self.glx_get_convolution_filter(context_tag, target, format, type_, swap_bytes)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameterfv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetConvolutionParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_convolution_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetConvolutionParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameterfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetConvolutionParameterfvReply> {
        let cookie = self.glx_get_convolution_parameterfv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameteriv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetConvolutionParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_convolution_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetConvolutionParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameteriv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetConvolutionParameterivReply> {
        let cookie = self.glx_get_convolution_parameteriv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_separable_filter(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Result<Cookie<types::glx::GetSeparableFilterReply>> {
        let span = tracing::info_span!(
            "glx_get_separable_filter",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let _enter = span.enter();
        let request = types::glx::GetSeparableFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_separable_filter_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Result<types::glx::GetSeparableFilterReply> {
        let cookie =
            self.glx_get_separable_filter(context_tag, target, format, type_, swap_bytes)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        reset: types::Bool,
    ) -> Result<Cookie<types::glx::GetHistogramReply>> {
        let span = tracing::info_span!(
            "glx_get_histogram",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            reset = ?reset,
        );
        let _enter = span.enter();
        let request = types::glx::GetHistogramRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        reset: types::Bool,
    ) -> Result<types::glx::GetHistogramReply> {
        let cookie =
            self.glx_get_histogram(context_tag, target, format, type_, swap_bytes, reset)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameterfv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetHistogramParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_histogram_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetHistogramParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameterfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetHistogramParameterfvReply> {
        let cookie = self.glx_get_histogram_parameterfv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameteriv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetHistogramParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_histogram_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetHistogramParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameteriv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetHistogramParameterivReply> {
        let cookie = self.glx_get_histogram_parameteriv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        reset: types::Bool,
    ) -> Result<Cookie<types::glx::GetMinmaxReply>> {
        let span = tracing::info_span!(
            "glx_get_minmax",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            reset = ?reset,
        );
        let _enter = span.enter();
        let request = types::glx::GetMinmaxRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        reset: types::Bool,
    ) -> Result<types::glx::GetMinmaxReply> {
        let cookie = self.glx_get_minmax(context_tag, target, format, type_, swap_bytes, reset)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameterfv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetMinmaxParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_minmax_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetMinmaxParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameterfv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetMinmaxParameterfvReply> {
        let cookie = self.glx_get_minmax_parameterfv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameteriv(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetMinmaxParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_minmax_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetMinmaxParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameteriv_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetMinmaxParameterivReply> {
        let cookie = self.glx_get_minmax_parameteriv(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_compressed_tex_image_arb(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
    ) -> Result<Cookie<types::glx::GetCompressedTexImageARBReply>> {
        let span = tracing::info_span!(
            "glx_get_compressed_tex_image_arb",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
        );
        let _enter = span.enter();
        let request = types::glx::GetCompressedTexImageARBRequest {
            context_tag,
            target,
            level,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_compressed_tex_image_arb_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
    ) -> Result<types::glx::GetCompressedTexImageARBReply> {
        let cookie = self.glx_get_compressed_tex_image_arb(context_tag, target, level)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_queries_arb(
        &mut self,
        context_tag: types::ContextTag,
        ids: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "glx_delete_queries_arb",
            context_tag = ?context_tag,
        );
        let _enter = span.enter();
        let request = types::glx::DeleteQueriesARBRequest {
            context_tag,
            ids: Cow::Borrowed(ids.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_queries_arb_checked(
        &mut self,
        context_tag: types::ContextTag,
        ids: impl AsRef<[types::Card32]>,
    ) -> Result<()> {
        let cookie = self.glx_delete_queries_arb(context_tag, ids)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_queries_arb(
        &mut self,
        context_tag: types::ContextTag,
        n: types::Int32,
    ) -> Result<Cookie<types::glx::GenQueriesARBReply>> {
        let span = tracing::info_span!(
            "glx_gen_queries_arb",
            context_tag = ?context_tag,
            n = ?n,
        );
        let _enter = span.enter();
        let request = types::glx::GenQueriesARBRequest { context_tag, n };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_queries_arb_immediate(
        &mut self,
        context_tag: types::ContextTag,
        n: types::Int32,
    ) -> Result<types::glx::GenQueriesARBReply> {
        let cookie = self.glx_gen_queries_arb(context_tag, n)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_is_query_arb(
        &mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
    ) -> Result<Cookie<types::glx::IsQueryARBReply>> {
        let span = tracing::info_span!(
            "glx_is_query_arb",
            context_tag = ?context_tag,
            id = ?id,
        );
        let _enter = span.enter();
        let request = types::glx::IsQueryARBRequest { context_tag, id };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_is_query_arb_immediate(
        &mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
    ) -> Result<types::glx::IsQueryARBReply> {
        let cookie = self.glx_is_query_arb(context_tag, id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_queryiv_arb(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetQueryivARBReply>> {
        let span = tracing::info_span!(
            "glx_get_queryiv_arb",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetQueryivARBRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_queryiv_arb_immediate(
        &mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetQueryivARBReply> {
        let cookie = self.glx_get_queryiv_arb(context_tag, target, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectiv_arb(
        &mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetQueryObjectivARBReply>> {
        let span = tracing::info_span!(
            "glx_get_query_objectiv_arb",
            context_tag = ?context_tag,
            id = ?id,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetQueryObjectivARBRequest {
            context_tag,
            id,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectiv_arb_immediate(
        &mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetQueryObjectivARBReply> {
        let cookie = self.glx_get_query_objectiv_arb(context_tag, id, pname)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectuiv_arb(
        &mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
        pname: types::Card32,
    ) -> Result<Cookie<types::glx::GetQueryObjectuivARBReply>> {
        let span = tracing::info_span!(
            "glx_get_query_objectuiv_arb",
            context_tag = ?context_tag,
            id = ?id,
            pname = ?pname,
        );
        let _enter = span.enter();
        let request = types::glx::GetQueryObjectuivARBRequest {
            context_tag,
            id,
            pname,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectuiv_arb_immediate(
        &mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
        pname: types::Card32,
    ) -> Result<types::glx::GetQueryObjectuivARBReply> {
        let cookie = self.glx_get_query_objectuiv_arb(context_tag, id, pname)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "present")]
    fn present_query_version(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Result<Cookie<types::present::QueryVersionReply>> {
        let span = tracing::info_span!(
            "present_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::present::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "present")]
    fn present_query_version_immediate(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Result<types::present::QueryVersionReply> {
        let cookie = self.present_query_version(major_version, minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "present")]
    fn present_pixmap(
        &mut self,
        window: types::xproto::Window,
        pixmap: types::xproto::Pixmap,
        serial: types::Card32,
        valid: types::Region,
        update: types::Region,
        x_off: types::Int16,
        y_off: types::Int16,
        target_crtc: types::Crtc,
        wait_fence: types::Fence,
        idle_fence: types::Fence,
        options: types::Card32,
        target_msc: types::Card64,
        divisor: types::Card64,
        remainder: types::Card64,
        notifies: impl AsRef<[types::present::Notify]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "present_pixmap",
            window = ?window,
            pixmap = ?pixmap,
            serial = ?serial,
            valid = ?valid,
            update = ?update,
            x_off = ?x_off,
            y_off = ?y_off,
            target_crtc = ?target_crtc,
            wait_fence = ?wait_fence,
            idle_fence = ?idle_fence,
            options = ?options,
            target_msc = ?target_msc,
            divisor = ?divisor,
            remainder = ?remainder,
        );
        let _enter = span.enter();
        let request = types::present::PixmapRequest {
            window,
            pixmap,
            serial,
            valid,
            update,
            x_off,
            y_off,
            target_crtc,
            wait_fence,
            idle_fence,
            options,
            target_msc,
            divisor,
            remainder,
            notifies: Cow::Borrowed(notifies.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "present")]
    fn present_pixmap_checked(
        &mut self,
        window: types::xproto::Window,
        pixmap: types::xproto::Pixmap,
        serial: types::Card32,
        valid: types::Region,
        update: types::Region,
        x_off: types::Int16,
        y_off: types::Int16,
        target_crtc: types::Crtc,
        wait_fence: types::Fence,
        idle_fence: types::Fence,
        options: types::Card32,
        target_msc: types::Card64,
        divisor: types::Card64,
        remainder: types::Card64,
        notifies: impl AsRef<[types::present::Notify]>,
    ) -> Result<()> {
        let cookie = self.present_pixmap(
            window,
            pixmap,
            serial,
            valid,
            update,
            x_off,
            y_off,
            target_crtc,
            wait_fence,
            idle_fence,
            options,
            target_msc,
            divisor,
            remainder,
            notifies,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "present")]
    fn present_notify_msc(
        &mut self,
        window: types::xproto::Window,
        serial: types::Card32,
        target_msc: types::Card64,
        divisor: types::Card64,
        remainder: types::Card64,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "present_notify_msc",
            window = ?window,
            serial = ?serial,
            target_msc = ?target_msc,
            divisor = ?divisor,
            remainder = ?remainder,
        );
        let _enter = span.enter();
        let request = types::present::NotifyMSCRequest {
            window,
            serial,
            target_msc,
            divisor,
            remainder,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "present")]
    fn present_notify_msc_checked(
        &mut self,
        window: types::xproto::Window,
        serial: types::Card32,
        target_msc: types::Card64,
        divisor: types::Card64,
        remainder: types::Card64,
    ) -> Result<()> {
        let cookie = self.present_notify_msc(window, serial, target_msc, divisor, remainder)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "present")]
    fn present_select_input(
        &mut self,
        eid: types::present::Event,
        window: types::xproto::Window,
        event_mask: impl Into<types::present::EventMask>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "present_select_input",
            eid = ?eid,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::present::SelectInputRequest {
            eid,
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "present")]
    fn present_select_input_checked(
        &mut self,
        eid: types::present::Event,
        window: types::xproto::Window,
        event_mask: impl Into<types::present::EventMask>,
    ) -> Result<()> {
        let cookie = self.present_select_input(eid, window, event_mask)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "present")]
    fn present_query_capabilities(
        &mut self,
        target: types::Card32,
    ) -> Result<Cookie<types::present::QueryCapabilitiesReply>> {
        let span = tracing::info_span!(
            "present_query_capabilities",
            target = ?target,
        );
        let _enter = span.enter();
        let request = types::present::QueryCapabilitiesRequest { target };
        self.send_reply_request(request)
    }
    #[cfg(feature = "present")]
    fn present_query_capabilities_immediate(
        &mut self,
        target: types::Card32,
    ) -> Result<types::present::QueryCapabilitiesReply> {
        let cookie = self.present_query_capabilities(target)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "randr")]
    fn randr_query_version(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Result<Cookie<types::randr::QueryVersionReply>> {
        let span = tracing::info_span!(
            "randr_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::randr::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_query_version_immediate(
        &mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Result<types::randr::QueryVersionReply> {
        let cookie = self.randr_query_version(major_version, minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_config(
        &mut self,
        window: types::xproto::Window,
        timestamp: types::Timestamp,
        config_timestamp: types::Timestamp,
        size_id: types::Card16,
        rotation: impl Into<types::Rotation>,
        rate: types::Card16,
    ) -> Result<Cookie<types::randr::SetScreenConfigReply>> {
        let span = tracing::info_span!(
            "randr_set_screen_config",
            window = ?window,
            timestamp = ?timestamp,
            config_timestamp = ?config_timestamp,
            size_id = ?size_id,
            rate = ?rate,
        );
        let _enter = span.enter();
        let request = types::randr::SetScreenConfigRequest {
            window,
            timestamp,
            config_timestamp,
            size_id,
            rotation: Into::<u32>::into(rotation.into()) as _,
            rate,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_config_immediate(
        &mut self,
        window: types::xproto::Window,
        timestamp: types::Timestamp,
        config_timestamp: types::Timestamp,
        size_id: types::Card16,
        rotation: impl Into<types::Rotation>,
        rate: types::Card16,
    ) -> Result<types::randr::SetScreenConfigReply> {
        let cookie = self.randr_set_screen_config(
            window,
            timestamp,
            config_timestamp,
            size_id,
            rotation,
            rate,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_select_input(
        &mut self,
        window: types::xproto::Window,
        enable: impl Into<types::NotifyMask>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_select_input",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::SelectInputRequest {
            window,
            enable: Into::<u32>::into(enable.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_select_input_checked(
        &mut self,
        window: types::xproto::Window,
        enable: impl Into<types::NotifyMask>,
    ) -> Result<()> {
        let cookie = self.randr_select_input(window, enable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_info(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::randr::GetScreenInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_screen_info",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetScreenInfoRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_info_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::randr::GetScreenInfoReply> {
        let cookie = self.randr_get_screen_info(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_size_range(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::randr::GetScreenSizeRangeReply>> {
        let span = tracing::info_span!(
            "randr_get_screen_size_range",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetScreenSizeRangeRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_size_range_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::randr::GetScreenSizeRangeReply> {
        let cookie = self.randr_get_screen_size_range(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_size(
        &mut self,
        window: types::xproto::Window,
        width: types::Card16,
        height: types::Card16,
        mm_width: types::Card32,
        mm_height: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_screen_size",
            window = ?window,
            width = ?width,
            height = ?height,
            mm_width = ?mm_width,
            mm_height = ?mm_height,
        );
        let _enter = span.enter();
        let request = types::randr::SetScreenSizeRequest {
            window,
            width,
            height,
            mm_width,
            mm_height,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_size_checked(
        &mut self,
        window: types::xproto::Window,
        width: types::Card16,
        height: types::Card16,
        mm_width: types::Card32,
        mm_height: types::Card32,
    ) -> Result<()> {
        let cookie = self.randr_set_screen_size(window, width, height, mm_width, mm_height)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::randr::GetScreenResourcesReply>> {
        let span = tracing::info_span!(
            "randr_get_screen_resources",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetScreenResourcesRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::randr::GetScreenResourcesReply> {
        let cookie = self.randr_get_screen_resources(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_info(
        &mut self,
        output: types::Output,
        config_timestamp: types::Timestamp,
    ) -> Result<Cookie<types::randr::GetOutputInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_output_info",
            output = ?output,
            config_timestamp = ?config_timestamp,
        );
        let _enter = span.enter();
        let request = types::randr::GetOutputInfoRequest {
            output,
            config_timestamp,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_info_immediate(
        &mut self,
        output: types::Output,
        config_timestamp: types::Timestamp,
    ) -> Result<types::randr::GetOutputInfoReply> {
        let cookie = self.randr_get_output_info(output, config_timestamp)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_list_output_properties(
        &mut self,
        output: types::Output,
    ) -> Result<Cookie<types::randr::ListOutputPropertiesReply>> {
        let span = tracing::info_span!(
            "randr_list_output_properties",
            output = ?output,
        );
        let _enter = span.enter();
        let request = types::randr::ListOutputPropertiesRequest { output };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_list_output_properties_immediate(
        &mut self,
        output: types::Output,
    ) -> Result<types::randr::ListOutputPropertiesReply> {
        let cookie = self.randr_list_output_properties(output)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_query_output_property(
        &mut self,
        output: types::Output,
        property: types::Atom,
    ) -> Result<Cookie<types::randr::QueryOutputPropertyReply>> {
        let span = tracing::info_span!(
            "randr_query_output_property",
            output = ?output,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::randr::QueryOutputPropertyRequest { output, property };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_query_output_property_immediate(
        &mut self,
        output: types::Output,
        property: types::Atom,
    ) -> Result<types::randr::QueryOutputPropertyReply> {
        let cookie = self.randr_query_output_property(output, property)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_output_property(
        &mut self,
        output: types::Output,
        property: types::Atom,
        pending: types::Bool,
        range: types::Bool,
        values: impl AsRef<[types::Int32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_configure_output_property",
            output = ?output,
            property = ?property,
            pending = ?pending,
            range = ?range,
        );
        let _enter = span.enter();
        let request = types::randr::ConfigureOutputPropertyRequest {
            output,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_output_property_checked(
        &mut self,
        output: types::Output,
        property: types::Atom,
        pending: types::Bool,
        range: types::Bool,
        values: impl AsRef<[types::Int32]>,
    ) -> Result<()> {
        let cookie =
            self.randr_configure_output_property(output, property, pending, range, values)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_change_output_property(
        &mut self,
        output: types::Output,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        mode: types::PropMode,
        num_units: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_change_output_property",
            output = ?output,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            mode = ?mode,
            num_units = ?num_units,
        );
        let _enter = span.enter();
        let request = types::randr::ChangeOutputPropertyRequest {
            output,
            property,
            type_,
            format,
            mode,
            num_units,
            data: Cow::Borrowed(data.bytes()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_change_output_property_checked(
        &mut self,
        output: types::Output,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        mode: types::PropMode,
        num_units: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Result<()> {
        let cookie = self
            .randr_change_output_property(output, property, type_, format, mode, num_units, data)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_property(
        &mut self,
        output: types::Output,
        property: types::Atom,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_delete_output_property",
            output = ?output,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::randr::DeleteOutputPropertyRequest { output, property };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_property_checked(
        &mut self,
        output: types::Output,
        property: types::Atom,
    ) -> Result<()> {
        let cookie = self.randr_delete_output_property(output, property)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_property(
        &mut self,
        output: types::Output,
        property: types::Atom,
        type_: impl Into<types::GetPropertyType>,
        long_offset: types::Card32,
        long_length: types::Card32,
        delete: types::Bool,
        pending: types::Bool,
    ) -> Result<Cookie<types::randr::GetOutputPropertyReply>> {
        let span = tracing::info_span!(
            "randr_get_output_property",
            output = ?output,
            property = ?property,
            long_offset = ?long_offset,
            long_length = ?long_length,
            delete = ?delete,
            pending = ?pending,
        );
        let _enter = span.enter();
        let request = types::randr::GetOutputPropertyRequest {
            output,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
            delete,
            pending,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_property_immediate(
        &mut self,
        output: types::Output,
        property: types::Atom,
        type_: impl Into<types::GetPropertyType>,
        long_offset: types::Card32,
        long_length: types::Card32,
        delete: types::Bool,
        pending: types::Bool,
    ) -> Result<types::randr::GetOutputPropertyReply> {
        let cookie = self.randr_get_output_property(
            output,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_create_mode(
        &mut self,
        window: types::xproto::Window,
        mode_info: types::randr::ModeInfo,
        name: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<types::randr::CreateModeReply>> {
        let span = tracing::info_span!(
            "randr_create_mode",
            window = ?window,
            mode_info = ?mode_info,
        );
        let _enter = span.enter();
        let request = types::randr::CreateModeRequest {
            window,
            mode_info,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_create_mode_immediate(
        &mut self,
        window: types::xproto::Window,
        mode_info: types::randr::ModeInfo,
        name: impl AsRef<[types::Char]>,
    ) -> Result<types::randr::CreateModeReply> {
        let cookie = self.randr_create_mode(window, mode_info, name)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_destroy_mode(&mut self, mode: types::Mode) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_destroy_mode",
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::randr::DestroyModeRequest { mode };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_destroy_mode_checked(&mut self, mode: types::Mode) -> Result<()> {
        let cookie = self.randr_destroy_mode(mode)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_add_output_mode(
        &mut self,
        output: types::Output,
        mode: types::Mode,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_add_output_mode",
            output = ?output,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::randr::AddOutputModeRequest { output, mode };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_add_output_mode_checked(
        &mut self,
        output: types::Output,
        mode: types::Mode,
    ) -> Result<()> {
        let cookie = self.randr_add_output_mode(output, mode)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_mode(
        &mut self,
        output: types::Output,
        mode: types::Mode,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_delete_output_mode",
            output = ?output,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::randr::DeleteOutputModeRequest { output, mode };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_mode_checked(
        &mut self,
        output: types::Output,
        mode: types::Mode,
    ) -> Result<()> {
        let cookie = self.randr_delete_output_mode(output, mode)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_info(
        &mut self,
        crtc: types::Crtc,
        config_timestamp: types::Timestamp,
    ) -> Result<Cookie<types::randr::GetCrtcInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_info",
            crtc = ?crtc,
            config_timestamp = ?config_timestamp,
        );
        let _enter = span.enter();
        let request = types::randr::GetCrtcInfoRequest {
            crtc,
            config_timestamp,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_info_immediate(
        &mut self,
        crtc: types::Crtc,
        config_timestamp: types::Timestamp,
    ) -> Result<types::randr::GetCrtcInfoReply> {
        let cookie = self.randr_get_crtc_info(crtc, config_timestamp)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_config(
        &mut self,
        crtc: types::Crtc,
        timestamp: types::Timestamp,
        config_timestamp: types::Timestamp,
        x: types::Int16,
        y: types::Int16,
        mode: types::Mode,
        rotation: impl Into<types::Rotation>,
        outputs: impl AsRef<[types::Output]>,
    ) -> Result<Cookie<types::randr::SetCrtcConfigReply>> {
        let span = tracing::info_span!(
            "randr_set_crtc_config",
            crtc = ?crtc,
            timestamp = ?timestamp,
            config_timestamp = ?config_timestamp,
            x = ?x,
            y = ?y,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::randr::SetCrtcConfigRequest {
            crtc,
            timestamp,
            config_timestamp,
            x,
            y,
            mode,
            rotation: Into::<u32>::into(rotation.into()) as _,
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_config_immediate(
        &mut self,
        crtc: types::Crtc,
        timestamp: types::Timestamp,
        config_timestamp: types::Timestamp,
        x: types::Int16,
        y: types::Int16,
        mode: types::Mode,
        rotation: impl Into<types::Rotation>,
        outputs: impl AsRef<[types::Output]>,
    ) -> Result<types::randr::SetCrtcConfigReply> {
        let cookie = self.randr_set_crtc_config(
            crtc,
            timestamp,
            config_timestamp,
            x,
            y,
            mode,
            rotation,
            outputs,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_size(
        &mut self,
        crtc: types::Crtc,
    ) -> Result<Cookie<types::randr::GetCrtcGammaSizeReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_gamma_size",
            crtc = ?crtc,
        );
        let _enter = span.enter();
        let request = types::randr::GetCrtcGammaSizeRequest { crtc };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_size_immediate(
        &mut self,
        crtc: types::Crtc,
    ) -> Result<types::randr::GetCrtcGammaSizeReply> {
        let cookie = self.randr_get_crtc_gamma_size(crtc)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma(
        &mut self,
        crtc: types::Crtc,
    ) -> Result<Cookie<types::randr::GetCrtcGammaReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_gamma",
            crtc = ?crtc,
        );
        let _enter = span.enter();
        let request = types::randr::GetCrtcGammaRequest { crtc };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_immediate(
        &mut self,
        crtc: types::Crtc,
    ) -> Result<types::randr::GetCrtcGammaReply> {
        let cookie = self.randr_get_crtc_gamma(crtc)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_gamma(
        &mut self,
        crtc: types::Crtc,
        red: impl AsRef<[types::Card16]>,
        green: impl AsRef<[types::Card16]>,
        blue: impl AsRef<[types::Card16]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_crtc_gamma",
            crtc = ?crtc,
        );
        let _enter = span.enter();
        let request = types::randr::SetCrtcGammaRequest {
            crtc,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_gamma_checked(
        &mut self,
        crtc: types::Crtc,
        red: impl AsRef<[types::Card16]>,
        green: impl AsRef<[types::Card16]>,
        blue: impl AsRef<[types::Card16]>,
    ) -> Result<()> {
        let cookie = self.randr_set_crtc_gamma(crtc, red, green, blue)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_current(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::randr::GetScreenResourcesCurrentReply>> {
        let span = tracing::info_span!(
            "randr_get_screen_resources_current",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetScreenResourcesCurrentRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_current_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::randr::GetScreenResourcesCurrentReply> {
        let cookie = self.randr_get_screen_resources_current(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_transform(
        &mut self,
        crtc: types::Crtc,
        transform: types::render::Transform,
        filter_name: impl AsRef<[types::Char]>,
        filter_params: impl AsRef<[types::Fixed]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_crtc_transform",
            crtc = ?crtc,
            transform = ?transform,
        );
        let _enter = span.enter();
        let request = types::randr::SetCrtcTransformRequest {
            crtc,
            transform,
            filter_name: Cow::Borrowed(filter_name.as_ref()),
            filter_params: Cow::Borrowed(filter_params.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_transform_checked(
        &mut self,
        crtc: types::Crtc,
        transform: types::render::Transform,
        filter_name: impl AsRef<[types::Char]>,
        filter_params: impl AsRef<[types::Fixed]>,
    ) -> Result<()> {
        let cookie = self.randr_set_crtc_transform(crtc, transform, filter_name, filter_params)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_transform(
        &mut self,
        crtc: types::Crtc,
    ) -> Result<Cookie<types::randr::GetCrtcTransformReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_transform",
            crtc = ?crtc,
        );
        let _enter = span.enter();
        let request = types::randr::GetCrtcTransformRequest { crtc };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_transform_immediate(
        &mut self,
        crtc: types::Crtc,
    ) -> Result<types::randr::GetCrtcTransformReply> {
        let cookie = self.randr_get_crtc_transform(crtc)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_panning(
        &mut self,
        crtc: types::Crtc,
    ) -> Result<Cookie<types::randr::GetPanningReply>> {
        let span = tracing::info_span!(
            "randr_get_panning",
            crtc = ?crtc,
        );
        let _enter = span.enter();
        let request = types::randr::GetPanningRequest { crtc };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_panning_immediate(
        &mut self,
        crtc: types::Crtc,
    ) -> Result<types::randr::GetPanningReply> {
        let cookie = self.randr_get_panning(crtc)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_panning(
        &mut self,
        crtc: types::Crtc,
        timestamp: types::Timestamp,
        left: types::Card16,
        top: types::Card16,
        width: types::Card16,
        height: types::Card16,
        track_left: types::Card16,
        track_top: types::Card16,
        track_width: types::Card16,
        track_height: types::Card16,
        border_left: types::Int16,
        border_top: types::Int16,
        border_right: types::Int16,
        border_bottom: types::Int16,
    ) -> Result<Cookie<types::randr::SetPanningReply>> {
        let span = tracing::info_span!(
            "randr_set_panning",
            crtc = ?crtc,
            timestamp = ?timestamp,
            left = ?left,
            top = ?top,
            width = ?width,
            height = ?height,
            track_left = ?track_left,
            track_top = ?track_top,
            track_width = ?track_width,
            track_height = ?track_height,
            border_left = ?border_left,
            border_top = ?border_top,
            border_right = ?border_right,
            border_bottom = ?border_bottom,
        );
        let _enter = span.enter();
        let request = types::randr::SetPanningRequest {
            crtc,
            timestamp,
            left,
            top,
            width,
            height,
            track_left,
            track_top,
            track_width,
            track_height,
            border_left,
            border_top,
            border_right,
            border_bottom,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_panning_immediate(
        &mut self,
        crtc: types::Crtc,
        timestamp: types::Timestamp,
        left: types::Card16,
        top: types::Card16,
        width: types::Card16,
        height: types::Card16,
        track_left: types::Card16,
        track_top: types::Card16,
        track_width: types::Card16,
        track_height: types::Card16,
        border_left: types::Int16,
        border_top: types::Int16,
        border_right: types::Int16,
        border_bottom: types::Int16,
    ) -> Result<types::randr::SetPanningReply> {
        let cookie = self.randr_set_panning(
            crtc,
            timestamp,
            left,
            top,
            width,
            height,
            track_left,
            track_top,
            track_width,
            track_height,
            border_left,
            border_top,
            border_right,
            border_bottom,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_output_primary(
        &mut self,
        window: types::xproto::Window,
        output: types::Output,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_output_primary",
            window = ?window,
            output = ?output,
        );
        let _enter = span.enter();
        let request = types::randr::SetOutputPrimaryRequest { window, output };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_output_primary_checked(
        &mut self,
        window: types::xproto::Window,
        output: types::Output,
    ) -> Result<()> {
        let cookie = self.randr_set_output_primary(window, output)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_primary(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::randr::GetOutputPrimaryReply>> {
        let span = tracing::info_span!(
            "randr_get_output_primary",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetOutputPrimaryRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_primary_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::randr::GetOutputPrimaryReply> {
        let cookie = self.randr_get_output_primary(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_providers(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::randr::GetProvidersReply>> {
        let span = tracing::info_span!(
            "randr_get_providers",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::randr::GetProvidersRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_providers_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::randr::GetProvidersReply> {
        let cookie = self.randr_get_providers(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_info(
        &mut self,
        provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Result<Cookie<types::randr::GetProviderInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_provider_info",
            provider = ?provider,
            config_timestamp = ?config_timestamp,
        );
        let _enter = span.enter();
        let request = types::randr::GetProviderInfoRequest {
            provider,
            config_timestamp,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_info_immediate(
        &mut self,
        provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Result<types::randr::GetProviderInfoReply> {
        let cookie = self.randr_get_provider_info(provider, config_timestamp)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_offload_sink(
        &mut self,
        provider: types::Provider,
        sink_provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_provider_offload_sink",
            provider = ?provider,
            sink_provider = ?sink_provider,
            config_timestamp = ?config_timestamp,
        );
        let _enter = span.enter();
        let request = types::randr::SetProviderOffloadSinkRequest {
            provider,
            sink_provider,
            config_timestamp,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_offload_sink_checked(
        &mut self,
        provider: types::Provider,
        sink_provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Result<()> {
        let cookie =
            self.randr_set_provider_offload_sink(provider, sink_provider, config_timestamp)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_output_source(
        &mut self,
        provider: types::Provider,
        source_provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_provider_output_source",
            provider = ?provider,
            source_provider = ?source_provider,
            config_timestamp = ?config_timestamp,
        );
        let _enter = span.enter();
        let request = types::randr::SetProviderOutputSourceRequest {
            provider,
            source_provider,
            config_timestamp,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_output_source_checked(
        &mut self,
        provider: types::Provider,
        source_provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Result<()> {
        let cookie =
            self.randr_set_provider_output_source(provider, source_provider, config_timestamp)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_list_provider_properties(
        &mut self,
        provider: types::Provider,
    ) -> Result<Cookie<types::randr::ListProviderPropertiesReply>> {
        let span = tracing::info_span!(
            "randr_list_provider_properties",
            provider = ?provider,
        );
        let _enter = span.enter();
        let request = types::randr::ListProviderPropertiesRequest { provider };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_list_provider_properties_immediate(
        &mut self,
        provider: types::Provider,
    ) -> Result<types::randr::ListProviderPropertiesReply> {
        let cookie = self.randr_list_provider_properties(provider)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_query_provider_property(
        &mut self,
        provider: types::Provider,
        property: types::Atom,
    ) -> Result<Cookie<types::randr::QueryProviderPropertyReply>> {
        let span = tracing::info_span!(
            "randr_query_provider_property",
            provider = ?provider,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::randr::QueryProviderPropertyRequest { provider, property };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_query_provider_property_immediate(
        &mut self,
        provider: types::Provider,
        property: types::Atom,
    ) -> Result<types::randr::QueryProviderPropertyReply> {
        let cookie = self.randr_query_provider_property(provider, property)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_provider_property(
        &mut self,
        provider: types::Provider,
        property: types::Atom,
        pending: types::Bool,
        range: types::Bool,
        values: impl AsRef<[types::Int32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_configure_provider_property",
            provider = ?provider,
            property = ?property,
            pending = ?pending,
            range = ?range,
        );
        let _enter = span.enter();
        let request = types::randr::ConfigureProviderPropertyRequest {
            provider,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_provider_property_checked(
        &mut self,
        provider: types::Provider,
        property: types::Atom,
        pending: types::Bool,
        range: types::Bool,
        values: impl AsRef<[types::Int32]>,
    ) -> Result<()> {
        let cookie =
            self.randr_configure_provider_property(provider, property, pending, range, values)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_change_provider_property(
        &mut self,
        provider: types::Provider,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        mode: types::Card8,
        num_items: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_change_provider_property",
            provider = ?provider,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            mode = ?mode,
            num_items = ?num_items,
        );
        let _enter = span.enter();
        let request = types::randr::ChangeProviderPropertyRequest {
            provider,
            property,
            type_,
            format,
            mode,
            num_items,
            data: Cow::Borrowed(data.bytes()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_change_provider_property_checked(
        &mut self,
        provider: types::Provider,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        mode: types::Card8,
        num_items: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Result<()> {
        let cookie = self.randr_change_provider_property(
            provider, property, type_, format, mode, num_items, data,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_provider_property(
        &mut self,
        provider: types::Provider,
        property: types::Atom,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_delete_provider_property",
            provider = ?provider,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::randr::DeleteProviderPropertyRequest { provider, property };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_provider_property_checked(
        &mut self,
        provider: types::Provider,
        property: types::Atom,
    ) -> Result<()> {
        let cookie = self.randr_delete_provider_property(provider, property)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_property(
        &mut self,
        provider: types::Provider,
        property: types::Atom,
        type_: types::Atom,
        long_offset: types::Card32,
        long_length: types::Card32,
        delete: types::Bool,
        pending: types::Bool,
    ) -> Result<Cookie<types::randr::GetProviderPropertyReply>> {
        let span = tracing::info_span!(
            "randr_get_provider_property",
            provider = ?provider,
            property = ?property,
            type_ = ?type_,
            long_offset = ?long_offset,
            long_length = ?long_length,
            delete = ?delete,
            pending = ?pending,
        );
        let _enter = span.enter();
        let request = types::randr::GetProviderPropertyRequest {
            provider,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_property_immediate(
        &mut self,
        provider: types::Provider,
        property: types::Atom,
        type_: types::Atom,
        long_offset: types::Card32,
        long_length: types::Card32,
        delete: types::Bool,
        pending: types::Bool,
    ) -> Result<types::randr::GetProviderPropertyReply> {
        let cookie = self.randr_get_provider_property(
            provider,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_get_monitors(
        &mut self,
        window: types::xproto::Window,
        get_active: types::Bool,
    ) -> Result<Cookie<types::randr::GetMonitorsReply>> {
        let span = tracing::info_span!(
            "randr_get_monitors",
            window = ?window,
            get_active = ?get_active,
        );
        let _enter = span.enter();
        let request = types::randr::GetMonitorsRequest { window, get_active };
        self.send_reply_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_get_monitors_immediate(
        &mut self,
        window: types::xproto::Window,
        get_active: types::Bool,
    ) -> Result<types::randr::GetMonitorsReply> {
        let cookie = self.randr_get_monitors(window, get_active)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_set_monitor(
        &mut self,
        window: types::xproto::Window,
        monitorinfo: types::MonitorInfo,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_set_monitor",
            window = ?window,
            monitorinfo = ?monitorinfo,
        );
        let _enter = span.enter();
        let request = types::randr::SetMonitorRequest {
            window,
            monitorinfo,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_set_monitor_checked(
        &mut self,
        window: types::xproto::Window,
        monitorinfo: types::MonitorInfo,
    ) -> Result<()> {
        let cookie = self.randr_set_monitor(window, monitorinfo)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_monitor(
        &mut self,
        window: types::xproto::Window,
        name: types::Atom,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_delete_monitor",
            window = ?window,
            name = ?name,
        );
        let _enter = span.enter();
        let request = types::randr::DeleteMonitorRequest { window, name };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_monitor_checked(
        &mut self,
        window: types::xproto::Window,
        name: types::Atom,
    ) -> Result<()> {
        let cookie = self.randr_delete_monitor(window, name)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_create_lease(
        &mut self,
        window: types::xproto::Window,
        lid: types::Lease,
        crtcs: impl AsRef<[types::Crtc]>,
        outputs: impl AsRef<[types::Output]>,
    ) -> Result<Cookie<types::randr::CreateLeaseReply>> {
        let span = tracing::info_span!(
            "randr_create_lease",
            window = ?window,
            lid = ?lid,
        );
        let _enter = span.enter();
        let request = types::randr::CreateLeaseRequest {
            window,
            lid,
            crtcs: Cow::Borrowed(crtcs.as_ref()),
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        self.send_reply_fd_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_create_lease_immediate(
        &mut self,
        window: types::xproto::Window,
        lid: types::Lease,
        crtcs: impl AsRef<[types::Crtc]>,
        outputs: impl AsRef<[types::Output]>,
    ) -> Result<types::randr::CreateLeaseReply> {
        let cookie = self.randr_create_lease(window, lid, crtcs, outputs)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "randr")]
    fn randr_free_lease(
        &mut self,
        lid: types::Lease,
        terminate: types::Byte,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "randr_free_lease",
            lid = ?lid,
            terminate = ?terminate,
        );
        let _enter = span.enter();
        let request = types::randr::FreeLeaseRequest { lid, terminate };
        self.send_void_request(request)
    }
    #[cfg(feature = "randr")]
    fn randr_free_lease_checked(
        &mut self,
        lid: types::Lease,
        terminate: types::Byte,
    ) -> Result<()> {
        let cookie = self.randr_free_lease(lid, terminate)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "record")]
    fn record_query_version(
        &mut self,
        major_version: types::Card16,
        minor_version: types::Card16,
    ) -> Result<Cookie<types::record::QueryVersionReply>> {
        let span = tracing::info_span!(
            "record_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::record::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "record")]
    fn record_query_version_immediate(
        &mut self,
        major_version: types::Card16,
        minor_version: types::Card16,
    ) -> Result<types::record::QueryVersionReply> {
        let cookie = self.record_query_version(major_version, minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_create_context(
        &mut self,
        context: types::record::Context,
        element_header: types::ElementHeader,
        client_specs: impl AsRef<[types::ClientSpec]>,
        ranges: impl AsRef<[types::Range]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "record_create_context",
            context = ?context,
            element_header = ?element_header,
        );
        let _enter = span.enter();
        let request = types::record::CreateContextRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_create_context_checked(
        &mut self,
        context: types::record::Context,
        element_header: types::ElementHeader,
        client_specs: impl AsRef<[types::ClientSpec]>,
        ranges: impl AsRef<[types::Range]>,
    ) -> Result<()> {
        let cookie = self.record_create_context(context, element_header, client_specs, ranges)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_register_clients(
        &mut self,
        context: types::record::Context,
        element_header: types::ElementHeader,
        client_specs: impl AsRef<[types::ClientSpec]>,
        ranges: impl AsRef<[types::Range]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "record_register_clients",
            context = ?context,
            element_header = ?element_header,
        );
        let _enter = span.enter();
        let request = types::record::RegisterClientsRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_register_clients_checked(
        &mut self,
        context: types::record::Context,
        element_header: types::ElementHeader,
        client_specs: impl AsRef<[types::ClientSpec]>,
        ranges: impl AsRef<[types::Range]>,
    ) -> Result<()> {
        let cookie = self.record_register_clients(context, element_header, client_specs, ranges)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_unregister_clients(
        &mut self,
        context: types::record::Context,
        client_specs: impl AsRef<[types::ClientSpec]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "record_unregister_clients",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::record::UnregisterClientsRequest {
            context,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_unregister_clients_checked(
        &mut self,
        context: types::record::Context,
        client_specs: impl AsRef<[types::ClientSpec]>,
    ) -> Result<()> {
        let cookie = self.record_unregister_clients(context, client_specs)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_get_context(
        &mut self,
        context: types::record::Context,
    ) -> Result<Cookie<types::record::GetContextReply>> {
        let span = tracing::info_span!(
            "record_get_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::record::GetContextRequest { context };
        self.send_reply_request(request)
    }
    #[cfg(feature = "record")]
    fn record_get_context_immediate(
        &mut self,
        context: types::record::Context,
    ) -> Result<types::record::GetContextReply> {
        let cookie = self.record_get_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_enable_context(
        &mut self,
        context: types::record::Context,
    ) -> Result<Cookie<types::record::EnableContextReply>> {
        let span = tracing::info_span!(
            "record_enable_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::record::EnableContextRequest { context };
        self.send_reply_request(request)
    }
    #[cfg(feature = "record")]
    fn record_enable_context_immediate(
        &mut self,
        context: types::record::Context,
    ) -> Result<types::record::EnableContextReply> {
        let cookie = self.record_enable_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_disable_context(&mut self, context: types::record::Context) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "record_disable_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::record::DisableContextRequest { context };
        self.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_disable_context_checked(&mut self, context: types::record::Context) -> Result<()> {
        let cookie = self.record_disable_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "record")]
    fn record_free_context(&mut self, context: types::record::Context) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "record_free_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::record::FreeContextRequest { context };
        self.send_void_request(request)
    }
    #[cfg(feature = "record")]
    fn record_free_context_checked(&mut self, context: types::record::Context) -> Result<()> {
        let cookie = self.record_free_context(context)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "render")]
    fn render_query_version(
        &mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Result<Cookie<types::render::QueryVersionReply>> {
        let span = tracing::info_span!(
            "render_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::render::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_query_version_immediate(
        &mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Result<types::render::QueryVersionReply> {
        let cookie = self.render_query_version(client_major_version, client_minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_formats(
        &mut self,
    ) -> Result<Cookie<types::render::QueryPictFormatsReply>> {
        let span = tracing::info_span!("render_query_pict_formats",);
        let _enter = span.enter();
        let request = types::render::QueryPictFormatsRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_formats_immediate(
        &mut self,
    ) -> Result<types::render::QueryPictFormatsReply> {
        let cookie = self.render_query_pict_formats()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_index_values(
        &mut self,
        format: types::Pictformat,
    ) -> Result<Cookie<types::render::QueryPictIndexValuesReply>> {
        let span = tracing::info_span!(
            "render_query_pict_index_values",
            format = ?format,
        );
        let _enter = span.enter();
        let request = types::render::QueryPictIndexValuesRequest { format };
        self.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_index_values_immediate(
        &mut self,
        format: types::Pictformat,
    ) -> Result<types::render::QueryPictIndexValuesReply> {
        let cookie = self.render_query_pict_index_values(format)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_picture(
        &mut self,
        pid: types::Picture,
        drawable: types::xproto::Drawable,
        format: types::Pictformat,
        value_list: impl Borrow<types::render::CreatePictureAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_picture",
            pid = ?pid,
            drawable = ?drawable,
            format = ?format,
        );
        let _enter = span.enter();
        let request = types::render::CreatePictureRequest {
            pid,
            drawable,
            format,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_picture_checked(
        &mut self,
        pid: types::Picture,
        drawable: types::xproto::Drawable,
        format: types::Pictformat,
        value_list: impl Borrow<types::render::CreatePictureAux>,
    ) -> Result<()> {
        let cookie = self.render_create_picture(pid, drawable, format, value_list)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_change_picture(
        &mut self,
        picture: types::Picture,
        value_list: impl Borrow<types::render::ChangePictureAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_change_picture",
            picture = ?picture,
        );
        let _enter = span.enter();
        let request = types::render::ChangePictureRequest {
            picture,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_change_picture_checked(
        &mut self,
        picture: types::Picture,
        value_list: impl Borrow<types::render::ChangePictureAux>,
    ) -> Result<()> {
        let cookie = self.render_change_picture(picture, value_list)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_clip_rectangles(
        &mut self,
        picture: types::Picture,
        clip_x_origin: types::Int16,
        clip_y_origin: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_set_picture_clip_rectangles",
            picture = ?picture,
            clip_x_origin = ?clip_x_origin,
            clip_y_origin = ?clip_y_origin,
        );
        let _enter = span.enter();
        let request = types::render::SetPictureClipRectanglesRequest {
            picture,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_clip_rectangles_checked(
        &mut self,
        picture: types::Picture,
        clip_x_origin: types::Int16,
        clip_y_origin: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<()> {
        let cookie = self.render_set_picture_clip_rectangles(
            picture,
            clip_x_origin,
            clip_y_origin,
            rectangles,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_free_picture(&mut self, picture: types::Picture) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_free_picture",
            picture = ?picture,
        );
        let _enter = span.enter();
        let request = types::render::FreePictureRequest { picture };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_free_picture_checked(&mut self, picture: types::Picture) -> Result<()> {
        let cookie = self.render_free_picture(picture)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_composite(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        mask: impl Into<types::Picture>,
        dst: types::Picture,
        src_x: types::Int16,
        src_y: types::Int16,
        mask_x: types::Int16,
        mask_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_composite",
            op = ?op,
            src = ?src,
            dst = ?dst,
            src_x = ?src_x,
            src_y = ?src_y,
            mask_x = ?mask_x,
            mask_y = ?mask_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::render::CompositeRequest {
            op,
            src,
            mask: Into::<u32>::into(mask.into()) as _,
            dst,
            src_x,
            src_y,
            mask_x,
            mask_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite_checked(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        mask: impl Into<types::Picture>,
        dst: types::Picture,
        src_x: types::Int16,
        src_y: types::Int16,
        mask_x: types::Int16,
        mask_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<()> {
        let cookie = self.render_composite(
            op, src, mask, dst, src_x, src_y, mask_x, mask_y, dst_x, dst_y, width, height,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_trapezoids(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        traps: impl AsRef<[types::Trapezoid]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_trapezoids",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::TrapezoidsRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_trapezoids_checked(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        traps: impl AsRef<[types::Trapezoid]>,
    ) -> Result<()> {
        let cookie = self.render_trapezoids(op, src, dst, mask_format, src_x, src_y, traps)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_triangles(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        triangles: impl AsRef<[types::Triangle]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_triangles",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::TrianglesRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            triangles: Cow::Borrowed(triangles.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_triangles_checked(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        triangles: impl AsRef<[types::Triangle]>,
    ) -> Result<()> {
        let cookie = self.render_triangles(op, src, dst, mask_format, src_x, src_y, triangles)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_tri_strip(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        points: impl AsRef<[types::Pointfix]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_tri_strip",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::TriStripRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_tri_strip_checked(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        points: impl AsRef<[types::Pointfix]>,
    ) -> Result<()> {
        let cookie = self.render_tri_strip(op, src, dst, mask_format, src_x, src_y, points)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_tri_fan(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        points: impl AsRef<[types::Pointfix]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_tri_fan",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::TriFanRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_tri_fan_checked(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        points: impl AsRef<[types::Pointfix]>,
    ) -> Result<()> {
        let cookie = self.render_tri_fan(op, src, dst, mask_format, src_x, src_y, points)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_glyph_set(
        &mut self,
        gsid: types::Glyphset,
        format: types::Pictformat,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_glyph_set",
            gsid = ?gsid,
            format = ?format,
        );
        let _enter = span.enter();
        let request = types::render::CreateGlyphSetRequest { gsid, format };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_glyph_set_checked(
        &mut self,
        gsid: types::Glyphset,
        format: types::Pictformat,
    ) -> Result<()> {
        let cookie = self.render_create_glyph_set(gsid, format)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_reference_glyph_set(
        &mut self,
        gsid: types::Glyphset,
        existing: types::Glyphset,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_reference_glyph_set",
            gsid = ?gsid,
            existing = ?existing,
        );
        let _enter = span.enter();
        let request = types::render::ReferenceGlyphSetRequest { gsid, existing };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_reference_glyph_set_checked(
        &mut self,
        gsid: types::Glyphset,
        existing: types::Glyphset,
    ) -> Result<()> {
        let cookie = self.render_reference_glyph_set(gsid, existing)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_free_glyph_set(&mut self, glyphset: types::Glyphset) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_free_glyph_set",
            glyphset = ?glyphset,
        );
        let _enter = span.enter();
        let request = types::render::FreeGlyphSetRequest { glyphset };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_free_glyph_set_checked(&mut self, glyphset: types::Glyphset) -> Result<()> {
        let cookie = self.render_free_glyph_set(glyphset)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_add_glyphs(
        &mut self,
        glyphset: types::Glyphset,
        glyphids: impl AsRef<[types::Card32]>,
        glyphs: impl AsRef<[types::Glyphinfo]>,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_add_glyphs",
            glyphset = ?glyphset,
        );
        let _enter = span.enter();
        let request = types::render::AddGlyphsRequest {
            glyphset,
            glyphids: Cow::Borrowed(glyphids.as_ref()),
            glyphs: Cow::Borrowed(glyphs.as_ref()),
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_add_glyphs_checked(
        &mut self,
        glyphset: types::Glyphset,
        glyphids: impl AsRef<[types::Card32]>,
        glyphs: impl AsRef<[types::Glyphinfo]>,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<()> {
        let cookie = self.render_add_glyphs(glyphset, glyphids, glyphs, data)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_free_glyphs(
        &mut self,
        glyphset: types::Glyphset,
        glyphs: impl AsRef<[types::Glyph]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_free_glyphs",
            glyphset = ?glyphset,
        );
        let _enter = span.enter();
        let request = types::render::FreeGlyphsRequest {
            glyphset,
            glyphs: Cow::Borrowed(glyphs.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_free_glyphs_checked(
        &mut self,
        glyphset: types::Glyphset,
        glyphs: impl AsRef<[types::Glyph]>,
    ) -> Result<()> {
        let cookie = self.render_free_glyphs(glyphset, glyphs)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs8(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_composite_glyphs8",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::CompositeGlyphs8Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs8_checked(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Result<()> {
        let cookie = self.render_composite_glyphs8(
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs16(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_composite_glyphs16",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::CompositeGlyphs16Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs16_checked(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Result<()> {
        let cookie = self.render_composite_glyphs16(
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs32(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_composite_glyphs32",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::render::CompositeGlyphs32Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs32_checked(
        &mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Result<()> {
        let cookie = self.render_composite_glyphs32(
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_fill_rectangles(
        &mut self,
        op: types::PictOp,
        dst: types::Picture,
        color: types::Color,
        rects: impl AsRef<[types::Rectangle]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_fill_rectangles",
            op = ?op,
            dst = ?dst,
            color = ?color,
        );
        let _enter = span.enter();
        let request = types::render::FillRectanglesRequest {
            op,
            dst,
            color,
            rects: Cow::Borrowed(rects.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_fill_rectangles_checked(
        &mut self,
        op: types::PictOp,
        dst: types::Picture,
        color: types::Color,
        rects: impl AsRef<[types::Rectangle]>,
    ) -> Result<()> {
        let cookie = self.render_fill_rectangles(op, dst, color, rects)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_cursor(
        &mut self,
        cid: types::xproto::Cursor,
        source: types::Picture,
        x: types::Card16,
        y: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_cursor",
            cid = ?cid,
            source = ?source,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::render::CreateCursorRequest { cid, source, x, y };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_cursor_checked(
        &mut self,
        cid: types::xproto::Cursor,
        source: types::Picture,
        x: types::Card16,
        y: types::Card16,
    ) -> Result<()> {
        let cookie = self.render_create_cursor(cid, source, x, y)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_transform(
        &mut self,
        picture: types::Picture,
        transform: types::render::Transform,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_set_picture_transform",
            picture = ?picture,
            transform = ?transform,
        );
        let _enter = span.enter();
        let request = types::render::SetPictureTransformRequest { picture, transform };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_transform_checked(
        &mut self,
        picture: types::Picture,
        transform: types::render::Transform,
    ) -> Result<()> {
        let cookie = self.render_set_picture_transform(picture, transform)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_query_filters(
        &mut self,
        drawable: types::xproto::Drawable,
    ) -> Result<Cookie<types::render::QueryFiltersReply>> {
        let span = tracing::info_span!(
            "render_query_filters",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::render::QueryFiltersRequest { drawable };
        self.send_reply_request(request)
    }
    #[cfg(feature = "render")]
    fn render_query_filters_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
    ) -> Result<types::render::QueryFiltersReply> {
        let cookie = self.render_query_filters(drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_filter(
        &mut self,
        picture: types::Picture,
        filter: impl AsRef<[types::Char]>,
        values: impl AsRef<[types::Fixed]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_set_picture_filter",
            picture = ?picture,
        );
        let _enter = span.enter();
        let request = types::render::SetPictureFilterRequest {
            picture,
            filter: Cow::Borrowed(filter.as_ref()),
            values: Cow::Borrowed(values.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_filter_checked(
        &mut self,
        picture: types::Picture,
        filter: impl AsRef<[types::Char]>,
        values: impl AsRef<[types::Fixed]>,
    ) -> Result<()> {
        let cookie = self.render_set_picture_filter(picture, filter, values)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_anim_cursor(
        &mut self,
        cid: types::xproto::Cursor,
        cursors: impl AsRef<[types::Animcursorelt]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_anim_cursor",
            cid = ?cid,
        );
        let _enter = span.enter();
        let request = types::render::CreateAnimCursorRequest {
            cid,
            cursors: Cow::Borrowed(cursors.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_anim_cursor_checked(
        &mut self,
        cid: types::xproto::Cursor,
        cursors: impl AsRef<[types::Animcursorelt]>,
    ) -> Result<()> {
        let cookie = self.render_create_anim_cursor(cid, cursors)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_add_traps(
        &mut self,
        picture: types::Picture,
        x_off: types::Int16,
        y_off: types::Int16,
        traps: impl AsRef<[types::Trap]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_add_traps",
            picture = ?picture,
            x_off = ?x_off,
            y_off = ?y_off,
        );
        let _enter = span.enter();
        let request = types::render::AddTrapsRequest {
            picture,
            x_off,
            y_off,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_add_traps_checked(
        &mut self,
        picture: types::Picture,
        x_off: types::Int16,
        y_off: types::Int16,
        traps: impl AsRef<[types::Trap]>,
    ) -> Result<()> {
        let cookie = self.render_add_traps(picture, x_off, y_off, traps)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_solid_fill(
        &mut self,
        picture: types::Picture,
        color: types::Color,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_solid_fill",
            picture = ?picture,
            color = ?color,
        );
        let _enter = span.enter();
        let request = types::render::CreateSolidFillRequest { picture, color };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_solid_fill_checked(
        &mut self,
        picture: types::Picture,
        color: types::Color,
    ) -> Result<()> {
        let cookie = self.render_create_solid_fill(picture, color)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_linear_gradient(
        &mut self,
        picture: types::Picture,
        p1: types::Pointfix,
        p2: types::Pointfix,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_linear_gradient",
            picture = ?picture,
            p1 = ?p1,
            p2 = ?p2,
        );
        let _enter = span.enter();
        let request = types::render::CreateLinearGradientRequest {
            picture,
            p1,
            p2,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_linear_gradient_checked(
        &mut self,
        picture: types::Picture,
        p1: types::Pointfix,
        p2: types::Pointfix,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Result<()> {
        let cookie = self.render_create_linear_gradient(picture, p1, p2, stops, colors)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_radial_gradient(
        &mut self,
        picture: types::Picture,
        inner: types::Pointfix,
        outer: types::Pointfix,
        inner_radius: types::Fixed,
        outer_radius: types::Fixed,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_radial_gradient",
            picture = ?picture,
            inner = ?inner,
            outer = ?outer,
            inner_radius = ?inner_radius,
            outer_radius = ?outer_radius,
        );
        let _enter = span.enter();
        let request = types::render::CreateRadialGradientRequest {
            picture,
            inner,
            outer,
            inner_radius,
            outer_radius,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_radial_gradient_checked(
        &mut self,
        picture: types::Picture,
        inner: types::Pointfix,
        outer: types::Pointfix,
        inner_radius: types::Fixed,
        outer_radius: types::Fixed,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Result<()> {
        let cookie = self.render_create_radial_gradient(
            picture,
            inner,
            outer,
            inner_radius,
            outer_radius,
            stops,
            colors,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "render")]
    fn render_create_conical_gradient(
        &mut self,
        picture: types::Picture,
        center: types::Pointfix,
        angle: types::Fixed,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "render_create_conical_gradient",
            picture = ?picture,
            center = ?center,
            angle = ?angle,
        );
        let _enter = span.enter();
        let request = types::render::CreateConicalGradientRequest {
            picture,
            center,
            angle,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "render")]
    fn render_create_conical_gradient_checked(
        &mut self,
        picture: types::Picture,
        center: types::Pointfix,
        angle: types::Fixed,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Result<()> {
        let cookie = self.render_create_conical_gradient(picture, center, angle, stops, colors)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "res")]
    fn res_query_version(
        &mut self,
        client_major: types::Card8,
        client_minor: types::Card8,
    ) -> Result<Cookie<types::res::QueryVersionReply>> {
        let span = tracing::info_span!(
            "res_query_version",
            client_major = ?client_major,
            client_minor = ?client_minor,
        );
        let _enter = span.enter();
        let request = types::res::QueryVersionRequest {
            client_major,
            client_minor,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_version_immediate(
        &mut self,
        client_major: types::Card8,
        client_minor: types::Card8,
    ) -> Result<types::res::QueryVersionReply> {
        let cookie = self.res_query_version(client_major, client_minor)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "res")]
    fn res_query_clients(&mut self) -> Result<Cookie<types::res::QueryClientsReply>> {
        let span = tracing::info_span!("res_query_clients",);
        let _enter = span.enter();
        let request = types::res::QueryClientsRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_clients_immediate(&mut self) -> Result<types::res::QueryClientsReply> {
        let cookie = self.res_query_clients()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "res")]
    fn res_query_client_resources(
        &mut self,
        xid: types::Card32,
    ) -> Result<Cookie<types::res::QueryClientResourcesReply>> {
        let span = tracing::info_span!(
            "res_query_client_resources",
            xid = ?xid,
        );
        let _enter = span.enter();
        let request = types::res::QueryClientResourcesRequest { xid };
        self.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_client_resources_immediate(
        &mut self,
        xid: types::Card32,
    ) -> Result<types::res::QueryClientResourcesReply> {
        let cookie = self.res_query_client_resources(xid)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "res")]
    fn res_query_client_pixmap_bytes(
        &mut self,
        xid: types::Card32,
    ) -> Result<Cookie<types::res::QueryClientPixmapBytesReply>> {
        let span = tracing::info_span!(
            "res_query_client_pixmap_bytes",
            xid = ?xid,
        );
        let _enter = span.enter();
        let request = types::res::QueryClientPixmapBytesRequest { xid };
        self.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_client_pixmap_bytes_immediate(
        &mut self,
        xid: types::Card32,
    ) -> Result<types::res::QueryClientPixmapBytesReply> {
        let cookie = self.res_query_client_pixmap_bytes(xid)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "res")]
    fn res_query_client_ids(
        &mut self,
        specs: impl AsRef<[types::ClientIdSpec]>,
    ) -> Result<Cookie<types::res::QueryClientIdsReply>> {
        let span = tracing::info_span!("res_query_client_ids",);
        let _enter = span.enter();
        let request = types::res::QueryClientIdsRequest {
            specs: Cow::Borrowed(specs.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_client_ids_immediate(
        &mut self,
        specs: impl AsRef<[types::ClientIdSpec]>,
    ) -> Result<types::res::QueryClientIdsReply> {
        let cookie = self.res_query_client_ids(specs)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "res")]
    fn res_query_resource_bytes(
        &mut self,
        client: types::Card32,
        specs: impl AsRef<[types::ResourceIdSpec]>,
    ) -> Result<Cookie<types::res::QueryResourceBytesReply>> {
        let span = tracing::info_span!(
            "res_query_resource_bytes",
            client = ?client,
        );
        let _enter = span.enter();
        let request = types::res::QueryResourceBytesRequest {
            client,
            specs: Cow::Borrowed(specs.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "res")]
    fn res_query_resource_bytes_immediate(
        &mut self,
        client: types::Card32,
        specs: impl AsRef<[types::ResourceIdSpec]>,
    ) -> Result<types::res::QueryResourceBytesReply> {
        let cookie = self.res_query_resource_bytes(client, specs)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "screensaver")]
    fn screensaver_query_version(
        &mut self,
        client_major_version: types::Card8,
        client_minor_version: types::Card8,
    ) -> Result<Cookie<types::screensaver::QueryVersionReply>> {
        let span = tracing::info_span!(
            "screensaver_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::screensaver::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_version_immediate(
        &mut self,
        client_major_version: types::Card8,
        client_minor_version: types::Card8,
    ) -> Result<types::screensaver::QueryVersionReply> {
        let cookie = self.screensaver_query_version(client_major_version, client_minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_info(
        &mut self,
        drawable: types::xproto::Drawable,
    ) -> Result<Cookie<types::screensaver::QueryInfoReply>> {
        let span = tracing::info_span!(
            "screensaver_query_info",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::screensaver::QueryInfoRequest { drawable };
        self.send_reply_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_info_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
    ) -> Result<types::screensaver::QueryInfoReply> {
        let cookie = self.screensaver_query_info(drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_select_input(
        &mut self,
        drawable: types::xproto::Drawable,
        event_mask: impl Into<types::screensaver::Event>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "screensaver_select_input",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::screensaver::SelectInputRequest {
            drawable,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_select_input_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        event_mask: impl Into<types::screensaver::Event>,
    ) -> Result<()> {
        let cookie = self.screensaver_select_input(drawable, event_mask)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_set_attributes(
        &mut self,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        border_width: types::Card16,
        class: types::WindowClass,
        depth: types::Card8,
        visual: types::Visualid,
        value_list: impl Borrow<types::screensaver::SetAttributesAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "screensaver_set_attributes",
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            border_width = ?border_width,
            class = ?class,
            depth = ?depth,
            visual = ?visual,
        );
        let _enter = span.enter();
        let request = types::screensaver::SetAttributesRequest {
            drawable,
            x,
            y,
            width,
            height,
            border_width,
            class,
            depth,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_set_attributes_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        border_width: types::Card16,
        class: types::WindowClass,
        depth: types::Card8,
        visual: types::Visualid,
        value_list: impl Borrow<types::screensaver::SetAttributesAux>,
    ) -> Result<()> {
        let cookie = self.screensaver_set_attributes(
            drawable,
            x,
            y,
            width,
            height,
            border_width,
            class,
            depth,
            visual,
            value_list,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_unset_attributes(
        &mut self,
        drawable: types::xproto::Drawable,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "screensaver_unset_attributes",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::screensaver::UnsetAttributesRequest { drawable };
        self.send_void_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_unset_attributes_checked(
        &mut self,
        drawable: types::xproto::Drawable,
    ) -> Result<()> {
        let cookie = self.screensaver_unset_attributes(drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_suspend(&mut self, suspend: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "screensaver_suspend",
            suspend = ?suspend,
        );
        let _enter = span.enter();
        let request = types::screensaver::SuspendRequest { suspend };
        self.send_void_request(request)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_suspend_checked(&mut self, suspend: types::Card32) -> Result<()> {
        let cookie = self.screensaver_suspend(suspend)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "shape")]
    fn shape_query_version(&mut self) -> Result<Cookie<types::shape::QueryVersionReply>> {
        let span = tracing::info_span!("shape_query_version",);
        let _enter = span.enter();
        let request = types::shape::QueryVersionRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_query_version_immediate(&mut self) -> Result<types::shape::QueryVersionReply> {
        let cookie = self.shape_query_version()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_rectangles(
        &mut self,
        operation: types::SO,
        destination_kind: types::SK,
        ordering: types::ClipOrdering,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shape_rectangles",
            operation = ?operation,
            destination_kind = ?destination_kind,
            ordering = ?ordering,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let _enter = span.enter();
        let request = types::shape::RectanglesRequest {
            operation,
            destination_kind,
            ordering,
            destination_window,
            x_offset,
            y_offset,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_rectangles_checked(
        &mut self,
        operation: types::SO,
        destination_kind: types::SK,
        ordering: types::ClipOrdering,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<()> {
        let cookie = self.shape_rectangles(
            operation,
            destination_kind,
            ordering,
            destination_window,
            x_offset,
            y_offset,
            rectangles,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_mask(
        &mut self,
        operation: types::SO,
        destination_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        source_bitmap: impl Into<types::xproto::Pixmap>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shape_mask",
            operation = ?operation,
            destination_kind = ?destination_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let _enter = span.enter();
        let request = types::shape::MaskRequest {
            operation,
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
            source_bitmap: Into::<u32>::into(source_bitmap.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_mask_checked(
        &mut self,
        operation: types::SO,
        destination_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        source_bitmap: impl Into<types::xproto::Pixmap>,
    ) -> Result<()> {
        let cookie = self.shape_mask(
            operation,
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
            source_bitmap,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_combine(
        &mut self,
        operation: types::SO,
        destination_kind: types::SK,
        source_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        source_window: types::xproto::Window,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shape_combine",
            operation = ?operation,
            destination_kind = ?destination_kind,
            source_kind = ?source_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
            source_window = ?source_window,
        );
        let _enter = span.enter();
        let request = types::shape::CombineRequest {
            operation,
            destination_kind,
            source_kind,
            destination_window,
            x_offset,
            y_offset,
            source_window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_combine_checked(
        &mut self,
        operation: types::SO,
        destination_kind: types::SK,
        source_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        source_window: types::xproto::Window,
    ) -> Result<()> {
        let cookie = self.shape_combine(
            operation,
            destination_kind,
            source_kind,
            destination_window,
            x_offset,
            y_offset,
            source_window,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_offset(
        &mut self,
        destination_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shape_offset",
            destination_kind = ?destination_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let _enter = span.enter();
        let request = types::shape::OffsetRequest {
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_offset_checked(
        &mut self,
        destination_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
    ) -> Result<()> {
        let cookie = self.shape_offset(destination_kind, destination_window, x_offset, y_offset)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_query_extents(
        &mut self,
        destination_window: types::xproto::Window,
    ) -> Result<Cookie<types::shape::QueryExtentsReply>> {
        let span = tracing::info_span!(
            "shape_query_extents",
            destination_window = ?destination_window,
        );
        let _enter = span.enter();
        let request = types::shape::QueryExtentsRequest { destination_window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_query_extents_immediate(
        &mut self,
        destination_window: types::xproto::Window,
    ) -> Result<types::shape::QueryExtentsReply> {
        let cookie = self.shape_query_extents(destination_window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_select_input(
        &mut self,
        destination_window: types::xproto::Window,
        enable: types::Bool,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shape_select_input",
            destination_window = ?destination_window,
            enable = ?enable,
        );
        let _enter = span.enter();
        let request = types::shape::SelectInputRequest {
            destination_window,
            enable,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_select_input_checked(
        &mut self,
        destination_window: types::xproto::Window,
        enable: types::Bool,
    ) -> Result<()> {
        let cookie = self.shape_select_input(destination_window, enable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_input_selected(
        &mut self,
        destination_window: types::xproto::Window,
    ) -> Result<Cookie<types::shape::InputSelectedReply>> {
        let span = tracing::info_span!(
            "shape_input_selected",
            destination_window = ?destination_window,
        );
        let _enter = span.enter();
        let request = types::shape::InputSelectedRequest { destination_window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_input_selected_immediate(
        &mut self,
        destination_window: types::xproto::Window,
    ) -> Result<types::shape::InputSelectedReply> {
        let cookie = self.shape_input_selected(destination_window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shape")]
    fn shape_get_rectangles(
        &mut self,
        window: types::xproto::Window,
        source_kind: types::SK,
    ) -> Result<Cookie<types::shape::GetRectanglesReply>> {
        let span = tracing::info_span!(
            "shape_get_rectangles",
            window = ?window,
            source_kind = ?source_kind,
        );
        let _enter = span.enter();
        let request = types::shape::GetRectanglesRequest {
            window,
            source_kind,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "shape")]
    fn shape_get_rectangles_immediate(
        &mut self,
        window: types::xproto::Window,
        source_kind: types::SK,
    ) -> Result<types::shape::GetRectanglesReply> {
        let cookie = self.shape_get_rectangles(window, source_kind)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "shm")]
    fn shm_query_version(&mut self) -> Result<Cookie<types::shm::QueryVersionReply>> {
        let span = tracing::info_span!("shm_query_version",);
        let _enter = span.enter();
        let request = types::shm::QueryVersionRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_query_version_immediate(&mut self) -> Result<types::shm::QueryVersionReply> {
        let cookie = self.shm_query_version()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_attach(
        &mut self,
        shmseg: types::Seg,
        shmid: types::Card32,
        read_only: types::Bool,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shm_attach",
            shmseg = ?shmseg,
            shmid = ?shmid,
            read_only = ?read_only,
        );
        let _enter = span.enter();
        let request = types::shm::AttachRequest {
            shmseg,
            shmid,
            read_only,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_attach_checked(
        &mut self,
        shmseg: types::Seg,
        shmid: types::Card32,
        read_only: types::Bool,
    ) -> Result<()> {
        let cookie = self.shm_attach(shmseg, shmid, read_only)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_detach(&mut self, shmseg: types::Seg) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shm_detach",
            shmseg = ?shmseg,
        );
        let _enter = span.enter();
        let request = types::shm::DetachRequest { shmseg };
        self.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_detach_checked(&mut self, shmseg: types::Seg) -> Result<()> {
        let cookie = self.shm_detach(shmseg)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_put_image(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        total_width: types::Card16,
        total_height: types::Card16,
        src_x: types::Card16,
        src_y: types::Card16,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        depth: types::Card8,
        format: types::Card8,
        send_event: types::Bool,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shm_put_image",
            drawable = ?drawable,
            gc = ?gc,
            total_width = ?total_width,
            total_height = ?total_height,
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            depth = ?depth,
            format = ?format,
            send_event = ?send_event,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let _enter = span.enter();
        let request = types::shm::PutImageRequest {
            drawable,
            gc,
            total_width,
            total_height,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            depth,
            format,
            send_event,
            shmseg,
            offset,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_put_image_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        total_width: types::Card16,
        total_height: types::Card16,
        src_x: types::Card16,
        src_y: types::Card16,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        depth: types::Card8,
        format: types::Card8,
        send_event: types::Bool,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Result<()> {
        let cookie = self.shm_put_image(
            drawable,
            gc,
            total_width,
            total_height,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            depth,
            format,
            send_event,
            shmseg,
            offset,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_get_image(
        &mut self,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        plane_mask: types::Card32,
        format: types::Card8,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Result<Cookie<types::shm::GetImageReply>> {
        let span = tracing::info_span!(
            "shm_get_image",
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            plane_mask = ?plane_mask,
            format = ?format,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let _enter = span.enter();
        let request = types::shm::GetImageRequest {
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
            format,
            shmseg,
            offset,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_get_image_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        plane_mask: types::Card32,
        format: types::Card8,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Result<types::shm::GetImageReply> {
        let cookie = self.shm_get_image(
            drawable, x, y, width, height, plane_mask, format, shmseg, offset,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_create_pixmap(
        &mut self,
        pid: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
        depth: types::Card8,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shm_create_pixmap",
            pid = ?pid,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
            depth = ?depth,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let _enter = span.enter();
        let request = types::shm::CreatePixmapRequest {
            pid,
            drawable,
            width,
            height,
            depth,
            shmseg,
            offset,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_create_pixmap_checked(
        &mut self,
        pid: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
        depth: types::Card8,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Result<()> {
        let cookie = self.shm_create_pixmap(pid, drawable, width, height, depth, shmseg, offset)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_attach_fd(
        &mut self,
        shmseg: types::Seg,
        shm_fd: types::Fd,
        read_only: types::Bool,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "shm_attach_fd",
            shmseg = ?shmseg,
            shm_fd = ?shm_fd,
            read_only = ?read_only,
        );
        let _enter = span.enter();
        let request = types::shm::AttachFdRequest {
            shmseg,
            shm_fd,
            read_only,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_attach_fd_checked(
        &mut self,
        shmseg: types::Seg,
        shm_fd: types::Fd,
        read_only: types::Bool,
    ) -> Result<()> {
        let cookie = self.shm_attach_fd(shmseg, shm_fd, read_only)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "shm")]
    fn shm_create_segment(
        &mut self,
        shmseg: types::Seg,
        size: types::Card32,
        read_only: types::Bool,
    ) -> Result<Cookie<types::shm::CreateSegmentReply>> {
        let span = tracing::info_span!(
            "shm_create_segment",
            shmseg = ?shmseg,
            size = ?size,
            read_only = ?read_only,
        );
        let _enter = span.enter();
        let request = types::shm::CreateSegmentRequest {
            shmseg,
            size,
            read_only,
        };
        self.send_reply_fd_request(request)
    }
    #[cfg(feature = "shm")]
    fn shm_create_segment_immediate(
        &mut self,
        shmseg: types::Seg,
        size: types::Card32,
        read_only: types::Bool,
    ) -> Result<types::shm::CreateSegmentReply> {
        let cookie = self.shm_create_segment(shmseg, size, read_only)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "sync")]
    fn sync_initialize(
        &mut self,
        desired_major_version: types::Card8,
        desired_minor_version: types::Card8,
    ) -> Result<Cookie<types::sync::InitializeReply>> {
        let span = tracing::info_span!(
            "sync_initialize",
            desired_major_version = ?desired_major_version,
            desired_minor_version = ?desired_minor_version,
        );
        let _enter = span.enter();
        let request = types::sync::InitializeRequest {
            desired_major_version,
            desired_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_initialize_immediate(
        &mut self,
        desired_major_version: types::Card8,
        desired_minor_version: types::Card8,
    ) -> Result<types::sync::InitializeReply> {
        let cookie = self.sync_initialize(desired_major_version, desired_minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_list_system_counters(
        &mut self,
    ) -> Result<Cookie<types::sync::ListSystemCountersReply>> {
        let span = tracing::info_span!("sync_list_system_counters",);
        let _enter = span.enter();
        let request = types::sync::ListSystemCountersRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_list_system_counters_immediate(
        &mut self,
    ) -> Result<types::sync::ListSystemCountersReply> {
        let cookie = self.sync_list_system_counters()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_create_counter(
        &mut self,
        id: types::Counter,
        initial_value: types::sync::Int64,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_create_counter",
            id = ?id,
            initial_value = ?initial_value,
        );
        let _enter = span.enter();
        let request = types::sync::CreateCounterRequest { id, initial_value };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_create_counter_checked(
        &mut self,
        id: types::Counter,
        initial_value: types::sync::Int64,
    ) -> Result<()> {
        let cookie = self.sync_create_counter(id, initial_value)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_counter(&mut self, counter: types::Counter) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_destroy_counter",
            counter = ?counter,
        );
        let _enter = span.enter();
        let request = types::sync::DestroyCounterRequest { counter };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_counter_checked(&mut self, counter: types::Counter) -> Result<()> {
        let cookie = self.sync_destroy_counter(counter)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_query_counter(
        &mut self,
        counter: types::Counter,
    ) -> Result<Cookie<types::sync::QueryCounterReply>> {
        let span = tracing::info_span!(
            "sync_query_counter",
            counter = ?counter,
        );
        let _enter = span.enter();
        let request = types::sync::QueryCounterRequest { counter };
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_query_counter_immediate(
        &mut self,
        counter: types::Counter,
    ) -> Result<types::sync::QueryCounterReply> {
        let cookie = self.sync_query_counter(counter)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_await(&mut self, wait_list: impl AsRef<[types::Waitcondition]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!("sync_await",);
        let _enter = span.enter();
        let request = types::sync::AwaitRequest {
            wait_list: Cow::Borrowed(wait_list.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_await_checked(&mut self, wait_list: impl AsRef<[types::Waitcondition]>) -> Result<()> {
        let cookie = self.sync_await(wait_list)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_change_counter(
        &mut self,
        counter: types::Counter,
        amount: types::sync::Int64,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_change_counter",
            counter = ?counter,
            amount = ?amount,
        );
        let _enter = span.enter();
        let request = types::sync::ChangeCounterRequest { counter, amount };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_change_counter_checked(
        &mut self,
        counter: types::Counter,
        amount: types::sync::Int64,
    ) -> Result<()> {
        let cookie = self.sync_change_counter(counter, amount)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_set_counter(
        &mut self,
        counter: types::Counter,
        value: types::sync::Int64,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_set_counter",
            counter = ?counter,
            value = ?value,
        );
        let _enter = span.enter();
        let request = types::sync::SetCounterRequest { counter, value };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_set_counter_checked(
        &mut self,
        counter: types::Counter,
        value: types::sync::Int64,
    ) -> Result<()> {
        let cookie = self.sync_set_counter(counter, value)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_create_alarm(
        &mut self,
        id: types::Alarm,
        value_list: impl Borrow<types::sync::CreateAlarmAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_create_alarm",
            id = ?id,
        );
        let _enter = span.enter();
        let request = types::sync::CreateAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_create_alarm_checked(
        &mut self,
        id: types::Alarm,
        value_list: impl Borrow<types::sync::CreateAlarmAux>,
    ) -> Result<()> {
        let cookie = self.sync_create_alarm(id, value_list)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_change_alarm(
        &mut self,
        id: types::Alarm,
        value_list: impl Borrow<types::sync::ChangeAlarmAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_change_alarm",
            id = ?id,
        );
        let _enter = span.enter();
        let request = types::sync::ChangeAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_change_alarm_checked(
        &mut self,
        id: types::Alarm,
        value_list: impl Borrow<types::sync::ChangeAlarmAux>,
    ) -> Result<()> {
        let cookie = self.sync_change_alarm(id, value_list)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_alarm(&mut self, alarm: types::Alarm) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_destroy_alarm",
            alarm = ?alarm,
        );
        let _enter = span.enter();
        let request = types::sync::DestroyAlarmRequest { alarm };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_alarm_checked(&mut self, alarm: types::Alarm) -> Result<()> {
        let cookie = self.sync_destroy_alarm(alarm)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_query_alarm(
        &mut self,
        alarm: types::Alarm,
    ) -> Result<Cookie<types::sync::QueryAlarmReply>> {
        let span = tracing::info_span!(
            "sync_query_alarm",
            alarm = ?alarm,
        );
        let _enter = span.enter();
        let request = types::sync::QueryAlarmRequest { alarm };
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_query_alarm_immediate(
        &mut self,
        alarm: types::Alarm,
    ) -> Result<types::sync::QueryAlarmReply> {
        let cookie = self.sync_query_alarm(alarm)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_set_priority(
        &mut self,
        id: types::Card32,
        priority: types::Int32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_set_priority",
            id = ?id,
            priority = ?priority,
        );
        let _enter = span.enter();
        let request = types::sync::SetPriorityRequest { id, priority };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_set_priority_checked(
        &mut self,
        id: types::Card32,
        priority: types::Int32,
    ) -> Result<()> {
        let cookie = self.sync_set_priority(id, priority)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_get_priority(
        &mut self,
        id: types::Card32,
    ) -> Result<Cookie<types::sync::GetPriorityReply>> {
        let span = tracing::info_span!(
            "sync_get_priority",
            id = ?id,
        );
        let _enter = span.enter();
        let request = types::sync::GetPriorityRequest { id };
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_get_priority_immediate(
        &mut self,
        id: types::Card32,
    ) -> Result<types::sync::GetPriorityReply> {
        let cookie = self.sync_get_priority(id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_create_fence(
        &mut self,
        drawable: types::xproto::Drawable,
        fence: types::Fence,
        initially_triggered: types::Bool,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_create_fence",
            drawable = ?drawable,
            fence = ?fence,
            initially_triggered = ?initially_triggered,
        );
        let _enter = span.enter();
        let request = types::sync::CreateFenceRequest {
            drawable,
            fence,
            initially_triggered,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_create_fence_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        fence: types::Fence,
        initially_triggered: types::Bool,
    ) -> Result<()> {
        let cookie = self.sync_create_fence(drawable, fence, initially_triggered)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_trigger_fence(&mut self, fence: types::Fence) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_trigger_fence",
            fence = ?fence,
        );
        let _enter = span.enter();
        let request = types::sync::TriggerFenceRequest { fence };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_trigger_fence_checked(&mut self, fence: types::Fence) -> Result<()> {
        let cookie = self.sync_trigger_fence(fence)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_reset_fence(&mut self, fence: types::Fence) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_reset_fence",
            fence = ?fence,
        );
        let _enter = span.enter();
        let request = types::sync::ResetFenceRequest { fence };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_reset_fence_checked(&mut self, fence: types::Fence) -> Result<()> {
        let cookie = self.sync_reset_fence(fence)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_fence(&mut self, fence: types::Fence) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "sync_destroy_fence",
            fence = ?fence,
        );
        let _enter = span.enter();
        let request = types::sync::DestroyFenceRequest { fence };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_fence_checked(&mut self, fence: types::Fence) -> Result<()> {
        let cookie = self.sync_destroy_fence(fence)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_query_fence(
        &mut self,
        fence: types::Fence,
    ) -> Result<Cookie<types::sync::QueryFenceReply>> {
        let span = tracing::info_span!(
            "sync_query_fence",
            fence = ?fence,
        );
        let _enter = span.enter();
        let request = types::sync::QueryFenceRequest { fence };
        self.send_reply_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_query_fence_immediate(
        &mut self,
        fence: types::Fence,
    ) -> Result<types::sync::QueryFenceReply> {
        let cookie = self.sync_query_fence(fence)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "sync")]
    fn sync_await_fence(&mut self, fence_list: impl AsRef<[types::Fence]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!("sync_await_fence",);
        let _enter = span.enter();
        let request = types::sync::AwaitFenceRequest {
            fence_list: Cow::Borrowed(fence_list.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "sync")]
    fn sync_await_fence_checked(&mut self, fence_list: impl AsRef<[types::Fence]>) -> Result<()> {
        let cookie = self.sync_await_fence(fence_list)?;
        self.wait_for_reply(cookie)
    }

    fn xc_misc_get_version(
        &mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Result<Cookie<types::xc_misc::GetVersionReply>> {
        let span = tracing::info_span!(
            "xc_misc_get_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::xc_misc::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    fn xc_misc_get_version_immediate(
        &mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Result<types::xc_misc::GetVersionReply> {
        let cookie = self.xc_misc_get_version(client_major_version, client_minor_version)?;
        self.wait_for_reply(cookie)
    }
    fn xc_misc_get_xid_range(&mut self) -> Result<Cookie<types::xc_misc::GetXIDRangeReply>> {
        let span = tracing::info_span!("xc_misc_get_xid_range",);
        let _enter = span.enter();
        let request = types::xc_misc::GetXIDRangeRequest {};
        self.send_reply_request(request)
    }
    fn xc_misc_get_xid_range_immediate(&mut self) -> Result<types::xc_misc::GetXIDRangeReply> {
        let cookie = self.xc_misc_get_xid_range()?;
        self.wait_for_reply(cookie)
    }
    fn xc_misc_get_xid_list(
        &mut self,
        count: types::Card32,
    ) -> Result<Cookie<types::xc_misc::GetXIDListReply>> {
        let span = tracing::info_span!(
            "xc_misc_get_xid_list",
            count = ?count,
        );
        let _enter = span.enter();
        let request = types::xc_misc::GetXIDListRequest { count };
        self.send_reply_request(request)
    }
    fn xc_misc_get_xid_list_immediate(
        &mut self,
        count: types::Card32,
    ) -> Result<types::xc_misc::GetXIDListReply> {
        let cookie = self.xc_misc_get_xid_list(count)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xevie")]
    fn xevie_query_version(
        &mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Result<Cookie<types::xevie::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xevie_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::xevie::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_query_version_immediate(
        &mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Result<types::xevie::QueryVersionReply> {
        let cookie = self.xevie_query_version(client_major_version, client_minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xevie")]
    fn xevie_start(&mut self, screen: types::Card32) -> Result<Cookie<types::xevie::StartReply>> {
        let span = tracing::info_span!(
            "xevie_start",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xevie::StartRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_start_immediate(&mut self, screen: types::Card32) -> Result<types::xevie::StartReply> {
        let cookie = self.xevie_start(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xevie")]
    fn xevie_end(&mut self, cmap: types::Card32) -> Result<Cookie<types::xevie::EndReply>> {
        let span = tracing::info_span!(
            "xevie_end",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xevie::EndRequest { cmap };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_end_immediate(&mut self, cmap: types::Card32) -> Result<types::xevie::EndReply> {
        let cookie = self.xevie_end(cmap)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xevie")]
    fn xevie_send(
        &mut self,
        event: types::xevie::Event,
        data_type: types::Card32,
    ) -> Result<Cookie<types::xevie::SendReply>> {
        let span = tracing::info_span!(
            "xevie_send",
            event = ?event,
            data_type = ?data_type,
        );
        let _enter = span.enter();
        let request = types::xevie::SendRequest { event, data_type };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_send_immediate(
        &mut self,
        event: types::xevie::Event,
        data_type: types::Card32,
    ) -> Result<types::xevie::SendReply> {
        let cookie = self.xevie_send(event, data_type)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xevie")]
    fn xevie_select_input(
        &mut self,
        event_mask: types::Card32,
    ) -> Result<Cookie<types::xevie::SelectInputReply>> {
        let span = tracing::info_span!(
            "xevie_select_input",
            event_mask = ?event_mask,
        );
        let _enter = span.enter();
        let request = types::xevie::SelectInputRequest { event_mask };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xevie")]
    fn xevie_select_input_immediate(
        &mut self,
        event_mask: types::Card32,
    ) -> Result<types::xevie::SelectInputReply> {
        let cookie = self.xevie_select_input(event_mask)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_version(&mut self) -> Result<Cookie<types::xf86dri::QueryVersionReply>> {
        let span = tracing::info_span!("xf86dri_query_version",);
        let _enter = span.enter();
        let request = types::xf86dri::QueryVersionRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_version_immediate(&mut self) -> Result<types::xf86dri::QueryVersionReply> {
        let cookie = self.xf86dri_query_version()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_direct_rendering_capable(
        &mut self,
        screen: types::Card32,
    ) -> Result<Cookie<types::xf86dri::QueryDirectRenderingCapableReply>> {
        let span = tracing::info_span!(
            "xf86dri_query_direct_rendering_capable",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86dri::QueryDirectRenderingCapableRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_direct_rendering_capable_immediate(
        &mut self,
        screen: types::Card32,
    ) -> Result<types::xf86dri::QueryDirectRenderingCapableReply> {
        let cookie = self.xf86dri_query_direct_rendering_capable(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_open_connection(
        &mut self,
        screen: types::Card32,
    ) -> Result<Cookie<types::xf86dri::OpenConnectionReply>> {
        let span = tracing::info_span!(
            "xf86dri_open_connection",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86dri::OpenConnectionRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_open_connection_immediate(
        &mut self,
        screen: types::Card32,
    ) -> Result<types::xf86dri::OpenConnectionReply> {
        let cookie = self.xf86dri_open_connection(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_close_connection(&mut self, screen: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86dri_close_connection",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86dri::CloseConnectionRequest { screen };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_close_connection_checked(&mut self, screen: types::Card32) -> Result<()> {
        let cookie = self.xf86dri_close_connection(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_client_driver_name(
        &mut self,
        screen: types::Card32,
    ) -> Result<Cookie<types::xf86dri::GetClientDriverNameReply>> {
        let span = tracing::info_span!(
            "xf86dri_get_client_driver_name",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86dri::GetClientDriverNameRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_client_driver_name_immediate(
        &mut self,
        screen: types::Card32,
    ) -> Result<types::xf86dri::GetClientDriverNameReply> {
        let cookie = self.xf86dri_get_client_driver_name(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_context(
        &mut self,
        screen: types::Card32,
        visual: types::Card32,
        context: types::Card32,
    ) -> Result<Cookie<types::xf86dri::CreateContextReply>> {
        let span = tracing::info_span!(
            "xf86dri_create_context",
            screen = ?screen,
            visual = ?visual,
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xf86dri::CreateContextRequest {
            screen,
            visual,
            context,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_context_immediate(
        &mut self,
        screen: types::Card32,
        visual: types::Card32,
        context: types::Card32,
    ) -> Result<types::xf86dri::CreateContextReply> {
        let cookie = self.xf86dri_create_context(screen, visual, context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_context(
        &mut self,
        screen: types::Card32,
        context: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86dri_destroy_context",
            screen = ?screen,
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xf86dri::DestroyContextRequest { screen, context };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_context_checked(
        &mut self,
        screen: types::Card32,
        context: types::Card32,
    ) -> Result<()> {
        let cookie = self.xf86dri_destroy_context(screen, context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_drawable(
        &mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Result<Cookie<types::xf86dri::CreateDrawableReply>> {
        let span = tracing::info_span!(
            "xf86dri_create_drawable",
            screen = ?screen,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xf86dri::CreateDrawableRequest { screen, drawable };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_drawable_immediate(
        &mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Result<types::xf86dri::CreateDrawableReply> {
        let cookie = self.xf86dri_create_drawable(screen, drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_drawable(
        &mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86dri_destroy_drawable",
            screen = ?screen,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xf86dri::DestroyDrawableRequest { screen, drawable };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_drawable_checked(
        &mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Result<()> {
        let cookie = self.xf86dri_destroy_drawable(screen, drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_drawable_info(
        &mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Result<Cookie<types::xf86dri::GetDrawableInfoReply>> {
        let span = tracing::info_span!(
            "xf86dri_get_drawable_info",
            screen = ?screen,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xf86dri::GetDrawableInfoRequest { screen, drawable };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_drawable_info_immediate(
        &mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Result<types::xf86dri::GetDrawableInfoReply> {
        let cookie = self.xf86dri_get_drawable_info(screen, drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_device_info(
        &mut self,
        screen: types::Card32,
    ) -> Result<Cookie<types::xf86dri::GetDeviceInfoReply>> {
        let span = tracing::info_span!(
            "xf86dri_get_device_info",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86dri::GetDeviceInfoRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_device_info_immediate(
        &mut self,
        screen: types::Card32,
    ) -> Result<types::xf86dri::GetDeviceInfoReply> {
        let cookie = self.xf86dri_get_device_info(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_auth_connection(
        &mut self,
        screen: types::Card32,
        magic: types::Card32,
    ) -> Result<Cookie<types::xf86dri::AuthConnectionReply>> {
        let span = tracing::info_span!(
            "xf86dri_auth_connection",
            screen = ?screen,
            magic = ?magic,
        );
        let _enter = span.enter();
        let request = types::xf86dri::AuthConnectionRequest { screen, magic };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_auth_connection_immediate(
        &mut self,
        screen: types::Card32,
        magic: types::Card32,
    ) -> Result<types::xf86dri::AuthConnectionReply> {
        let cookie = self.xf86dri_auth_connection(screen, magic)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_query_version(
        &mut self,
    ) -> Result<Cookie<types::xf86vidmode::QueryVersionReply>> {
        let span = tracing::info_span!("xf86vidmode_query_version",);
        let _enter = span.enter();
        let request = types::xf86vidmode::QueryVersionRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_query_version_immediate(
        &mut self,
    ) -> Result<types::xf86vidmode::QueryVersionReply> {
        let cookie = self.xf86vidmode_query_version()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_mode_line(
        &mut self,
        screen: types::Card16,
    ) -> Result<Cookie<types::xf86vidmode::GetModeLineReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_mode_line",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetModeLineRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_mode_line_immediate(
        &mut self,
        screen: types::Card16,
    ) -> Result<types::xf86vidmode::GetModeLineReply> {
        let cookie = self.xf86vidmode_get_mode_line(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_mod_mode_line(
        &mut self,
        screen: types::Card32,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_mod_mode_line",
            screen = ?screen,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::ModModeLineRequest {
            screen,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_mod_mode_line_checked(
        &mut self,
        screen: types::Card32,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Result<()> {
        let cookie = self.xf86vidmode_mod_mode_line(
            screen, hdisplay, hsyncstart, hsyncend, htotal, hskew, vdisplay, vsyncstart, vsyncend,
            vtotal, flags, private,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_mode(
        &mut self,
        screen: types::Card16,
        zoom: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_switch_mode",
            screen = ?screen,
            zoom = ?zoom,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SwitchModeRequest { screen, zoom };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_mode_checked(
        &mut self,
        screen: types::Card16,
        zoom: types::Card16,
    ) -> Result<()> {
        let cookie = self.xf86vidmode_switch_mode(screen, zoom)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_monitor(
        &mut self,
        screen: types::Card16,
    ) -> Result<Cookie<types::xf86vidmode::GetMonitorReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_monitor",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetMonitorRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_monitor_immediate(
        &mut self,
        screen: types::Card16,
    ) -> Result<types::xf86vidmode::GetMonitorReply> {
        let cookie = self.xf86vidmode_get_monitor(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_lock_mode_switch(
        &mut self,
        screen: types::Card16,
        lock: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_lock_mode_switch",
            screen = ?screen,
            lock = ?lock,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::LockModeSwitchRequest { screen, lock };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_lock_mode_switch_checked(
        &mut self,
        screen: types::Card16,
        lock: types::Card16,
    ) -> Result<()> {
        let cookie = self.xf86vidmode_lock_mode_switch(screen, lock)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_all_mode_lines(
        &mut self,
        screen: types::Card16,
    ) -> Result<Cookie<types::xf86vidmode::GetAllModeLinesReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_all_mode_lines",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetAllModeLinesRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_all_mode_lines_immediate(
        &mut self,
        screen: types::Card16,
    ) -> Result<types::xf86vidmode::GetAllModeLinesReply> {
        let cookie = self.xf86vidmode_get_all_mode_lines(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_add_mode_line(
        &mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        after_dotclock: types::Dotclock,
        after_hdisplay: types::Card16,
        after_hsyncstart: types::Card16,
        after_hsyncend: types::Card16,
        after_htotal: types::Card16,
        after_hskew: types::Card16,
        after_vdisplay: types::Card16,
        after_vsyncstart: types::Card16,
        after_vsyncend: types::Card16,
        after_vtotal: types::Card16,
        after_flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_add_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
            after_dotclock = ?after_dotclock,
            after_hdisplay = ?after_hdisplay,
            after_hsyncstart = ?after_hsyncstart,
            after_hsyncend = ?after_hsyncend,
            after_htotal = ?after_htotal,
            after_hskew = ?after_hskew,
            after_vdisplay = ?after_vdisplay,
            after_vsyncstart = ?after_vsyncstart,
            after_vsyncend = ?after_vsyncend,
            after_vtotal = ?after_vtotal,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::AddModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            after_dotclock,
            after_hdisplay,
            after_hsyncstart,
            after_hsyncend,
            after_htotal,
            after_hskew,
            after_vdisplay,
            after_vsyncstart,
            after_vsyncend,
            after_vtotal,
            after_flags: Into::<u32>::into(after_flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_add_mode_line_checked(
        &mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        after_dotclock: types::Dotclock,
        after_hdisplay: types::Card16,
        after_hsyncstart: types::Card16,
        after_hsyncend: types::Card16,
        after_htotal: types::Card16,
        after_hskew: types::Card16,
        after_vdisplay: types::Card16,
        after_vsyncstart: types::Card16,
        after_vsyncend: types::Card16,
        after_vtotal: types::Card16,
        after_flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Result<()> {
        let cookie = self.xf86vidmode_add_mode_line(
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags,
            after_dotclock,
            after_hdisplay,
            after_hsyncstart,
            after_hsyncend,
            after_htotal,
            after_hskew,
            after_vdisplay,
            after_vsyncstart,
            after_vsyncend,
            after_vtotal,
            after_flags,
            private,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_delete_mode_line(
        &mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_delete_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::DeleteModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_delete_mode_line_checked(
        &mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Result<()> {
        let cookie = self.xf86vidmode_delete_mode_line(
            screen, dotclock, hdisplay, hsyncstart, hsyncend, htotal, hskew, vdisplay, vsyncstart,
            vsyncend, vtotal, flags, private,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_validate_mode_line(
        &mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Result<Cookie<types::xf86vidmode::ValidateModeLineReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_validate_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::ValidateModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_validate_mode_line_immediate(
        &mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Result<types::xf86vidmode::ValidateModeLineReply> {
        let cookie = self.xf86vidmode_validate_mode_line(
            screen, dotclock, hdisplay, hsyncstart, hsyncend, htotal, hskew, vdisplay, vsyncstart,
            vsyncend, vtotal, flags, private,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_to_mode(
        &mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_switch_to_mode",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SwitchToModeRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_to_mode_checked(
        &mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Result<()> {
        let cookie = self.xf86vidmode_switch_to_mode(
            screen, dotclock, hdisplay, hsyncstart, hsyncend, htotal, hskew, vdisplay, vsyncstart,
            vsyncend, vtotal, flags, private,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_view_port(
        &mut self,
        screen: types::Card16,
    ) -> Result<Cookie<types::xf86vidmode::GetViewPortReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_view_port",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetViewPortRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_view_port_immediate(
        &mut self,
        screen: types::Card16,
    ) -> Result<types::xf86vidmode::GetViewPortReply> {
        let cookie = self.xf86vidmode_get_view_port(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_view_port(
        &mut self,
        screen: types::Card16,
        x: types::Card32,
        y: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_view_port",
            screen = ?screen,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SetViewPortRequest { screen, x, y };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_view_port_checked(
        &mut self,
        screen: types::Card16,
        x: types::Card32,
        y: types::Card32,
    ) -> Result<()> {
        let cookie = self.xf86vidmode_set_view_port(screen, x, y)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_dot_clocks(
        &mut self,
        screen: types::Card16,
    ) -> Result<Cookie<types::xf86vidmode::GetDotClocksReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_dot_clocks",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetDotClocksRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_dot_clocks_immediate(
        &mut self,
        screen: types::Card16,
    ) -> Result<types::xf86vidmode::GetDotClocksReply> {
        let cookie = self.xf86vidmode_get_dot_clocks(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_client_version(
        &mut self,
        major: types::Card16,
        minor: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_client_version",
            major = ?major,
            minor = ?minor,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SetClientVersionRequest { major, minor };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_client_version_checked(
        &mut self,
        major: types::Card16,
        minor: types::Card16,
    ) -> Result<()> {
        let cookie = self.xf86vidmode_set_client_version(major, minor)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma(
        &mut self,
        screen: types::Card16,
        red: types::Card32,
        green: types::Card32,
        blue: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_gamma",
            screen = ?screen,
            red = ?red,
            green = ?green,
            blue = ?blue,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SetGammaRequest {
            screen,
            red,
            green,
            blue,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_checked(
        &mut self,
        screen: types::Card16,
        red: types::Card32,
        green: types::Card32,
        blue: types::Card32,
    ) -> Result<()> {
        let cookie = self.xf86vidmode_set_gamma(screen, red, green, blue)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma(
        &mut self,
        screen: types::Card16,
    ) -> Result<Cookie<types::xf86vidmode::GetGammaReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetGammaRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_immediate(
        &mut self,
        screen: types::Card16,
    ) -> Result<types::xf86vidmode::GetGammaReply> {
        let cookie = self.xf86vidmode_get_gamma(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp(
        &mut self,
        screen: types::Card16,
        size: types::Card16,
    ) -> Result<Cookie<types::xf86vidmode::GetGammaRampReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma_ramp",
            screen = ?screen,
            size = ?size,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetGammaRampRequest { screen, size };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_immediate(
        &mut self,
        screen: types::Card16,
        size: types::Card16,
    ) -> Result<types::xf86vidmode::GetGammaRampReply> {
        let cookie = self.xf86vidmode_get_gamma_ramp(screen, size)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_ramp(
        &mut self,
        screen: types::Card16,
        size: types::Card16,
        red: impl AsRef<[types::Card16]>,
        green: impl AsRef<[types::Card16]>,
        blue: impl AsRef<[types::Card16]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_gamma_ramp",
            screen = ?screen,
            size = ?size,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::SetGammaRampRequest {
            screen,
            size,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_ramp_checked(
        &mut self,
        screen: types::Card16,
        size: types::Card16,
        red: impl AsRef<[types::Card16]>,
        green: impl AsRef<[types::Card16]>,
        blue: impl AsRef<[types::Card16]>,
    ) -> Result<()> {
        let cookie = self.xf86vidmode_set_gamma_ramp(screen, size, red, green, blue)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_size(
        &mut self,
        screen: types::Card16,
    ) -> Result<Cookie<types::xf86vidmode::GetGammaRampSizeReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma_ramp_size",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetGammaRampSizeRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_size_immediate(
        &mut self,
        screen: types::Card16,
    ) -> Result<types::xf86vidmode::GetGammaRampSizeReply> {
        let cookie = self.xf86vidmode_get_gamma_ramp_size(screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_permissions(
        &mut self,
        screen: types::Card16,
    ) -> Result<Cookie<types::xf86vidmode::GetPermissionsReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_permissions",
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xf86vidmode::GetPermissionsRequest { screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_permissions_immediate(
        &mut self,
        screen: types::Card16,
    ) -> Result<types::xf86vidmode::GetPermissionsReply> {
        let cookie = self.xf86vidmode_get_permissions(screen)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xfixes")]
    fn xfixes_query_version(
        &mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Result<Cookie<types::xfixes::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xfixes_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let _enter = span.enter();
        let request = types::xfixes::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_query_version_immediate(
        &mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Result<types::xfixes::QueryVersionReply> {
        let cookie = self.xfixes_query_version(client_major_version, client_minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_save_set(
        &mut self,
        mode: types::SaveSetMode,
        target: types::SaveSetTarget,
        map: types::SaveSetMapping,
        window: types::xproto::Window,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_change_save_set",
            mode = ?mode,
            target = ?target,
            map = ?map,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xfixes::ChangeSaveSetRequest {
            mode,
            target,
            map,
            window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_save_set_checked(
        &mut self,
        mode: types::SaveSetMode,
        target: types::SaveSetTarget,
        map: types::SaveSetMapping,
        window: types::xproto::Window,
    ) -> Result<()> {
        let cookie = self.xfixes_change_save_set(mode, target, map, window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_selection_input(
        &mut self,
        window: types::xproto::Window,
        selection: types::Atom,
        event_mask: impl Into<types::SelectionEventMask>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_select_selection_input",
            window = ?window,
            selection = ?selection,
        );
        let _enter = span.enter();
        let request = types::xfixes::SelectSelectionInputRequest {
            window,
            selection,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_selection_input_checked(
        &mut self,
        window: types::xproto::Window,
        selection: types::Atom,
        event_mask: impl Into<types::SelectionEventMask>,
    ) -> Result<()> {
        let cookie = self.xfixes_select_selection_input(window, selection, event_mask)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_cursor_input(
        &mut self,
        window: types::xproto::Window,
        event_mask: impl Into<types::CursorNotifyMask>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_select_cursor_input",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xfixes::SelectCursorInputRequest {
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_cursor_input_checked(
        &mut self,
        window: types::xproto::Window,
        event_mask: impl Into<types::CursorNotifyMask>,
    ) -> Result<()> {
        let cookie = self.xfixes_select_cursor_input(window, event_mask)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image(&mut self) -> Result<Cookie<types::xfixes::GetCursorImageReply>> {
        let span = tracing::info_span!("xfixes_get_cursor_image",);
        let _enter = span.enter();
        let request = types::xfixes::GetCursorImageRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_immediate(&mut self) -> Result<types::xfixes::GetCursorImageReply> {
        let cookie = self.xfixes_get_cursor_image()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region(
        &mut self,
        region: types::Region,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_region",
            region = ?region,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreateRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_checked(
        &mut self,
        region: types::Region,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<()> {
        let cookie = self.xfixes_create_region(region, rectangles)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_bitmap(
        &mut self,
        region: types::Region,
        bitmap: types::xproto::Pixmap,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_bitmap",
            region = ?region,
            bitmap = ?bitmap,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreateRegionFromBitmapRequest { region, bitmap };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_bitmap_checked(
        &mut self,
        region: types::Region,
        bitmap: types::xproto::Pixmap,
    ) -> Result<()> {
        let cookie = self.xfixes_create_region_from_bitmap(region, bitmap)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_window(
        &mut self,
        region: types::Region,
        window: types::xproto::Window,
        kind: types::SK,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_window",
            region = ?region,
            window = ?window,
            kind = ?kind,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreateRegionFromWindowRequest {
            region,
            window,
            kind,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_window_checked(
        &mut self,
        region: types::Region,
        window: types::xproto::Window,
        kind: types::SK,
    ) -> Result<()> {
        let cookie = self.xfixes_create_region_from_window(region, window, kind)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_gc(
        &mut self,
        region: types::Region,
        gc: types::Gcontext,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_gc",
            region = ?region,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreateRegionFromGCRequest { region, gc };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_gc_checked(
        &mut self,
        region: types::Region,
        gc: types::Gcontext,
    ) -> Result<()> {
        let cookie = self.xfixes_create_region_from_gc(region, gc)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_picture(
        &mut self,
        region: types::Region,
        picture: types::Picture,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_picture",
            region = ?region,
            picture = ?picture,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreateRegionFromPictureRequest { region, picture };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_picture_checked(
        &mut self,
        region: types::Region,
        picture: types::Picture,
    ) -> Result<()> {
        let cookie = self.xfixes_create_region_from_picture(region, picture)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_destroy_region(&mut self, region: types::Region) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_destroy_region",
            region = ?region,
        );
        let _enter = span.enter();
        let request = types::xfixes::DestroyRegionRequest { region };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_destroy_region_checked(&mut self, region: types::Region) -> Result<()> {
        let cookie = self.xfixes_destroy_region(region)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_region(
        &mut self,
        region: types::Region,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_set_region",
            region = ?region,
        );
        let _enter = span.enter();
        let request = types::xfixes::SetRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_region_checked(
        &mut self,
        region: types::Region,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<()> {
        let cookie = self.xfixes_set_region(region, rectangles)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_copy_region(
        &mut self,
        source: types::Region,
        destination: types::Region,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_copy_region",
            source = ?source,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::CopyRegionRequest {
            source,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_copy_region_checked(
        &mut self,
        source: types::Region,
        destination: types::Region,
    ) -> Result<()> {
        let cookie = self.xfixes_copy_region(source, destination)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_union_region(
        &mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_union_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::UnionRegionRequest {
            source1,
            source2,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_union_region_checked(
        &mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Result<()> {
        let cookie = self.xfixes_union_region(source1, source2, destination)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_intersect_region(
        &mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_intersect_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::IntersectRegionRequest {
            source1,
            source2,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_intersect_region_checked(
        &mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Result<()> {
        let cookie = self.xfixes_intersect_region(source1, source2, destination)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_subtract_region(
        &mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_subtract_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::SubtractRegionRequest {
            source1,
            source2,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_subtract_region_checked(
        &mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Result<()> {
        let cookie = self.xfixes_subtract_region(source1, source2, destination)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_invert_region(
        &mut self,
        source: types::Region,
        bounds: types::Rectangle,
        destination: types::Region,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_invert_region",
            source = ?source,
            bounds = ?bounds,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::InvertRegionRequest {
            source,
            bounds,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_invert_region_checked(
        &mut self,
        source: types::Region,
        bounds: types::Rectangle,
        destination: types::Region,
    ) -> Result<()> {
        let cookie = self.xfixes_invert_region(source, bounds, destination)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_translate_region(
        &mut self,
        region: types::Region,
        dx: types::Int16,
        dy: types::Int16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_translate_region",
            region = ?region,
            dx = ?dx,
            dy = ?dy,
        );
        let _enter = span.enter();
        let request = types::xfixes::TranslateRegionRequest { region, dx, dy };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_translate_region_checked(
        &mut self,
        region: types::Region,
        dx: types::Int16,
        dy: types::Int16,
    ) -> Result<()> {
        let cookie = self.xfixes_translate_region(region, dx, dy)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_region_extents(
        &mut self,
        source: types::Region,
        destination: types::Region,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_region_extents",
            source = ?source,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::RegionExtentsRequest {
            source,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_region_extents_checked(
        &mut self,
        source: types::Region,
        destination: types::Region,
    ) -> Result<()> {
        let cookie = self.xfixes_region_extents(source, destination)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_fetch_region(
        &mut self,
        region: types::Region,
    ) -> Result<Cookie<types::xfixes::FetchRegionReply>> {
        let span = tracing::info_span!(
            "xfixes_fetch_region",
            region = ?region,
        );
        let _enter = span.enter();
        let request = types::xfixes::FetchRegionRequest { region };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_fetch_region_immediate(
        &mut self,
        region: types::Region,
    ) -> Result<types::xfixes::FetchRegionReply> {
        let cookie = self.xfixes_fetch_region(region)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_gc_clip_region(
        &mut self,
        gc: types::Gcontext,
        region: impl Into<types::Region>,
        x_origin: types::Int16,
        y_origin: types::Int16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_set_gc_clip_region",
            gc = ?gc,
            x_origin = ?x_origin,
            y_origin = ?y_origin,
        );
        let _enter = span.enter();
        let request = types::xfixes::SetGCClipRegionRequest {
            gc,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_gc_clip_region_checked(
        &mut self,
        gc: types::Gcontext,
        region: impl Into<types::Region>,
        x_origin: types::Int16,
        y_origin: types::Int16,
    ) -> Result<()> {
        let cookie = self.xfixes_set_gc_clip_region(gc, region, x_origin, y_origin)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_window_shape_region(
        &mut self,
        dest: types::xproto::Window,
        dest_kind: types::SK,
        x_offset: types::Int16,
        y_offset: types::Int16,
        region: impl Into<types::Region>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_set_window_shape_region",
            dest = ?dest,
            dest_kind = ?dest_kind,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let _enter = span.enter();
        let request = types::xfixes::SetWindowShapeRegionRequest {
            dest,
            dest_kind,
            x_offset,
            y_offset,
            region: Into::<u32>::into(region.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_window_shape_region_checked(
        &mut self,
        dest: types::xproto::Window,
        dest_kind: types::SK,
        x_offset: types::Int16,
        y_offset: types::Int16,
        region: impl Into<types::Region>,
    ) -> Result<()> {
        let cookie =
            self.xfixes_set_window_shape_region(dest, dest_kind, x_offset, y_offset, region)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_picture_clip_region(
        &mut self,
        picture: types::Picture,
        region: impl Into<types::Region>,
        x_origin: types::Int16,
        y_origin: types::Int16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_set_picture_clip_region",
            picture = ?picture,
            x_origin = ?x_origin,
            y_origin = ?y_origin,
        );
        let _enter = span.enter();
        let request = types::xfixes::SetPictureClipRegionRequest {
            picture,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_picture_clip_region_checked(
        &mut self,
        picture: types::Picture,
        region: impl Into<types::Region>,
        x_origin: types::Int16,
        y_origin: types::Int16,
    ) -> Result<()> {
        let cookie = self.xfixes_set_picture_clip_region(picture, region, x_origin, y_origin)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_cursor_name(
        &mut self,
        cursor: types::xproto::Cursor,
        name: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_set_cursor_name",
            cursor = ?cursor,
        );
        let _enter = span.enter();
        let request = types::xfixes::SetCursorNameRequest {
            cursor,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_cursor_name_checked(
        &mut self,
        cursor: types::xproto::Cursor,
        name: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.xfixes_set_cursor_name(cursor, name)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_name(
        &mut self,
        cursor: types::xproto::Cursor,
    ) -> Result<Cookie<types::xfixes::GetCursorNameReply>> {
        let span = tracing::info_span!(
            "xfixes_get_cursor_name",
            cursor = ?cursor,
        );
        let _enter = span.enter();
        let request = types::xfixes::GetCursorNameRequest { cursor };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_name_immediate(
        &mut self,
        cursor: types::xproto::Cursor,
    ) -> Result<types::xfixes::GetCursorNameReply> {
        let cookie = self.xfixes_get_cursor_name(cursor)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_and_name(
        &mut self,
    ) -> Result<Cookie<types::xfixes::GetCursorImageAndNameReply>> {
        let span = tracing::info_span!("xfixes_get_cursor_image_and_name",);
        let _enter = span.enter();
        let request = types::xfixes::GetCursorImageAndNameRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_and_name_immediate(
        &mut self,
    ) -> Result<types::xfixes::GetCursorImageAndNameReply> {
        let cookie = self.xfixes_get_cursor_image_and_name()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor(
        &mut self,
        source: types::xproto::Cursor,
        destination: types::xproto::Cursor,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_change_cursor",
            source = ?source,
            destination = ?destination,
        );
        let _enter = span.enter();
        let request = types::xfixes::ChangeCursorRequest {
            source,
            destination,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_checked(
        &mut self,
        source: types::xproto::Cursor,
        destination: types::xproto::Cursor,
    ) -> Result<()> {
        let cookie = self.xfixes_change_cursor(source, destination)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_by_name(
        &mut self,
        src: types::xproto::Cursor,
        name: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_change_cursor_by_name",
            src = ?src,
        );
        let _enter = span.enter();
        let request = types::xfixes::ChangeCursorByNameRequest {
            src,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_by_name_checked(
        &mut self,
        src: types::xproto::Cursor,
        name: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.xfixes_change_cursor_by_name(src, name)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_expand_region(
        &mut self,
        source: types::Region,
        destination: types::Region,
        left: types::Card16,
        right: types::Card16,
        top: types::Card16,
        bottom: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_expand_region",
            source = ?source,
            destination = ?destination,
            left = ?left,
            right = ?right,
            top = ?top,
            bottom = ?bottom,
        );
        let _enter = span.enter();
        let request = types::xfixes::ExpandRegionRequest {
            source,
            destination,
            left,
            right,
            top,
            bottom,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_expand_region_checked(
        &mut self,
        source: types::Region,
        destination: types::Region,
        left: types::Card16,
        right: types::Card16,
        top: types::Card16,
        bottom: types::Card16,
    ) -> Result<()> {
        let cookie = self.xfixes_expand_region(source, destination, left, right, top, bottom)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_hide_cursor(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_hide_cursor",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xfixes::HideCursorRequest { window };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_hide_cursor_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let cookie = self.xfixes_hide_cursor(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_show_cursor(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_show_cursor",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xfixes::ShowCursorRequest { window };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_show_cursor_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let cookie = self.xfixes_show_cursor(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_pointer_barrier(
        &mut self,
        barrier: types::Barrier,
        window: types::xproto::Window,
        x1: types::Card16,
        y1: types::Card16,
        x2: types::Card16,
        y2: types::Card16,
        directions: impl Into<types::BarrierDirections>,
        devices: impl AsRef<[types::Card16]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_create_pointer_barrier",
            barrier = ?barrier,
            window = ?window,
            x1 = ?x1,
            y1 = ?y1,
            x2 = ?x2,
            y2 = ?y2,
        );
        let _enter = span.enter();
        let request = types::xfixes::CreatePointerBarrierRequest {
            barrier,
            window,
            x1,
            y1,
            x2,
            y2,
            directions: Into::<u32>::into(directions.into()) as _,
            devices: Cow::Borrowed(devices.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_pointer_barrier_checked(
        &mut self,
        barrier: types::Barrier,
        window: types::xproto::Window,
        x1: types::Card16,
        y1: types::Card16,
        x2: types::Card16,
        y2: types::Card16,
        directions: impl Into<types::BarrierDirections>,
        devices: impl AsRef<[types::Card16]>,
    ) -> Result<()> {
        let cookie = self
            .xfixes_create_pointer_barrier(barrier, window, x1, y1, x2, y2, directions, devices)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_delete_pointer_barrier(&mut self, barrier: types::Barrier) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xfixes_delete_pointer_barrier",
            barrier = ?barrier,
        );
        let _enter = span.enter();
        let request = types::xfixes::DeletePointerBarrierRequest { barrier };
        self.send_void_request(request)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_delete_pointer_barrier_checked(&mut self, barrier: types::Barrier) -> Result<()> {
        let cookie = self.xfixes_delete_pointer_barrier(barrier)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xinerama")]
    fn xinerama_query_version(
        &mut self,
        major: types::Card8,
        minor: types::Card8,
    ) -> Result<Cookie<types::xinerama::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xinerama_query_version",
            major = ?major,
            minor = ?minor,
        );
        let _enter = span.enter();
        let request = types::xinerama::QueryVersionRequest { major, minor };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_version_immediate(
        &mut self,
        major: types::Card8,
        minor: types::Card8,
    ) -> Result<types::xinerama::QueryVersionReply> {
        let cookie = self.xinerama_query_version(major, minor)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_state(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xinerama::GetStateReply>> {
        let span = tracing::info_span!(
            "xinerama_get_state",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinerama::GetStateRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_state_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xinerama::GetStateReply> {
        let cookie = self.xinerama_get_state(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_count(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xinerama::GetScreenCountReply>> {
        let span = tracing::info_span!(
            "xinerama_get_screen_count",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinerama::GetScreenCountRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_count_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xinerama::GetScreenCountReply> {
        let cookie = self.xinerama_get_screen_count(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_size(
        &mut self,
        window: types::xproto::Window,
        screen: types::Card32,
    ) -> Result<Cookie<types::xinerama::GetScreenSizeReply>> {
        let span = tracing::info_span!(
            "xinerama_get_screen_size",
            window = ?window,
            screen = ?screen,
        );
        let _enter = span.enter();
        let request = types::xinerama::GetScreenSizeRequest { window, screen };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_size_immediate(
        &mut self,
        window: types::xproto::Window,
        screen: types::Card32,
    ) -> Result<types::xinerama::GetScreenSizeReply> {
        let cookie = self.xinerama_get_screen_size(window, screen)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_is_active(&mut self) -> Result<Cookie<types::xinerama::IsActiveReply>> {
        let span = tracing::info_span!("xinerama_is_active",);
        let _enter = span.enter();
        let request = types::xinerama::IsActiveRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_is_active_immediate(&mut self) -> Result<types::xinerama::IsActiveReply> {
        let cookie = self.xinerama_is_active()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_screens(&mut self) -> Result<Cookie<types::xinerama::QueryScreensReply>> {
        let span = tracing::info_span!("xinerama_query_screens",);
        let _enter = span.enter();
        let request = types::xinerama::QueryScreensRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_screens_immediate(&mut self) -> Result<types::xinerama::QueryScreensReply> {
        let cookie = self.xinerama_query_screens()?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xinput")]
    fn xinput_get_extension_version(
        &mut self,
        name: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<types::xinput::GetExtensionVersionReply>> {
        let span = tracing::info_span!("xinput_get_extension_version",);
        let _enter = span.enter();
        let request = types::xinput::GetExtensionVersionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_extension_version_immediate(
        &mut self,
        name: impl AsRef<[types::Char]>,
    ) -> Result<types::xinput::GetExtensionVersionReply> {
        let cookie = self.xinput_get_extension_version(name)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_input_devices(
        &mut self,
    ) -> Result<Cookie<types::xinput::ListInputDevicesReply>> {
        let span = tracing::info_span!("xinput_list_input_devices",);
        let _enter = span.enter();
        let request = types::xinput::ListInputDevicesRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_input_devices_immediate(
        &mut self,
    ) -> Result<types::xinput::ListInputDevicesReply> {
        let cookie = self.xinput_list_input_devices()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_open_device(
        &mut self,
        device_id: types::Card8,
    ) -> Result<Cookie<types::xinput::OpenDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_open_device",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::OpenDeviceRequest { device_id };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_open_device_immediate(
        &mut self,
        device_id: types::Card8,
    ) -> Result<types::xinput::OpenDeviceReply> {
        let cookie = self.xinput_open_device(device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_close_device(&mut self, device_id: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_close_device",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::CloseDeviceRequest { device_id };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_close_device_checked(&mut self, device_id: types::Card8) -> Result<()> {
        let cookie = self.xinput_close_device(device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_mode(
        &mut self,
        device_id: types::Card8,
        mode: types::ValuatorMode,
    ) -> Result<Cookie<types::xinput::SetDeviceModeReply>> {
        let span = tracing::info_span!(
            "xinput_set_device_mode",
            device_id = ?device_id,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xinput::SetDeviceModeRequest { device_id, mode };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_mode_immediate(
        &mut self,
        device_id: types::Card8,
        mode: types::ValuatorMode,
    ) -> Result<types::xinput::SetDeviceModeReply> {
        let cookie = self.xinput_set_device_mode(device_id, mode)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_select_extension_event(
        &mut self,
        window: types::xproto::Window,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_select_extension_event",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::SelectExtensionEventRequest {
            window,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_select_extension_event_checked(
        &mut self,
        window: types::xproto::Window,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<()> {
        let cookie = self.xinput_select_extension_event(window, classes)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_selected_extension_events(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xinput::GetSelectedExtensionEventsReply>> {
        let span = tracing::info_span!(
            "xinput_get_selected_extension_events",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::GetSelectedExtensionEventsRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_selected_extension_events_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xinput::GetSelectedExtensionEventsReply> {
        let cookie = self.xinput_get_selected_extension_events(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_dont_propagate_list(
        &mut self,
        window: types::xproto::Window,
        mode: types::PropagateMode,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_change_device_dont_propagate_list",
            window = ?window,
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeDeviceDontPropagateListRequest {
            window,
            mode,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_dont_propagate_list_checked(
        &mut self,
        window: types::xproto::Window,
        mode: types::PropagateMode,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<()> {
        let cookie = self.xinput_change_device_dont_propagate_list(window, mode, classes)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_dont_propagate_list(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xinput::GetDeviceDontPropagateListReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_dont_propagate_list",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceDontPropagateListRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_dont_propagate_list_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xinput::GetDeviceDontPropagateListReply> {
        let cookie = self.xinput_get_device_dont_propagate_list(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_motion_events(
        &mut self,
        start: types::Timestamp,
        stop: impl Into<types::Time>,
        device_id: types::Card8,
    ) -> Result<Cookie<types::xinput::GetDeviceMotionEventsReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_motion_events",
            start = ?start,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceMotionEventsRequest {
            start,
            stop: Into::<u32>::into(stop.into()) as _,
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_motion_events_immediate(
        &mut self,
        start: types::Timestamp,
        stop: impl Into<types::Time>,
        device_id: types::Card8,
    ) -> Result<types::xinput::GetDeviceMotionEventsReply> {
        let cookie = self.xinput_get_device_motion_events(start, stop, device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_keyboard_device(
        &mut self,
        device_id: types::Card8,
    ) -> Result<Cookie<types::xinput::ChangeKeyboardDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_change_keyboard_device",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeKeyboardDeviceRequest { device_id };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_keyboard_device_immediate(
        &mut self,
        device_id: types::Card8,
    ) -> Result<types::xinput::ChangeKeyboardDeviceReply> {
        let cookie = self.xinput_change_keyboard_device(device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_pointer_device(
        &mut self,
        x_axis: types::Card8,
        y_axis: types::Card8,
        device_id: types::Card8,
    ) -> Result<Cookie<types::xinput::ChangePointerDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_change_pointer_device",
            x_axis = ?x_axis,
            y_axis = ?y_axis,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangePointerDeviceRequest {
            x_axis,
            y_axis,
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_pointer_device_immediate(
        &mut self,
        x_axis: types::Card8,
        y_axis: types::Card8,
        device_id: types::Card8,
    ) -> Result<types::xinput::ChangePointerDeviceReply> {
        let cookie = self.xinput_change_pointer_device(x_axis, y_axis, device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device(
        &mut self,
        grab_window: types::xproto::Window,
        time: impl Into<types::Time>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        owner_events: types::Bool,
        device_id: types::Card8,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<Cookie<types::xinput::GrabDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_grab_device",
            grab_window = ?grab_window,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GrabDeviceRequest {
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            device_id,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_immediate(
        &mut self,
        grab_window: types::xproto::Window,
        time: impl Into<types::Time>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        owner_events: types::Bool,
        device_id: types::Card8,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<types::xinput::GrabDeviceReply> {
        let cookie = self.xinput_grab_device(
            grab_window,
            time,
            this_device_mode,
            other_device_mode,
            owner_events,
            device_id,
            classes,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device(
        &mut self,
        time: impl Into<types::Time>,
        device_id: types::Card8,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_ungrab_device",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::UngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            device_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_checked(
        &mut self,
        time: impl Into<types::Time>,
        device_id: types::Card8,
    ) -> Result<()> {
        let cookie = self.xinput_ungrab_device(time, device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_key(
        &mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        grabbed_device: types::Card8,
        key: impl Into<types::Grab>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        owner_events: types::Bool,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_grab_device_key",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
        );
        let _enter = span.enter();
        let request = types::xinput::GrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            grabbed_device,
            key: Into::<u32>::into(key.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_key_checked(
        &mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        grabbed_device: types::Card8,
        key: impl Into<types::Grab>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        owner_events: types::Bool,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<()> {
        let cookie = self.xinput_grab_device_key(
            grab_window,
            modifiers,
            modifier_device,
            grabbed_device,
            key,
            this_device_mode,
            other_device_mode,
            owner_events,
            classes,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_key(
        &mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        key: impl Into<types::Grab>,
        grabbed_device: types::Card8,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_ungrab_device_key",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
        );
        let _enter = span.enter();
        let request = types::xinput::UngrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            grabbed_device,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_key_checked(
        &mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        key: impl Into<types::Grab>,
        grabbed_device: types::Card8,
    ) -> Result<()> {
        let cookie = self.xinput_ungrab_device_key(
            grab_window,
            modifiers,
            modifier_device,
            key,
            grabbed_device,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_button(
        &mut self,
        grab_window: types::xproto::Window,
        grabbed_device: types::Card8,
        modifier_device: impl Into<types::ModifierDevice>,
        modifiers: impl Into<types::ModMask>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        button: impl Into<types::Grab>,
        owner_events: types::Bool,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_grab_device_button",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
        );
        let _enter = span.enter();
        let request = types::xinput::GrabDeviceButtonRequest {
            grab_window,
            grabbed_device,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            this_device_mode,
            other_device_mode,
            button: Into::<u32>::into(button.into()) as _,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_button_checked(
        &mut self,
        grab_window: types::xproto::Window,
        grabbed_device: types::Card8,
        modifier_device: impl Into<types::ModifierDevice>,
        modifiers: impl Into<types::ModMask>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        button: impl Into<types::Grab>,
        owner_events: types::Bool,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<()> {
        let cookie = self.xinput_grab_device_button(
            grab_window,
            grabbed_device,
            modifier_device,
            modifiers,
            this_device_mode,
            other_device_mode,
            button,
            owner_events,
            classes,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_button(
        &mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        button: impl Into<types::Grab>,
        grabbed_device: types::Card8,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_ungrab_device_button",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
        );
        let _enter = span.enter();
        let request = types::xinput::UngrabDeviceButtonRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            button: Into::<u32>::into(button.into()) as _,
            grabbed_device,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_button_checked(
        &mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        button: impl Into<types::Grab>,
        grabbed_device: types::Card8,
    ) -> Result<()> {
        let cookie = self.xinput_ungrab_device_button(
            grab_window,
            modifiers,
            modifier_device,
            button,
            grabbed_device,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_allow_device_events(
        &mut self,
        time: impl Into<types::Time>,
        mode: types::DeviceInputMode,
        device_id: types::Card8,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_allow_device_events",
            mode = ?mode,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::AllowDeviceEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            mode,
            device_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_allow_device_events_checked(
        &mut self,
        time: impl Into<types::Time>,
        mode: types::DeviceInputMode,
        device_id: types::Card8,
    ) -> Result<()> {
        let cookie = self.xinput_allow_device_events(time, mode, device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_focus(
        &mut self,
        device_id: types::Card8,
    ) -> Result<Cookie<types::xinput::GetDeviceFocusReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_focus",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceFocusRequest { device_id };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_focus_immediate(
        &mut self,
        device_id: types::Card8,
    ) -> Result<types::xinput::GetDeviceFocusReply> {
        let cookie = self.xinput_get_device_focus(device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_focus(
        &mut self,
        focus: impl Into<types::InputFocus>,
        time: impl Into<types::Time>,
        revert_to: types::InputFocus,
        device_id: types::Card8,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_set_device_focus",
            revert_to = ?revert_to,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::SetDeviceFocusRequest {
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            revert_to,
            device_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_focus_checked(
        &mut self,
        focus: impl Into<types::InputFocus>,
        time: impl Into<types::Time>,
        revert_to: types::InputFocus,
        device_id: types::Card8,
    ) -> Result<()> {
        let cookie = self.xinput_set_device_focus(focus, time, revert_to, device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_feedback_control(
        &mut self,
        device_id: types::Card8,
    ) -> Result<Cookie<types::xinput::GetFeedbackControlReply>> {
        let span = tracing::info_span!(
            "xinput_get_feedback_control",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetFeedbackControlRequest { device_id };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_feedback_control_immediate(
        &mut self,
        device_id: types::Card8,
    ) -> Result<types::xinput::GetFeedbackControlReply> {
        let cookie = self.xinput_get_feedback_control(device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_feedback_control(
        &mut self,
        mask: impl Into<types::ChangeFeedbackControlMask>,
        device_id: types::Card8,
        feedback_id: types::Card8,
        feedback: types::FeedbackCtl,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_change_feedback_control",
            device_id = ?device_id,
            feedback_id = ?feedback_id,
            feedback = ?feedback,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeFeedbackControlRequest {
            mask: Into::<u32>::into(mask.into()) as _,
            device_id,
            feedback_id,
            feedback,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_feedback_control_checked(
        &mut self,
        mask: impl Into<types::ChangeFeedbackControlMask>,
        device_id: types::Card8,
        feedback_id: types::Card8,
        feedback: types::FeedbackCtl,
    ) -> Result<()> {
        let cookie = self.xinput_change_feedback_control(mask, device_id, feedback_id, feedback)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_key_mapping(
        &mut self,
        device_id: types::Card8,
        first_keycode: types::KeyCode,
        count: types::Card8,
    ) -> Result<Cookie<types::xinput::GetDeviceKeyMappingReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_key_mapping",
            device_id = ?device_id,
            first_keycode = ?first_keycode,
            count = ?count,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            count,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_key_mapping_immediate(
        &mut self,
        device_id: types::Card8,
        first_keycode: types::KeyCode,
        count: types::Card8,
    ) -> Result<types::xinput::GetDeviceKeyMappingReply> {
        let cookie = self.xinput_get_device_key_mapping(device_id, first_keycode, count)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_key_mapping(
        &mut self,
        device_id: types::Card8,
        first_keycode: types::KeyCode,
        keysyms_per_keycode: types::Card8,
        keycode_count: types::Card8,
        keysyms: impl AsRef<[types::Keysym]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_change_device_key_mapping",
            device_id = ?device_id,
            first_keycode = ?first_keycode,
            keysyms_per_keycode = ?keysyms_per_keycode,
            keycode_count = ?keycode_count,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            keysyms_per_keycode,
            keycode_count,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_key_mapping_checked(
        &mut self,
        device_id: types::Card8,
        first_keycode: types::KeyCode,
        keysyms_per_keycode: types::Card8,
        keycode_count: types::Card8,
        keysyms: impl AsRef<[types::Keysym]>,
    ) -> Result<()> {
        let cookie = self.xinput_change_device_key_mapping(
            device_id,
            first_keycode,
            keysyms_per_keycode,
            keycode_count,
            keysyms,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_modifier_mapping(
        &mut self,
        device_id: types::Card8,
    ) -> Result<Cookie<types::xinput::GetDeviceModifierMappingReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_modifier_mapping",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceModifierMappingRequest { device_id };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_modifier_mapping_immediate(
        &mut self,
        device_id: types::Card8,
    ) -> Result<types::xinput::GetDeviceModifierMappingReply> {
        let cookie = self.xinput_get_device_modifier_mapping(device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_modifier_mapping(
        &mut self,
        device_id: types::Card8,
        keymaps: impl AsRef<[types::Card8]>,
    ) -> Result<Cookie<types::xinput::SetDeviceModifierMappingReply>> {
        let span = tracing::info_span!(
            "xinput_set_device_modifier_mapping",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::SetDeviceModifierMappingRequest {
            device_id,
            keymaps: Cow::Borrowed(keymaps.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_modifier_mapping_immediate(
        &mut self,
        device_id: types::Card8,
        keymaps: impl AsRef<[types::Card8]>,
    ) -> Result<types::xinput::SetDeviceModifierMappingReply> {
        let cookie = self.xinput_set_device_modifier_mapping(device_id, keymaps)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_button_mapping(
        &mut self,
        device_id: types::Card8,
    ) -> Result<Cookie<types::xinput::GetDeviceButtonMappingReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_button_mapping",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceButtonMappingRequest { device_id };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_button_mapping_immediate(
        &mut self,
        device_id: types::Card8,
    ) -> Result<types::xinput::GetDeviceButtonMappingReply> {
        let cookie = self.xinput_get_device_button_mapping(device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_button_mapping(
        &mut self,
        device_id: types::Card8,
        map: impl AsRef<[types::Card8]>,
    ) -> Result<Cookie<types::xinput::SetDeviceButtonMappingReply>> {
        let span = tracing::info_span!(
            "xinput_set_device_button_mapping",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::SetDeviceButtonMappingRequest {
            device_id,
            map: Cow::Borrowed(map.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_button_mapping_immediate(
        &mut self,
        device_id: types::Card8,
        map: impl AsRef<[types::Card8]>,
    ) -> Result<types::xinput::SetDeviceButtonMappingReply> {
        let cookie = self.xinput_set_device_button_mapping(device_id, map)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_query_device_state(
        &mut self,
        device_id: types::Card8,
    ) -> Result<Cookie<types::xinput::QueryDeviceStateReply>> {
        let span = tracing::info_span!(
            "xinput_query_device_state",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::QueryDeviceStateRequest { device_id };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_query_device_state_immediate(
        &mut self,
        device_id: types::Card8,
    ) -> Result<types::xinput::QueryDeviceStateReply> {
        let cookie = self.xinput_query_device_state(device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_device_bell(
        &mut self,
        device_id: types::Card8,
        feedback_id: types::Card8,
        feedback_class: types::Card8,
        percent: types::Int8,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_device_bell",
            device_id = ?device_id,
            feedback_id = ?feedback_id,
            feedback_class = ?feedback_class,
            percent = ?percent,
        );
        let _enter = span.enter();
        let request = types::xinput::DeviceBellRequest {
            device_id,
            feedback_id,
            feedback_class,
            percent,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_device_bell_checked(
        &mut self,
        device_id: types::Card8,
        feedback_id: types::Card8,
        feedback_class: types::Card8,
        percent: types::Int8,
    ) -> Result<()> {
        let cookie = self.xinput_device_bell(device_id, feedback_id, feedback_class, percent)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_valuators(
        &mut self,
        device_id: types::Card8,
        first_valuator: types::Card8,
        valuators: impl AsRef<[types::Int32]>,
    ) -> Result<Cookie<types::xinput::SetDeviceValuatorsReply>> {
        let span = tracing::info_span!(
            "xinput_set_device_valuators",
            device_id = ?device_id,
            first_valuator = ?first_valuator,
        );
        let _enter = span.enter();
        let request = types::xinput::SetDeviceValuatorsRequest {
            device_id,
            first_valuator,
            valuators: Cow::Borrowed(valuators.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_valuators_immediate(
        &mut self,
        device_id: types::Card8,
        first_valuator: types::Card8,
        valuators: impl AsRef<[types::Int32]>,
    ) -> Result<types::xinput::SetDeviceValuatorsReply> {
        let cookie = self.xinput_set_device_valuators(device_id, first_valuator, valuators)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_control(
        &mut self,
        control_id: types::DeviceControl,
        device_id: types::Card8,
    ) -> Result<Cookie<types::xinput::GetDeviceControlReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_control",
            control_id = ?control_id,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDeviceControlRequest {
            control_id,
            device_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_control_immediate(
        &mut self,
        control_id: types::DeviceControl,
        device_id: types::Card8,
    ) -> Result<types::xinput::GetDeviceControlReply> {
        let cookie = self.xinput_get_device_control(control_id, device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_control(
        &mut self,
        control_id: types::DeviceControl,
        device_id: types::Card8,
        control: types::DeviceCtl,
    ) -> Result<Cookie<types::xinput::ChangeDeviceControlReply>> {
        let span = tracing::info_span!(
            "xinput_change_device_control",
            control_id = ?control_id,
            device_id = ?device_id,
            control = ?control,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeDeviceControlRequest {
            control_id,
            device_id,
            control,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_control_immediate(
        &mut self,
        control_id: types::DeviceControl,
        device_id: types::Card8,
        control: types::DeviceCtl,
    ) -> Result<types::xinput::ChangeDeviceControlReply> {
        let cookie = self.xinput_change_device_control(control_id, device_id, control)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_device_properties(
        &mut self,
        device_id: types::Card8,
    ) -> Result<Cookie<types::xinput::ListDevicePropertiesReply>> {
        let span = tracing::info_span!(
            "xinput_list_device_properties",
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::ListDevicePropertiesRequest { device_id };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_device_properties_immediate(
        &mut self,
        device_id: types::Card8,
    ) -> Result<types::xinput::ListDevicePropertiesReply> {
        let cookie = self.xinput_list_device_properties(device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_property(
        &mut self,
        property: types::Atom,
        type_: types::Atom,
        device_id: types::Card8,
        mode: types::PropMode,
        num_items: types::Card32,
        items: impl Borrow<types::xinput::ChangeDevicePropertyAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_change_device_property",
            property = ?property,
            type_ = ?type_,
            device_id = ?device_id,
            mode = ?mode,
            num_items = ?num_items,
        );
        let _enter = span.enter();
        let request = types::xinput::ChangeDevicePropertyRequest {
            property,
            type_,
            device_id,
            mode,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_property_checked(
        &mut self,
        property: types::Atom,
        type_: types::Atom,
        device_id: types::Card8,
        mode: types::PropMode,
        num_items: types::Card32,
        items: impl Borrow<types::xinput::ChangeDevicePropertyAux>,
    ) -> Result<()> {
        let cookie =
            self.xinput_change_device_property(property, type_, device_id, mode, num_items, items)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_delete_device_property(
        &mut self,
        property: types::Atom,
        device_id: types::Card8,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_delete_device_property",
            property = ?property,
            device_id = ?device_id,
        );
        let _enter = span.enter();
        let request = types::xinput::DeleteDevicePropertyRequest {
            property,
            device_id,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_delete_device_property_checked(
        &mut self,
        property: types::Atom,
        device_id: types::Card8,
    ) -> Result<()> {
        let cookie = self.xinput_delete_device_property(property, device_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_property(
        &mut self,
        property: types::Atom,
        type_: types::Atom,
        offset: types::Card32,
        len: types::Card32,
        device_id: types::Card8,
        delete: types::Bool,
    ) -> Result<Cookie<types::xinput::GetDevicePropertyReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_property",
            property = ?property,
            type_ = ?type_,
            offset = ?offset,
            len = ?len,
            device_id = ?device_id,
            delete = ?delete,
        );
        let _enter = span.enter();
        let request = types::xinput::GetDevicePropertyRequest {
            property,
            type_,
            offset,
            len,
            device_id,
            delete,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_property_immediate(
        &mut self,
        property: types::Atom,
        type_: types::Atom,
        offset: types::Card32,
        len: types::Card32,
        device_id: types::Card8,
        delete: types::Bool,
    ) -> Result<types::xinput::GetDevicePropertyReply> {
        let cookie =
            self.xinput_get_device_property(property, type_, offset, len, device_id, delete)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_pointer(
        &mut self,
        window: types::xproto::Window,
        deviceid: impl Into<types::Device>,
    ) -> Result<Cookie<types::xinput::XIQueryPointerReply>> {
        let span = tracing::info_span!(
            "xinput_xi_query_pointer",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XIQueryPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_pointer_immediate(
        &mut self,
        window: types::xproto::Window,
        deviceid: impl Into<types::Device>,
    ) -> Result<types::xinput::XIQueryPointerReply> {
        let cookie = self.xinput_xi_query_pointer(window, deviceid)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_warp_pointer(
        &mut self,
        src_win: types::xproto::Window,
        dst_win: types::xproto::Window,
        src_x: types::Fp1616,
        src_y: types::Fp1616,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Fp1616,
        dst_y: types::Fp1616,
        deviceid: impl Into<types::Device>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_warp_pointer",
            src_win = ?src_win,
            dst_win = ?dst_win,
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
        );
        let _enter = span.enter();
        let request = types::xinput::XIWarpPointerRequest {
            src_win,
            dst_win,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_warp_pointer_checked(
        &mut self,
        src_win: types::xproto::Window,
        dst_win: types::xproto::Window,
        src_x: types::Fp1616,
        src_y: types::Fp1616,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Fp1616,
        dst_y: types::Fp1616,
        deviceid: impl Into<types::Device>,
    ) -> Result<()> {
        let cookie = self.xinput_xi_warp_pointer(
            src_win, dst_win, src_x, src_y, src_width, src_height, dst_x, dst_y, deviceid,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_cursor(
        &mut self,
        window: types::xproto::Window,
        cursor: types::xproto::Cursor,
        deviceid: impl Into<types::Device>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_change_cursor",
            window = ?window,
            cursor = ?cursor,
        );
        let _enter = span.enter();
        let request = types::xinput::XIChangeCursorRequest {
            window,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_cursor_checked(
        &mut self,
        window: types::xproto::Window,
        cursor: types::xproto::Cursor,
        deviceid: impl Into<types::Device>,
    ) -> Result<()> {
        let cookie = self.xinput_xi_change_cursor(window, cursor, deviceid)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_hierarchy(
        &mut self,
        changes: impl AsRef<[types::HierarchyChange]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!("xinput_xi_change_hierarchy",);
        let _enter = span.enter();
        let request = types::xinput::XIChangeHierarchyRequest {
            changes: Cow::Borrowed(changes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_hierarchy_checked(
        &mut self,
        changes: impl AsRef<[types::HierarchyChange]>,
    ) -> Result<()> {
        let cookie = self.xinput_xi_change_hierarchy(changes)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_client_pointer(
        &mut self,
        window: types::xproto::Window,
        deviceid: impl Into<types::Device>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_set_client_pointer",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XISetClientPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_client_pointer_checked(
        &mut self,
        window: types::xproto::Window,
        deviceid: impl Into<types::Device>,
    ) -> Result<()> {
        let cookie = self.xinput_xi_set_client_pointer(window, deviceid)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_client_pointer(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xinput::XIGetClientPointerReply>> {
        let span = tracing::info_span!(
            "xinput_xi_get_client_pointer",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XIGetClientPointerRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_client_pointer_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xinput::XIGetClientPointerReply> {
        let cookie = self.xinput_xi_get_client_pointer(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_select_events(
        &mut self,
        window: types::xproto::Window,
        masks: impl AsRef<[types::xinput::EventMask]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_select_events",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XISelectEventsRequest {
            window,
            masks: Cow::Borrowed(masks.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_select_events_checked(
        &mut self,
        window: types::xproto::Window,
        masks: impl AsRef<[types::xinput::EventMask]>,
    ) -> Result<()> {
        let cookie = self.xinput_xi_select_events(window, masks)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_version(
        &mut self,
        major_version: types::Card16,
        minor_version: types::Card16,
    ) -> Result<Cookie<types::xinput::XIQueryVersionReply>> {
        let span = tracing::info_span!(
            "xinput_xi_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::xinput::XIQueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_version_immediate(
        &mut self,
        major_version: types::Card16,
        minor_version: types::Card16,
    ) -> Result<types::xinput::XIQueryVersionReply> {
        let cookie = self.xinput_xi_query_version(major_version, minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_device(
        &mut self,
        deviceid: impl Into<types::Device>,
    ) -> Result<Cookie<types::xinput::XIQueryDeviceReply>> {
        let span = tracing::info_span!("xinput_xi_query_device",);
        let _enter = span.enter();
        let request = types::xinput::XIQueryDeviceRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_device_immediate(
        &mut self,
        deviceid: impl Into<types::Device>,
    ) -> Result<types::xinput::XIQueryDeviceReply> {
        let cookie = self.xinput_xi_query_device(deviceid)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_focus(
        &mut self,
        window: types::xproto::Window,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_set_focus",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XISetFocusRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_focus_checked(
        &mut self,
        window: types::xproto::Window,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
    ) -> Result<()> {
        let cookie = self.xinput_xi_set_focus(window, time, deviceid)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_focus(
        &mut self,
        deviceid: impl Into<types::Device>,
    ) -> Result<Cookie<types::xinput::XIGetFocusReply>> {
        let span = tracing::info_span!("xinput_xi_get_focus",);
        let _enter = span.enter();
        let request = types::xinput::XIGetFocusRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_focus_immediate(
        &mut self,
        deviceid: impl Into<types::Device>,
    ) -> Result<types::xinput::XIGetFocusReply> {
        let cookie = self.xinput_xi_get_focus(deviceid)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_grab_device(
        &mut self,
        window: types::xproto::Window,
        time: impl Into<types::Time>,
        cursor: types::xproto::Cursor,
        deviceid: impl Into<types::Device>,
        mode: types::GrabMode,
        paired_device_mode: types::GrabMode,
        owner_events: types::GrabOwner,
        mask: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<types::xinput::XIGrabDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_xi_grab_device",
            window = ?window,
            cursor = ?cursor,
            mode = ?mode,
            paired_device_mode = ?paired_device_mode,
            owner_events = ?owner_events,
        );
        let _enter = span.enter();
        let request = types::xinput::XIGrabDeviceRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_grab_device_immediate(
        &mut self,
        window: types::xproto::Window,
        time: impl Into<types::Time>,
        cursor: types::xproto::Cursor,
        deviceid: impl Into<types::Device>,
        mode: types::GrabMode,
        paired_device_mode: types::GrabMode,
        owner_events: types::GrabOwner,
        mask: impl AsRef<[types::Card32]>,
    ) -> Result<types::xinput::XIGrabDeviceReply> {
        let cookie = self.xinput_xi_grab_device(
            window,
            time,
            cursor,
            deviceid,
            mode,
            paired_device_mode,
            owner_events,
            mask,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_ungrab_device(
        &mut self,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!("xinput_xi_ungrab_device",);
        let _enter = span.enter();
        let request = types::xinput::XIUngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_ungrab_device_checked(
        &mut self,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
    ) -> Result<()> {
        let cookie = self.xinput_xi_ungrab_device(time, deviceid)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_allow_events(
        &mut self,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
        event_mode: types::EventMode,
        touchid: types::Card32,
        grab_window: types::xproto::Window,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_allow_events",
            event_mode = ?event_mode,
            touchid = ?touchid,
            grab_window = ?grab_window,
        );
        let _enter = span.enter();
        let request = types::xinput::XIAllowEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            event_mode,
            touchid,
            grab_window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_allow_events_checked(
        &mut self,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
        event_mode: types::EventMode,
        touchid: types::Card32,
        grab_window: types::xproto::Window,
    ) -> Result<()> {
        let cookie =
            self.xinput_xi_allow_events(time, deviceid, event_mode, touchid, grab_window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_grab_device(
        &mut self,
        time: impl Into<types::Time>,
        grab_window: types::xproto::Window,
        cursor: types::xproto::Cursor,
        detail: types::Card32,
        deviceid: impl Into<types::Device>,
        grab_type: types::GrabType,
        grab_mode: types::GrabMode22,
        paired_device_mode: types::GrabMode,
        owner_events: types::GrabOwner,
        mask: impl AsRef<[types::Card32]>,
        modifiers: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<types::xinput::XIPassiveGrabDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_xi_passive_grab_device",
            grab_window = ?grab_window,
            cursor = ?cursor,
            detail = ?detail,
            grab_type = ?grab_type,
            grab_mode = ?grab_mode,
            paired_device_mode = ?paired_device_mode,
            owner_events = ?owner_events,
        );
        let _enter = span.enter();
        let request = types::xinput::XIPassiveGrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            grab_window,
            cursor,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            grab_mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_grab_device_immediate(
        &mut self,
        time: impl Into<types::Time>,
        grab_window: types::xproto::Window,
        cursor: types::xproto::Cursor,
        detail: types::Card32,
        deviceid: impl Into<types::Device>,
        grab_type: types::GrabType,
        grab_mode: types::GrabMode22,
        paired_device_mode: types::GrabMode,
        owner_events: types::GrabOwner,
        mask: impl AsRef<[types::Card32]>,
        modifiers: impl AsRef<[types::Card32]>,
    ) -> Result<types::xinput::XIPassiveGrabDeviceReply> {
        let cookie = self.xinput_xi_passive_grab_device(
            time,
            grab_window,
            cursor,
            detail,
            deviceid,
            grab_type,
            grab_mode,
            paired_device_mode,
            owner_events,
            mask,
            modifiers,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_ungrab_device(
        &mut self,
        grab_window: types::xproto::Window,
        detail: types::Card32,
        deviceid: impl Into<types::Device>,
        grab_type: types::GrabType,
        modifiers: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_passive_ungrab_device",
            grab_window = ?grab_window,
            detail = ?detail,
            grab_type = ?grab_type,
        );
        let _enter = span.enter();
        let request = types::xinput::XIPassiveUngrabDeviceRequest {
            grab_window,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_ungrab_device_checked(
        &mut self,
        grab_window: types::xproto::Window,
        detail: types::Card32,
        deviceid: impl Into<types::Device>,
        grab_type: types::GrabType,
        modifiers: impl AsRef<[types::Card32]>,
    ) -> Result<()> {
        let cookie = self.xinput_xi_passive_ungrab_device(
            grab_window,
            detail,
            deviceid,
            grab_type,
            modifiers,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_list_properties(
        &mut self,
        deviceid: impl Into<types::Device>,
    ) -> Result<Cookie<types::xinput::XIListPropertiesReply>> {
        let span = tracing::info_span!("xinput_xi_list_properties",);
        let _enter = span.enter();
        let request = types::xinput::XIListPropertiesRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_list_properties_immediate(
        &mut self,
        deviceid: impl Into<types::Device>,
    ) -> Result<types::xinput::XIListPropertiesReply> {
        let cookie = self.xinput_xi_list_properties(deviceid)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_property(
        &mut self,
        deviceid: impl Into<types::Device>,
        mode: types::PropMode,
        property: types::Atom,
        type_: types::Atom,
        num_items: types::Card32,
        items: impl Borrow<types::xinput::XIChangePropertyAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_change_property",
            mode = ?mode,
            property = ?property,
            type_ = ?type_,
            num_items = ?num_items,
        );
        let _enter = span.enter();
        let request = types::xinput::XIChangePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            property,
            type_,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_property_checked(
        &mut self,
        deviceid: impl Into<types::Device>,
        mode: types::PropMode,
        property: types::Atom,
        type_: types::Atom,
        num_items: types::Card32,
        items: impl Borrow<types::xinput::XIChangePropertyAux>,
    ) -> Result<()> {
        let cookie =
            self.xinput_xi_change_property(deviceid, mode, property, type_, num_items, items)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_delete_property(
        &mut self,
        deviceid: impl Into<types::Device>,
        property: types::Atom,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_xi_delete_property",
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::xinput::XIDeletePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            property,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_delete_property_checked(
        &mut self,
        deviceid: impl Into<types::Device>,
        property: types::Atom,
    ) -> Result<()> {
        let cookie = self.xinput_xi_delete_property(deviceid, property)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_property(
        &mut self,
        deviceid: impl Into<types::Device>,
        delete: types::Bool,
        property: types::Atom,
        type_: types::Atom,
        offset: types::Card32,
        len: types::Card32,
    ) -> Result<Cookie<types::xinput::XIGetPropertyReply>> {
        let span = tracing::info_span!(
            "xinput_xi_get_property",
            delete = ?delete,
            property = ?property,
            type_ = ?type_,
            offset = ?offset,
            len = ?len,
        );
        let _enter = span.enter();
        let request = types::xinput::XIGetPropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            delete,
            property,
            type_,
            offset,
            len,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_property_immediate(
        &mut self,
        deviceid: impl Into<types::Device>,
        delete: types::Bool,
        property: types::Atom,
        type_: types::Atom,
        offset: types::Card32,
        len: types::Card32,
    ) -> Result<types::xinput::XIGetPropertyReply> {
        let cookie = self.xinput_xi_get_property(deviceid, delete, property, type_, offset, len)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_selected_events(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xinput::XIGetSelectedEventsReply>> {
        let span = tracing::info_span!(
            "xinput_xi_get_selected_events",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xinput::XIGetSelectedEventsRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_selected_events_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xinput::XIGetSelectedEventsReply> {
        let cookie = self.xinput_xi_get_selected_events(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_barrier_release_pointer(
        &mut self,
        barriers: impl AsRef<[types::BarrierReleasePointerInfo]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!("xinput_xi_barrier_release_pointer",);
        let _enter = span.enter();
        let request = types::xinput::XIBarrierReleasePointerRequest {
            barriers: Cow::Borrowed(barriers.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_barrier_release_pointer_checked(
        &mut self,
        barriers: impl AsRef<[types::BarrierReleasePointerInfo]>,
    ) -> Result<()> {
        let cookie = self.xinput_xi_barrier_release_pointer(barriers)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xinput")]
    fn xinput_send_extension_event(
        &mut self,
        destination: types::xproto::Window,
        device_id: types::Card8,
        propagate: types::Bool,
        events: impl AsRef<[types::EventForSend]>,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xinput_send_extension_event",
            destination = ?destination,
            device_id = ?device_id,
            propagate = ?propagate,
        );
        let _enter = span.enter();
        let request = types::xinput::SendExtensionEventRequest {
            destination,
            device_id,
            propagate,
            events: Cow::Borrowed(events.as_ref()),
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xinput")]
    fn xinput_send_extension_event_checked(
        &mut self,
        destination: types::xproto::Window,
        device_id: types::Card8,
        propagate: types::Bool,
        events: impl AsRef<[types::EventForSend]>,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Result<()> {
        let cookie =
            self.xinput_send_extension_event(destination, device_id, propagate, events, classes)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xkb")]
    fn xkb_use_extension(
        &mut self,
        wanted_major: types::Card16,
        wanted_minor: types::Card16,
    ) -> Result<Cookie<types::xkb::UseExtensionReply>> {
        let span = tracing::info_span!(
            "xkb_use_extension",
            wanted_major = ?wanted_major,
            wanted_minor = ?wanted_minor,
        );
        let _enter = span.enter();
        let request = types::xkb::UseExtensionRequest {
            wanted_major,
            wanted_minor,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_use_extension_immediate(
        &mut self,
        wanted_major: types::Card16,
        wanted_minor: types::Card16,
    ) -> Result<types::xkb::UseExtensionReply> {
        let cookie = self.xkb_use_extension(wanted_major, wanted_minor)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_select_events(
        &mut self,
        device_spec: types::DeviceSpec,
        clear: impl Into<types::xkb::EventType>,
        select_all: impl Into<types::xkb::EventType>,
        affect_map: impl Into<types::MapPart>,
        map: impl Into<types::MapPart>,
        details: impl Borrow<types::xkb::SelectEventsAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_select_events",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::SelectEventsRequest {
            device_spec,
            clear: Into::<u32>::into(clear.into()) as _,
            select_all: Into::<u32>::into(select_all.into()) as _,
            affect_map: Into::<u32>::into(affect_map.into()) as _,
            map: Into::<u32>::into(map.into()) as _,
            details: Cow::Borrowed(details.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_select_events_checked(
        &mut self,
        device_spec: types::DeviceSpec,
        clear: impl Into<types::xkb::EventType>,
        select_all: impl Into<types::xkb::EventType>,
        affect_map: impl Into<types::MapPart>,
        map: impl Into<types::MapPart>,
        details: impl Borrow<types::xkb::SelectEventsAux>,
    ) -> Result<()> {
        let cookie =
            self.xkb_select_events(device_spec, clear, select_all, affect_map, map, details)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_bell(
        &mut self,
        device_spec: types::DeviceSpec,
        bell_class: types::BellClassSpec,
        bell_id: types::IDSpec,
        percent: types::Int8,
        force_sound: types::Bool,
        event_only: types::Bool,
        pitch: types::Int16,
        duration: types::Int16,
        name: types::Atom,
        window: types::xproto::Window,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_bell",
            device_spec = ?device_spec,
            bell_class = ?bell_class,
            bell_id = ?bell_id,
            percent = ?percent,
            force_sound = ?force_sound,
            event_only = ?event_only,
            pitch = ?pitch,
            duration = ?duration,
            name = ?name,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xkb::BellRequest {
            device_spec,
            bell_class,
            bell_id,
            percent,
            force_sound,
            event_only,
            pitch,
            duration,
            name,
            window,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_bell_checked(
        &mut self,
        device_spec: types::DeviceSpec,
        bell_class: types::BellClassSpec,
        bell_id: types::IDSpec,
        percent: types::Int8,
        force_sound: types::Bool,
        event_only: types::Bool,
        pitch: types::Int16,
        duration: types::Int16,
        name: types::Atom,
        window: types::xproto::Window,
    ) -> Result<()> {
        let cookie = self.xkb_bell(
            device_spec,
            bell_class,
            bell_id,
            percent,
            force_sound,
            event_only,
            pitch,
            duration,
            name,
            window,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_state(
        &mut self,
        device_spec: types::DeviceSpec,
    ) -> Result<Cookie<types::xkb::GetStateReply>> {
        let span = tracing::info_span!(
            "xkb_get_state",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::GetStateRequest { device_spec };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_state_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
    ) -> Result<types::xkb::GetStateReply> {
        let cookie = self.xkb_get_state(device_spec)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_latch_lock_state(
        &mut self,
        device_spec: types::DeviceSpec,
        affect_mod_locks: impl Into<types::ModMask>,
        mod_locks: impl Into<types::ModMask>,
        lock_group: types::Bool,
        group_lock: types::Group,
        affect_mod_latches: impl Into<types::ModMask>,
        latch_group: types::Bool,
        group_latch: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_latch_lock_state",
            device_spec = ?device_spec,
            lock_group = ?lock_group,
            group_lock = ?group_lock,
            latch_group = ?latch_group,
            group_latch = ?group_latch,
        );
        let _enter = span.enter();
        let request = types::xkb::LatchLockStateRequest {
            device_spec,
            affect_mod_locks: Into::<u32>::into(affect_mod_locks.into()) as _,
            mod_locks: Into::<u32>::into(mod_locks.into()) as _,
            lock_group,
            group_lock,
            affect_mod_latches: Into::<u32>::into(affect_mod_latches.into()) as _,
            latch_group,
            group_latch,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_latch_lock_state_checked(
        &mut self,
        device_spec: types::DeviceSpec,
        affect_mod_locks: impl Into<types::ModMask>,
        mod_locks: impl Into<types::ModMask>,
        lock_group: types::Bool,
        group_lock: types::Group,
        affect_mod_latches: impl Into<types::ModMask>,
        latch_group: types::Bool,
        group_latch: types::Card16,
    ) -> Result<()> {
        let cookie = self.xkb_latch_lock_state(
            device_spec,
            affect_mod_locks,
            mod_locks,
            lock_group,
            group_lock,
            affect_mod_latches,
            latch_group,
            group_latch,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_controls(
        &mut self,
        device_spec: types::DeviceSpec,
    ) -> Result<Cookie<types::xkb::GetControlsReply>> {
        let span = tracing::info_span!(
            "xkb_get_controls",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::GetControlsRequest { device_spec };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_controls_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
    ) -> Result<types::xkb::GetControlsReply> {
        let cookie = self.xkb_get_controls(device_spec)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_controls(
        &mut self,
        device_spec: types::DeviceSpec,
        affect_internal_real_mods: impl Into<types::ModMask>,
        internal_real_mods: impl Into<types::ModMask>,
        affect_ignore_lock_real_mods: impl Into<types::ModMask>,
        ignore_lock_real_mods: impl Into<types::ModMask>,
        affect_internal_virtual_mods: impl Into<types::VMod>,
        internal_virtual_mods: impl Into<types::VMod>,
        affect_ignore_lock_virtual_mods: impl Into<types::VMod>,
        ignore_lock_virtual_mods: impl Into<types::VMod>,
        mouse_keys_dflt_btn: types::Card8,
        groups_wrap: types::Card8,
        access_x_options: impl Into<types::AXOption>,
        affect_enabled_controls: impl Into<types::BoolCtrl>,
        enabled_controls: impl Into<types::BoolCtrl>,
        change_controls: impl Into<types::Control>,
        repeat_delay: types::Card16,
        repeat_interval: types::Card16,
        slow_keys_delay: types::Card16,
        debounce_delay: types::Card16,
        mouse_keys_delay: types::Card16,
        mouse_keys_interval: types::Card16,
        mouse_keys_time_to_max: types::Card16,
        mouse_keys_max_speed: types::Card16,
        mouse_keys_curve: types::Int16,
        access_x_timeout: types::Card16,
        access_x_timeout_mask: impl Into<types::BoolCtrl>,
        access_x_timeout_values: impl Into<types::BoolCtrl>,
        access_x_timeout_options_mask: impl Into<types::AXOption>,
        access_x_timeout_options_values: impl Into<types::AXOption>,
        per_key_repeat: impl Borrow<[types::Card8; 32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_controls",
            device_spec = ?device_spec,
            mouse_keys_dflt_btn = ?mouse_keys_dflt_btn,
            groups_wrap = ?groups_wrap,
            repeat_delay = ?repeat_delay,
            repeat_interval = ?repeat_interval,
            slow_keys_delay = ?slow_keys_delay,
            debounce_delay = ?debounce_delay,
            mouse_keys_delay = ?mouse_keys_delay,
            mouse_keys_interval = ?mouse_keys_interval,
            mouse_keys_time_to_max = ?mouse_keys_time_to_max,
            mouse_keys_max_speed = ?mouse_keys_max_speed,
            mouse_keys_curve = ?mouse_keys_curve,
            access_x_timeout = ?access_x_timeout,
        );
        let _enter = span.enter();
        let request = types::xkb::SetControlsRequest {
            device_spec,
            affect_internal_real_mods: Into::<u32>::into(affect_internal_real_mods.into()) as _,
            internal_real_mods: Into::<u32>::into(internal_real_mods.into()) as _,
            affect_ignore_lock_real_mods: Into::<u32>::into(affect_ignore_lock_real_mods.into())
                as _,
            ignore_lock_real_mods: Into::<u32>::into(ignore_lock_real_mods.into()) as _,
            affect_internal_virtual_mods: Into::<u32>::into(affect_internal_virtual_mods.into())
                as _,
            internal_virtual_mods: Into::<u32>::into(internal_virtual_mods.into()) as _,
            affect_ignore_lock_virtual_mods: Into::<u32>::into(
                affect_ignore_lock_virtual_mods.into(),
            ) as _,
            ignore_lock_virtual_mods: Into::<u32>::into(ignore_lock_virtual_mods.into()) as _,
            mouse_keys_dflt_btn,
            groups_wrap,
            access_x_options: Into::<u32>::into(access_x_options.into()) as _,
            affect_enabled_controls: Into::<u32>::into(affect_enabled_controls.into()) as _,
            enabled_controls: Into::<u32>::into(enabled_controls.into()) as _,
            change_controls: Into::<u32>::into(change_controls.into()) as _,
            repeat_delay,
            repeat_interval,
            slow_keys_delay,
            debounce_delay,
            mouse_keys_delay,
            mouse_keys_interval,
            mouse_keys_time_to_max,
            mouse_keys_max_speed,
            mouse_keys_curve,
            access_x_timeout,
            access_x_timeout_mask: Into::<u32>::into(access_x_timeout_mask.into()) as _,
            access_x_timeout_values: Into::<u32>::into(access_x_timeout_values.into()) as _,
            access_x_timeout_options_mask: Into::<u32>::into(access_x_timeout_options_mask.into())
                as _,
            access_x_timeout_options_values: Into::<u32>::into(
                access_x_timeout_options_values.into(),
            ) as _,
            per_key_repeat: Cow::Borrowed(per_key_repeat.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_controls_checked(
        &mut self,
        device_spec: types::DeviceSpec,
        affect_internal_real_mods: impl Into<types::ModMask>,
        internal_real_mods: impl Into<types::ModMask>,
        affect_ignore_lock_real_mods: impl Into<types::ModMask>,
        ignore_lock_real_mods: impl Into<types::ModMask>,
        affect_internal_virtual_mods: impl Into<types::VMod>,
        internal_virtual_mods: impl Into<types::VMod>,
        affect_ignore_lock_virtual_mods: impl Into<types::VMod>,
        ignore_lock_virtual_mods: impl Into<types::VMod>,
        mouse_keys_dflt_btn: types::Card8,
        groups_wrap: types::Card8,
        access_x_options: impl Into<types::AXOption>,
        affect_enabled_controls: impl Into<types::BoolCtrl>,
        enabled_controls: impl Into<types::BoolCtrl>,
        change_controls: impl Into<types::Control>,
        repeat_delay: types::Card16,
        repeat_interval: types::Card16,
        slow_keys_delay: types::Card16,
        debounce_delay: types::Card16,
        mouse_keys_delay: types::Card16,
        mouse_keys_interval: types::Card16,
        mouse_keys_time_to_max: types::Card16,
        mouse_keys_max_speed: types::Card16,
        mouse_keys_curve: types::Int16,
        access_x_timeout: types::Card16,
        access_x_timeout_mask: impl Into<types::BoolCtrl>,
        access_x_timeout_values: impl Into<types::BoolCtrl>,
        access_x_timeout_options_mask: impl Into<types::AXOption>,
        access_x_timeout_options_values: impl Into<types::AXOption>,
        per_key_repeat: impl Borrow<[types::Card8; 32]>,
    ) -> Result<()> {
        let cookie = self.xkb_set_controls(
            device_spec,
            affect_internal_real_mods,
            internal_real_mods,
            affect_ignore_lock_real_mods,
            ignore_lock_real_mods,
            affect_internal_virtual_mods,
            internal_virtual_mods,
            affect_ignore_lock_virtual_mods,
            ignore_lock_virtual_mods,
            mouse_keys_dflt_btn,
            groups_wrap,
            access_x_options,
            affect_enabled_controls,
            enabled_controls,
            change_controls,
            repeat_delay,
            repeat_interval,
            slow_keys_delay,
            debounce_delay,
            mouse_keys_delay,
            mouse_keys_interval,
            mouse_keys_time_to_max,
            mouse_keys_max_speed,
            mouse_keys_curve,
            access_x_timeout,
            access_x_timeout_mask,
            access_x_timeout_values,
            access_x_timeout_options_mask,
            access_x_timeout_options_values,
            per_key_repeat,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_map(
        &mut self,
        device_spec: types::DeviceSpec,
        full: impl Into<types::MapPart>,
        partial: impl Into<types::MapPart>,
        first_type: types::Card8,
        n_types: types::Card8,
        first_key_sym: types::Keycode,
        n_key_syms: types::Card8,
        first_key_action: types::Keycode,
        n_key_actions: types::Card8,
        first_key_behavior: types::Keycode,
        n_key_behaviors: types::Card8,
        virtual_mods: impl Into<types::VMod>,
        first_key_explicit: types::Keycode,
        n_key_explicit: types::Card8,
        first_mod_map_key: types::Keycode,
        n_mod_map_keys: types::Card8,
        first_v_mod_map_key: types::Keycode,
        n_v_mod_map_keys: types::Card8,
    ) -> Result<Cookie<types::xkb::GetMapReply>> {
        let span = tracing::info_span!(
            "xkb_get_map",
            device_spec = ?device_spec,
            first_type = ?first_type,
            n_types = ?n_types,
            first_key_sym = ?first_key_sym,
            n_key_syms = ?n_key_syms,
            first_key_action = ?first_key_action,
            n_key_actions = ?n_key_actions,
            first_key_behavior = ?first_key_behavior,
            n_key_behaviors = ?n_key_behaviors,
            first_key_explicit = ?first_key_explicit,
            n_key_explicit = ?n_key_explicit,
            first_mod_map_key = ?first_mod_map_key,
            n_mod_map_keys = ?n_mod_map_keys,
            first_v_mod_map_key = ?first_v_mod_map_key,
            n_v_mod_map_keys = ?n_v_mod_map_keys,
        );
        let _enter = span.enter();
        let request = types::xkb::GetMapRequest {
            device_spec,
            full: Into::<u32>::into(full.into()) as _,
            partial: Into::<u32>::into(partial.into()) as _,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            first_key_action,
            n_key_actions,
            first_key_behavior,
            n_key_behaviors,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_key_explicit,
            n_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_map_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
        full: impl Into<types::MapPart>,
        partial: impl Into<types::MapPart>,
        first_type: types::Card8,
        n_types: types::Card8,
        first_key_sym: types::Keycode,
        n_key_syms: types::Card8,
        first_key_action: types::Keycode,
        n_key_actions: types::Card8,
        first_key_behavior: types::Keycode,
        n_key_behaviors: types::Card8,
        virtual_mods: impl Into<types::VMod>,
        first_key_explicit: types::Keycode,
        n_key_explicit: types::Card8,
        first_mod_map_key: types::Keycode,
        n_mod_map_keys: types::Card8,
        first_v_mod_map_key: types::Keycode,
        n_v_mod_map_keys: types::Card8,
    ) -> Result<types::xkb::GetMapReply> {
        let cookie = self.xkb_get_map(
            device_spec,
            full,
            partial,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            first_key_action,
            n_key_actions,
            first_key_behavior,
            n_key_behaviors,
            virtual_mods,
            first_key_explicit,
            n_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_map(
        &mut self,
        device_spec: types::DeviceSpec,
        flags: impl Into<types::SetMapFlags>,
        min_key_code: types::Keycode,
        max_key_code: types::Keycode,
        first_type: types::Card8,
        n_types: types::Card8,
        first_key_sym: types::Keycode,
        n_key_syms: types::Card8,
        total_syms: types::Card16,
        first_key_action: types::Keycode,
        n_key_actions: types::Card8,
        total_actions: types::Card16,
        first_key_behavior: types::Keycode,
        n_key_behaviors: types::Card8,
        total_key_behaviors: types::Card8,
        first_key_explicit: types::Keycode,
        n_key_explicit: types::Card8,
        total_key_explicit: types::Card8,
        first_mod_map_key: types::Keycode,
        n_mod_map_keys: types::Card8,
        total_mod_map_keys: types::Card8,
        first_v_mod_map_key: types::Keycode,
        n_v_mod_map_keys: types::Card8,
        total_v_mod_map_keys: types::Card8,
        virtual_mods: impl Into<types::VMod>,
        values: impl Borrow<types::xkb::SetMapAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_map",
            device_spec = ?device_spec,
            min_key_code = ?min_key_code,
            max_key_code = ?max_key_code,
            first_type = ?first_type,
            n_types = ?n_types,
            first_key_sym = ?first_key_sym,
            n_key_syms = ?n_key_syms,
            total_syms = ?total_syms,
            first_key_action = ?first_key_action,
            n_key_actions = ?n_key_actions,
            total_actions = ?total_actions,
            first_key_behavior = ?first_key_behavior,
            n_key_behaviors = ?n_key_behaviors,
            total_key_behaviors = ?total_key_behaviors,
            first_key_explicit = ?first_key_explicit,
            n_key_explicit = ?n_key_explicit,
            total_key_explicit = ?total_key_explicit,
            first_mod_map_key = ?first_mod_map_key,
            n_mod_map_keys = ?n_mod_map_keys,
            total_mod_map_keys = ?total_mod_map_keys,
            first_v_mod_map_key = ?first_v_mod_map_key,
            n_v_mod_map_keys = ?n_v_mod_map_keys,
            total_v_mod_map_keys = ?total_v_mod_map_keys,
        );
        let _enter = span.enter();
        let request = types::xkb::SetMapRequest {
            device_spec,
            flags: Into::<u32>::into(flags.into()) as _,
            min_key_code,
            max_key_code,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            total_syms,
            first_key_action,
            n_key_actions,
            total_actions,
            first_key_behavior,
            n_key_behaviors,
            total_key_behaviors,
            first_key_explicit,
            n_key_explicit,
            total_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            total_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
            total_v_mod_map_keys,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            values: Cow::Borrowed(values.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_map_checked(
        &mut self,
        device_spec: types::DeviceSpec,
        flags: impl Into<types::SetMapFlags>,
        min_key_code: types::Keycode,
        max_key_code: types::Keycode,
        first_type: types::Card8,
        n_types: types::Card8,
        first_key_sym: types::Keycode,
        n_key_syms: types::Card8,
        total_syms: types::Card16,
        first_key_action: types::Keycode,
        n_key_actions: types::Card8,
        total_actions: types::Card16,
        first_key_behavior: types::Keycode,
        n_key_behaviors: types::Card8,
        total_key_behaviors: types::Card8,
        first_key_explicit: types::Keycode,
        n_key_explicit: types::Card8,
        total_key_explicit: types::Card8,
        first_mod_map_key: types::Keycode,
        n_mod_map_keys: types::Card8,
        total_mod_map_keys: types::Card8,
        first_v_mod_map_key: types::Keycode,
        n_v_mod_map_keys: types::Card8,
        total_v_mod_map_keys: types::Card8,
        virtual_mods: impl Into<types::VMod>,
        values: impl Borrow<types::xkb::SetMapAux>,
    ) -> Result<()> {
        let cookie = self.xkb_set_map(
            device_spec,
            flags,
            min_key_code,
            max_key_code,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            total_syms,
            first_key_action,
            n_key_actions,
            total_actions,
            first_key_behavior,
            n_key_behaviors,
            total_key_behaviors,
            first_key_explicit,
            n_key_explicit,
            total_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            total_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
            total_v_mod_map_keys,
            virtual_mods,
            values,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_compat_map(
        &mut self,
        device_spec: types::DeviceSpec,
        groups: impl Into<types::SetOfGroup>,
        get_all_si: types::Bool,
        first_si: types::Card16,
        n_si: types::Card16,
    ) -> Result<Cookie<types::xkb::GetCompatMapReply>> {
        let span = tracing::info_span!(
            "xkb_get_compat_map",
            device_spec = ?device_spec,
            get_all_si = ?get_all_si,
            first_si = ?first_si,
            n_si = ?n_si,
        );
        let _enter = span.enter();
        let request = types::xkb::GetCompatMapRequest {
            device_spec,
            groups: Into::<u32>::into(groups.into()) as _,
            get_all_si,
            first_si,
            n_si,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_compat_map_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
        groups: impl Into<types::SetOfGroup>,
        get_all_si: types::Bool,
        first_si: types::Card16,
        n_si: types::Card16,
    ) -> Result<types::xkb::GetCompatMapReply> {
        let cookie = self.xkb_get_compat_map(device_spec, groups, get_all_si, first_si, n_si)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_compat_map(
        &mut self,
        device_spec: types::DeviceSpec,
        recompute_actions: types::Bool,
        truncate_si: types::Bool,
        groups: impl Into<types::SetOfGroup>,
        first_si: types::Card16,
        si: impl AsRef<[types::SymInterpret]>,
        group_maps: impl AsRef<[types::ModDef]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_compat_map",
            device_spec = ?device_spec,
            recompute_actions = ?recompute_actions,
            truncate_si = ?truncate_si,
            first_si = ?first_si,
        );
        let _enter = span.enter();
        let request = types::xkb::SetCompatMapRequest {
            device_spec,
            recompute_actions,
            truncate_si,
            groups: Into::<u32>::into(groups.into()) as _,
            first_si,
            si: Cow::Borrowed(si.as_ref()),
            group_maps: Cow::Borrowed(group_maps.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_compat_map_checked(
        &mut self,
        device_spec: types::DeviceSpec,
        recompute_actions: types::Bool,
        truncate_si: types::Bool,
        groups: impl Into<types::SetOfGroup>,
        first_si: types::Card16,
        si: impl AsRef<[types::SymInterpret]>,
        group_maps: impl AsRef<[types::ModDef]>,
    ) -> Result<()> {
        let cookie = self.xkb_set_compat_map(
            device_spec,
            recompute_actions,
            truncate_si,
            groups,
            first_si,
            si,
            group_maps,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_state(
        &mut self,
        device_spec: types::DeviceSpec,
    ) -> Result<Cookie<types::xkb::GetIndicatorStateReply>> {
        let span = tracing::info_span!(
            "xkb_get_indicator_state",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::GetIndicatorStateRequest { device_spec };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_state_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
    ) -> Result<types::xkb::GetIndicatorStateReply> {
        let cookie = self.xkb_get_indicator_state(device_spec)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_map(
        &mut self,
        device_spec: types::DeviceSpec,
        which: types::Card32,
    ) -> Result<Cookie<types::xkb::GetIndicatorMapReply>> {
        let span = tracing::info_span!(
            "xkb_get_indicator_map",
            device_spec = ?device_spec,
            which = ?which,
        );
        let _enter = span.enter();
        let request = types::xkb::GetIndicatorMapRequest { device_spec, which };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_map_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
        which: types::Card32,
    ) -> Result<types::xkb::GetIndicatorMapReply> {
        let cookie = self.xkb_get_indicator_map(device_spec, which)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_indicator_map(
        &mut self,
        device_spec: types::DeviceSpec,
        which: types::Card32,
        maps: impl AsRef<[types::IndicatorMap]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_indicator_map",
            device_spec = ?device_spec,
            which = ?which,
        );
        let _enter = span.enter();
        let request = types::xkb::SetIndicatorMapRequest {
            device_spec,
            which,
            maps: Cow::Borrowed(maps.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_indicator_map_checked(
        &mut self,
        device_spec: types::DeviceSpec,
        which: types::Card32,
        maps: impl AsRef<[types::IndicatorMap]>,
    ) -> Result<()> {
        let cookie = self.xkb_set_indicator_map(device_spec, which, maps)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_named_indicator(
        &mut self,
        device_spec: types::DeviceSpec,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
        indicator: types::Atom,
    ) -> Result<Cookie<types::xkb::GetNamedIndicatorReply>> {
        let span = tracing::info_span!(
            "xkb_get_named_indicator",
            device_spec = ?device_spec,
            led_class = ?led_class,
            indicator = ?indicator,
        );
        let _enter = span.enter();
        let request = types::xkb::GetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_named_indicator_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
        indicator: types::Atom,
    ) -> Result<types::xkb::GetNamedIndicatorReply> {
        let cookie = self.xkb_get_named_indicator(device_spec, led_class, led_id, indicator)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_named_indicator(
        &mut self,
        device_spec: types::DeviceSpec,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
        indicator: types::Atom,
        set_state: types::Bool,
        on: types::Bool,
        set_map: types::Bool,
        create_map: types::Bool,
        map_flags: impl Into<types::IMFlag>,
        map_which_groups: impl Into<types::IMGroupsWhich>,
        map_groups: impl Into<types::SetOfGroups>,
        map_which_mods: impl Into<types::IMModsWhich>,
        map_real_mods: impl Into<types::ModMask>,
        map_vmods: impl Into<types::VMod>,
        map_ctrls: impl Into<types::BoolCtrl>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_named_indicator",
            device_spec = ?device_spec,
            led_class = ?led_class,
            indicator = ?indicator,
            set_state = ?set_state,
            on = ?on,
            set_map = ?set_map,
            create_map = ?create_map,
        );
        let _enter = span.enter();
        let request = types::xkb::SetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
            set_state,
            on,
            set_map,
            create_map,
            map_flags: Into::<u32>::into(map_flags.into()) as _,
            map_which_groups: Into::<u32>::into(map_which_groups.into()) as _,
            map_groups: Into::<u32>::into(map_groups.into()) as _,
            map_which_mods: Into::<u32>::into(map_which_mods.into()) as _,
            map_real_mods: Into::<u32>::into(map_real_mods.into()) as _,
            map_vmods: Into::<u32>::into(map_vmods.into()) as _,
            map_ctrls: Into::<u32>::into(map_ctrls.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_named_indicator_checked(
        &mut self,
        device_spec: types::DeviceSpec,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
        indicator: types::Atom,
        set_state: types::Bool,
        on: types::Bool,
        set_map: types::Bool,
        create_map: types::Bool,
        map_flags: impl Into<types::IMFlag>,
        map_which_groups: impl Into<types::IMGroupsWhich>,
        map_groups: impl Into<types::SetOfGroups>,
        map_which_mods: impl Into<types::IMModsWhich>,
        map_real_mods: impl Into<types::ModMask>,
        map_vmods: impl Into<types::VMod>,
        map_ctrls: impl Into<types::BoolCtrl>,
    ) -> Result<()> {
        let cookie = self.xkb_set_named_indicator(
            device_spec,
            led_class,
            led_id,
            indicator,
            set_state,
            on,
            set_map,
            create_map,
            map_flags,
            map_which_groups,
            map_groups,
            map_which_mods,
            map_real_mods,
            map_vmods,
            map_ctrls,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_names(
        &mut self,
        device_spec: types::DeviceSpec,
        which: impl Into<types::NameDetail>,
    ) -> Result<Cookie<types::xkb::GetNamesReply>> {
        let span = tracing::info_span!(
            "xkb_get_names",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::GetNamesRequest {
            device_spec,
            which: Into::<u32>::into(which.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_names_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
        which: impl Into<types::NameDetail>,
    ) -> Result<types::xkb::GetNamesReply> {
        let cookie = self.xkb_get_names(device_spec, which)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_names(
        &mut self,
        device_spec: types::DeviceSpec,
        virtual_mods: impl Into<types::VMod>,
        first_type: types::Card8,
        n_types: types::Card8,
        first_kt_levelt: types::Card8,
        n_kt_levels: types::Card8,
        indicators: types::Card32,
        group_names: impl Into<types::SetOfGroup>,
        n_radio_groups: types::Card8,
        first_key: types::Keycode,
        n_keys: types::Card8,
        n_key_aliases: types::Card8,
        total_kt_level_names: types::Card16,
        values: impl Borrow<types::xkb::SetNamesAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_names",
            device_spec = ?device_spec,
            first_type = ?first_type,
            n_types = ?n_types,
            first_kt_levelt = ?first_kt_levelt,
            n_kt_levels = ?n_kt_levels,
            indicators = ?indicators,
            n_radio_groups = ?n_radio_groups,
            first_key = ?first_key,
            n_keys = ?n_keys,
            n_key_aliases = ?n_key_aliases,
            total_kt_level_names = ?total_kt_level_names,
        );
        let _enter = span.enter();
        let request = types::xkb::SetNamesRequest {
            device_spec,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_type,
            n_types,
            first_kt_levelt,
            n_kt_levels,
            indicators,
            group_names: Into::<u32>::into(group_names.into()) as _,
            n_radio_groups,
            first_key,
            n_keys,
            n_key_aliases,
            total_kt_level_names,
            values: Cow::Borrowed(values.borrow()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_names_checked(
        &mut self,
        device_spec: types::DeviceSpec,
        virtual_mods: impl Into<types::VMod>,
        first_type: types::Card8,
        n_types: types::Card8,
        first_kt_levelt: types::Card8,
        n_kt_levels: types::Card8,
        indicators: types::Card32,
        group_names: impl Into<types::SetOfGroup>,
        n_radio_groups: types::Card8,
        first_key: types::Keycode,
        n_keys: types::Card8,
        n_key_aliases: types::Card8,
        total_kt_level_names: types::Card16,
        values: impl Borrow<types::xkb::SetNamesAux>,
    ) -> Result<()> {
        let cookie = self.xkb_set_names(
            device_spec,
            virtual_mods,
            first_type,
            n_types,
            first_kt_levelt,
            n_kt_levels,
            indicators,
            group_names,
            n_radio_groups,
            first_key,
            n_keys,
            n_key_aliases,
            total_kt_level_names,
            values,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_per_client_flags(
        &mut self,
        device_spec: types::DeviceSpec,
        change: impl Into<types::PerClientFlag>,
        value: impl Into<types::PerClientFlag>,
        ctrls_to_change: impl Into<types::BoolCtrl>,
        auto_ctrls: impl Into<types::BoolCtrl>,
        auto_ctrls_values: impl Into<types::BoolCtrl>,
    ) -> Result<Cookie<types::xkb::PerClientFlagsReply>> {
        let span = tracing::info_span!(
            "xkb_per_client_flags",
            device_spec = ?device_spec,
        );
        let _enter = span.enter();
        let request = types::xkb::PerClientFlagsRequest {
            device_spec,
            change: Into::<u32>::into(change.into()) as _,
            value: Into::<u32>::into(value.into()) as _,
            ctrls_to_change: Into::<u32>::into(ctrls_to_change.into()) as _,
            auto_ctrls: Into::<u32>::into(auto_ctrls.into()) as _,
            auto_ctrls_values: Into::<u32>::into(auto_ctrls_values.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_per_client_flags_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
        change: impl Into<types::PerClientFlag>,
        value: impl Into<types::PerClientFlag>,
        ctrls_to_change: impl Into<types::BoolCtrl>,
        auto_ctrls: impl Into<types::BoolCtrl>,
        auto_ctrls_values: impl Into<types::BoolCtrl>,
    ) -> Result<types::xkb::PerClientFlagsReply> {
        let cookie = self.xkb_per_client_flags(
            device_spec,
            change,
            value,
            ctrls_to_change,
            auto_ctrls,
            auto_ctrls_values,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_list_components(
        &mut self,
        device_spec: types::DeviceSpec,
        max_names: types::Card16,
    ) -> Result<Cookie<types::xkb::ListComponentsReply>> {
        let span = tracing::info_span!(
            "xkb_list_components",
            device_spec = ?device_spec,
            max_names = ?max_names,
        );
        let _enter = span.enter();
        let request = types::xkb::ListComponentsRequest {
            device_spec,
            max_names,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_list_components_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
        max_names: types::Card16,
    ) -> Result<types::xkb::ListComponentsReply> {
        let cookie = self.xkb_list_components(device_spec, max_names)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_kbd_by_name(
        &mut self,
        device_spec: types::DeviceSpec,
        need: impl Into<types::GBNDetail>,
        want: impl Into<types::GBNDetail>,
        load: types::Bool,
    ) -> Result<Cookie<types::xkb::GetKbdByNameReply>> {
        let span = tracing::info_span!(
            "xkb_get_kbd_by_name",
            device_spec = ?device_spec,
            load = ?load,
        );
        let _enter = span.enter();
        let request = types::xkb::GetKbdByNameRequest {
            device_spec,
            need: Into::<u32>::into(need.into()) as _,
            want: Into::<u32>::into(want.into()) as _,
            load,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_kbd_by_name_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
        need: impl Into<types::GBNDetail>,
        want: impl Into<types::GBNDetail>,
        load: types::Bool,
    ) -> Result<types::xkb::GetKbdByNameReply> {
        let cookie = self.xkb_get_kbd_by_name(device_spec, need, want, load)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_device_info(
        &mut self,
        device_spec: types::DeviceSpec,
        wanted: impl Into<types::XIFeature>,
        all_buttons: types::Bool,
        first_button: types::Card8,
        n_buttons: types::Card8,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
    ) -> Result<Cookie<types::xkb::GetDeviceInfoReply>> {
        let span = tracing::info_span!(
            "xkb_get_device_info",
            device_spec = ?device_spec,
            all_buttons = ?all_buttons,
            first_button = ?first_button,
            n_buttons = ?n_buttons,
            led_class = ?led_class,
        );
        let _enter = span.enter();
        let request = types::xkb::GetDeviceInfoRequest {
            device_spec,
            wanted: Into::<u32>::into(wanted.into()) as _,
            all_buttons,
            first_button,
            n_buttons,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_device_info_immediate(
        &mut self,
        device_spec: types::DeviceSpec,
        wanted: impl Into<types::XIFeature>,
        all_buttons: types::Bool,
        first_button: types::Card8,
        n_buttons: types::Card8,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
    ) -> Result<types::xkb::GetDeviceInfoReply> {
        let cookie = self.xkb_get_device_info(
            device_spec,
            wanted,
            all_buttons,
            first_button,
            n_buttons,
            led_class,
            led_id,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_device_info(
        &mut self,
        device_spec: types::DeviceSpec,
        first_btn: types::Card8,
        change: impl Into<types::XIFeature>,
        btn_actions: impl AsRef<[types::Action]>,
        leds: impl AsRef<[types::DeviceLedInfo]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xkb_set_device_info",
            device_spec = ?device_spec,
            first_btn = ?first_btn,
        );
        let _enter = span.enter();
        let request = types::xkb::SetDeviceInfoRequest {
            device_spec,
            first_btn,
            change: Into::<u32>::into(change.into()) as _,
            btn_actions: Cow::Borrowed(btn_actions.as_ref()),
            leds: Cow::Borrowed(leds.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_device_info_checked(
        &mut self,
        device_spec: types::DeviceSpec,
        first_btn: types::Card8,
        change: impl Into<types::XIFeature>,
        btn_actions: impl AsRef<[types::Action]>,
        leds: impl AsRef<[types::DeviceLedInfo]>,
    ) -> Result<()> {
        let cookie = self.xkb_set_device_info(device_spec, first_btn, change, btn_actions, leds)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_debugging_flags(
        &mut self,
        affect_flags: types::Card32,
        flags: types::Card32,
        affect_ctrls: types::Card32,
        ctrls: types::Card32,
        message: impl AsRef<[types::xkb::String8]>,
    ) -> Result<Cookie<types::xkb::SetDebuggingFlagsReply>> {
        let span = tracing::info_span!(
            "xkb_set_debugging_flags",
            affect_flags = ?affect_flags,
            flags = ?flags,
            affect_ctrls = ?affect_ctrls,
            ctrls = ?ctrls,
        );
        let _enter = span.enter();
        let request = types::xkb::SetDebuggingFlagsRequest {
            affect_flags,
            flags,
            affect_ctrls,
            ctrls,
            message: Cow::Borrowed(message.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_debugging_flags_immediate(
        &mut self,
        affect_flags: types::Card32,
        flags: types::Card32,
        affect_ctrls: types::Card32,
        ctrls: types::Card32,
        message: impl AsRef<[types::xkb::String8]>,
    ) -> Result<types::xkb::SetDebuggingFlagsReply> {
        let cookie =
            self.xkb_set_debugging_flags(affect_flags, flags, affect_ctrls, ctrls, message)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xprint")]
    fn xprint_print_query_version(
        &mut self,
    ) -> Result<Cookie<types::xprint::PrintQueryVersionReply>> {
        let span = tracing::info_span!("xprint_print_query_version",);
        let _enter = span.enter();
        let request = types::xprint::PrintQueryVersionRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_version_immediate(
        &mut self,
    ) -> Result<types::xprint::PrintQueryVersionReply> {
        let cookie = self.xprint_print_query_version()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_printer_list(
        &mut self,
        printer_name: impl AsRef<[types::xprint::String8]>,
        locale: impl AsRef<[types::xprint::String8]>,
    ) -> Result<Cookie<types::xprint::PrintGetPrinterListReply>> {
        let span = tracing::info_span!("xprint_print_get_printer_list",);
        let _enter = span.enter();
        let request = types::xprint::PrintGetPrinterListRequest {
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_printer_list_immediate(
        &mut self,
        printer_name: impl AsRef<[types::xprint::String8]>,
        locale: impl AsRef<[types::xprint::String8]>,
    ) -> Result<types::xprint::PrintGetPrinterListReply> {
        let cookie = self.xprint_print_get_printer_list(printer_name, locale)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_rehash_printer_list(&mut self) -> Result<Cookie<()>> {
        let span = tracing::info_span!("xprint_print_rehash_printer_list",);
        let _enter = span.enter();
        let request = types::xprint::PrintRehashPrinterListRequest {};
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_rehash_printer_list_checked(&mut self) -> Result<()> {
        let cookie = self.xprint_print_rehash_printer_list()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_create_context(
        &mut self,
        context_id: types::Card32,
        printer_name: impl AsRef<[types::xprint::String8]>,
        locale: impl AsRef<[types::xprint::String8]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_create_context",
            context_id = ?context_id,
        );
        let _enter = span.enter();
        let request = types::xprint::CreateContextRequest {
            context_id,
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_create_context_checked(
        &mut self,
        context_id: types::Card32,
        printer_name: impl AsRef<[types::xprint::String8]>,
        locale: impl AsRef<[types::xprint::String8]>,
    ) -> Result<()> {
        let cookie = self.xprint_create_context(context_id, printer_name, locale)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_context(&mut self, context: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_set_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintSetContextRequest { context };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_context_checked(&mut self, context: types::Card32) -> Result<()> {
        let cookie = self.xprint_print_set_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_context(&mut self) -> Result<Cookie<types::xprint::PrintGetContextReply>> {
        let span = tracing::info_span!("xprint_print_get_context",);
        let _enter = span.enter();
        let request = types::xprint::PrintGetContextRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_context_immediate(
        &mut self,
    ) -> Result<types::xprint::PrintGetContextReply> {
        let cookie = self.xprint_print_get_context()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_destroy_context(&mut self, context: types::Card32) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_destroy_context",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintDestroyContextRequest { context };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_destroy_context_checked(&mut self, context: types::Card32) -> Result<()> {
        let cookie = self.xprint_print_destroy_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_screen_of_context(
        &mut self,
    ) -> Result<Cookie<types::xprint::PrintGetScreenOfContextReply>> {
        let span = tracing::info_span!("xprint_print_get_screen_of_context",);
        let _enter = span.enter();
        let request = types::xprint::PrintGetScreenOfContextRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_screen_of_context_immediate(
        &mut self,
    ) -> Result<types::xprint::PrintGetScreenOfContextReply> {
        let cookie = self.xprint_print_get_screen_of_context()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_job(&mut self, output_mode: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_start_job",
            output_mode = ?output_mode,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintStartJobRequest { output_mode };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_job_checked(&mut self, output_mode: types::Card8) -> Result<()> {
        let cookie = self.xprint_print_start_job(output_mode)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_job(&mut self, cancel: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_end_job",
            cancel = ?cancel,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintEndJobRequest { cancel };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_job_checked(&mut self, cancel: types::Bool) -> Result<()> {
        let cookie = self.xprint_print_end_job(cancel)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_doc(&mut self, driver_mode: types::Card8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_start_doc",
            driver_mode = ?driver_mode,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintStartDocRequest { driver_mode };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_doc_checked(&mut self, driver_mode: types::Card8) -> Result<()> {
        let cookie = self.xprint_print_start_doc(driver_mode)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_doc(&mut self, cancel: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_end_doc",
            cancel = ?cancel,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintEndDocRequest { cancel };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_doc_checked(&mut self, cancel: types::Bool) -> Result<()> {
        let cookie = self.xprint_print_end_doc(cancel)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_put_document_data(
        &mut self,
        drawable: types::xproto::Drawable,
        data: impl AsRef<[types::Byte]>,
        doc_format: impl AsRef<[types::xprint::String8]>,
        options: impl AsRef<[types::xprint::String8]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_put_document_data",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintPutDocumentDataRequest {
            drawable,
            data: Cow::Borrowed(data.as_ref()),
            doc_format: Cow::Borrowed(doc_format.as_ref()),
            options: Cow::Borrowed(options.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_put_document_data_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        data: impl AsRef<[types::Byte]>,
        doc_format: impl AsRef<[types::xprint::String8]>,
        options: impl AsRef<[types::xprint::String8]>,
    ) -> Result<()> {
        let cookie = self.xprint_print_put_document_data(drawable, data, doc_format, options)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_document_data(
        &mut self,
        context: types::Pcontext,
        max_bytes: types::Card32,
    ) -> Result<Cookie<types::xprint::PrintGetDocumentDataReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_document_data",
            context = ?context,
            max_bytes = ?max_bytes,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetDocumentDataRequest { context, max_bytes };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_document_data_immediate(
        &mut self,
        context: types::Pcontext,
        max_bytes: types::Card32,
    ) -> Result<types::xprint::PrintGetDocumentDataReply> {
        let cookie = self.xprint_print_get_document_data(context, max_bytes)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_page(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_start_page",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintStartPageRequest { window };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_page_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let cookie = self.xprint_print_start_page(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_page(&mut self, cancel: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_end_page",
            cancel = ?cancel,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintEndPageRequest { cancel };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_page_checked(&mut self, cancel: types::Bool) -> Result<()> {
        let cookie = self.xprint_print_end_page(cancel)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_select_input(
        &mut self,
        context: types::Pcontext,
        event_mask: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_select_input",
            context = ?context,
            event_mask = ?event_mask,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintSelectInputRequest {
            context,
            event_mask,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_select_input_checked(
        &mut self,
        context: types::Pcontext,
        event_mask: types::Card32,
    ) -> Result<()> {
        let cookie = self.xprint_print_select_input(context, event_mask)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_input_selected(
        &mut self,
        context: types::Pcontext,
    ) -> Result<Cookie<types::xprint::PrintInputSelectedReply>> {
        let span = tracing::info_span!(
            "xprint_print_input_selected",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintInputSelectedRequest { context };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_input_selected_immediate(
        &mut self,
        context: types::Pcontext,
    ) -> Result<types::xprint::PrintInputSelectedReply> {
        let cookie = self.xprint_print_input_selected(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_attributes(
        &mut self,
        context: types::Pcontext,
        pool: types::Card8,
    ) -> Result<Cookie<types::xprint::PrintGetAttributesReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_attributes",
            context = ?context,
            pool = ?pool,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetAttributesRequest { context, pool };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_attributes_immediate(
        &mut self,
        context: types::Pcontext,
        pool: types::Card8,
    ) -> Result<types::xprint::PrintGetAttributesReply> {
        let cookie = self.xprint_print_get_attributes(context, pool)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_one_attributes(
        &mut self,
        context: types::Pcontext,
        pool: types::Card8,
        name: impl AsRef<[types::xprint::String8]>,
    ) -> Result<Cookie<types::xprint::PrintGetOneAttributesReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_one_attributes",
            context = ?context,
            pool = ?pool,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetOneAttributesRequest {
            context,
            pool,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_one_attributes_immediate(
        &mut self,
        context: types::Pcontext,
        pool: types::Card8,
        name: impl AsRef<[types::xprint::String8]>,
    ) -> Result<types::xprint::PrintGetOneAttributesReply> {
        let cookie = self.xprint_print_get_one_attributes(context, pool, name)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_attributes(
        &mut self,
        context: types::Pcontext,
        string_len: types::Card32,
        pool: types::Card8,
        rule: types::Card8,
        attributes: impl AsRef<[types::xprint::String8]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xprint_print_set_attributes",
            context = ?context,
            string_len = ?string_len,
            pool = ?pool,
            rule = ?rule,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintSetAttributesRequest {
            context,
            string_len,
            pool,
            rule,
            attributes: Cow::Borrowed(attributes.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_attributes_checked(
        &mut self,
        context: types::Pcontext,
        string_len: types::Card32,
        pool: types::Card8,
        rule: types::Card8,
        attributes: impl AsRef<[types::xprint::String8]>,
    ) -> Result<()> {
        let cookie =
            self.xprint_print_set_attributes(context, string_len, pool, rule, attributes)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_page_dimensions(
        &mut self,
        context: types::Pcontext,
    ) -> Result<Cookie<types::xprint::PrintGetPageDimensionsReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_page_dimensions",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetPageDimensionsRequest { context };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_page_dimensions_immediate(
        &mut self,
        context: types::Pcontext,
    ) -> Result<types::xprint::PrintGetPageDimensionsReply> {
        let cookie = self.xprint_print_get_page_dimensions(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_screens(
        &mut self,
    ) -> Result<Cookie<types::xprint::PrintQueryScreensReply>> {
        let span = tracing::info_span!("xprint_print_query_screens",);
        let _enter = span.enter();
        let request = types::xprint::PrintQueryScreensRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_screens_immediate(
        &mut self,
    ) -> Result<types::xprint::PrintQueryScreensReply> {
        let cookie = self.xprint_print_query_screens()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_image_resolution(
        &mut self,
        context: types::Pcontext,
        image_resolution: types::Card16,
    ) -> Result<Cookie<types::xprint::PrintSetImageResolutionReply>> {
        let span = tracing::info_span!(
            "xprint_print_set_image_resolution",
            context = ?context,
            image_resolution = ?image_resolution,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintSetImageResolutionRequest {
            context,
            image_resolution,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_image_resolution_immediate(
        &mut self,
        context: types::Pcontext,
        image_resolution: types::Card16,
    ) -> Result<types::xprint::PrintSetImageResolutionReply> {
        let cookie = self.xprint_print_set_image_resolution(context, image_resolution)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_image_resolution(
        &mut self,
        context: types::Pcontext,
    ) -> Result<Cookie<types::xprint::PrintGetImageResolutionReply>> {
        let span = tracing::info_span!(
            "xprint_print_get_image_resolution",
            context = ?context,
        );
        let _enter = span.enter();
        let request = types::xprint::PrintGetImageResolutionRequest { context };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_image_resolution_immediate(
        &mut self,
        context: types::Pcontext,
    ) -> Result<types::xprint::PrintGetImageResolutionReply> {
        let cookie = self.xprint_print_get_image_resolution(context)?;
        self.wait_for_reply(cookie)
    }

    fn create_window(
        &mut self,
        depth: types::Card8,
        wid: types::xproto::Window,
        parent: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        border_width: types::Card16,
        class: types::WindowClass,
        visual: types::Visualid,
        value_list: impl Borrow<types::xproto::CreateWindowAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_window",
            depth = ?depth,
            wid = ?wid,
            parent = ?parent,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            border_width = ?border_width,
            class = ?class,
            visual = ?visual,
        );
        let _enter = span.enter();
        let request = types::xproto::CreateWindowRequest {
            depth,
            wid,
            parent,
            x,
            y,
            width,
            height,
            border_width,
            class,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn create_window_checked(
        &mut self,
        depth: types::Card8,
        wid: types::xproto::Window,
        parent: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        border_width: types::Card16,
        class: types::WindowClass,
        visual: types::Visualid,
        value_list: impl Borrow<types::xproto::CreateWindowAux>,
    ) -> Result<()> {
        let cookie = self.create_window(
            depth,
            wid,
            parent,
            x,
            y,
            width,
            height,
            border_width,
            class,
            visual,
            value_list,
        )?;
        self.wait_for_reply(cookie)
    }
    fn change_window_attributes(
        &mut self,
        window: types::xproto::Window,
        value_list: impl Borrow<types::xproto::ChangeWindowAttributesAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_window_attributes",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeWindowAttributesRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn change_window_attributes_checked(
        &mut self,
        window: types::xproto::Window,
        value_list: impl Borrow<types::xproto::ChangeWindowAttributesAux>,
    ) -> Result<()> {
        let cookie = self.change_window_attributes(window, value_list)?;
        self.wait_for_reply(cookie)
    }
    fn get_window_attributes(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xproto::GetWindowAttributesReply>> {
        let span = tracing::info_span!(
            "get_window_attributes",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::GetWindowAttributesRequest { window };
        self.send_reply_request(request)
    }
    fn get_window_attributes_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xproto::GetWindowAttributesReply> {
        let cookie = self.get_window_attributes(window)?;
        self.wait_for_reply(cookie)
    }
    fn destroy_window(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "destroy_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::DestroyWindowRequest { window };
        self.send_void_request(request)
    }
    fn destroy_window_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let cookie = self.destroy_window(window)?;
        self.wait_for_reply(cookie)
    }
    fn destroy_subwindows(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "destroy_subwindows",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::DestroySubwindowsRequest { window };
        self.send_void_request(request)
    }
    fn destroy_subwindows_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let cookie = self.destroy_subwindows(window)?;
        self.wait_for_reply(cookie)
    }
    fn change_save_set(
        &mut self,
        mode: types::SetMode,
        window: types::xproto::Window,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_save_set",
            mode = ?mode,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeSaveSetRequest { mode, window };
        self.send_void_request(request)
    }
    fn change_save_set_checked(
        &mut self,
        mode: types::SetMode,
        window: types::xproto::Window,
    ) -> Result<()> {
        let cookie = self.change_save_set(mode, window)?;
        self.wait_for_reply(cookie)
    }
    fn reparent_window(
        &mut self,
        window: types::xproto::Window,
        parent: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "reparent_window",
            window = ?window,
            parent = ?parent,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::ReparentWindowRequest {
            window,
            parent,
            x,
            y,
        };
        self.send_void_request(request)
    }
    fn reparent_window_checked(
        &mut self,
        window: types::xproto::Window,
        parent: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
    ) -> Result<()> {
        let cookie = self.reparent_window(window, parent, x, y)?;
        self.wait_for_reply(cookie)
    }
    fn map_window(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "map_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::MapWindowRequest { window };
        self.send_void_request(request)
    }
    fn map_window_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let cookie = self.map_window(window)?;
        self.wait_for_reply(cookie)
    }
    fn map_subwindows(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "map_subwindows",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::MapSubwindowsRequest { window };
        self.send_void_request(request)
    }
    fn map_subwindows_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let cookie = self.map_subwindows(window)?;
        self.wait_for_reply(cookie)
    }
    fn unmap_window(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "unmap_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::UnmapWindowRequest { window };
        self.send_void_request(request)
    }
    fn unmap_window_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let cookie = self.unmap_window(window)?;
        self.wait_for_reply(cookie)
    }
    fn unmap_subwindows(&mut self, window: types::xproto::Window) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "unmap_subwindows",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::UnmapSubwindowsRequest { window };
        self.send_void_request(request)
    }
    fn unmap_subwindows_checked(&mut self, window: types::xproto::Window) -> Result<()> {
        let cookie = self.unmap_subwindows(window)?;
        self.wait_for_reply(cookie)
    }
    fn configure_window(
        &mut self,
        window: types::xproto::Window,
        value_list: impl Borrow<types::xproto::ConfigureWindowAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "configure_window",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::ConfigureWindowRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn configure_window_checked(
        &mut self,
        window: types::xproto::Window,
        value_list: impl Borrow<types::xproto::ConfigureWindowAux>,
    ) -> Result<()> {
        let cookie = self.configure_window(window, value_list)?;
        self.wait_for_reply(cookie)
    }
    fn circulate_window(
        &mut self,
        direction: types::Circulate,
        window: types::xproto::Window,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "circulate_window",
            direction = ?direction,
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::CirculateWindowRequest { direction, window };
        self.send_void_request(request)
    }
    fn circulate_window_checked(
        &mut self,
        direction: types::Circulate,
        window: types::xproto::Window,
    ) -> Result<()> {
        let cookie = self.circulate_window(direction, window)?;
        self.wait_for_reply(cookie)
    }
    fn get_geometry(
        &mut self,
        drawable: types::xproto::Drawable,
    ) -> Result<Cookie<types::xproto::GetGeometryReply>> {
        let span = tracing::info_span!(
            "get_geometry",
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xproto::GetGeometryRequest { drawable };
        self.send_reply_request(request)
    }
    fn get_geometry_immediate(
        &mut self,
        drawable: types::xproto::Drawable,
    ) -> Result<types::xproto::GetGeometryReply> {
        let cookie = self.get_geometry(drawable)?;
        self.wait_for_reply(cookie)
    }
    fn query_tree(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xproto::QueryTreeReply>> {
        let span = tracing::info_span!(
            "query_tree",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryTreeRequest { window };
        self.send_reply_request(request)
    }
    fn query_tree_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xproto::QueryTreeReply> {
        let cookie = self.query_tree(window)?;
        self.wait_for_reply(cookie)
    }
    fn intern_atom(
        &mut self,
        only_if_exists: types::Bool,
        name: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<types::xproto::InternAtomReply>> {
        let span = tracing::info_span!(
            "intern_atom",
            only_if_exists = ?only_if_exists,
        );
        let _enter = span.enter();
        let request = types::xproto::InternAtomRequest {
            only_if_exists,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn intern_atom_immediate(
        &mut self,
        only_if_exists: types::Bool,
        name: impl AsRef<[types::Char]>,
    ) -> Result<types::xproto::InternAtomReply> {
        let cookie = self.intern_atom(only_if_exists, name)?;
        self.wait_for_reply(cookie)
    }
    fn get_atom_name(
        &mut self,
        atom: types::Atom,
    ) -> Result<Cookie<types::xproto::GetAtomNameReply>> {
        let span = tracing::info_span!(
            "get_atom_name",
            atom = ?atom,
        );
        let _enter = span.enter();
        let request = types::xproto::GetAtomNameRequest { atom };
        self.send_reply_request(request)
    }
    fn get_atom_name_immediate(
        &mut self,
        atom: types::Atom,
    ) -> Result<types::xproto::GetAtomNameReply> {
        let cookie = self.get_atom_name(atom)?;
        self.wait_for_reply(cookie)
    }
    fn change_property(
        &mut self,
        mode: types::PropMode,
        window: types::xproto::Window,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        data_len: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_property",
            mode = ?mode,
            window = ?window,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            data_len = ?data_len,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangePropertyRequest {
            mode,
            window,
            property,
            type_,
            format,
            data_len,
            data: Cow::Borrowed(data.bytes()),
        };
        self.send_void_request(request)
    }
    fn change_property_checked(
        &mut self,
        mode: types::PropMode,
        window: types::xproto::Window,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        data_len: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Result<()> {
        let cookie = self.change_property(mode, window, property, type_, format, data_len, data)?;
        self.wait_for_reply(cookie)
    }
    fn delete_property(
        &mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "delete_property",
            window = ?window,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::xproto::DeletePropertyRequest { window, property };
        self.send_void_request(request)
    }
    fn delete_property_checked(
        &mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Result<()> {
        let cookie = self.delete_property(window, property)?;
        self.wait_for_reply(cookie)
    }
    fn get_property(
        &mut self,
        delete: types::Bool,
        window: types::xproto::Window,
        property: types::Atom,
        type_: impl Into<types::GetPropertyType>,
        long_offset: types::Card32,
        long_length: types::Card32,
    ) -> Result<Cookie<types::xproto::GetPropertyReply>> {
        let span = tracing::info_span!(
            "get_property",
            delete = ?delete,
            window = ?window,
            property = ?property,
            long_offset = ?long_offset,
            long_length = ?long_length,
        );
        let _enter = span.enter();
        let request = types::xproto::GetPropertyRequest {
            delete,
            window,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
        };
        self.send_reply_request(request)
    }
    fn get_property_immediate(
        &mut self,
        delete: types::Bool,
        window: types::xproto::Window,
        property: types::Atom,
        type_: impl Into<types::GetPropertyType>,
        long_offset: types::Card32,
        long_length: types::Card32,
    ) -> Result<types::xproto::GetPropertyReply> {
        let cookie =
            self.get_property(delete, window, property, type_, long_offset, long_length)?;
        self.wait_for_reply(cookie)
    }
    fn list_properties(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xproto::ListPropertiesReply>> {
        let span = tracing::info_span!(
            "list_properties",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::ListPropertiesRequest { window };
        self.send_reply_request(request)
    }
    fn list_properties_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xproto::ListPropertiesReply> {
        let cookie = self.list_properties(window)?;
        self.wait_for_reply(cookie)
    }
    fn set_selection_owner(
        &mut self,
        owner: impl Into<types::xproto::Window>,
        selection: types::Atom,
        time: impl Into<types::Time>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_selection_owner",
            selection = ?selection,
        );
        let _enter = span.enter();
        let request = types::xproto::SetSelectionOwnerRequest {
            owner: Into::<u32>::into(owner.into()) as _,
            selection,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn set_selection_owner_checked(
        &mut self,
        owner: impl Into<types::xproto::Window>,
        selection: types::Atom,
        time: impl Into<types::Time>,
    ) -> Result<()> {
        let cookie = self.set_selection_owner(owner, selection, time)?;
        self.wait_for_reply(cookie)
    }
    fn get_selection_owner(
        &mut self,
        selection: types::Atom,
    ) -> Result<Cookie<types::xproto::GetSelectionOwnerReply>> {
        let span = tracing::info_span!(
            "get_selection_owner",
            selection = ?selection,
        );
        let _enter = span.enter();
        let request = types::xproto::GetSelectionOwnerRequest { selection };
        self.send_reply_request(request)
    }
    fn get_selection_owner_immediate(
        &mut self,
        selection: types::Atom,
    ) -> Result<types::xproto::GetSelectionOwnerReply> {
        let cookie = self.get_selection_owner(selection)?;
        self.wait_for_reply(cookie)
    }
    fn convert_selection(
        &mut self,
        requestor: types::xproto::Window,
        selection: types::Atom,
        target: types::Atom,
        property: impl Into<types::Atom>,
        time: impl Into<types::Time>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "convert_selection",
            requestor = ?requestor,
            selection = ?selection,
            target = ?target,
        );
        let _enter = span.enter();
        let request = types::xproto::ConvertSelectionRequest {
            requestor,
            selection,
            target,
            property: Into::<u32>::into(property.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn convert_selection_checked(
        &mut self,
        requestor: types::xproto::Window,
        selection: types::Atom,
        target: types::Atom,
        property: impl Into<types::Atom>,
        time: impl Into<types::Time>,
    ) -> Result<()> {
        let cookie = self.convert_selection(requestor, selection, target, property, time)?;
        self.wait_for_reply(cookie)
    }
    fn send_event(
        &mut self,
        propagate: types::Bool,
        destination: impl Into<types::SendEventDest>,
        event_mask: impl Into<types::xproto::EventMask>,
        event: impl Borrow<[types::Char; 32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "send_event",
            propagate = ?propagate,
        );
        let _enter = span.enter();
        let request = types::xproto::SendEventRequest {
            propagate,
            destination: Into::<u32>::into(destination.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            event: Cow::Borrowed(event.borrow()),
        };
        self.send_void_request(request)
    }
    fn send_event_checked(
        &mut self,
        propagate: types::Bool,
        destination: impl Into<types::SendEventDest>,
        event_mask: impl Into<types::xproto::EventMask>,
        event: impl Borrow<[types::Char; 32]>,
    ) -> Result<()> {
        let cookie = self.send_event(propagate, destination, event_mask, event)?;
        self.wait_for_reply(cookie)
    }
    fn grab_pointer(
        &mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        event_mask: impl Into<types::xproto::EventMask>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
        confine_to: impl Into<types::xproto::Window>,
        cursor: impl Into<types::xproto::Cursor>,
        time: impl Into<types::Time>,
    ) -> Result<Cookie<types::xproto::GrabPointerReply>> {
        let span = tracing::info_span!(
            "grab_pointer",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let _enter = span.enter();
        let request = types::xproto::GrabPointerRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_reply_request(request)
    }
    fn grab_pointer_immediate(
        &mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        event_mask: impl Into<types::xproto::EventMask>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
        confine_to: impl Into<types::xproto::Window>,
        cursor: impl Into<types::xproto::Cursor>,
        time: impl Into<types::Time>,
    ) -> Result<types::xproto::GrabPointerReply> {
        let cookie = self.grab_pointer(
            owner_events,
            grab_window,
            event_mask,
            pointer_mode,
            keyboard_mode,
            confine_to,
            cursor,
            time,
        )?;
        self.wait_for_reply(cookie)
    }
    fn ungrab_pointer(&mut self, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let span = tracing::info_span!("ungrab_pointer",);
        let _enter = span.enter();
        let request = types::xproto::UngrabPointerRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn ungrab_pointer_checked(&mut self, time: impl Into<types::Time>) -> Result<()> {
        let cookie = self.ungrab_pointer(time)?;
        self.wait_for_reply(cookie)
    }
    fn grab_button(
        &mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        event_mask: impl Into<types::xproto::EventMask>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
        confine_to: impl Into<types::xproto::Window>,
        cursor: impl Into<types::xproto::Cursor>,
        button: types::ButtonIndex,
        modifiers: impl Into<types::ModMask>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "grab_button",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
            button = ?button,
        );
        let _enter = span.enter();
        let request = types::xproto::GrabButtonRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            button,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        self.send_void_request(request)
    }
    fn grab_button_checked(
        &mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        event_mask: impl Into<types::xproto::EventMask>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
        confine_to: impl Into<types::xproto::Window>,
        cursor: impl Into<types::xproto::Cursor>,
        button: types::ButtonIndex,
        modifiers: impl Into<types::ModMask>,
    ) -> Result<()> {
        let cookie = self.grab_button(
            owner_events,
            grab_window,
            event_mask,
            pointer_mode,
            keyboard_mode,
            confine_to,
            cursor,
            button,
            modifiers,
        )?;
        self.wait_for_reply(cookie)
    }
    fn ungrab_button(
        &mut self,
        button: types::ButtonIndex,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "ungrab_button",
            button = ?button,
            grab_window = ?grab_window,
        );
        let _enter = span.enter();
        let request = types::xproto::UngrabButtonRequest {
            button,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        self.send_void_request(request)
    }
    fn ungrab_button_checked(
        &mut self,
        button: types::ButtonIndex,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
    ) -> Result<()> {
        let cookie = self.ungrab_button(button, grab_window, modifiers)?;
        self.wait_for_reply(cookie)
    }
    fn change_active_pointer_grab(
        &mut self,
        cursor: impl Into<types::xproto::Cursor>,
        time: impl Into<types::Time>,
        event_mask: impl Into<types::xproto::EventMask>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!("change_active_pointer_grab",);
        let _enter = span.enter();
        let request = types::xproto::ChangeActivePointerGrabRequest {
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    fn change_active_pointer_grab_checked(
        &mut self,
        cursor: impl Into<types::xproto::Cursor>,
        time: impl Into<types::Time>,
        event_mask: impl Into<types::xproto::EventMask>,
    ) -> Result<()> {
        let cookie = self.change_active_pointer_grab(cursor, time, event_mask)?;
        self.wait_for_reply(cookie)
    }
    fn grab_keyboard(
        &mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        time: impl Into<types::Time>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
    ) -> Result<Cookie<types::xproto::GrabKeyboardReply>> {
        let span = tracing::info_span!(
            "grab_keyboard",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let _enter = span.enter();
        let request = types::xproto::GrabKeyboardRequest {
            owner_events,
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        self.send_reply_request(request)
    }
    fn grab_keyboard_immediate(
        &mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        time: impl Into<types::Time>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
    ) -> Result<types::xproto::GrabKeyboardReply> {
        let cookie =
            self.grab_keyboard(owner_events, grab_window, time, pointer_mode, keyboard_mode)?;
        self.wait_for_reply(cookie)
    }
    fn ungrab_keyboard(&mut self, time: impl Into<types::Time>) -> Result<Cookie<()>> {
        let span = tracing::info_span!("ungrab_keyboard",);
        let _enter = span.enter();
        let request = types::xproto::UngrabKeyboardRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn ungrab_keyboard_checked(&mut self, time: impl Into<types::Time>) -> Result<()> {
        let cookie = self.ungrab_keyboard(time)?;
        self.wait_for_reply(cookie)
    }
    fn grab_key(
        &mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        key: impl Into<types::Grab>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "grab_key",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let _enter = span.enter();
        let request = types::xproto::GrabKeyRequest {
            owner_events,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        self.send_void_request(request)
    }
    fn grab_key_checked(
        &mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        key: impl Into<types::Grab>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
    ) -> Result<()> {
        let cookie = self.grab_key(
            owner_events,
            grab_window,
            modifiers,
            key,
            pointer_mode,
            keyboard_mode,
        )?;
        self.wait_for_reply(cookie)
    }
    fn ungrab_key(
        &mut self,
        key: impl Into<types::Grab>,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "ungrab_key",
            grab_window = ?grab_window,
        );
        let _enter = span.enter();
        let request = types::xproto::UngrabKeyRequest {
            key: Into::<u32>::into(key.into()) as _,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        self.send_void_request(request)
    }
    fn ungrab_key_checked(
        &mut self,
        key: impl Into<types::Grab>,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
    ) -> Result<()> {
        let cookie = self.ungrab_key(key, grab_window, modifiers)?;
        self.wait_for_reply(cookie)
    }
    fn allow_events(
        &mut self,
        mode: types::Allow,
        time: impl Into<types::Time>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "allow_events",
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xproto::AllowEventsRequest {
            mode,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn allow_events_checked(
        &mut self,
        mode: types::Allow,
        time: impl Into<types::Time>,
    ) -> Result<()> {
        let cookie = self.allow_events(mode, time)?;
        self.wait_for_reply(cookie)
    }
    fn grab_server(&mut self) -> Result<Cookie<()>> {
        let span = tracing::info_span!("grab_server",);
        let _enter = span.enter();
        let request = types::xproto::GrabServerRequest {};
        self.send_void_request(request)
    }
    fn grab_server_checked(&mut self) -> Result<()> {
        let cookie = self.grab_server()?;
        self.wait_for_reply(cookie)
    }
    fn ungrab_server(&mut self) -> Result<Cookie<()>> {
        let span = tracing::info_span!("ungrab_server",);
        let _enter = span.enter();
        let request = types::xproto::UngrabServerRequest {};
        self.send_void_request(request)
    }
    fn ungrab_server_checked(&mut self) -> Result<()> {
        let cookie = self.ungrab_server()?;
        self.wait_for_reply(cookie)
    }
    fn query_pointer(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xproto::QueryPointerReply>> {
        let span = tracing::info_span!(
            "query_pointer",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryPointerRequest { window };
        self.send_reply_request(request)
    }
    fn query_pointer_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xproto::QueryPointerReply> {
        let cookie = self.query_pointer(window)?;
        self.wait_for_reply(cookie)
    }
    fn get_motion_events(
        &mut self,
        window: types::xproto::Window,
        start: impl Into<types::Time>,
        stop: impl Into<types::Time>,
    ) -> Result<Cookie<types::xproto::GetMotionEventsReply>> {
        let span = tracing::info_span!(
            "get_motion_events",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::GetMotionEventsRequest {
            window,
            start: Into::<u32>::into(start.into()) as _,
            stop: Into::<u32>::into(stop.into()) as _,
        };
        self.send_reply_request(request)
    }
    fn get_motion_events_immediate(
        &mut self,
        window: types::xproto::Window,
        start: impl Into<types::Time>,
        stop: impl Into<types::Time>,
    ) -> Result<types::xproto::GetMotionEventsReply> {
        let cookie = self.get_motion_events(window, start, stop)?;
        self.wait_for_reply(cookie)
    }
    fn translate_coordinates(
        &mut self,
        src_window: types::xproto::Window,
        dst_window: types::xproto::Window,
        src_x: types::Int16,
        src_y: types::Int16,
    ) -> Result<Cookie<types::xproto::TranslateCoordinatesReply>> {
        let span = tracing::info_span!(
            "translate_coordinates",
            src_window = ?src_window,
            dst_window = ?dst_window,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let _enter = span.enter();
        let request = types::xproto::TranslateCoordinatesRequest {
            src_window,
            dst_window,
            src_x,
            src_y,
        };
        self.send_reply_request(request)
    }
    fn translate_coordinates_immediate(
        &mut self,
        src_window: types::xproto::Window,
        dst_window: types::xproto::Window,
        src_x: types::Int16,
        src_y: types::Int16,
    ) -> Result<types::xproto::TranslateCoordinatesReply> {
        let cookie = self.translate_coordinates(src_window, dst_window, src_x, src_y)?;
        self.wait_for_reply(cookie)
    }
    fn warp_pointer(
        &mut self,
        src_window: impl Into<types::xproto::Window>,
        dst_window: impl Into<types::xproto::Window>,
        src_x: types::Int16,
        src_y: types::Int16,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "warp_pointer",
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
        );
        let _enter = span.enter();
        let request = types::xproto::WarpPointerRequest {
            src_window: Into::<u32>::into(src_window.into()) as _,
            dst_window: Into::<u32>::into(dst_window.into()) as _,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
        };
        self.send_void_request(request)
    }
    fn warp_pointer_checked(
        &mut self,
        src_window: impl Into<types::xproto::Window>,
        dst_window: impl Into<types::xproto::Window>,
        src_x: types::Int16,
        src_y: types::Int16,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
    ) -> Result<()> {
        let cookie = self.warp_pointer(
            src_window, dst_window, src_x, src_y, src_width, src_height, dst_x, dst_y,
        )?;
        self.wait_for_reply(cookie)
    }
    fn set_input_focus(
        &mut self,
        revert_to: types::InputFocus,
        focus: impl Into<types::InputFocus>,
        time: impl Into<types::Time>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_input_focus",
            revert_to = ?revert_to,
        );
        let _enter = span.enter();
        let request = types::xproto::SetInputFocusRequest {
            revert_to,
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    fn set_input_focus_checked(
        &mut self,
        revert_to: types::InputFocus,
        focus: impl Into<types::InputFocus>,
        time: impl Into<types::Time>,
    ) -> Result<()> {
        let cookie = self.set_input_focus(revert_to, focus, time)?;
        self.wait_for_reply(cookie)
    }
    fn get_input_focus(&mut self) -> Result<Cookie<types::xproto::GetInputFocusReply>> {
        let span = tracing::info_span!("get_input_focus",);
        let _enter = span.enter();
        let request = types::xproto::GetInputFocusRequest {};
        self.send_reply_request(request)
    }
    fn get_input_focus_immediate(&mut self) -> Result<types::xproto::GetInputFocusReply> {
        let cookie = self.get_input_focus()?;
        self.wait_for_reply(cookie)
    }
    fn query_keymap(&mut self) -> Result<Cookie<types::xproto::QueryKeymapReply>> {
        let span = tracing::info_span!("query_keymap",);
        let _enter = span.enter();
        let request = types::xproto::QueryKeymapRequest {};
        self.send_reply_request(request)
    }
    fn query_keymap_immediate(&mut self) -> Result<types::xproto::QueryKeymapReply> {
        let cookie = self.query_keymap()?;
        self.wait_for_reply(cookie)
    }
    fn open_font(
        &mut self,
        fid: types::Font,
        name: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "open_font",
            fid = ?fid,
        );
        let _enter = span.enter();
        let request = types::xproto::OpenFontRequest {
            fid,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request)
    }
    fn open_font_checked(
        &mut self,
        fid: types::Font,
        name: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.open_font(fid, name)?;
        self.wait_for_reply(cookie)
    }
    fn close_font(&mut self, font: types::Font) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "close_font",
            font = ?font,
        );
        let _enter = span.enter();
        let request = types::xproto::CloseFontRequest { font };
        self.send_void_request(request)
    }
    fn close_font_checked(&mut self, font: types::Font) -> Result<()> {
        let cookie = self.close_font(font)?;
        self.wait_for_reply(cookie)
    }
    fn query_font(
        &mut self,
        font: types::Fontable,
    ) -> Result<Cookie<types::xproto::QueryFontReply>> {
        let span = tracing::info_span!(
            "query_font",
            font = ?font,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryFontRequest { font };
        self.send_reply_request(request)
    }
    fn query_font_immediate(
        &mut self,
        font: types::Fontable,
    ) -> Result<types::xproto::QueryFontReply> {
        let cookie = self.query_font(font)?;
        self.wait_for_reply(cookie)
    }
    fn query_text_extents(
        &mut self,
        font: types::Fontable,
        string: impl AsRef<[types::Char2b]>,
    ) -> Result<Cookie<types::xproto::QueryTextExtentsReply>> {
        let span = tracing::info_span!(
            "query_text_extents",
            font = ?font,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryTextExtentsRequest {
            font,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn query_text_extents_immediate(
        &mut self,
        font: types::Fontable,
        string: impl AsRef<[types::Char2b]>,
    ) -> Result<types::xproto::QueryTextExtentsReply> {
        let cookie = self.query_text_extents(font, string)?;
        self.wait_for_reply(cookie)
    }
    fn list_fonts(
        &mut self,
        max_names: types::Card16,
        pattern: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<types::xproto::ListFontsReply>> {
        let span = tracing::info_span!(
            "list_fonts",
            max_names = ?max_names,
        );
        let _enter = span.enter();
        let request = types::xproto::ListFontsRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn list_fonts_immediate(
        &mut self,
        max_names: types::Card16,
        pattern: impl AsRef<[types::Char]>,
    ) -> Result<types::xproto::ListFontsReply> {
        let cookie = self.list_fonts(max_names, pattern)?;
        self.wait_for_reply(cookie)
    }
    fn list_fonts_with_info(
        &mut self,
        max_names: types::Card16,
        pattern: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<types::xproto::ListFontsWithInfoReply>> {
        let span = tracing::info_span!(
            "list_fonts_with_info",
            max_names = ?max_names,
        );
        let _enter = span.enter();
        let request = types::xproto::ListFontsWithInfoRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn list_fonts_with_info_immediate(
        &mut self,
        max_names: types::Card16,
        pattern: impl AsRef<[types::Char]>,
    ) -> Result<types::xproto::ListFontsWithInfoReply> {
        let cookie = self.list_fonts_with_info(max_names, pattern)?;
        self.wait_for_reply(cookie)
    }
    fn set_font_path(&mut self, font: impl AsRef<[types::Str]>) -> Result<Cookie<()>> {
        let span = tracing::info_span!("set_font_path",);
        let _enter = span.enter();
        let request = types::xproto::SetFontPathRequest {
            font: Cow::Borrowed(font.as_ref()),
        };
        self.send_void_request(request)
    }
    fn set_font_path_checked(&mut self, font: impl AsRef<[types::Str]>) -> Result<()> {
        let cookie = self.set_font_path(font)?;
        self.wait_for_reply(cookie)
    }
    fn get_font_path(&mut self) -> Result<Cookie<types::xproto::GetFontPathReply>> {
        let span = tracing::info_span!("get_font_path",);
        let _enter = span.enter();
        let request = types::xproto::GetFontPathRequest {};
        self.send_reply_request(request)
    }
    fn get_font_path_immediate(&mut self) -> Result<types::xproto::GetFontPathReply> {
        let cookie = self.get_font_path()?;
        self.wait_for_reply(cookie)
    }
    fn create_pixmap(
        &mut self,
        depth: types::Card8,
        pid: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_pixmap",
            depth = ?depth,
            pid = ?pid,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xproto::CreatePixmapRequest {
            depth,
            pid,
            drawable,
            width,
            height,
        };
        self.send_void_request(request)
    }
    fn create_pixmap_checked(
        &mut self,
        depth: types::Card8,
        pid: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<()> {
        let cookie = self.create_pixmap(depth, pid, drawable, width, height)?;
        self.wait_for_reply(cookie)
    }
    fn free_pixmap(&mut self, pixmap: types::xproto::Pixmap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "free_pixmap",
            pixmap = ?pixmap,
        );
        let _enter = span.enter();
        let request = types::xproto::FreePixmapRequest { pixmap };
        self.send_void_request(request)
    }
    fn free_pixmap_checked(&mut self, pixmap: types::xproto::Pixmap) -> Result<()> {
        let cookie = self.free_pixmap(pixmap)?;
        self.wait_for_reply(cookie)
    }
    fn create_gc(
        &mut self,
        cid: types::Gcontext,
        drawable: types::xproto::Drawable,
        value_list: impl Borrow<types::xproto::CreateGCAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_gc",
            cid = ?cid,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xproto::CreateGCRequest {
            cid,
            drawable,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn create_gc_checked(
        &mut self,
        cid: types::Gcontext,
        drawable: types::xproto::Drawable,
        value_list: impl Borrow<types::xproto::CreateGCAux>,
    ) -> Result<()> {
        let cookie = self.create_gc(cid, drawable, value_list)?;
        self.wait_for_reply(cookie)
    }
    fn change_gc(
        &mut self,
        gc: types::Gcontext,
        value_list: impl Borrow<types::xproto::ChangeGCAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_gc",
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeGCRequest {
            gc,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn change_gc_checked(
        &mut self,
        gc: types::Gcontext,
        value_list: impl Borrow<types::xproto::ChangeGCAux>,
    ) -> Result<()> {
        let cookie = self.change_gc(gc, value_list)?;
        self.wait_for_reply(cookie)
    }
    fn copy_gc(
        &mut self,
        src_gc: types::Gcontext,
        dst_gc: types::Gcontext,
        value_mask: impl Into<types::xproto::GC>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "copy_gc",
            src_gc = ?src_gc,
            dst_gc = ?dst_gc,
        );
        let _enter = span.enter();
        let request = types::xproto::CopyGCRequest {
            src_gc,
            dst_gc,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
        };
        self.send_void_request(request)
    }
    fn copy_gc_checked(
        &mut self,
        src_gc: types::Gcontext,
        dst_gc: types::Gcontext,
        value_mask: impl Into<types::xproto::GC>,
    ) -> Result<()> {
        let cookie = self.copy_gc(src_gc, dst_gc, value_mask)?;
        self.wait_for_reply(cookie)
    }
    fn set_dashes(
        &mut self,
        gc: types::Gcontext,
        dash_offset: types::Card16,
        dashes: impl AsRef<[types::Card8]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_dashes",
            gc = ?gc,
            dash_offset = ?dash_offset,
        );
        let _enter = span.enter();
        let request = types::xproto::SetDashesRequest {
            gc,
            dash_offset,
            dashes: Cow::Borrowed(dashes.as_ref()),
        };
        self.send_void_request(request)
    }
    fn set_dashes_checked(
        &mut self,
        gc: types::Gcontext,
        dash_offset: types::Card16,
        dashes: impl AsRef<[types::Card8]>,
    ) -> Result<()> {
        let cookie = self.set_dashes(gc, dash_offset, dashes)?;
        self.wait_for_reply(cookie)
    }
    fn set_clip_rectangles(
        &mut self,
        ordering: types::ClipOrdering,
        gc: types::Gcontext,
        clip_x_origin: types::Int16,
        clip_y_origin: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_clip_rectangles",
            ordering = ?ordering,
            gc = ?gc,
            clip_x_origin = ?clip_x_origin,
            clip_y_origin = ?clip_y_origin,
        );
        let _enter = span.enter();
        let request = types::xproto::SetClipRectanglesRequest {
            ordering,
            gc,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    fn set_clip_rectangles_checked(
        &mut self,
        ordering: types::ClipOrdering,
        gc: types::Gcontext,
        clip_x_origin: types::Int16,
        clip_y_origin: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<()> {
        let cookie =
            self.set_clip_rectangles(ordering, gc, clip_x_origin, clip_y_origin, rectangles)?;
        self.wait_for_reply(cookie)
    }
    fn free_gc(&mut self, gc: types::Gcontext) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "free_gc",
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::FreeGCRequest { gc };
        self.send_void_request(request)
    }
    fn free_gc_checked(&mut self, gc: types::Gcontext) -> Result<()> {
        let cookie = self.free_gc(gc)?;
        self.wait_for_reply(cookie)
    }
    fn clear_area(
        &mut self,
        exposures: types::Bool,
        window: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "clear_area",
            exposures = ?exposures,
            window = ?window,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xproto::ClearAreaRequest {
            exposures,
            window,
            x,
            y,
            width,
            height,
        };
        self.send_void_request(request)
    }
    fn clear_area_checked(
        &mut self,
        exposures: types::Bool,
        window: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<()> {
        let cookie = self.clear_area(exposures, window, x, y, width, height)?;
        self.wait_for_reply(cookie)
    }
    fn copy_area(
        &mut self,
        src_drawable: types::xproto::Drawable,
        dst_drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        src_x: types::Int16,
        src_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "copy_area",
            src_drawable = ?src_drawable,
            dst_drawable = ?dst_drawable,
            gc = ?gc,
            src_x = ?src_x,
            src_y = ?src_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xproto::CopyAreaRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        self.send_void_request(request)
    }
    fn copy_area_checked(
        &mut self,
        src_drawable: types::xproto::Drawable,
        dst_drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        src_x: types::Int16,
        src_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<()> {
        let cookie = self.copy_area(
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
        )?;
        self.wait_for_reply(cookie)
    }
    fn copy_plane(
        &mut self,
        src_drawable: types::xproto::Drawable,
        dst_drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        src_x: types::Int16,
        src_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        bit_plane: types::Card32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "copy_plane",
            src_drawable = ?src_drawable,
            dst_drawable = ?dst_drawable,
            gc = ?gc,
            src_x = ?src_x,
            src_y = ?src_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
            bit_plane = ?bit_plane,
        );
        let _enter = span.enter();
        let request = types::xproto::CopyPlaneRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
            bit_plane,
        };
        self.send_void_request(request)
    }
    fn copy_plane_checked(
        &mut self,
        src_drawable: types::xproto::Drawable,
        dst_drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        src_x: types::Int16,
        src_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        bit_plane: types::Card32,
    ) -> Result<()> {
        let cookie = self.copy_plane(
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
            bit_plane,
        )?;
        self.wait_for_reply(cookie)
    }
    fn poly_point(
        &mut self,
        coordinate_mode: types::CoordMode,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        points: impl AsRef<[types::Point]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_point",
            coordinate_mode = ?coordinate_mode,
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyPointRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_point_checked(
        &mut self,
        coordinate_mode: types::CoordMode,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        points: impl AsRef<[types::Point]>,
    ) -> Result<()> {
        let cookie = self.poly_point(coordinate_mode, drawable, gc, points)?;
        self.wait_for_reply(cookie)
    }
    fn poly_line(
        &mut self,
        coordinate_mode: types::CoordMode,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        points: impl AsRef<[types::Point]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_line",
            coordinate_mode = ?coordinate_mode,
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyLineRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_line_checked(
        &mut self,
        coordinate_mode: types::CoordMode,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        points: impl AsRef<[types::Point]>,
    ) -> Result<()> {
        let cookie = self.poly_line(coordinate_mode, drawable, gc, points)?;
        self.wait_for_reply(cookie)
    }
    fn poly_segment(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        segments: impl AsRef<[types::Segment]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_segment",
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolySegmentRequest {
            drawable,
            gc,
            segments: Cow::Borrowed(segments.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_segment_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        segments: impl AsRef<[types::Segment]>,
    ) -> Result<()> {
        let cookie = self.poly_segment(drawable, gc, segments)?;
        self.wait_for_reply(cookie)
    }
    fn poly_rectangle(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_rectangle",
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_rectangle_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<()> {
        let cookie = self.poly_rectangle(drawable, gc, rectangles)?;
        self.wait_for_reply(cookie)
    }
    fn poly_arc(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        arcs: impl AsRef<[types::Arc]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_arc",
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_arc_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        arcs: impl AsRef<[types::Arc]>,
    ) -> Result<()> {
        let cookie = self.poly_arc(drawable, gc, arcs)?;
        self.wait_for_reply(cookie)
    }
    fn fill_poly(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        shape: types::PolyShape,
        coordinate_mode: types::CoordMode,
        points: impl AsRef<[types::Point]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "fill_poly",
            drawable = ?drawable,
            gc = ?gc,
            shape = ?shape,
            coordinate_mode = ?coordinate_mode,
        );
        let _enter = span.enter();
        let request = types::xproto::FillPolyRequest {
            drawable,
            gc,
            shape,
            coordinate_mode,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request)
    }
    fn fill_poly_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        shape: types::PolyShape,
        coordinate_mode: types::CoordMode,
        points: impl AsRef<[types::Point]>,
    ) -> Result<()> {
        let cookie = self.fill_poly(drawable, gc, shape, coordinate_mode, points)?;
        self.wait_for_reply(cookie)
    }
    fn poly_fill_rectangle(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_fill_rectangle",
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyFillRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_fill_rectangle_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Result<()> {
        let cookie = self.poly_fill_rectangle(drawable, gc, rectangles)?;
        self.wait_for_reply(cookie)
    }
    fn poly_fill_arc(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        arcs: impl AsRef<[types::Arc]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_fill_arc",
            drawable = ?drawable,
            gc = ?gc,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyFillArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_fill_arc_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        arcs: impl AsRef<[types::Arc]>,
    ) -> Result<()> {
        let cookie = self.poly_fill_arc(drawable, gc, arcs)?;
        self.wait_for_reply(cookie)
    }
    fn put_image(
        &mut self,
        format: types::ImageFormat,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        width: types::Card16,
        height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        left_pad: types::Card8,
        depth: types::Card8,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "put_image",
            format = ?format,
            drawable = ?drawable,
            gc = ?gc,
            width = ?width,
            height = ?height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            left_pad = ?left_pad,
            depth = ?depth,
        );
        let _enter = span.enter();
        let request = types::xproto::PutImageRequest {
            format,
            drawable,
            gc,
            width,
            height,
            dst_x,
            dst_y,
            left_pad,
            depth,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    fn put_image_checked(
        &mut self,
        format: types::ImageFormat,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        width: types::Card16,
        height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        left_pad: types::Card8,
        depth: types::Card8,
        data: impl AsRef<[types::Byte]>,
    ) -> Result<()> {
        let cookie = self.put_image(
            format, drawable, gc, width, height, dst_x, dst_y, left_pad, depth, data,
        )?;
        self.wait_for_reply(cookie)
    }
    fn get_image(
        &mut self,
        format: types::ImageFormat,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        plane_mask: types::Card32,
    ) -> Result<Cookie<types::xproto::GetImageReply>> {
        let span = tracing::info_span!(
            "get_image",
            format = ?format,
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            plane_mask = ?plane_mask,
        );
        let _enter = span.enter();
        let request = types::xproto::GetImageRequest {
            format,
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
        };
        self.send_reply_request(request)
    }
    fn get_image_immediate(
        &mut self,
        format: types::ImageFormat,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        plane_mask: types::Card32,
    ) -> Result<types::xproto::GetImageReply> {
        let cookie = self.get_image(format, drawable, x, y, width, height, plane_mask)?;
        self.wait_for_reply(cookie)
    }
    fn poly_text8(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        items: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_text8",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyText8Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_text8_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        items: impl AsRef<[types::Byte]>,
    ) -> Result<()> {
        let cookie = self.poly_text8(drawable, gc, x, y, items)?;
        self.wait_for_reply(cookie)
    }
    fn poly_text16(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        items: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "poly_text16",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::PolyText16Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        self.send_void_request(request)
    }
    fn poly_text16_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        items: impl AsRef<[types::Byte]>,
    ) -> Result<()> {
        let cookie = self.poly_text16(drawable, gc, x, y, items)?;
        self.wait_for_reply(cookie)
    }
    fn image_text8(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        string: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "image_text8",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::ImageText8Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_void_request(request)
    }
    fn image_text8_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        string: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.image_text8(drawable, gc, x, y, string)?;
        self.wait_for_reply(cookie)
    }
    fn image_text16(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        string: impl AsRef<[types::Char2b]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "image_text16",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::ImageText16Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_void_request(request)
    }
    fn image_text16_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        string: impl AsRef<[types::Char2b]>,
    ) -> Result<()> {
        let cookie = self.image_text16(drawable, gc, x, y, string)?;
        self.wait_for_reply(cookie)
    }
    fn create_colormap(
        &mut self,
        alloc: types::ColormapAlloc,
        mid: types::Colormap,
        window: types::xproto::Window,
        visual: types::Visualid,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_colormap",
            alloc = ?alloc,
            mid = ?mid,
            window = ?window,
            visual = ?visual,
        );
        let _enter = span.enter();
        let request = types::xproto::CreateColormapRequest {
            alloc,
            mid,
            window,
            visual,
        };
        self.send_void_request(request)
    }
    fn create_colormap_checked(
        &mut self,
        alloc: types::ColormapAlloc,
        mid: types::Colormap,
        window: types::xproto::Window,
        visual: types::Visualid,
    ) -> Result<()> {
        let cookie = self.create_colormap(alloc, mid, window, visual)?;
        self.wait_for_reply(cookie)
    }
    fn free_colormap(&mut self, cmap: types::Colormap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "free_colormap",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::FreeColormapRequest { cmap };
        self.send_void_request(request)
    }
    fn free_colormap_checked(&mut self, cmap: types::Colormap) -> Result<()> {
        let cookie = self.free_colormap(cmap)?;
        self.wait_for_reply(cookie)
    }
    fn copy_colormap_and_free(
        &mut self,
        mid: types::Colormap,
        src_cmap: types::Colormap,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "copy_colormap_and_free",
            mid = ?mid,
            src_cmap = ?src_cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::CopyColormapAndFreeRequest { mid, src_cmap };
        self.send_void_request(request)
    }
    fn copy_colormap_and_free_checked(
        &mut self,
        mid: types::Colormap,
        src_cmap: types::Colormap,
    ) -> Result<()> {
        let cookie = self.copy_colormap_and_free(mid, src_cmap)?;
        self.wait_for_reply(cookie)
    }
    fn install_colormap(&mut self, cmap: types::Colormap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "install_colormap",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::InstallColormapRequest { cmap };
        self.send_void_request(request)
    }
    fn install_colormap_checked(&mut self, cmap: types::Colormap) -> Result<()> {
        let cookie = self.install_colormap(cmap)?;
        self.wait_for_reply(cookie)
    }
    fn uninstall_colormap(&mut self, cmap: types::Colormap) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "uninstall_colormap",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::UninstallColormapRequest { cmap };
        self.send_void_request(request)
    }
    fn uninstall_colormap_checked(&mut self, cmap: types::Colormap) -> Result<()> {
        let cookie = self.uninstall_colormap(cmap)?;
        self.wait_for_reply(cookie)
    }
    fn list_installed_colormaps(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xproto::ListInstalledColormapsReply>> {
        let span = tracing::info_span!(
            "list_installed_colormaps",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xproto::ListInstalledColormapsRequest { window };
        self.send_reply_request(request)
    }
    fn list_installed_colormaps_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xproto::ListInstalledColormapsReply> {
        let cookie = self.list_installed_colormaps(window)?;
        self.wait_for_reply(cookie)
    }
    fn alloc_color(
        &mut self,
        cmap: types::Colormap,
        red: types::Card16,
        green: types::Card16,
        blue: types::Card16,
    ) -> Result<Cookie<types::xproto::AllocColorReply>> {
        let span = tracing::info_span!(
            "alloc_color",
            cmap = ?cmap,
            red = ?red,
            green = ?green,
            blue = ?blue,
        );
        let _enter = span.enter();
        let request = types::xproto::AllocColorRequest {
            cmap,
            red,
            green,
            blue,
        };
        self.send_reply_request(request)
    }
    fn alloc_color_immediate(
        &mut self,
        cmap: types::Colormap,
        red: types::Card16,
        green: types::Card16,
        blue: types::Card16,
    ) -> Result<types::xproto::AllocColorReply> {
        let cookie = self.alloc_color(cmap, red, green, blue)?;
        self.wait_for_reply(cookie)
    }
    fn alloc_named_color(
        &mut self,
        cmap: types::Colormap,
        name: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<types::xproto::AllocNamedColorReply>> {
        let span = tracing::info_span!(
            "alloc_named_color",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::AllocNamedColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn alloc_named_color_immediate(
        &mut self,
        cmap: types::Colormap,
        name: impl AsRef<[types::Char]>,
    ) -> Result<types::xproto::AllocNamedColorReply> {
        let cookie = self.alloc_named_color(cmap, name)?;
        self.wait_for_reply(cookie)
    }
    fn alloc_color_cells(
        &mut self,
        contiguous: types::Bool,
        cmap: types::Colormap,
        colors: types::Card16,
        planes: types::Card16,
    ) -> Result<Cookie<types::xproto::AllocColorCellsReply>> {
        let span = tracing::info_span!(
            "alloc_color_cells",
            contiguous = ?contiguous,
            cmap = ?cmap,
            colors = ?colors,
            planes = ?planes,
        );
        let _enter = span.enter();
        let request = types::xproto::AllocColorCellsRequest {
            contiguous,
            cmap,
            colors,
            planes,
        };
        self.send_reply_request(request)
    }
    fn alloc_color_cells_immediate(
        &mut self,
        contiguous: types::Bool,
        cmap: types::Colormap,
        colors: types::Card16,
        planes: types::Card16,
    ) -> Result<types::xproto::AllocColorCellsReply> {
        let cookie = self.alloc_color_cells(contiguous, cmap, colors, planes)?;
        self.wait_for_reply(cookie)
    }
    fn alloc_color_planes(
        &mut self,
        contiguous: types::Bool,
        cmap: types::Colormap,
        colors: types::Card16,
        reds: types::Card16,
        greens: types::Card16,
        blues: types::Card16,
    ) -> Result<Cookie<types::xproto::AllocColorPlanesReply>> {
        let span = tracing::info_span!(
            "alloc_color_planes",
            contiguous = ?contiguous,
            cmap = ?cmap,
            colors = ?colors,
            reds = ?reds,
            greens = ?greens,
            blues = ?blues,
        );
        let _enter = span.enter();
        let request = types::xproto::AllocColorPlanesRequest {
            contiguous,
            cmap,
            colors,
            reds,
            greens,
            blues,
        };
        self.send_reply_request(request)
    }
    fn alloc_color_planes_immediate(
        &mut self,
        contiguous: types::Bool,
        cmap: types::Colormap,
        colors: types::Card16,
        reds: types::Card16,
        greens: types::Card16,
        blues: types::Card16,
    ) -> Result<types::xproto::AllocColorPlanesReply> {
        let cookie = self.alloc_color_planes(contiguous, cmap, colors, reds, greens, blues)?;
        self.wait_for_reply(cookie)
    }
    fn free_colors(
        &mut self,
        cmap: types::Colormap,
        plane_mask: types::Card32,
        pixels: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "free_colors",
            cmap = ?cmap,
            plane_mask = ?plane_mask,
        );
        let _enter = span.enter();
        let request = types::xproto::FreeColorsRequest {
            cmap,
            plane_mask,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        self.send_void_request(request)
    }
    fn free_colors_checked(
        &mut self,
        cmap: types::Colormap,
        plane_mask: types::Card32,
        pixels: impl AsRef<[types::Card32]>,
    ) -> Result<()> {
        let cookie = self.free_colors(cmap, plane_mask, pixels)?;
        self.wait_for_reply(cookie)
    }
    fn store_colors(
        &mut self,
        cmap: types::Colormap,
        items: impl AsRef<[types::Coloritem]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "store_colors",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::StoreColorsRequest {
            cmap,
            items: Cow::Borrowed(items.as_ref()),
        };
        self.send_void_request(request)
    }
    fn store_colors_checked(
        &mut self,
        cmap: types::Colormap,
        items: impl AsRef<[types::Coloritem]>,
    ) -> Result<()> {
        let cookie = self.store_colors(cmap, items)?;
        self.wait_for_reply(cookie)
    }
    fn store_named_color(
        &mut self,
        flags: impl Into<types::ColorFlag>,
        cmap: types::Colormap,
        pixel: types::Card32,
        name: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "store_named_color",
            cmap = ?cmap,
            pixel = ?pixel,
        );
        let _enter = span.enter();
        let request = types::xproto::StoreNamedColorRequest {
            flags: Into::<u32>::into(flags.into()) as _,
            cmap,
            pixel,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request)
    }
    fn store_named_color_checked(
        &mut self,
        flags: impl Into<types::ColorFlag>,
        cmap: types::Colormap,
        pixel: types::Card32,
        name: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.store_named_color(flags, cmap, pixel, name)?;
        self.wait_for_reply(cookie)
    }
    fn query_colors(
        &mut self,
        cmap: types::Colormap,
        pixels: impl AsRef<[types::Card32]>,
    ) -> Result<Cookie<types::xproto::QueryColorsReply>> {
        let span = tracing::info_span!(
            "query_colors",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryColorsRequest {
            cmap,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn query_colors_immediate(
        &mut self,
        cmap: types::Colormap,
        pixels: impl AsRef<[types::Card32]>,
    ) -> Result<types::xproto::QueryColorsReply> {
        let cookie = self.query_colors(cmap, pixels)?;
        self.wait_for_reply(cookie)
    }
    fn lookup_color(
        &mut self,
        cmap: types::Colormap,
        name: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<types::xproto::LookupColorReply>> {
        let span = tracing::info_span!(
            "lookup_color",
            cmap = ?cmap,
        );
        let _enter = span.enter();
        let request = types::xproto::LookupColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn lookup_color_immediate(
        &mut self,
        cmap: types::Colormap,
        name: impl AsRef<[types::Char]>,
    ) -> Result<types::xproto::LookupColorReply> {
        let cookie = self.lookup_color(cmap, name)?;
        self.wait_for_reply(cookie)
    }
    fn create_cursor(
        &mut self,
        cid: types::xproto::Cursor,
        source: types::xproto::Pixmap,
        mask: impl Into<types::xproto::Pixmap>,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
        x: types::Card16,
        y: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_cursor",
            cid = ?cid,
            source = ?source,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
            x = ?x,
            y = ?y,
        );
        let _enter = span.enter();
        let request = types::xproto::CreateCursorRequest {
            cid,
            source,
            mask: Into::<u32>::into(mask.into()) as _,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
            x,
            y,
        };
        self.send_void_request(request)
    }
    fn create_cursor_checked(
        &mut self,
        cid: types::xproto::Cursor,
        source: types::xproto::Pixmap,
        mask: impl Into<types::xproto::Pixmap>,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
        x: types::Card16,
        y: types::Card16,
    ) -> Result<()> {
        let cookie = self.create_cursor(
            cid, source, mask, fore_red, fore_green, fore_blue, back_red, back_green, back_blue, x,
            y,
        )?;
        self.wait_for_reply(cookie)
    }
    fn create_glyph_cursor(
        &mut self,
        cid: types::xproto::Cursor,
        source_font: types::Font,
        mask_font: impl Into<types::Font>,
        source_char: types::Card16,
        mask_char: types::Card16,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "create_glyph_cursor",
            cid = ?cid,
            source_font = ?source_font,
            source_char = ?source_char,
            mask_char = ?mask_char,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
        );
        let _enter = span.enter();
        let request = types::xproto::CreateGlyphCursorRequest {
            cid,
            source_font,
            mask_font: Into::<u32>::into(mask_font.into()) as _,
            source_char,
            mask_char,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        self.send_void_request(request)
    }
    fn create_glyph_cursor_checked(
        &mut self,
        cid: types::xproto::Cursor,
        source_font: types::Font,
        mask_font: impl Into<types::Font>,
        source_char: types::Card16,
        mask_char: types::Card16,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
    ) -> Result<()> {
        let cookie = self.create_glyph_cursor(
            cid,
            source_font,
            mask_font,
            source_char,
            mask_char,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        )?;
        self.wait_for_reply(cookie)
    }
    fn free_cursor(&mut self, cursor: types::xproto::Cursor) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "free_cursor",
            cursor = ?cursor,
        );
        let _enter = span.enter();
        let request = types::xproto::FreeCursorRequest { cursor };
        self.send_void_request(request)
    }
    fn free_cursor_checked(&mut self, cursor: types::xproto::Cursor) -> Result<()> {
        let cookie = self.free_cursor(cursor)?;
        self.wait_for_reply(cookie)
    }
    fn recolor_cursor(
        &mut self,
        cursor: types::xproto::Cursor,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "recolor_cursor",
            cursor = ?cursor,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
        );
        let _enter = span.enter();
        let request = types::xproto::RecolorCursorRequest {
            cursor,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        self.send_void_request(request)
    }
    fn recolor_cursor_checked(
        &mut self,
        cursor: types::xproto::Cursor,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
    ) -> Result<()> {
        let cookie = self.recolor_cursor(
            cursor, fore_red, fore_green, fore_blue, back_red, back_green, back_blue,
        )?;
        self.wait_for_reply(cookie)
    }
    fn query_best_size(
        &mut self,
        class: types::QueryShapeOf,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<Cookie<types::xproto::QueryBestSizeReply>> {
        let span = tracing::info_span!(
            "query_best_size",
            class = ?class,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xproto::QueryBestSizeRequest {
            class,
            drawable,
            width,
            height,
        };
        self.send_reply_request(request)
    }
    fn query_best_size_immediate(
        &mut self,
        class: types::QueryShapeOf,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<types::xproto::QueryBestSizeReply> {
        let cookie = self.query_best_size(class, drawable, width, height)?;
        self.wait_for_reply(cookie)
    }
    fn query_extension(
        &mut self,
        name: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<types::xproto::QueryExtensionReply>> {
        let span = tracing::info_span!("query_extension",);
        let _enter = span.enter();
        let request = types::xproto::QueryExtensionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn query_extension_immediate(
        &mut self,
        name: impl AsRef<[types::Char]>,
    ) -> Result<types::xproto::QueryExtensionReply> {
        let cookie = self.query_extension(name)?;
        self.wait_for_reply(cookie)
    }
    fn list_extensions(&mut self) -> Result<Cookie<types::xproto::ListExtensionsReply>> {
        let span = tracing::info_span!("list_extensions",);
        let _enter = span.enter();
        let request = types::xproto::ListExtensionsRequest {};
        self.send_reply_request(request)
    }
    fn list_extensions_immediate(&mut self) -> Result<types::xproto::ListExtensionsReply> {
        let cookie = self.list_extensions()?;
        self.wait_for_reply(cookie)
    }
    fn change_keyboard_mapping(
        &mut self,
        keycode_count: types::Card8,
        first_keycode: types::Keycode,
        keysyms_per_keycode: types::Card8,
        keysyms: impl AsRef<[types::Keysym]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_keyboard_mapping",
            keycode_count = ?keycode_count,
            first_keycode = ?first_keycode,
            keysyms_per_keycode = ?keysyms_per_keycode,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeKeyboardMappingRequest {
            keycode_count,
            first_keycode,
            keysyms_per_keycode,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        self.send_void_request(request)
    }
    fn change_keyboard_mapping_checked(
        &mut self,
        keycode_count: types::Card8,
        first_keycode: types::Keycode,
        keysyms_per_keycode: types::Card8,
        keysyms: impl AsRef<[types::Keysym]>,
    ) -> Result<()> {
        let cookie = self.change_keyboard_mapping(
            keycode_count,
            first_keycode,
            keysyms_per_keycode,
            keysyms,
        )?;
        self.wait_for_reply(cookie)
    }
    fn get_keyboard_mapping(
        &mut self,
        first_keycode: types::Keycode,
        count: types::Card8,
    ) -> Result<Cookie<types::xproto::GetKeyboardMappingReply>> {
        let span = tracing::info_span!(
            "get_keyboard_mapping",
            first_keycode = ?first_keycode,
            count = ?count,
        );
        let _enter = span.enter();
        let request = types::xproto::GetKeyboardMappingRequest {
            first_keycode,
            count,
        };
        self.send_reply_request(request)
    }
    fn get_keyboard_mapping_immediate(
        &mut self,
        first_keycode: types::Keycode,
        count: types::Card8,
    ) -> Result<types::xproto::GetKeyboardMappingReply> {
        let cookie = self.get_keyboard_mapping(first_keycode, count)?;
        self.wait_for_reply(cookie)
    }
    fn change_keyboard_control(
        &mut self,
        value_list: impl Borrow<types::xproto::ChangeKeyboardControlAux>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!("change_keyboard_control",);
        let _enter = span.enter();
        let request = types::xproto::ChangeKeyboardControlRequest {
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request)
    }
    fn change_keyboard_control_checked(
        &mut self,
        value_list: impl Borrow<types::xproto::ChangeKeyboardControlAux>,
    ) -> Result<()> {
        let cookie = self.change_keyboard_control(value_list)?;
        self.wait_for_reply(cookie)
    }
    fn get_keyboard_control(&mut self) -> Result<Cookie<types::xproto::GetKeyboardControlReply>> {
        let span = tracing::info_span!("get_keyboard_control",);
        let _enter = span.enter();
        let request = types::xproto::GetKeyboardControlRequest {};
        self.send_reply_request(request)
    }
    fn get_keyboard_control_immediate(&mut self) -> Result<types::xproto::GetKeyboardControlReply> {
        let cookie = self.get_keyboard_control()?;
        self.wait_for_reply(cookie)
    }
    fn bell(&mut self, percent: types::Int8) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "bell",
            percent = ?percent,
        );
        let _enter = span.enter();
        let request = types::xproto::BellRequest { percent };
        self.send_void_request(request)
    }
    fn bell_checked(&mut self, percent: types::Int8) -> Result<()> {
        let cookie = self.bell(percent)?;
        self.wait_for_reply(cookie)
    }
    fn change_pointer_control(
        &mut self,
        acceleration_numerator: types::Int16,
        acceleration_denominator: types::Int16,
        threshold: types::Int16,
        do_acceleration: types::Bool,
        do_threshold: types::Bool,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_pointer_control",
            acceleration_numerator = ?acceleration_numerator,
            acceleration_denominator = ?acceleration_denominator,
            threshold = ?threshold,
            do_acceleration = ?do_acceleration,
            do_threshold = ?do_threshold,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangePointerControlRequest {
            acceleration_numerator,
            acceleration_denominator,
            threshold,
            do_acceleration,
            do_threshold,
        };
        self.send_void_request(request)
    }
    fn change_pointer_control_checked(
        &mut self,
        acceleration_numerator: types::Int16,
        acceleration_denominator: types::Int16,
        threshold: types::Int16,
        do_acceleration: types::Bool,
        do_threshold: types::Bool,
    ) -> Result<()> {
        let cookie = self.change_pointer_control(
            acceleration_numerator,
            acceleration_denominator,
            threshold,
            do_acceleration,
            do_threshold,
        )?;
        self.wait_for_reply(cookie)
    }
    fn get_pointer_control(&mut self) -> Result<Cookie<types::xproto::GetPointerControlReply>> {
        let span = tracing::info_span!("get_pointer_control",);
        let _enter = span.enter();
        let request = types::xproto::GetPointerControlRequest {};
        self.send_reply_request(request)
    }
    fn get_pointer_control_immediate(&mut self) -> Result<types::xproto::GetPointerControlReply> {
        let cookie = self.get_pointer_control()?;
        self.wait_for_reply(cookie)
    }
    fn set_screen_saver(
        &mut self,
        timeout: types::Int16,
        interval: types::Int16,
        prefer_blanking: types::Blanking,
        allow_exposures: types::Exposures,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_screen_saver",
            timeout = ?timeout,
            interval = ?interval,
            prefer_blanking = ?prefer_blanking,
            allow_exposures = ?allow_exposures,
        );
        let _enter = span.enter();
        let request = types::xproto::SetScreenSaverRequest {
            timeout,
            interval,
            prefer_blanking,
            allow_exposures,
        };
        self.send_void_request(request)
    }
    fn set_screen_saver_checked(
        &mut self,
        timeout: types::Int16,
        interval: types::Int16,
        prefer_blanking: types::Blanking,
        allow_exposures: types::Exposures,
    ) -> Result<()> {
        let cookie = self.set_screen_saver(timeout, interval, prefer_blanking, allow_exposures)?;
        self.wait_for_reply(cookie)
    }
    fn get_screen_saver(&mut self) -> Result<Cookie<types::xproto::GetScreenSaverReply>> {
        let span = tracing::info_span!("get_screen_saver",);
        let _enter = span.enter();
        let request = types::xproto::GetScreenSaverRequest {};
        self.send_reply_request(request)
    }
    fn get_screen_saver_immediate(&mut self) -> Result<types::xproto::GetScreenSaverReply> {
        let cookie = self.get_screen_saver()?;
        self.wait_for_reply(cookie)
    }
    fn change_hosts(
        &mut self,
        mode: types::HostMode,
        family: types::Family,
        address: impl AsRef<[types::Byte]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "change_hosts",
            mode = ?mode,
            family = ?family,
        );
        let _enter = span.enter();
        let request = types::xproto::ChangeHostsRequest {
            mode,
            family,
            address: Cow::Borrowed(address.as_ref()),
        };
        self.send_void_request(request)
    }
    fn change_hosts_checked(
        &mut self,
        mode: types::HostMode,
        family: types::Family,
        address: impl AsRef<[types::Byte]>,
    ) -> Result<()> {
        let cookie = self.change_hosts(mode, family, address)?;
        self.wait_for_reply(cookie)
    }
    fn list_hosts(&mut self) -> Result<Cookie<types::xproto::ListHostsReply>> {
        let span = tracing::info_span!("list_hosts",);
        let _enter = span.enter();
        let request = types::xproto::ListHostsRequest {};
        self.send_reply_request(request)
    }
    fn list_hosts_immediate(&mut self) -> Result<types::xproto::ListHostsReply> {
        let cookie = self.list_hosts()?;
        self.wait_for_reply(cookie)
    }
    fn set_access_control(&mut self, mode: types::AccessControl) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_access_control",
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xproto::SetAccessControlRequest { mode };
        self.send_void_request(request)
    }
    fn set_access_control_checked(&mut self, mode: types::AccessControl) -> Result<()> {
        let cookie = self.set_access_control(mode)?;
        self.wait_for_reply(cookie)
    }
    fn set_close_down_mode(&mut self, mode: types::CloseDown) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "set_close_down_mode",
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xproto::SetCloseDownModeRequest { mode };
        self.send_void_request(request)
    }
    fn set_close_down_mode_checked(&mut self, mode: types::CloseDown) -> Result<()> {
        let cookie = self.set_close_down_mode(mode)?;
        self.wait_for_reply(cookie)
    }
    fn kill_client(&mut self, resource: impl Into<types::Kill>) -> Result<Cookie<()>> {
        let span = tracing::info_span!("kill_client",);
        let _enter = span.enter();
        let request = types::xproto::KillClientRequest {
            resource: Into::<u32>::into(resource.into()) as _,
        };
        self.send_void_request(request)
    }
    fn kill_client_checked(&mut self, resource: impl Into<types::Kill>) -> Result<()> {
        let cookie = self.kill_client(resource)?;
        self.wait_for_reply(cookie)
    }
    fn rotate_properties(
        &mut self,
        window: types::xproto::Window,
        delta: types::Int16,
        atoms: impl AsRef<[types::Atom]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "rotate_properties",
            window = ?window,
            delta = ?delta,
        );
        let _enter = span.enter();
        let request = types::xproto::RotatePropertiesRequest {
            window,
            delta,
            atoms: Cow::Borrowed(atoms.as_ref()),
        };
        self.send_void_request(request)
    }
    fn rotate_properties_checked(
        &mut self,
        window: types::xproto::Window,
        delta: types::Int16,
        atoms: impl AsRef<[types::Atom]>,
    ) -> Result<()> {
        let cookie = self.rotate_properties(window, delta, atoms)?;
        self.wait_for_reply(cookie)
    }
    fn force_screen_saver(&mut self, mode: types::ScreenSaver) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "force_screen_saver",
            mode = ?mode,
        );
        let _enter = span.enter();
        let request = types::xproto::ForceScreenSaverRequest { mode };
        self.send_void_request(request)
    }
    fn force_screen_saver_checked(&mut self, mode: types::ScreenSaver) -> Result<()> {
        let cookie = self.force_screen_saver(mode)?;
        self.wait_for_reply(cookie)
    }
    fn set_pointer_mapping(
        &mut self,
        map: impl AsRef<[types::Card8]>,
    ) -> Result<Cookie<types::xproto::SetPointerMappingReply>> {
        let span = tracing::info_span!("set_pointer_mapping",);
        let _enter = span.enter();
        let request = types::xproto::SetPointerMappingRequest {
            map: Cow::Borrowed(map.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn set_pointer_mapping_immediate(
        &mut self,
        map: impl AsRef<[types::Card8]>,
    ) -> Result<types::xproto::SetPointerMappingReply> {
        let cookie = self.set_pointer_mapping(map)?;
        self.wait_for_reply(cookie)
    }
    fn get_pointer_mapping(&mut self) -> Result<Cookie<types::xproto::GetPointerMappingReply>> {
        let span = tracing::info_span!("get_pointer_mapping",);
        let _enter = span.enter();
        let request = types::xproto::GetPointerMappingRequest {};
        self.send_reply_request(request)
    }
    fn get_pointer_mapping_immediate(&mut self) -> Result<types::xproto::GetPointerMappingReply> {
        let cookie = self.get_pointer_mapping()?;
        self.wait_for_reply(cookie)
    }
    fn set_modifier_mapping(
        &mut self,
        keycodes: impl AsRef<[types::Keycode]>,
    ) -> Result<Cookie<types::xproto::SetModifierMappingReply>> {
        let span = tracing::info_span!("set_modifier_mapping",);
        let _enter = span.enter();
        let request = types::xproto::SetModifierMappingRequest {
            keycodes: Cow::Borrowed(keycodes.as_ref()),
        };
        self.send_reply_request(request)
    }
    fn set_modifier_mapping_immediate(
        &mut self,
        keycodes: impl AsRef<[types::Keycode]>,
    ) -> Result<types::xproto::SetModifierMappingReply> {
        let cookie = self.set_modifier_mapping(keycodes)?;
        self.wait_for_reply(cookie)
    }
    fn get_modifier_mapping(&mut self) -> Result<Cookie<types::xproto::GetModifierMappingReply>> {
        let span = tracing::info_span!("get_modifier_mapping",);
        let _enter = span.enter();
        let request = types::xproto::GetModifierMappingRequest {};
        self.send_reply_request(request)
    }
    fn get_modifier_mapping_immediate(&mut self) -> Result<types::xproto::GetModifierMappingReply> {
        let cookie = self.get_modifier_mapping()?;
        self.wait_for_reply(cookie)
    }
    fn no_operation(&mut self) -> Result<Cookie<()>> {
        let span = tracing::info_span!("no_operation",);
        let _enter = span.enter();
        let request = types::xproto::NoOperationRequest {};
        self.send_void_request(request)
    }
    fn no_operation_checked(&mut self) -> Result<()> {
        let cookie = self.no_operation()?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xselinux")]
    fn xselinux_query_version(
        &mut self,
        client_major: types::Card8,
        client_minor: types::Card8,
    ) -> Result<Cookie<types::xselinux::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xselinux_query_version",
            client_major = ?client_major,
            client_minor = ?client_minor,
        );
        let _enter = span.enter();
        let request = types::xselinux::QueryVersionRequest {
            client_major,
            client_minor,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_query_version_immediate(
        &mut self,
        client_major: types::Card8,
        client_minor: types::Card8,
    ) -> Result<types::xselinux::QueryVersionReply> {
        let cookie = self.xselinux_query_version(client_major, client_minor)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_create_context(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!("xselinux_set_device_create_context",);
        let _enter = span.enter();
        let request = types::xselinux::SetDeviceCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_create_context_checked(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.xselinux_set_device_create_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_create_context(
        &mut self,
    ) -> Result<Cookie<types::xselinux::GetDeviceCreateContextReply>> {
        let span = tracing::info_span!("xselinux_get_device_create_context",);
        let _enter = span.enter();
        let request = types::xselinux::GetDeviceCreateContextRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_create_context_immediate(
        &mut self,
    ) -> Result<types::xselinux::GetDeviceCreateContextReply> {
        let cookie = self.xselinux_get_device_create_context()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_context(
        &mut self,
        device: types::Card32,
        context: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xselinux_set_device_context",
            device = ?device,
        );
        let _enter = span.enter();
        let request = types::xselinux::SetDeviceContextRequest {
            device,
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_context_checked(
        &mut self,
        device: types::Card32,
        context: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.xselinux_set_device_context(device, context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_context(
        &mut self,
        device: types::Card32,
    ) -> Result<Cookie<types::xselinux::GetDeviceContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_device_context",
            device = ?device,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetDeviceContextRequest { device };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_context_immediate(
        &mut self,
        device: types::Card32,
    ) -> Result<types::xselinux::GetDeviceContextReply> {
        let cookie = self.xselinux_get_device_context(device)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_window_create_context(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!("xselinux_set_window_create_context",);
        let _enter = span.enter();
        let request = types::xselinux::SetWindowCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_window_create_context_checked(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.xselinux_set_window_create_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_create_context(
        &mut self,
    ) -> Result<Cookie<types::xselinux::GetWindowCreateContextReply>> {
        let span = tracing::info_span!("xselinux_get_window_create_context",);
        let _enter = span.enter();
        let request = types::xselinux::GetWindowCreateContextRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_create_context_immediate(
        &mut self,
    ) -> Result<types::xselinux::GetWindowCreateContextReply> {
        let cookie = self.xselinux_get_window_create_context()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_context(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xselinux::GetWindowContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_window_context",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetWindowContextRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_context_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xselinux::GetWindowContextReply> {
        let cookie = self.xselinux_get_window_context(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_create_context(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!("xselinux_set_property_create_context",);
        let _enter = span.enter();
        let request = types::xselinux::SetPropertyCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_create_context_checked(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.xselinux_set_property_create_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_create_context(
        &mut self,
    ) -> Result<Cookie<types::xselinux::GetPropertyCreateContextReply>> {
        let span = tracing::info_span!("xselinux_get_property_create_context",);
        let _enter = span.enter();
        let request = types::xselinux::GetPropertyCreateContextRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_create_context_immediate(
        &mut self,
    ) -> Result<types::xselinux::GetPropertyCreateContextReply> {
        let cookie = self.xselinux_get_property_create_context()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_use_context(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!("xselinux_set_property_use_context",);
        let _enter = span.enter();
        let request = types::xselinux::SetPropertyUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_use_context_checked(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.xselinux_set_property_use_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_use_context(
        &mut self,
    ) -> Result<Cookie<types::xselinux::GetPropertyUseContextReply>> {
        let span = tracing::info_span!("xselinux_get_property_use_context",);
        let _enter = span.enter();
        let request = types::xselinux::GetPropertyUseContextRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_use_context_immediate(
        &mut self,
    ) -> Result<types::xselinux::GetPropertyUseContextReply> {
        let cookie = self.xselinux_get_property_use_context()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_context(
        &mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Result<Cookie<types::xselinux::GetPropertyContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_property_context",
            window = ?window,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetPropertyContextRequest { window, property };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_context_immediate(
        &mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Result<types::xselinux::GetPropertyContextReply> {
        let cookie = self.xselinux_get_property_context(window, property)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_data_context(
        &mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Result<Cookie<types::xselinux::GetPropertyDataContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_property_data_context",
            window = ?window,
            property = ?property,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetPropertyDataContextRequest { window, property };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_data_context_immediate(
        &mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Result<types::xselinux::GetPropertyDataContextReply> {
        let cookie = self.xselinux_get_property_data_context(window, property)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_properties(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xselinux::ListPropertiesReply>> {
        let span = tracing::info_span!(
            "xselinux_list_properties",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xselinux::ListPropertiesRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_properties_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xselinux::ListPropertiesReply> {
        let cookie = self.xselinux_list_properties(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_create_context(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!("xselinux_set_selection_create_context",);
        let _enter = span.enter();
        let request = types::xselinux::SetSelectionCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_create_context_checked(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.xselinux_set_selection_create_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_create_context(
        &mut self,
    ) -> Result<Cookie<types::xselinux::GetSelectionCreateContextReply>> {
        let span = tracing::info_span!("xselinux_get_selection_create_context",);
        let _enter = span.enter();
        let request = types::xselinux::GetSelectionCreateContextRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_create_context_immediate(
        &mut self,
    ) -> Result<types::xselinux::GetSelectionCreateContextReply> {
        let cookie = self.xselinux_get_selection_create_context()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_use_context(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!("xselinux_set_selection_use_context",);
        let _enter = span.enter();
        let request = types::xselinux::SetSelectionUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_use_context_checked(
        &mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Result<()> {
        let cookie = self.xselinux_set_selection_use_context(context)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_use_context(
        &mut self,
    ) -> Result<Cookie<types::xselinux::GetSelectionUseContextReply>> {
        let span = tracing::info_span!("xselinux_get_selection_use_context",);
        let _enter = span.enter();
        let request = types::xselinux::GetSelectionUseContextRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_use_context_immediate(
        &mut self,
    ) -> Result<types::xselinux::GetSelectionUseContextReply> {
        let cookie = self.xselinux_get_selection_use_context()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_context(
        &mut self,
        selection: types::Atom,
    ) -> Result<Cookie<types::xselinux::GetSelectionContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_selection_context",
            selection = ?selection,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetSelectionContextRequest { selection };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_context_immediate(
        &mut self,
        selection: types::Atom,
    ) -> Result<types::xselinux::GetSelectionContextReply> {
        let cookie = self.xselinux_get_selection_context(selection)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_data_context(
        &mut self,
        selection: types::Atom,
    ) -> Result<Cookie<types::xselinux::GetSelectionDataContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_selection_data_context",
            selection = ?selection,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetSelectionDataContextRequest { selection };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_data_context_immediate(
        &mut self,
        selection: types::Atom,
    ) -> Result<types::xselinux::GetSelectionDataContextReply> {
        let cookie = self.xselinux_get_selection_data_context(selection)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_selections(&mut self) -> Result<Cookie<types::xselinux::ListSelectionsReply>> {
        let span = tracing::info_span!("xselinux_list_selections",);
        let _enter = span.enter();
        let request = types::xselinux::ListSelectionsRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_selections_immediate(
        &mut self,
    ) -> Result<types::xselinux::ListSelectionsReply> {
        let cookie = self.xselinux_list_selections()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_client_context(
        &mut self,
        resource: types::Card32,
    ) -> Result<Cookie<types::xselinux::GetClientContextReply>> {
        let span = tracing::info_span!(
            "xselinux_get_client_context",
            resource = ?resource,
        );
        let _enter = span.enter();
        let request = types::xselinux::GetClientContextRequest { resource };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_client_context_immediate(
        &mut self,
        resource: types::Card32,
    ) -> Result<types::xselinux::GetClientContextReply> {
        let cookie = self.xselinux_get_client_context(resource)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xtest")]
    fn xtest_get_version(
        &mut self,
        major_version: types::Card8,
        minor_version: types::Card16,
    ) -> Result<Cookie<types::xtest::GetVersionReply>> {
        let span = tracing::info_span!(
            "xtest_get_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let _enter = span.enter();
        let request = types::xtest::GetVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xtest")]
    fn xtest_get_version_immediate(
        &mut self,
        major_version: types::Card8,
        minor_version: types::Card16,
    ) -> Result<types::xtest::GetVersionReply> {
        let cookie = self.xtest_get_version(major_version, minor_version)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xtest")]
    fn xtest_compare_cursor(
        &mut self,
        window: types::xproto::Window,
        cursor: types::xproto::Cursor,
    ) -> Result<Cookie<types::xtest::CompareCursorReply>> {
        let span = tracing::info_span!(
            "xtest_compare_cursor",
            window = ?window,
            cursor = ?cursor,
        );
        let _enter = span.enter();
        let request = types::xtest::CompareCursorRequest { window, cursor };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xtest")]
    fn xtest_compare_cursor_immediate(
        &mut self,
        window: types::xproto::Window,
        cursor: types::xproto::Cursor,
    ) -> Result<types::xtest::CompareCursorReply> {
        let cookie = self.xtest_compare_cursor(window, cursor)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xtest")]
    fn xtest_fake_input(
        &mut self,
        type_: types::Byte,
        detail: types::Byte,
        time: types::Card32,
        root: types::xproto::Window,
        root_x: types::Int16,
        root_y: types::Int16,
        deviceid: types::Card8,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xtest_fake_input",
            type_ = ?type_,
            detail = ?detail,
            time = ?time,
            root = ?root,
            root_x = ?root_x,
            root_y = ?root_y,
            deviceid = ?deviceid,
        );
        let _enter = span.enter();
        let request = types::xtest::FakeInputRequest {
            type_,
            detail,
            time,
            root,
            root_x,
            root_y,
            deviceid,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xtest")]
    fn xtest_fake_input_checked(
        &mut self,
        type_: types::Byte,
        detail: types::Byte,
        time: types::Card32,
        root: types::xproto::Window,
        root_x: types::Int16,
        root_y: types::Int16,
        deviceid: types::Card8,
    ) -> Result<()> {
        let cookie = self.xtest_fake_input(type_, detail, time, root, root_x, root_y, deviceid)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xtest")]
    fn xtest_grab_control(&mut self, impervious: types::Bool) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xtest_grab_control",
            impervious = ?impervious,
        );
        let _enter = span.enter();
        let request = types::xtest::GrabControlRequest { impervious };
        self.send_void_request(request)
    }
    #[cfg(feature = "xtest")]
    fn xtest_grab_control_checked(&mut self, impervious: types::Bool) -> Result<()> {
        let cookie = self.xtest_grab_control(impervious)?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xv")]
    fn xv_query_extension(&mut self) -> Result<Cookie<types::xv::QueryExtensionReply>> {
        let span = tracing::info_span!("xv_query_extension",);
        let _enter = span.enter();
        let request = types::xv::QueryExtensionRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_extension_immediate(&mut self) -> Result<types::xv::QueryExtensionReply> {
        let cookie = self.xv_query_extension()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_query_adaptors(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<Cookie<types::xv::QueryAdaptorsReply>> {
        let span = tracing::info_span!(
            "xv_query_adaptors",
            window = ?window,
        );
        let _enter = span.enter();
        let request = types::xv::QueryAdaptorsRequest { window };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_adaptors_immediate(
        &mut self,
        window: types::xproto::Window,
    ) -> Result<types::xv::QueryAdaptorsReply> {
        let cookie = self.xv_query_adaptors(window)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_query_encodings(
        &mut self,
        port: types::Port,
    ) -> Result<Cookie<types::xv::QueryEncodingsReply>> {
        let span = tracing::info_span!(
            "xv_query_encodings",
            port = ?port,
        );
        let _enter = span.enter();
        let request = types::xv::QueryEncodingsRequest { port };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_encodings_immediate(
        &mut self,
        port: types::Port,
    ) -> Result<types::xv::QueryEncodingsReply> {
        let cookie = self.xv_query_encodings(port)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_grab_port(
        &mut self,
        port: types::Port,
        time: impl Into<types::Time>,
    ) -> Result<Cookie<types::xv::GrabPortReply>> {
        let span = tracing::info_span!(
            "xv_grab_port",
            port = ?port,
        );
        let _enter = span.enter();
        let request = types::xv::GrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_grab_port_immediate(
        &mut self,
        port: types::Port,
        time: impl Into<types::Time>,
    ) -> Result<types::xv::GrabPortReply> {
        let cookie = self.xv_grab_port(port, time)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_ungrab_port(
        &mut self,
        port: types::Port,
        time: impl Into<types::Time>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_ungrab_port",
            port = ?port,
        );
        let _enter = span.enter();
        let request = types::xv::UngrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_ungrab_port_checked(
        &mut self,
        port: types::Port,
        time: impl Into<types::Time>,
    ) -> Result<()> {
        let cookie = self.xv_ungrab_port(port, time)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_put_video(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_put_video",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let _enter = span.enter();
        let request = types::xv::PutVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_put_video_checked(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Result<()> {
        let cookie = self.xv_put_video(
            port, drawable, gc, vid_x, vid_y, vid_w, vid_h, drw_x, drw_y, drw_w, drw_h,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_put_still(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_put_still",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let _enter = span.enter();
        let request = types::xv::PutStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_put_still_checked(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Result<()> {
        let cookie = self.xv_put_still(
            port, drawable, gc, vid_x, vid_y, vid_w, vid_h, drw_x, drw_y, drw_w, drw_h,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_get_video(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_get_video",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let _enter = span.enter();
        let request = types::xv::GetVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_get_video_checked(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Result<()> {
        let cookie = self.xv_get_video(
            port, drawable, gc, vid_x, vid_y, vid_w, vid_h, drw_x, drw_y, drw_w, drw_h,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_get_still(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_get_still",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let _enter = span.enter();
        let request = types::xv::GetStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_get_still_checked(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Result<()> {
        let cookie = self.xv_get_still(
            port, drawable, gc, vid_x, vid_y, vid_w, vid_h, drw_x, drw_y, drw_w, drw_h,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_stop_video(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_stop_video",
            port = ?port,
            drawable = ?drawable,
        );
        let _enter = span.enter();
        let request = types::xv::StopVideoRequest { port, drawable };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_stop_video_checked(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
    ) -> Result<()> {
        let cookie = self.xv_stop_video(port, drawable)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_select_video_notify(
        &mut self,
        drawable: types::xproto::Drawable,
        onoff: types::Bool,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_select_video_notify",
            drawable = ?drawable,
            onoff = ?onoff,
        );
        let _enter = span.enter();
        let request = types::xv::SelectVideoNotifyRequest { drawable, onoff };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_select_video_notify_checked(
        &mut self,
        drawable: types::xproto::Drawable,
        onoff: types::Bool,
    ) -> Result<()> {
        let cookie = self.xv_select_video_notify(drawable, onoff)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_select_port_notify(
        &mut self,
        port: types::Port,
        onoff: types::Bool,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_select_port_notify",
            port = ?port,
            onoff = ?onoff,
        );
        let _enter = span.enter();
        let request = types::xv::SelectPortNotifyRequest { port, onoff };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_select_port_notify_checked(
        &mut self,
        port: types::Port,
        onoff: types::Bool,
    ) -> Result<()> {
        let cookie = self.xv_select_port_notify(port, onoff)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_query_best_size(
        &mut self,
        port: types::Port,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        motion: types::Bool,
    ) -> Result<Cookie<types::xv::QueryBestSizeReply>> {
        let span = tracing::info_span!(
            "xv_query_best_size",
            port = ?port,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            motion = ?motion,
        );
        let _enter = span.enter();
        let request = types::xv::QueryBestSizeRequest {
            port,
            vid_w,
            vid_h,
            drw_w,
            drw_h,
            motion,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_best_size_immediate(
        &mut self,
        port: types::Port,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        motion: types::Bool,
    ) -> Result<types::xv::QueryBestSizeReply> {
        let cookie = self.xv_query_best_size(port, vid_w, vid_h, drw_w, drw_h, motion)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_set_port_attribute(
        &mut self,
        port: types::Port,
        attribute: types::Atom,
        value: types::Int32,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_set_port_attribute",
            port = ?port,
            attribute = ?attribute,
            value = ?value,
        );
        let _enter = span.enter();
        let request = types::xv::SetPortAttributeRequest {
            port,
            attribute,
            value,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_set_port_attribute_checked(
        &mut self,
        port: types::Port,
        attribute: types::Atom,
        value: types::Int32,
    ) -> Result<()> {
        let cookie = self.xv_set_port_attribute(port, attribute, value)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_get_port_attribute(
        &mut self,
        port: types::Port,
        attribute: types::Atom,
    ) -> Result<Cookie<types::xv::GetPortAttributeReply>> {
        let span = tracing::info_span!(
            "xv_get_port_attribute",
            port = ?port,
            attribute = ?attribute,
        );
        let _enter = span.enter();
        let request = types::xv::GetPortAttributeRequest { port, attribute };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_get_port_attribute_immediate(
        &mut self,
        port: types::Port,
        attribute: types::Atom,
    ) -> Result<types::xv::GetPortAttributeReply> {
        let cookie = self.xv_get_port_attribute(port, attribute)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_query_port_attributes(
        &mut self,
        port: types::Port,
    ) -> Result<Cookie<types::xv::QueryPortAttributesReply>> {
        let span = tracing::info_span!(
            "xv_query_port_attributes",
            port = ?port,
        );
        let _enter = span.enter();
        let request = types::xv::QueryPortAttributesRequest { port };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_port_attributes_immediate(
        &mut self,
        port: types::Port,
    ) -> Result<types::xv::QueryPortAttributesReply> {
        let cookie = self.xv_query_port_attributes(port)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_list_image_formats(
        &mut self,
        port: types::Port,
    ) -> Result<Cookie<types::xv::ListImageFormatsReply>> {
        let span = tracing::info_span!(
            "xv_list_image_formats",
            port = ?port,
        );
        let _enter = span.enter();
        let request = types::xv::ListImageFormatsRequest { port };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_list_image_formats_immediate(
        &mut self,
        port: types::Port,
    ) -> Result<types::xv::ListImageFormatsReply> {
        let cookie = self.xv_list_image_formats(port)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_query_image_attributes(
        &mut self,
        port: types::Port,
        id: types::Card32,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<Cookie<types::xv::QueryImageAttributesReply>> {
        let span = tracing::info_span!(
            "xv_query_image_attributes",
            port = ?port,
            id = ?id,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xv::QueryImageAttributesRequest {
            port,
            id,
            width,
            height,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_query_image_attributes_immediate(
        &mut self,
        port: types::Port,
        id: types::Card32,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<types::xv::QueryImageAttributesReply> {
        let cookie = self.xv_query_image_attributes(port, id, width, height)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_put_image(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        id: types::Card32,
        src_x: types::Int16,
        src_y: types::Int16,
        src_w: types::Card16,
        src_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        width: types::Card16,
        height: types::Card16,
        data: impl AsRef<[types::Card8]>,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_put_image",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            id = ?id,
            src_x = ?src_x,
            src_y = ?src_y,
            src_w = ?src_w,
            src_h = ?src_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xv::PutImageRequest {
            port,
            drawable,
            gc,
            id,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_put_image_checked(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        id: types::Card32,
        src_x: types::Int16,
        src_y: types::Int16,
        src_w: types::Card16,
        src_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        width: types::Card16,
        height: types::Card16,
        data: impl AsRef<[types::Card8]>,
    ) -> Result<()> {
        let cookie = self.xv_put_image(
            port, drawable, gc, id, src_x, src_y, src_w, src_h, drw_x, drw_y, drw_w, drw_h, width,
            height, data,
        )?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xv")]
    fn xv_shm_put_image(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        shmseg: types::Seg,
        id: types::Card32,
        offset: types::Card32,
        src_x: types::Int16,
        src_y: types::Int16,
        src_w: types::Card16,
        src_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        width: types::Card16,
        height: types::Card16,
        send_event: types::Card8,
    ) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xv_shm_put_image",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            shmseg = ?shmseg,
            id = ?id,
            offset = ?offset,
            src_x = ?src_x,
            src_y = ?src_y,
            src_w = ?src_w,
            src_h = ?src_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            width = ?width,
            height = ?height,
            send_event = ?send_event,
        );
        let _enter = span.enter();
        let request = types::xv::ShmPutImageRequest {
            port,
            drawable,
            gc,
            shmseg,
            id,
            offset,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            send_event,
        };
        self.send_void_request(request)
    }
    #[cfg(feature = "xv")]
    fn xv_shm_put_image_checked(
        &mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        shmseg: types::Seg,
        id: types::Card32,
        offset: types::Card32,
        src_x: types::Int16,
        src_y: types::Int16,
        src_w: types::Card16,
        src_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        width: types::Card16,
        height: types::Card16,
        send_event: types::Card8,
    ) -> Result<()> {
        let cookie = self.xv_shm_put_image(
            port, drawable, gc, shmseg, id, offset, src_x, src_y, src_w, src_h, drw_x, drw_y,
            drw_w, drw_h, width, height, send_event,
        )?;
        self.wait_for_reply(cookie)
    }

    #[cfg(feature = "xvmc")]
    fn xvmc_query_version(&mut self) -> Result<Cookie<types::xvmc::QueryVersionReply>> {
        let span = tracing::info_span!("xvmc_query_version",);
        let _enter = span.enter();
        let request = types::xvmc::QueryVersionRequest {};
        self.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_query_version_immediate(&mut self) -> Result<types::xvmc::QueryVersionReply> {
        let cookie = self.xvmc_query_version()?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_surface_types(
        &mut self,
        port_id: types::Port,
    ) -> Result<Cookie<types::xvmc::ListSurfaceTypesReply>> {
        let span = tracing::info_span!(
            "xvmc_list_surface_types",
            port_id = ?port_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::ListSurfaceTypesRequest { port_id };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_surface_types_immediate(
        &mut self,
        port_id: types::Port,
    ) -> Result<types::xvmc::ListSurfaceTypesReply> {
        let cookie = self.xvmc_list_surface_types(port_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_context(
        &mut self,
        context_id: types::xvmc::Context,
        port_id: types::Port,
        surface_id: types::Surface,
        width: types::Card16,
        height: types::Card16,
        flags: types::Card32,
    ) -> Result<Cookie<types::xvmc::CreateContextReply>> {
        let span = tracing::info_span!(
            "xvmc_create_context",
            context_id = ?context_id,
            port_id = ?port_id,
            surface_id = ?surface_id,
            width = ?width,
            height = ?height,
            flags = ?flags,
        );
        let _enter = span.enter();
        let request = types::xvmc::CreateContextRequest {
            context_id,
            port_id,
            surface_id,
            width,
            height,
            flags,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_context_immediate(
        &mut self,
        context_id: types::xvmc::Context,
        port_id: types::Port,
        surface_id: types::Surface,
        width: types::Card16,
        height: types::Card16,
        flags: types::Card32,
    ) -> Result<types::xvmc::CreateContextReply> {
        let cookie =
            self.xvmc_create_context(context_id, port_id, surface_id, width, height, flags)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_context(&mut self, context_id: types::xvmc::Context) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xvmc_destroy_context",
            context_id = ?context_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::DestroyContextRequest { context_id };
        self.send_void_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_context_checked(&mut self, context_id: types::xvmc::Context) -> Result<()> {
        let cookie = self.xvmc_destroy_context(context_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_surface(
        &mut self,
        surface_id: types::Surface,
        context_id: types::xvmc::Context,
    ) -> Result<Cookie<types::xvmc::CreateSurfaceReply>> {
        let span = tracing::info_span!(
            "xvmc_create_surface",
            surface_id = ?surface_id,
            context_id = ?context_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::CreateSurfaceRequest {
            surface_id,
            context_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_surface_immediate(
        &mut self,
        surface_id: types::Surface,
        context_id: types::xvmc::Context,
    ) -> Result<types::xvmc::CreateSurfaceReply> {
        let cookie = self.xvmc_create_surface(surface_id, context_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_surface(&mut self, surface_id: types::Surface) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xvmc_destroy_surface",
            surface_id = ?surface_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::DestroySurfaceRequest { surface_id };
        self.send_void_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_surface_checked(&mut self, surface_id: types::Surface) -> Result<()> {
        let cookie = self.xvmc_destroy_surface(surface_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_subpicture(
        &mut self,
        subpicture_id: types::Subpicture,
        context: types::xvmc::Context,
        xvimage_id: types::Card32,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<Cookie<types::xvmc::CreateSubpictureReply>> {
        let span = tracing::info_span!(
            "xvmc_create_subpicture",
            subpicture_id = ?subpicture_id,
            context = ?context,
            xvimage_id = ?xvimage_id,
            width = ?width,
            height = ?height,
        );
        let _enter = span.enter();
        let request = types::xvmc::CreateSubpictureRequest {
            subpicture_id,
            context,
            xvimage_id,
            width,
            height,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_subpicture_immediate(
        &mut self,
        subpicture_id: types::Subpicture,
        context: types::xvmc::Context,
        xvimage_id: types::Card32,
        width: types::Card16,
        height: types::Card16,
    ) -> Result<types::xvmc::CreateSubpictureReply> {
        let cookie =
            self.xvmc_create_subpicture(subpicture_id, context, xvimage_id, width, height)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_subpicture(&mut self, subpicture_id: types::Subpicture) -> Result<Cookie<()>> {
        let span = tracing::info_span!(
            "xvmc_destroy_subpicture",
            subpicture_id = ?subpicture_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::DestroySubpictureRequest { subpicture_id };
        self.send_void_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_subpicture_checked(&mut self, subpicture_id: types::Subpicture) -> Result<()> {
        let cookie = self.xvmc_destroy_subpicture(subpicture_id)?;
        self.wait_for_reply(cookie)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_subpicture_types(
        &mut self,
        port_id: types::Port,
        surface_id: types::Surface,
    ) -> Result<Cookie<types::xvmc::ListSubpictureTypesReply>> {
        let span = tracing::info_span!(
            "xvmc_list_subpicture_types",
            port_id = ?port_id,
            surface_id = ?surface_id,
        );
        let _enter = span.enter();
        let request = types::xvmc::ListSubpictureTypesRequest {
            port_id,
            surface_id,
        };
        self.send_reply_request(request)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_subpicture_types_immediate(
        &mut self,
        port_id: types::Port,
        surface_id: types::Surface,
    ) -> Result<types::xvmc::ListSubpictureTypesReply> {
        let cookie = self.xvmc_list_subpicture_types(port_id, surface_id)?;
        self.wait_for_reply(cookie)
    }
}

#[cfg(feature = "async")]
pub trait AsyncDisplayFunctionsExt: AsyncDisplay + Sealed2 {
    fn bigreq_enable<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::bigreq::EnableReply>> {
        let span = tracing::info_span!("bigreq_enable",);
        let request = types::bigreq::EnableRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn bigreq_enable_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::bigreq::EnableReply>> {
        let cookie = self.bigreq_enable();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::bigreq::EnableReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "composite")]
    fn composite_query_version<'this>(
        &'this mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::composite::QueryVersionReply>> {
        let span = tracing::info_span!(
            "composite_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::composite::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_query_version_immediate<'this>(
        &'this mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::composite::QueryVersionReply>>
    {
        let cookie = self.composite_query_version(client_major_version, client_minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::composite::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_window<'this>(
        &'this mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "composite_redirect_window",
            window = ?window,
            update = ?update,
        );
        let request = types::composite::RedirectWindowRequest { window, update };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_window_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.composite_redirect_window(window, update);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_subwindows<'this>(
        &'this mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "composite_redirect_subwindows",
            window = ?window,
            update = ?update,
        );
        let request = types::composite::RedirectSubwindowsRequest { window, update };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_redirect_subwindows_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.composite_redirect_subwindows(window, update);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_window<'this>(
        &'this mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "composite_unredirect_window",
            window = ?window,
            update = ?update,
        );
        let request = types::composite::UnredirectWindowRequest { window, update };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_window_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.composite_unredirect_window(window, update);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_subwindows<'this>(
        &'this mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "composite_unredirect_subwindows",
            window = ?window,
            update = ?update,
        );
        let request = types::composite::UnredirectSubwindowsRequest { window, update };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_unredirect_subwindows_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        update: types::Redirect,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.composite_unredirect_subwindows(window, update);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_create_region_from_border_clip<'this>(
        &'this mut self,
        region: types::Region,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "composite_create_region_from_border_clip",
            region = ?region,
            window = ?window,
        );
        let request = types::composite::CreateRegionFromBorderClipRequest { region, window };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_create_region_from_border_clip_checked<'this>(
        &'this mut self,
        region: types::Region,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.composite_create_region_from_border_clip(region, window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_name_window_pixmap<'this>(
        &'this mut self,
        window: types::xproto::Window,
        pixmap: types::xproto::Pixmap,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "composite_name_window_pixmap",
            window = ?window,
            pixmap = ?pixmap,
        );
        let request = types::composite::NameWindowPixmapRequest { window, pixmap };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_name_window_pixmap_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        pixmap: types::xproto::Pixmap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.composite_name_window_pixmap(window, pixmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_get_overlay_window<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::composite::GetOverlayWindowReply>>
    {
        let span = tracing::info_span!(
            "composite_get_overlay_window",
            window = ?window,
        );
        let request = types::composite::GetOverlayWindowRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_get_overlay_window_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::composite::GetOverlayWindowReply>,
    > {
        let cookie = self.composite_get_overlay_window(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::composite::GetOverlayWindowReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_release_overlay_window<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "composite_release_overlay_window",
            window = ?window,
        );
        let request = types::composite::ReleaseOverlayWindowRequest { window };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "composite")]
    fn composite_release_overlay_window_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.composite_release_overlay_window(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "damage")]
    fn damage_query_version<'this>(
        &'this mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::damage::QueryVersionReply>> {
        let span = tracing::info_span!(
            "damage_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::damage::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "damage")]
    fn damage_query_version_immediate<'this>(
        &'this mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::damage::QueryVersionReply>>
    {
        let cookie = self.damage_query_version(client_major_version, client_minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::damage::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "damage")]
    fn damage_create<'this>(
        &'this mut self,
        damage: types::Damage,
        drawable: types::xproto::Drawable,
        level: types::ReportLevel,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "damage_create",
            damage = ?damage,
            drawable = ?drawable,
            level = ?level,
        );
        let request = types::damage::CreateRequest {
            damage,
            drawable,
            level,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "damage")]
    fn damage_create_checked<'this>(
        &'this mut self,
        damage: types::Damage,
        drawable: types::xproto::Drawable,
        level: types::ReportLevel,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.damage_create(damage, drawable, level);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "damage")]
    fn damage_destroy<'this>(
        &'this mut self,
        damage: types::Damage,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "damage_destroy",
            damage = ?damage,
        );
        let request = types::damage::DestroyRequest { damage };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "damage")]
    fn damage_destroy_checked<'this>(
        &'this mut self,
        damage: types::Damage,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.damage_destroy(damage);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "damage")]
    fn damage_subtract<'this>(
        &'this mut self,
        damage: types::Damage,
        repair: impl Into<types::Region>,
        parts: impl Into<types::Region>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "damage_subtract",
            damage = ?damage,
        );
        let request = types::damage::SubtractRequest {
            damage,
            repair: Into::<u32>::into(repair.into()) as _,
            parts: Into::<u32>::into(parts.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "damage")]
    fn damage_subtract_checked<'this>(
        &'this mut self,
        damage: types::Damage,
        repair: impl Into<types::Region>,
        parts: impl Into<types::Region>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.damage_subtract(damage, repair, parts);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "damage")]
    fn damage_add<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        region: types::Region,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "damage_add",
            drawable = ?drawable,
            region = ?region,
        );
        let request = types::damage::AddRequest { drawable, region };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "damage")]
    fn damage_add_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        region: types::Region,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.damage_add(drawable, region);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "dpms")]
    fn dpms_get_version<'this>(
        &'this mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dpms::GetVersionReply>> {
        let span = tracing::info_span!(
            "dpms_get_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::dpms::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_version_immediate<'this>(
        &'this mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dpms::GetVersionReply>> {
        let cookie = self.dpms_get_version(client_major_version, client_minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dpms::GetVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_capable<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dpms::CapableReply>> {
        let span = tracing::info_span!("dpms_capable",);
        let request = types::dpms::CapableRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_capable_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dpms::CapableReply>> {
        let cookie = self.dpms_capable();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dpms::CapableReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_timeouts<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dpms::GetTimeoutsReply>> {
        let span = tracing::info_span!("dpms_get_timeouts",);
        let request = types::dpms::GetTimeoutsRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_get_timeouts_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dpms::GetTimeoutsReply>> {
        let cookie = self.dpms_get_timeouts();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dpms::GetTimeoutsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_set_timeouts<'this>(
        &'this mut self,
        standby_timeout: types::Card16,
        suspend_timeout: types::Card16,
        off_timeout: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "dpms_set_timeouts",
            standby_timeout = ?standby_timeout,
            suspend_timeout = ?suspend_timeout,
            off_timeout = ?off_timeout,
        );
        let request = types::dpms::SetTimeoutsRequest {
            standby_timeout,
            suspend_timeout,
            off_timeout,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_set_timeouts_checked<'this>(
        &'this mut self,
        standby_timeout: types::Card16,
        suspend_timeout: types::Card16,
        off_timeout: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.dpms_set_timeouts(standby_timeout, suspend_timeout, off_timeout);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_enable<'this>(&'this mut self) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("dpms_enable",);
        let request = types::dpms::EnableRequest {};
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_enable_checked<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.dpms_enable();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_disable<'this>(&'this mut self) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("dpms_disable",);
        let request = types::dpms::DisableRequest {};
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_disable_checked<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.dpms_disable();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_force_level<'this>(
        &'this mut self,
        power_level: types::DPMSMode,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "dpms_force_level",
            power_level = ?power_level,
        );
        let request = types::dpms::ForceLevelRequest { power_level };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_force_level_checked<'this>(
        &'this mut self,
        power_level: types::DPMSMode,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.dpms_force_level(power_level);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_info<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dpms::InfoReply>> {
        let span = tracing::info_span!("dpms_info",);
        let request = types::dpms::InfoRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dpms")]
    fn dpms_info_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dpms::InfoReply>> {
        let cookie = self.dpms_info();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dpms::InfoReply> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "dri2")]
    fn dri2_query_version<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri2::QueryVersionReply>> {
        let span = tracing::info_span!(
            "dri2_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::dri2::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_query_version_immediate<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri2::QueryVersionReply>>
    {
        let cookie = self.dri2_query_version(major_version, minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_connect<'this>(
        &'this mut self,
        window: types::xproto::Window,
        driver_type: types::DriverType,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri2::ConnectReply>> {
        let span = tracing::info_span!(
            "dri2_connect",
            window = ?window,
            driver_type = ?driver_type,
        );
        let request = types::dri2::ConnectRequest {
            window,
            driver_type,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_connect_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        driver_type: types::DriverType,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri2::ConnectReply>> {
        let cookie = self.dri2_connect(window, driver_type);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::ConnectReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_authenticate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        magic: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri2::AuthenticateReply>> {
        let span = tracing::info_span!(
            "dri2_authenticate",
            window = ?window,
            magic = ?magic,
        );
        let request = types::dri2::AuthenticateRequest { window, magic };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_authenticate_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        magic: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri2::AuthenticateReply>>
    {
        let cookie = self.dri2_authenticate(window, magic);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::AuthenticateReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_create_drawable<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "dri2_create_drawable",
            drawable = ?drawable,
        );
        let request = types::dri2::CreateDrawableRequest { drawable };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_create_drawable_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.dri2_create_drawable(drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_destroy_drawable<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "dri2_destroy_drawable",
            drawable = ?drawable,
        );
        let request = types::dri2::DestroyDrawableRequest { drawable };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_destroy_drawable_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.dri2_destroy_drawable(drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_copy_region<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        region: types::Card32,
        dest: types::Card32,
        src: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri2::CopyRegionReply>> {
        let span = tracing::info_span!(
            "dri2_copy_region",
            drawable = ?drawable,
            region = ?region,
            dest = ?dest,
            src = ?src,
        );
        let request = types::dri2::CopyRegionRequest {
            drawable,
            region,
            dest,
            src,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_copy_region_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        region: types::Card32,
        dest: types::Card32,
        src: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri2::CopyRegionReply>> {
        let cookie = self.dri2_copy_region(drawable, region, dest, src);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::CopyRegionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_buffers<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        target_msc_hi: types::Card32,
        target_msc_lo: types::Card32,
        divisor_hi: types::Card32,
        divisor_lo: types::Card32,
        remainder_hi: types::Card32,
        remainder_lo: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri2::SwapBuffersReply>> {
        let span = tracing::info_span!(
            "dri2_swap_buffers",
            drawable = ?drawable,
            target_msc_hi = ?target_msc_hi,
            target_msc_lo = ?target_msc_lo,
            divisor_hi = ?divisor_hi,
            divisor_lo = ?divisor_lo,
            remainder_hi = ?remainder_hi,
            remainder_lo = ?remainder_lo,
        );
        let request = types::dri2::SwapBuffersRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_buffers_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        target_msc_hi: types::Card32,
        target_msc_lo: types::Card32,
        divisor_hi: types::Card32,
        divisor_lo: types::Card32,
        remainder_hi: types::Card32,
        remainder_lo: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri2::SwapBuffersReply>> {
        let cookie = self.dri2_swap_buffers(
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::SwapBuffersReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_msc<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri2::GetMSCReply>> {
        let span = tracing::info_span!(
            "dri2_get_msc",
            drawable = ?drawable,
        );
        let request = types::dri2::GetMSCRequest { drawable };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_msc_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri2::GetMSCReply>> {
        let cookie = self.dri2_get_msc(drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::GetMSCReply> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_msc<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        target_msc_hi: types::Card32,
        target_msc_lo: types::Card32,
        divisor_hi: types::Card32,
        divisor_lo: types::Card32,
        remainder_hi: types::Card32,
        remainder_lo: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri2::WaitMSCReply>> {
        let span = tracing::info_span!(
            "dri2_wait_msc",
            drawable = ?drawable,
            target_msc_hi = ?target_msc_hi,
            target_msc_lo = ?target_msc_lo,
            divisor_hi = ?divisor_hi,
            divisor_lo = ?divisor_lo,
            remainder_hi = ?remainder_hi,
            remainder_lo = ?remainder_lo,
        );
        let request = types::dri2::WaitMSCRequest {
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_msc_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        target_msc_hi: types::Card32,
        target_msc_lo: types::Card32,
        divisor_hi: types::Card32,
        divisor_lo: types::Card32,
        remainder_hi: types::Card32,
        remainder_lo: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri2::WaitMSCReply>> {
        let cookie = self.dri2_wait_msc(
            drawable,
            target_msc_hi,
            target_msc_lo,
            divisor_hi,
            divisor_lo,
            remainder_hi,
            remainder_lo,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::WaitMSCReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_sbc<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        target_sbc_hi: types::Card32,
        target_sbc_lo: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri2::WaitSBCReply>> {
        let span = tracing::info_span!(
            "dri2_wait_sbc",
            drawable = ?drawable,
            target_sbc_hi = ?target_sbc_hi,
            target_sbc_lo = ?target_sbc_lo,
        );
        let request = types::dri2::WaitSBCRequest {
            drawable,
            target_sbc_hi,
            target_sbc_lo,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_wait_sbc_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        target_sbc_hi: types::Card32,
        target_sbc_lo: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri2::WaitSBCReply>> {
        let cookie = self.dri2_wait_sbc(drawable, target_sbc_hi, target_sbc_lo);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::WaitSBCReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_interval<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        interval: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "dri2_swap_interval",
            drawable = ?drawable,
            interval = ?interval,
        );
        let request = types::dri2::SwapIntervalRequest { drawable, interval };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_swap_interval_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        interval: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.dri2_swap_interval(drawable, interval);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_param<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        param: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri2::GetParamReply>> {
        let span = tracing::info_span!(
            "dri2_get_param",
            drawable = ?drawable,
            param = ?param,
        );
        let request = types::dri2::GetParamRequest { drawable, param };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dri2")]
    fn dri2_get_param_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        param: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri2::GetParamReply>> {
        let cookie = self.dri2_get_param(drawable, param);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri2::GetParamReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "dri3")]
    fn dri3_query_version<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri3::QueryVersionReply>> {
        let span = tracing::info_span!(
            "dri3_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::dri3::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_query_version_immediate<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri3::QueryVersionReply>>
    {
        let cookie = self.dri3_query_version(major_version, minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_open<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        provider: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri3::OpenReply>> {
        let span = tracing::info_span!(
            "dri3_open",
            drawable = ?drawable,
            provider = ?provider,
        );
        let request = types::dri3::OpenRequest { drawable, provider };
        self.send_reply_fd_request(request).instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_open_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        provider: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri3::OpenReply>> {
        let cookie = self.dri3_open(drawable, provider);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::OpenReply> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffer<'this>(
        &'this mut self,
        pixmap: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        size: types::Card32,
        width: types::Card16,
        height: types::Card16,
        stride: types::Card16,
        depth: types::Card8,
        bpp: types::Card8,
        pixmap_fd: types::Fd,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "dri3_pixmap_from_buffer",
            pixmap = ?pixmap,
            drawable = ?drawable,
            size = ?size,
            width = ?width,
            height = ?height,
            stride = ?stride,
            depth = ?depth,
            bpp = ?bpp,
            pixmap_fd = ?pixmap_fd,
        );
        let request = types::dri3::PixmapFromBufferRequest {
            pixmap,
            drawable,
            size,
            width,
            height,
            stride,
            depth,
            bpp,
            pixmap_fd,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffer_checked<'this>(
        &'this mut self,
        pixmap: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        size: types::Card32,
        width: types::Card16,
        height: types::Card16,
        stride: types::Card16,
        depth: types::Card8,
        bpp: types::Card8,
        pixmap_fd: types::Fd,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.dri3_pixmap_from_buffer(
            pixmap, drawable, size, width, height, stride, depth, bpp, pixmap_fd,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffer_from_pixmap<'this>(
        &'this mut self,
        pixmap: types::xproto::Pixmap,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri3::BufferFromPixmapReply>> {
        let span = tracing::info_span!(
            "dri3_buffer_from_pixmap",
            pixmap = ?pixmap,
        );
        let request = types::dri3::BufferFromPixmapRequest { pixmap };
        self.send_reply_fd_request(request).instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffer_from_pixmap_immediate<'this>(
        &'this mut self,
        pixmap: types::xproto::Pixmap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri3::BufferFromPixmapReply>>
    {
        let cookie = self.dri3_buffer_from_pixmap(pixmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::BufferFromPixmapReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fence_from_fd<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        fence: types::Card32,
        initially_triggered: types::Bool,
        fence_fd: types::Fd,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "dri3_fence_from_fd",
            drawable = ?drawable,
            fence = ?fence,
            initially_triggered = ?initially_triggered,
            fence_fd = ?fence_fd,
        );
        let request = types::dri3::FenceFromFDRequest {
            drawable,
            fence,
            initially_triggered,
            fence_fd,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fence_from_fd_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        fence: types::Card32,
        initially_triggered: types::Bool,
        fence_fd: types::Fd,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.dri3_fence_from_fd(drawable, fence, initially_triggered, fence_fd);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fd_from_fence<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        fence: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri3::FDFromFenceReply>> {
        let span = tracing::info_span!(
            "dri3_fd_from_fence",
            drawable = ?drawable,
            fence = ?fence,
        );
        let request = types::dri3::FDFromFenceRequest { drawable, fence };
        self.send_reply_fd_request(request).instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_fd_from_fence_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        fence: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri3::FDFromFenceReply>> {
        let cookie = self.dri3_fd_from_fence(drawable, fence);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::FDFromFenceReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_get_supported_modifiers<'this>(
        &'this mut self,
        window: types::Card32,
        depth: types::Card8,
        bpp: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri3::GetSupportedModifiersReply>>
    {
        let span = tracing::info_span!(
            "dri3_get_supported_modifiers",
            window = ?window,
            depth = ?depth,
            bpp = ?bpp,
        );
        let request = types::dri3::GetSupportedModifiersRequest { window, depth, bpp };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_get_supported_modifiers_immediate<'this>(
        &'this mut self,
        window: types::Card32,
        depth: types::Card8,
        bpp: types::Card8,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::dri3::GetSupportedModifiersReply>,
    > {
        let cookie = self.dri3_get_supported_modifiers(window, depth, bpp);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::GetSupportedModifiersReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffers<'this>(
        &'this mut self,
        pixmap: types::xproto::Pixmap,
        window: types::xproto::Window,
        width: types::Card16,
        height: types::Card16,
        stride0: types::Card32,
        offset0: types::Card32,
        stride1: types::Card32,
        offset1: types::Card32,
        stride2: types::Card32,
        offset2: types::Card32,
        stride3: types::Card32,
        offset3: types::Card32,
        depth: types::Card8,
        bpp: types::Card8,
        modifier: types::Card64,
        buffers: Vec<types::Fd>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "dri3_pixmap_from_buffers",
            pixmap = ?pixmap,
            window = ?window,
            width = ?width,
            height = ?height,
            stride0 = ?stride0,
            offset0 = ?offset0,
            stride1 = ?stride1,
            offset1 = ?offset1,
            stride2 = ?stride2,
            offset2 = ?offset2,
            stride3 = ?stride3,
            offset3 = ?offset3,
            depth = ?depth,
            bpp = ?bpp,
            modifier = ?modifier,
        );
        let request = types::dri3::PixmapFromBuffersRequest {
            pixmap,
            window,
            width,
            height,
            stride0,
            offset0,
            stride1,
            offset1,
            stride2,
            offset2,
            stride3,
            offset3,
            depth,
            bpp,
            modifier,
            buffers,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_pixmap_from_buffers_checked<'this>(
        &'this mut self,
        pixmap: types::xproto::Pixmap,
        window: types::xproto::Window,
        width: types::Card16,
        height: types::Card16,
        stride0: types::Card32,
        offset0: types::Card32,
        stride1: types::Card32,
        offset1: types::Card32,
        stride2: types::Card32,
        offset2: types::Card32,
        stride3: types::Card32,
        offset3: types::Card32,
        depth: types::Card8,
        bpp: types::Card8,
        modifier: types::Card64,
        buffers: Vec<types::Fd>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.dri3_pixmap_from_buffers(
            pixmap, window, width, height, stride0, offset0, stride1, offset1, stride2, offset2,
            stride3, offset3, depth, bpp, modifier, buffers,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffers_from_pixmap<'this>(
        &'this mut self,
        pixmap: types::xproto::Pixmap,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::dri3::BuffersFromPixmapReply>> {
        let span = tracing::info_span!(
            "dri3_buffers_from_pixmap",
            pixmap = ?pixmap,
        );
        let request = types::dri3::BuffersFromPixmapRequest { pixmap };
        self.send_reply_fd_request(request).instrument(span)
    }
    #[cfg(feature = "dri3")]
    fn dri3_buffers_from_pixmap_immediate<'this>(
        &'this mut self,
        pixmap: types::xproto::Pixmap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::dri3::BuffersFromPixmapReply>>
    {
        let cookie = self.dri3_buffers_from_pixmap(pixmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::dri3::BuffersFromPixmapReply> =
            cookie.into();
        res.instrument(span)
    }

    fn ge_query_version<'this>(
        &'this mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::ge::QueryVersionReply>> {
        let span = tracing::info_span!(
            "ge_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::ge::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn ge_query_version_immediate<'this>(
        &'this mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::ge::QueryVersionReply>> {
        let cookie = self.ge_query_version(client_major_version, client_minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::ge::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "glx")]
    fn glx_render<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_render",
            context_tag = ?context_tag,
        );
        let request = types::glx::RenderRequest {
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_render_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_render(context_tag, data);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_render_large<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        request_num: types::Card16,
        request_total: types::Card16,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_render_large",
            context_tag = ?context_tag,
            request_num = ?request_num,
            request_total = ?request_total,
        );
        let request = types::glx::RenderLargeRequest {
            context_tag,
            request_num,
            request_total,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_render_large_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        request_num: types::Card16,
        request_total: types::Card16,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_render_large(context_tag, request_num, request_total, data);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context<'this>(
        &'this mut self,
        context: types::glx::Context,
        visual: types::Visualid,
        screen: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_create_context",
            context = ?context,
            visual = ?visual,
            screen = ?screen,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let request = types::glx::CreateContextRequest {
            context,
            visual,
            screen,
            share_list,
            is_direct,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_checked<'this>(
        &'this mut self,
        context: types::glx::Context,
        visual: types::Visualid,
        screen: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_create_context(context, visual, screen, share_list, is_direct);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_context<'this>(
        &'this mut self,
        context: types::glx::Context,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_destroy_context",
            context = ?context,
        );
        let request = types::glx::DestroyContextRequest { context };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_context_checked<'this>(
        &'this mut self,
        context: types::glx::Context,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_destroy_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_make_current<'this>(
        &'this mut self,
        drawable: types::glx::Drawable,
        context: types::glx::Context,
        old_context_tag: types::ContextTag,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::MakeCurrentReply>> {
        let span = tracing::info_span!(
            "glx_make_current",
            drawable = ?drawable,
            context = ?context,
            old_context_tag = ?old_context_tag,
        );
        let request = types::glx::MakeCurrentRequest {
            drawable,
            context,
            old_context_tag,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_make_current_immediate<'this>(
        &'this mut self,
        drawable: types::glx::Drawable,
        context: types::glx::Context,
        old_context_tag: types::ContextTag,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::MakeCurrentReply>> {
        let cookie = self.glx_make_current(drawable, context, old_context_tag);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::MakeCurrentReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_is_direct<'this>(
        &'this mut self,
        context: types::glx::Context,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::IsDirectReply>> {
        let span = tracing::info_span!(
            "glx_is_direct",
            context = ?context,
        );
        let request = types::glx::IsDirectRequest { context };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_is_direct_immediate<'this>(
        &'this mut self,
        context: types::glx::Context,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::IsDirectReply>> {
        let cookie = self.glx_is_direct(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::IsDirectReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_query_version<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::QueryVersionReply>> {
        let span = tracing::info_span!(
            "glx_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::glx::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_query_version_immediate<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::QueryVersionReply>> {
        let cookie = self.glx_query_version(major_version, minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_gl<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_wait_gl",
            context_tag = ?context_tag,
        );
        let request = types::glx::WaitGLRequest { context_tag };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_gl_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_wait_gl(context_tag);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_x<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_wait_x",
            context_tag = ?context_tag,
        );
        let request = types::glx::WaitXRequest { context_tag };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_wait_x_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_wait_x(context_tag);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_copy_context<'this>(
        &'this mut self,
        src: types::glx::Context,
        dest: types::glx::Context,
        mask: types::Card32,
        src_context_tag: types::ContextTag,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_copy_context",
            src = ?src,
            dest = ?dest,
            mask = ?mask,
            src_context_tag = ?src_context_tag,
        );
        let request = types::glx::CopyContextRequest {
            src,
            dest,
            mask,
            src_context_tag,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_copy_context_checked<'this>(
        &'this mut self,
        src: types::glx::Context,
        dest: types::glx::Context,
        mask: types::Card32,
        src_context_tag: types::ContextTag,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_copy_context(src, dest, mask, src_context_tag);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_swap_buffers<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        drawable: types::glx::Drawable,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_swap_buffers",
            context_tag = ?context_tag,
            drawable = ?drawable,
        );
        let request = types::glx::SwapBuffersRequest {
            context_tag,
            drawable,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_swap_buffers_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        drawable: types::glx::Drawable,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_swap_buffers(context_tag, drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_use_x_font<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        font: types::Font,
        first: types::Card32,
        count: types::Card32,
        list_base: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_use_x_font",
            context_tag = ?context_tag,
            font = ?font,
            first = ?first,
            count = ?count,
            list_base = ?list_base,
        );
        let request = types::glx::UseXFontRequest {
            context_tag,
            font,
            first,
            count,
            list_base,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_use_x_font_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        font: types::Font,
        first: types::Card32,
        count: types::Card32,
        list_base: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_use_x_font(context_tag, font, first, count, list_base);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_glx_pixmap<'this>(
        &'this mut self,
        screen: types::Card32,
        visual: types::Visualid,
        pixmap: types::xproto::Pixmap,
        glx_pixmap: types::glx::Pixmap,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_create_glx_pixmap",
            screen = ?screen,
            visual = ?visual,
            pixmap = ?pixmap,
            glx_pixmap = ?glx_pixmap,
        );
        let request = types::glx::CreateGLXPixmapRequest {
            screen,
            visual,
            pixmap,
            glx_pixmap,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_glx_pixmap_checked<'this>(
        &'this mut self,
        screen: types::Card32,
        visual: types::Visualid,
        pixmap: types::xproto::Pixmap,
        glx_pixmap: types::glx::Pixmap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_create_glx_pixmap(screen, visual, pixmap, glx_pixmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_visual_configs<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetVisualConfigsReply>> {
        let span = tracing::info_span!(
            "glx_get_visual_configs",
            screen = ?screen,
        );
        let request = types::glx::GetVisualConfigsRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_visual_configs_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetVisualConfigsReply>>
    {
        let cookie = self.glx_get_visual_configs(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetVisualConfigsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_glx_pixmap<'this>(
        &'this mut self,
        glx_pixmap: types::glx::Pixmap,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_destroy_glx_pixmap",
            glx_pixmap = ?glx_pixmap,
        );
        let request = types::glx::DestroyGLXPixmapRequest { glx_pixmap };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_glx_pixmap_checked<'this>(
        &'this mut self,
        glx_pixmap: types::glx::Pixmap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_destroy_glx_pixmap(glx_pixmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private<'this>(
        &'this mut self,
        vendor_code: types::Card32,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_vendor_private",
            vendor_code = ?vendor_code,
            context_tag = ?context_tag,
        );
        let request = types::glx::VendorPrivateRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_checked<'this>(
        &'this mut self,
        vendor_code: types::Card32,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_vendor_private(vendor_code, context_tag, data);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_with_reply<'this>(
        &'this mut self,
        vendor_code: types::Card32,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::VendorPrivateWithReplyReply>>
    {
        let span = tracing::info_span!(
            "glx_vendor_private_with_reply",
            vendor_code = ?vendor_code,
            context_tag = ?context_tag,
        );
        let request = types::glx::VendorPrivateWithReplyRequest {
            vendor_code,
            context_tag,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_vendor_private_with_reply_immediate<'this>(
        &'this mut self,
        vendor_code: types::Card32,
        context_tag: types::ContextTag,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::VendorPrivateWithReplyReply>,
    > {
        let cookie = self.glx_vendor_private_with_reply(vendor_code, context_tag, data);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::VendorPrivateWithReplyReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_query_extensions_string<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::QueryExtensionsStringReply>>
    {
        let span = tracing::info_span!(
            "glx_query_extensions_string",
            screen = ?screen,
        );
        let request = types::glx::QueryExtensionsStringRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_query_extensions_string_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::QueryExtensionsStringReply>,
    > {
        let cookie = self.glx_query_extensions_string(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::QueryExtensionsStringReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_query_server_string<'this>(
        &'this mut self,
        screen: types::Card32,
        name: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::QueryServerStringReply>> {
        let span = tracing::info_span!(
            "glx_query_server_string",
            screen = ?screen,
            name = ?name,
        );
        let request = types::glx::QueryServerStringRequest { screen, name };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_query_server_string_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
        name: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::QueryServerStringReply>>
    {
        let cookie = self.glx_query_server_string(screen, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::QueryServerStringReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_client_info<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        string: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_client_info",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::glx::ClientInfoRequest {
            major_version,
            minor_version,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_client_info_checked<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        string: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_client_info(major_version, minor_version, string);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_fb_configs<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetFBConfigsReply>> {
        let span = tracing::info_span!(
            "glx_get_fb_configs",
            screen = ?screen,
        );
        let request = types::glx::GetFBConfigsRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_fb_configs_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetFBConfigsReply>> {
        let cookie = self.glx_get_fb_configs(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetFBConfigsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pixmap<'this>(
        &'this mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        pixmap: types::xproto::Pixmap,
        glx_pixmap: types::glx::Pixmap,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_create_pixmap",
            screen = ?screen,
            fbconfig = ?fbconfig,
            pixmap = ?pixmap,
            glx_pixmap = ?glx_pixmap,
        );
        let request = types::glx::CreatePixmapRequest {
            screen,
            fbconfig,
            pixmap,
            glx_pixmap,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pixmap_checked<'this>(
        &'this mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        pixmap: types::xproto::Pixmap,
        glx_pixmap: types::glx::Pixmap,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_create_pixmap(screen, fbconfig, pixmap, glx_pixmap, attribs);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pixmap<'this>(
        &'this mut self,
        glx_pixmap: types::glx::Pixmap,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_destroy_pixmap",
            glx_pixmap = ?glx_pixmap,
        );
        let request = types::glx::DestroyPixmapRequest { glx_pixmap };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pixmap_checked<'this>(
        &'this mut self,
        glx_pixmap: types::glx::Pixmap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_destroy_pixmap(glx_pixmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_new_context<'this>(
        &'this mut self,
        context: types::glx::Context,
        fbconfig: types::Fbconfig,
        screen: types::Card32,
        render_type: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_create_new_context",
            context = ?context,
            fbconfig = ?fbconfig,
            screen = ?screen,
            render_type = ?render_type,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let request = types::glx::CreateNewContextRequest {
            context,
            fbconfig,
            screen,
            render_type,
            share_list,
            is_direct,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_new_context_checked<'this>(
        &'this mut self,
        context: types::glx::Context,
        fbconfig: types::Fbconfig,
        screen: types::Card32,
        render_type: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_create_new_context(
            context,
            fbconfig,
            screen,
            render_type,
            share_list,
            is_direct,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_query_context<'this>(
        &'this mut self,
        context: types::glx::Context,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::QueryContextReply>> {
        let span = tracing::info_span!(
            "glx_query_context",
            context = ?context,
        );
        let request = types::glx::QueryContextRequest { context };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_query_context_immediate<'this>(
        &'this mut self,
        context: types::glx::Context,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::QueryContextReply>> {
        let cookie = self.glx_query_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::QueryContextReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_make_context_current<'this>(
        &'this mut self,
        old_context_tag: types::ContextTag,
        drawable: types::glx::Drawable,
        read_drawable: types::glx::Drawable,
        context: types::glx::Context,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::MakeContextCurrentReply>> {
        let span = tracing::info_span!(
            "glx_make_context_current",
            old_context_tag = ?old_context_tag,
            drawable = ?drawable,
            read_drawable = ?read_drawable,
            context = ?context,
        );
        let request = types::glx::MakeContextCurrentRequest {
            old_context_tag,
            drawable,
            read_drawable,
            context,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_make_context_current_immediate<'this>(
        &'this mut self,
        old_context_tag: types::ContextTag,
        drawable: types::glx::Drawable,
        read_drawable: types::glx::Drawable,
        context: types::glx::Context,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::MakeContextCurrentReply>>
    {
        let cookie =
            self.glx_make_context_current(old_context_tag, drawable, read_drawable, context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::MakeContextCurrentReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pbuffer<'this>(
        &'this mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        pbuffer: types::Pbuffer,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_create_pbuffer",
            screen = ?screen,
            fbconfig = ?fbconfig,
            pbuffer = ?pbuffer,
        );
        let request = types::glx::CreatePbufferRequest {
            screen,
            fbconfig,
            pbuffer,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_pbuffer_checked<'this>(
        &'this mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        pbuffer: types::Pbuffer,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_create_pbuffer(screen, fbconfig, pbuffer, attribs);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pbuffer<'this>(
        &'this mut self,
        pbuffer: types::Pbuffer,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_destroy_pbuffer",
            pbuffer = ?pbuffer,
        );
        let request = types::glx::DestroyPbufferRequest { pbuffer };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_destroy_pbuffer_checked<'this>(
        &'this mut self,
        pbuffer: types::Pbuffer,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_destroy_pbuffer(pbuffer);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_drawable_attributes<'this>(
        &'this mut self,
        drawable: types::glx::Drawable,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetDrawableAttributesReply>>
    {
        let span = tracing::info_span!(
            "glx_get_drawable_attributes",
            drawable = ?drawable,
        );
        let request = types::glx::GetDrawableAttributesRequest { drawable };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_drawable_attributes_immediate<'this>(
        &'this mut self,
        drawable: types::glx::Drawable,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::GetDrawableAttributesReply>,
    > {
        let cookie = self.glx_get_drawable_attributes(drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetDrawableAttributesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_change_drawable_attributes<'this>(
        &'this mut self,
        drawable: types::glx::Drawable,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_change_drawable_attributes",
            drawable = ?drawable,
        );
        let request = types::glx::ChangeDrawableAttributesRequest {
            drawable,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_change_drawable_attributes_checked<'this>(
        &'this mut self,
        drawable: types::glx::Drawable,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_change_drawable_attributes(drawable, attribs);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_window<'this>(
        &'this mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        window: types::xproto::Window,
        glx_window: types::glx::Window,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_create_window",
            screen = ?screen,
            fbconfig = ?fbconfig,
            window = ?window,
            glx_window = ?glx_window,
        );
        let request = types::glx::CreateWindowRequest {
            screen,
            fbconfig,
            window,
            glx_window,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_window_checked<'this>(
        &'this mut self,
        screen: types::Card32,
        fbconfig: types::Fbconfig,
        window: types::xproto::Window,
        glx_window: types::glx::Window,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_create_window(screen, fbconfig, window, glx_window, attribs);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_window<'this>(
        &'this mut self,
        glxwindow: types::glx::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_delete_window",
            glxwindow = ?glxwindow,
        );
        let request = types::glx::DeleteWindowRequest { glxwindow };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_window_checked<'this>(
        &'this mut self,
        glxwindow: types::glx::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_delete_window(glxwindow);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info_arb<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        gl_versions: impl AsRef<[types::Card32]>,
        gl_extension_string: impl AsRef<[types::Char]>,
        glx_extension_string: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_set_client_info_arb",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::glx::SetClientInfoARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info_arb_checked<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        gl_versions: impl AsRef<[types::Card32]>,
        gl_extension_string: impl AsRef<[types::Char]>,
        glx_extension_string: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_set_client_info_arb(
            major_version,
            minor_version,
            gl_versions,
            gl_extension_string,
            glx_extension_string,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_attribs_arb<'this>(
        &'this mut self,
        context: types::glx::Context,
        fbconfig: types::Fbconfig,
        screen: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_create_context_attribs_arb",
            context = ?context,
            fbconfig = ?fbconfig,
            screen = ?screen,
            share_list = ?share_list,
            is_direct = ?is_direct,
        );
        let request = types::glx::CreateContextAttribsARBRequest {
            context,
            fbconfig,
            screen,
            share_list,
            is_direct,
            attribs: Cow::Borrowed(attribs.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_create_context_attribs_arb_checked<'this>(
        &'this mut self,
        context: types::glx::Context,
        fbconfig: types::Fbconfig,
        screen: types::Card32,
        share_list: types::glx::Context,
        is_direct: types::Bool,
        attribs: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_create_context_attribs_arb(
            context, fbconfig, screen, share_list, is_direct, attribs,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info2_arb<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        gl_versions: impl AsRef<[types::Card32]>,
        gl_extension_string: impl AsRef<[types::Char]>,
        glx_extension_string: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_set_client_info2_arb",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::glx::SetClientInfo2ARBRequest {
            major_version,
            minor_version,
            gl_versions: Cow::Borrowed(gl_versions.as_ref()),
            gl_extension_string: Cow::Borrowed(gl_extension_string.as_ref()),
            glx_extension_string: Cow::Borrowed(glx_extension_string.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_set_client_info2_arb_checked<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
        gl_versions: impl AsRef<[types::Card32]>,
        gl_extension_string: impl AsRef<[types::Char]>,
        glx_extension_string: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_set_client_info2_arb(
            major_version,
            minor_version,
            gl_versions,
            gl_extension_string,
            glx_extension_string,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_new_list<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
        mode: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_new_list",
            context_tag = ?context_tag,
            list = ?list,
            mode = ?mode,
        );
        let request = types::glx::NewListRequest {
            context_tag,
            list,
            mode,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_new_list_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
        mode: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_new_list(context_tag, list, mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_end_list<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_end_list",
            context_tag = ?context_tag,
        );
        let request = types::glx::EndListRequest { context_tag };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_end_list_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_end_list(context_tag);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_lists<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
        range: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_delete_lists",
            context_tag = ?context_tag,
            list = ?list,
            range = ?range,
        );
        let request = types::glx::DeleteListsRequest {
            context_tag,
            list,
            range,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_lists_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
        range: types::Int32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_delete_lists(context_tag, list, range);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_lists<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        range: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GenListsReply>> {
        let span = tracing::info_span!(
            "glx_gen_lists",
            context_tag = ?context_tag,
            range = ?range,
        );
        let request = types::glx::GenListsRequest { context_tag, range };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_lists_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        range: types::Int32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GenListsReply>> {
        let cookie = self.glx_gen_lists(context_tag, range);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GenListsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_feedback_buffer<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        size: types::Int32,
        type_: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_feedback_buffer",
            context_tag = ?context_tag,
            size = ?size,
            type_ = ?type_,
        );
        let request = types::glx::FeedbackBufferRequest {
            context_tag,
            size,
            type_,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_feedback_buffer_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        size: types::Int32,
        type_: types::Int32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_feedback_buffer(context_tag, size, type_);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_select_buffer<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        size: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_select_buffer",
            context_tag = ?context_tag,
            size = ?size,
        );
        let request = types::glx::SelectBufferRequest { context_tag, size };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_select_buffer_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        size: types::Int32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_select_buffer(context_tag, size);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_render_mode<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        mode: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::RenderModeReply>> {
        let span = tracing::info_span!(
            "glx_render_mode",
            context_tag = ?context_tag,
            mode = ?mode,
        );
        let request = types::glx::RenderModeRequest { context_tag, mode };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_render_mode_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        mode: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::RenderModeReply>> {
        let cookie = self.glx_render_mode(context_tag, mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::RenderModeReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_finish<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::FinishReply>> {
        let span = tracing::info_span!(
            "glx_finish",
            context_tag = ?context_tag,
        );
        let request = types::glx::FinishRequest { context_tag };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_finish_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::FinishReply>> {
        let cookie = self.glx_finish(context_tag);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::FinishReply> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storef<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
        datum: types::Float32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_pixel_storef",
            context_tag = ?context_tag,
            pname = ?pname,
            datum = ?datum,
        );
        let request = types::glx::PixelStorefRequest {
            context_tag,
            pname,
            datum,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storef_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
        datum: types::Float32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_pixel_storef(context_tag, pname, datum);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storei<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
        datum: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_pixel_storei",
            context_tag = ?context_tag,
            pname = ?pname,
            datum = ?datum,
        );
        let request = types::glx::PixelStoreiRequest {
            context_tag,
            pname,
            datum,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_pixel_storei_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
        datum: types::Int32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_pixel_storei(context_tag, pname, datum);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_read_pixels<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        x: types::Int32,
        y: types::Int32,
        width: types::Int32,
        height: types::Int32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        lsb_first: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::ReadPixelsReply>> {
        let span = tracing::info_span!(
            "glx_read_pixels",
            context_tag = ?context_tag,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            lsb_first = ?lsb_first,
        );
        let request = types::glx::ReadPixelsRequest {
            context_tag,
            x,
            y,
            width,
            height,
            format,
            type_,
            swap_bytes,
            lsb_first,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_read_pixels_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        x: types::Int32,
        y: types::Int32,
        width: types::Int32,
        height: types::Int32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        lsb_first: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::ReadPixelsReply>> {
        let cookie = self.glx_read_pixels(
            context_tag,
            x,
            y,
            width,
            height,
            format,
            type_,
            swap_bytes,
            lsb_first,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::ReadPixelsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_booleanv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetBooleanvReply>> {
        let span = tracing::info_span!(
            "glx_get_booleanv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let request = types::glx::GetBooleanvRequest { context_tag, pname };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_booleanv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Int32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetBooleanvReply>> {
        let cookie = self.glx_get_booleanv(context_tag, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetBooleanvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_clip_plane<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        plane: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetClipPlaneReply>> {
        let span = tracing::info_span!(
            "glx_get_clip_plane",
            context_tag = ?context_tag,
            plane = ?plane,
        );
        let request = types::glx::GetClipPlaneRequest { context_tag, plane };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_clip_plane_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        plane: types::Int32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetClipPlaneReply>> {
        let cookie = self.glx_get_clip_plane(context_tag, plane);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetClipPlaneReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_doublev<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetDoublevReply>> {
        let span = tracing::info_span!(
            "glx_get_doublev",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let request = types::glx::GetDoublevRequest { context_tag, pname };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_doublev_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetDoublevReply>> {
        let cookie = self.glx_get_doublev(context_tag, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetDoublevReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_error<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetErrorReply>> {
        let span = tracing::info_span!(
            "glx_get_error",
            context_tag = ?context_tag,
        );
        let request = types::glx::GetErrorRequest { context_tag };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_error_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetErrorReply>> {
        let cookie = self.glx_get_error(context_tag);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetErrorReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_floatv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetFloatvReply>> {
        let span = tracing::info_span!(
            "glx_get_floatv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let request = types::glx::GetFloatvRequest { context_tag, pname };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_floatv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetFloatvReply>> {
        let cookie = self.glx_get_floatv(context_tag, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetFloatvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_integerv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetIntegervReply>> {
        let span = tracing::info_span!(
            "glx_get_integerv",
            context_tag = ?context_tag,
            pname = ?pname,
        );
        let request = types::glx::GetIntegervRequest { context_tag, pname };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_integerv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetIntegervReply>> {
        let cookie = self.glx_get_integerv(context_tag, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetIntegervReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        light: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetLightfvReply>> {
        let span = tracing::info_span!(
            "glx_get_lightfv",
            context_tag = ?context_tag,
            light = ?light,
            pname = ?pname,
        );
        let request = types::glx::GetLightfvRequest {
            context_tag,
            light,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        light: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetLightfvReply>> {
        let cookie = self.glx_get_lightfv(context_tag, light, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetLightfvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightiv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        light: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetLightivReply>> {
        let span = tracing::info_span!(
            "glx_get_lightiv",
            context_tag = ?context_tag,
            light = ?light,
            pname = ?pname,
        );
        let request = types::glx::GetLightivRequest {
            context_tag,
            light,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_lightiv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        light: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetLightivReply>> {
        let cookie = self.glx_get_lightiv(context_tag, light, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetLightivReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapdv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetMapdvReply>> {
        let span = tracing::info_span!(
            "glx_get_mapdv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let request = types::glx::GetMapdvRequest {
            context_tag,
            target,
            query,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapdv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetMapdvReply>> {
        let cookie = self.glx_get_mapdv(context_tag, target, query);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMapdvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetMapfvReply>> {
        let span = tracing::info_span!(
            "glx_get_mapfv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let request = types::glx::GetMapfvRequest {
            context_tag,
            target,
            query,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetMapfvReply>> {
        let cookie = self.glx_get_mapfv(context_tag, target, query);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMapfvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapiv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetMapivReply>> {
        let span = tracing::info_span!(
            "glx_get_mapiv",
            context_tag = ?context_tag,
            target = ?target,
            query = ?query,
        );
        let request = types::glx::GetMapivRequest {
            context_tag,
            target,
            query,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_mapiv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        query: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetMapivReply>> {
        let cookie = self.glx_get_mapiv(context_tag, target, query);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMapivReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        face: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetMaterialfvReply>> {
        let span = tracing::info_span!(
            "glx_get_materialfv",
            context_tag = ?context_tag,
            face = ?face,
            pname = ?pname,
        );
        let request = types::glx::GetMaterialfvRequest {
            context_tag,
            face,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        face: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetMaterialfvReply>>
    {
        let cookie = self.glx_get_materialfv(context_tag, face, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMaterialfvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialiv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        face: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetMaterialivReply>> {
        let span = tracing::info_span!(
            "glx_get_materialiv",
            context_tag = ?context_tag,
            face = ?face,
            pname = ?pname,
        );
        let request = types::glx::GetMaterialivRequest {
            context_tag,
            face,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_materialiv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        face: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetMaterialivReply>>
    {
        let cookie = self.glx_get_materialiv(context_tag, face, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMaterialivReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetPixelMapfvReply>> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapfv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let request = types::glx::GetPixelMapfvRequest { context_tag, map };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapfvReply>>
    {
        let cookie = self.glx_get_pixel_mapfv(context_tag, map);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapfvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapuiv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetPixelMapuivReply>> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapuiv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let request = types::glx::GetPixelMapuivRequest { context_tag, map };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapuiv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapuivReply>>
    {
        let cookie = self.glx_get_pixel_mapuiv(context_tag, map);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapuivReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapusv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetPixelMapusvReply>> {
        let span = tracing::info_span!(
            "glx_get_pixel_mapusv",
            context_tag = ?context_tag,
            map = ?map,
        );
        let request = types::glx::GetPixelMapusvRequest { context_tag, map };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_pixel_mapusv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        map: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapusvReply>>
    {
        let cookie = self.glx_get_pixel_mapusv(context_tag, map);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetPixelMapusvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_polygon_stipple<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        lsb_first: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetPolygonStippleReply>> {
        let span = tracing::info_span!(
            "glx_get_polygon_stipple",
            context_tag = ?context_tag,
            lsb_first = ?lsb_first,
        );
        let request = types::glx::GetPolygonStippleRequest {
            context_tag,
            lsb_first,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_polygon_stipple_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        lsb_first: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetPolygonStippleReply>>
    {
        let cookie = self.glx_get_polygon_stipple(context_tag, lsb_first);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetPolygonStippleReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_string<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        name: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetStringReply>> {
        let span = tracing::info_span!(
            "glx_get_string",
            context_tag = ?context_tag,
            name = ?name,
        );
        let request = types::glx::GetStringRequest { context_tag, name };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_string_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        name: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetStringReply>> {
        let cookie = self.glx_get_string(context_tag, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetStringReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_envfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetTexEnvfvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_envfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetTexEnvfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_envfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetTexEnvfvReply>> {
        let cookie = self.glx_get_tex_envfv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexEnvfvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_enviv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetTexEnvivReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_enviv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetTexEnvivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_enviv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetTexEnvivReply>> {
        let cookie = self.glx_get_tex_enviv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexEnvivReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_gendv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetTexGendvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_gendv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let request = types::glx::GetTexGendvRequest {
            context_tag,
            coord,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_gendv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetTexGendvReply>> {
        let cookie = self.glx_get_tex_gendv(context_tag, coord, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexGendvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_genfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetTexGenfvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_genfv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let request = types::glx::GetTexGenfvRequest {
            context_tag,
            coord,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_genfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetTexGenfvReply>> {
        let cookie = self.glx_get_tex_genfv(context_tag, coord, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexGenfvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_geniv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetTexGenivReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_geniv",
            context_tag = ?context_tag,
            coord = ?coord,
            pname = ?pname,
        );
        let request = types::glx::GetTexGenivRequest {
            context_tag,
            coord,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_geniv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        coord: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetTexGenivReply>> {
        let cookie = self.glx_get_tex_geniv(context_tag, coord, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexGenivReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_image<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetTexImageReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_image",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let request = types::glx::GetTexImageRequest {
            context_tag,
            target,
            level,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_image_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetTexImageReply>> {
        let cookie = self.glx_get_tex_image(context_tag, target, level, format, type_, swap_bytes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexImageReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameterfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetTexParameterfvReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetTexParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameterfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetTexParameterfvReply>>
    {
        let cookie = self.glx_get_tex_parameterfv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexParameterfvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameteriv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetTexParameterivReply>> {
        let span = tracing::info_span!(
            "glx_get_tex_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetTexParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_parameteriv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetTexParameterivReply>>
    {
        let cookie = self.glx_get_tex_parameteriv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexParameterivReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameterfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetTexLevelParameterfvReply>>
    {
        let span = tracing::info_span!(
            "glx_get_tex_level_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            pname = ?pname,
        );
        let request = types::glx::GetTexLevelParameterfvRequest {
            context_tag,
            target,
            level,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameterfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        pname: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::GetTexLevelParameterfvReply>,
    > {
        let cookie = self.glx_get_tex_level_parameterfv(context_tag, target, level, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexLevelParameterfvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameteriv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetTexLevelParameterivReply>>
    {
        let span = tracing::info_span!(
            "glx_get_tex_level_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
            pname = ?pname,
        );
        let request = types::glx::GetTexLevelParameterivRequest {
            context_tag,
            target,
            level,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_tex_level_parameteriv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
        pname: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::GetTexLevelParameterivReply>,
    > {
        let cookie = self.glx_get_tex_level_parameteriv(context_tag, target, level, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetTexLevelParameterivReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_is_enabled<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        capability: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::IsEnabledReply>> {
        let span = tracing::info_span!(
            "glx_is_enabled",
            context_tag = ?context_tag,
            capability = ?capability,
        );
        let request = types::glx::IsEnabledRequest {
            context_tag,
            capability,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_is_enabled_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        capability: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::IsEnabledReply>> {
        let cookie = self.glx_is_enabled(context_tag, capability);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::IsEnabledReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_is_list<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::IsListReply>> {
        let span = tracing::info_span!(
            "glx_is_list",
            context_tag = ?context_tag,
            list = ?list,
        );
        let request = types::glx::IsListRequest { context_tag, list };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_is_list_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        list: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::IsListReply>> {
        let cookie = self.glx_is_list(context_tag, list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::IsListReply> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_flush<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_flush",
            context_tag = ?context_tag,
        );
        let request = types::glx::FlushRequest { context_tag };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_flush_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_flush(context_tag);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_are_textures_resident<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        textures: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::AreTexturesResidentReply>> {
        let span = tracing::info_span!(
            "glx_are_textures_resident",
            context_tag = ?context_tag,
        );
        let request = types::glx::AreTexturesResidentRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_are_textures_resident_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        textures: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::AreTexturesResidentReply>>
    {
        let cookie = self.glx_are_textures_resident(context_tag, textures);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::AreTexturesResidentReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_textures<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        textures: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_delete_textures",
            context_tag = ?context_tag,
        );
        let request = types::glx::DeleteTexturesRequest {
            context_tag,
            textures: Cow::Borrowed(textures.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_textures_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        textures: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_delete_textures(context_tag, textures);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_textures<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        n: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GenTexturesReply>> {
        let span = tracing::info_span!(
            "glx_gen_textures",
            context_tag = ?context_tag,
            n = ?n,
        );
        let request = types::glx::GenTexturesRequest { context_tag, n };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_textures_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        n: types::Int32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GenTexturesReply>> {
        let cookie = self.glx_gen_textures(context_tag, n);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GenTexturesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_is_texture<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        texture: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::IsTextureReply>> {
        let span = tracing::info_span!(
            "glx_is_texture",
            context_tag = ?context_tag,
            texture = ?texture,
        );
        let request = types::glx::IsTextureRequest {
            context_tag,
            texture,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_is_texture_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        texture: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::IsTextureReply>> {
        let cookie = self.glx_is_texture(context_tag, texture);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::IsTextureReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetColorTableReply>> {
        let span = tracing::info_span!(
            "glx_get_color_table",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let request = types::glx::GetColorTableRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetColorTableReply>>
    {
        let cookie = self.glx_get_color_table(context_tag, target, format, type_, swap_bytes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetColorTableReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameterfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetColorTableParameterfvReply>>
    {
        let span = tracing::info_span!(
            "glx_get_color_table_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetColorTableParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameterfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::GetColorTableParameterfvReply>,
    > {
        let cookie = self.glx_get_color_table_parameterfv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::glx::GetColorTableParameterfvReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameteriv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetColorTableParameterivReply>>
    {
        let span = tracing::info_span!(
            "glx_get_color_table_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetColorTableParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_color_table_parameteriv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::GetColorTableParameterivReply>,
    > {
        let cookie = self.glx_get_color_table_parameteriv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::glx::GetColorTableParameterivReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_filter<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetConvolutionFilterReply>>
    {
        let span = tracing::info_span!(
            "glx_get_convolution_filter",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let request = types::glx::GetConvolutionFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_filter_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetConvolutionFilterReply>>
    {
        let cookie =
            self.glx_get_convolution_filter(context_tag, target, format, type_, swap_bytes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetConvolutionFilterReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameterfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetConvolutionParameterfvReply>>
    {
        let span = tracing::info_span!(
            "glx_get_convolution_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetConvolutionParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameterfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::GetConvolutionParameterfvReply>,
    > {
        let cookie = self.glx_get_convolution_parameterfv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::glx::GetConvolutionParameterfvReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameteriv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetConvolutionParameterivReply>>
    {
        let span = tracing::info_span!(
            "glx_get_convolution_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetConvolutionParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_convolution_parameteriv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::GetConvolutionParameterivReply>,
    > {
        let cookie = self.glx_get_convolution_parameteriv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::glx::GetConvolutionParameterivReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_separable_filter<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetSeparableFilterReply>> {
        let span = tracing::info_span!(
            "glx_get_separable_filter",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
        );
        let request = types::glx::GetSeparableFilterRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_separable_filter_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetSeparableFilterReply>>
    {
        let cookie = self.glx_get_separable_filter(context_tag, target, format, type_, swap_bytes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetSeparableFilterReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        reset: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetHistogramReply>> {
        let span = tracing::info_span!(
            "glx_get_histogram",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            reset = ?reset,
        );
        let request = types::glx::GetHistogramRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        reset: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetHistogramReply>> {
        let cookie = self.glx_get_histogram(context_tag, target, format, type_, swap_bytes, reset);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetHistogramReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameterfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetHistogramParameterfvReply>>
    {
        let span = tracing::info_span!(
            "glx_get_histogram_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetHistogramParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameterfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::GetHistogramParameterfvReply>,
    > {
        let cookie = self.glx_get_histogram_parameterfv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::glx::GetHistogramParameterfvReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameteriv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetHistogramParameterivReply>>
    {
        let span = tracing::info_span!(
            "glx_get_histogram_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetHistogramParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_histogram_parameteriv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::GetHistogramParameterivReply>,
    > {
        let cookie = self.glx_get_histogram_parameteriv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::glx::GetHistogramParameterivReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        reset: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetMinmaxReply>> {
        let span = tracing::info_span!(
            "glx_get_minmax",
            context_tag = ?context_tag,
            target = ?target,
            format = ?format,
            type_ = ?type_,
            swap_bytes = ?swap_bytes,
            reset = ?reset,
        );
        let request = types::glx::GetMinmaxRequest {
            context_tag,
            target,
            format,
            type_,
            swap_bytes,
            reset,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        format: types::Card32,
        type_: types::Card32,
        swap_bytes: types::Bool,
        reset: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxReply>> {
        let cookie = self.glx_get_minmax(context_tag, target, format, type_, swap_bytes, reset);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameterfv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetMinmaxParameterfvReply>>
    {
        let span = tracing::info_span!(
            "glx_get_minmax_parameterfv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetMinmaxParameterfvRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameterfv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxParameterfvReply>>
    {
        let cookie = self.glx_get_minmax_parameterfv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxParameterfvReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameteriv<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetMinmaxParameterivReply>>
    {
        let span = tracing::info_span!(
            "glx_get_minmax_parameteriv",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetMinmaxParameterivRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_minmax_parameteriv_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxParameterivReply>>
    {
        let cookie = self.glx_get_minmax_parameteriv(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetMinmaxParameterivReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_compressed_tex_image_arb<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetCompressedTexImageARBReply>>
    {
        let span = tracing::info_span!(
            "glx_get_compressed_tex_image_arb",
            context_tag = ?context_tag,
            target = ?target,
            level = ?level,
        );
        let request = types::glx::GetCompressedTexImageARBRequest {
            context_tag,
            target,
            level,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_compressed_tex_image_arb_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        level: types::Int32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::glx::GetCompressedTexImageARBReply>,
    > {
        let cookie = self.glx_get_compressed_tex_image_arb(context_tag, target, level);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::glx::GetCompressedTexImageARBReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_queries_arb<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        ids: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "glx_delete_queries_arb",
            context_tag = ?context_tag,
        );
        let request = types::glx::DeleteQueriesARBRequest {
            context_tag,
            ids: Cow::Borrowed(ids.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_delete_queries_arb_checked<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        ids: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.glx_delete_queries_arb(context_tag, ids);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_queries_arb<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        n: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GenQueriesARBReply>> {
        let span = tracing::info_span!(
            "glx_gen_queries_arb",
            context_tag = ?context_tag,
            n = ?n,
        );
        let request = types::glx::GenQueriesARBRequest { context_tag, n };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_gen_queries_arb_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        n: types::Int32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GenQueriesARBReply>>
    {
        let cookie = self.glx_gen_queries_arb(context_tag, n);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GenQueriesARBReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_is_query_arb<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::IsQueryARBReply>> {
        let span = tracing::info_span!(
            "glx_is_query_arb",
            context_tag = ?context_tag,
            id = ?id,
        );
        let request = types::glx::IsQueryARBRequest { context_tag, id };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_is_query_arb_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::IsQueryARBReply>> {
        let cookie = self.glx_is_query_arb(context_tag, id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::IsQueryARBReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_queryiv_arb<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetQueryivARBReply>> {
        let span = tracing::info_span!(
            "glx_get_queryiv_arb",
            context_tag = ?context_tag,
            target = ?target,
            pname = ?pname,
        );
        let request = types::glx::GetQueryivARBRequest {
            context_tag,
            target,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_queryiv_arb_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        target: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetQueryivARBReply>>
    {
        let cookie = self.glx_get_queryiv_arb(context_tag, target, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetQueryivARBReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectiv_arb<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetQueryObjectivARBReply>> {
        let span = tracing::info_span!(
            "glx_get_query_objectiv_arb",
            context_tag = ?context_tag,
            id = ?id,
            pname = ?pname,
        );
        let request = types::glx::GetQueryObjectivARBRequest {
            context_tag,
            id,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectiv_arb_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetQueryObjectivARBReply>>
    {
        let cookie = self.glx_get_query_objectiv_arb(context_tag, id, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetQueryObjectivARBReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectuiv_arb<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::glx::GetQueryObjectuivARBReply>>
    {
        let span = tracing::info_span!(
            "glx_get_query_objectuiv_arb",
            context_tag = ?context_tag,
            id = ?id,
            pname = ?pname,
        );
        let request = types::glx::GetQueryObjectuivARBRequest {
            context_tag,
            id,
            pname,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "glx")]
    fn glx_get_query_objectuiv_arb_immediate<'this>(
        &'this mut self,
        context_tag: types::ContextTag,
        id: types::Card32,
        pname: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::glx::GetQueryObjectuivARBReply>>
    {
        let cookie = self.glx_get_query_objectuiv_arb(context_tag, id, pname);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::glx::GetQueryObjectuivARBReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "present")]
    fn present_query_version<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::present::QueryVersionReply>> {
        let span = tracing::info_span!(
            "present_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::present::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "present")]
    fn present_query_version_immediate<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::present::QueryVersionReply>>
    {
        let cookie = self.present_query_version(major_version, minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::present::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "present")]
    fn present_pixmap<'this>(
        &'this mut self,
        window: types::xproto::Window,
        pixmap: types::xproto::Pixmap,
        serial: types::Card32,
        valid: types::Region,
        update: types::Region,
        x_off: types::Int16,
        y_off: types::Int16,
        target_crtc: types::Crtc,
        wait_fence: types::Fence,
        idle_fence: types::Fence,
        options: types::Card32,
        target_msc: types::Card64,
        divisor: types::Card64,
        remainder: types::Card64,
        notifies: impl AsRef<[types::present::Notify]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "present_pixmap",
            window = ?window,
            pixmap = ?pixmap,
            serial = ?serial,
            valid = ?valid,
            update = ?update,
            x_off = ?x_off,
            y_off = ?y_off,
            target_crtc = ?target_crtc,
            wait_fence = ?wait_fence,
            idle_fence = ?idle_fence,
            options = ?options,
            target_msc = ?target_msc,
            divisor = ?divisor,
            remainder = ?remainder,
        );
        let request = types::present::PixmapRequest {
            window,
            pixmap,
            serial,
            valid,
            update,
            x_off,
            y_off,
            target_crtc,
            wait_fence,
            idle_fence,
            options,
            target_msc,
            divisor,
            remainder,
            notifies: Cow::Borrowed(notifies.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "present")]
    fn present_pixmap_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        pixmap: types::xproto::Pixmap,
        serial: types::Card32,
        valid: types::Region,
        update: types::Region,
        x_off: types::Int16,
        y_off: types::Int16,
        target_crtc: types::Crtc,
        wait_fence: types::Fence,
        idle_fence: types::Fence,
        options: types::Card32,
        target_msc: types::Card64,
        divisor: types::Card64,
        remainder: types::Card64,
        notifies: impl AsRef<[types::present::Notify]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.present_pixmap(
            window,
            pixmap,
            serial,
            valid,
            update,
            x_off,
            y_off,
            target_crtc,
            wait_fence,
            idle_fence,
            options,
            target_msc,
            divisor,
            remainder,
            notifies,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "present")]
    fn present_notify_msc<'this>(
        &'this mut self,
        window: types::xproto::Window,
        serial: types::Card32,
        target_msc: types::Card64,
        divisor: types::Card64,
        remainder: types::Card64,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "present_notify_msc",
            window = ?window,
            serial = ?serial,
            target_msc = ?target_msc,
            divisor = ?divisor,
            remainder = ?remainder,
        );
        let request = types::present::NotifyMSCRequest {
            window,
            serial,
            target_msc,
            divisor,
            remainder,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "present")]
    fn present_notify_msc_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        serial: types::Card32,
        target_msc: types::Card64,
        divisor: types::Card64,
        remainder: types::Card64,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.present_notify_msc(window, serial, target_msc, divisor, remainder);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "present")]
    fn present_select_input<'this>(
        &'this mut self,
        eid: types::present::Event,
        window: types::xproto::Window,
        event_mask: impl Into<types::present::EventMask>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "present_select_input",
            eid = ?eid,
            window = ?window,
        );
        let request = types::present::SelectInputRequest {
            eid,
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "present")]
    fn present_select_input_checked<'this>(
        &'this mut self,
        eid: types::present::Event,
        window: types::xproto::Window,
        event_mask: impl Into<types::present::EventMask>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.present_select_input(eid, window, event_mask);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "present")]
    fn present_query_capabilities<'this>(
        &'this mut self,
        target: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::present::QueryCapabilitiesReply>>
    {
        let span = tracing::info_span!(
            "present_query_capabilities",
            target = ?target,
        );
        let request = types::present::QueryCapabilitiesRequest { target };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "present")]
    fn present_query_capabilities_immediate<'this>(
        &'this mut self,
        target: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::present::QueryCapabilitiesReply>,
    > {
        let cookie = self.present_query_capabilities(target);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::present::QueryCapabilitiesReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "randr")]
    fn randr_query_version<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::QueryVersionReply>> {
        let span = tracing::info_span!(
            "randr_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::randr::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_query_version_immediate<'this>(
        &'this mut self,
        major_version: types::Card32,
        minor_version: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::QueryVersionReply>>
    {
        let cookie = self.randr_query_version(major_version, minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_config<'this>(
        &'this mut self,
        window: types::xproto::Window,
        timestamp: types::Timestamp,
        config_timestamp: types::Timestamp,
        size_id: types::Card16,
        rotation: impl Into<types::Rotation>,
        rate: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::SetScreenConfigReply>> {
        let span = tracing::info_span!(
            "randr_set_screen_config",
            window = ?window,
            timestamp = ?timestamp,
            config_timestamp = ?config_timestamp,
            size_id = ?size_id,
            rate = ?rate,
        );
        let request = types::randr::SetScreenConfigRequest {
            window,
            timestamp,
            config_timestamp,
            size_id,
            rotation: Into::<u32>::into(rotation.into()) as _,
            rate,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_config_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        timestamp: types::Timestamp,
        config_timestamp: types::Timestamp,
        size_id: types::Card16,
        rotation: impl Into<types::Rotation>,
        rate: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::SetScreenConfigReply>>
    {
        let cookie = self.randr_set_screen_config(
            window,
            timestamp,
            config_timestamp,
            size_id,
            rotation,
            rate,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::SetScreenConfigReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_select_input<'this>(
        &'this mut self,
        window: types::xproto::Window,
        enable: impl Into<types::NotifyMask>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_select_input",
            window = ?window,
        );
        let request = types::randr::SelectInputRequest {
            window,
            enable: Into::<u32>::into(enable.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_select_input_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        enable: impl Into<types::NotifyMask>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_select_input(window, enable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_info<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetScreenInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_screen_info",
            window = ?window,
        );
        let request = types::randr::GetScreenInfoRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_info_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetScreenInfoReply>>
    {
        let cookie = self.randr_get_screen_info(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetScreenInfoReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_size_range<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetScreenSizeRangeReply>>
    {
        let span = tracing::info_span!(
            "randr_get_screen_size_range",
            window = ?window,
        );
        let request = types::randr::GetScreenSizeRangeRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_size_range_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetScreenSizeRangeReply>>
    {
        let cookie = self.randr_get_screen_size_range(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetScreenSizeRangeReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_size<'this>(
        &'this mut self,
        window: types::xproto::Window,
        width: types::Card16,
        height: types::Card16,
        mm_width: types::Card32,
        mm_height: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_set_screen_size",
            window = ?window,
            width = ?width,
            height = ?height,
            mm_width = ?mm_width,
            mm_height = ?mm_height,
        );
        let request = types::randr::SetScreenSizeRequest {
            window,
            width,
            height,
            mm_width,
            mm_height,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_screen_size_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        width: types::Card16,
        height: types::Card16,
        mm_width: types::Card32,
        mm_height: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_set_screen_size(window, width, height, mm_width, mm_height);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetScreenResourcesReply>>
    {
        let span = tracing::info_span!(
            "randr_get_screen_resources",
            window = ?window,
        );
        let request = types::randr::GetScreenResourcesRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetScreenResourcesReply>>
    {
        let cookie = self.randr_get_screen_resources(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetScreenResourcesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_info<'this>(
        &'this mut self,
        output: types::Output,
        config_timestamp: types::Timestamp,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetOutputInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_output_info",
            output = ?output,
            config_timestamp = ?config_timestamp,
        );
        let request = types::randr::GetOutputInfoRequest {
            output,
            config_timestamp,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_info_immediate<'this>(
        &'this mut self,
        output: types::Output,
        config_timestamp: types::Timestamp,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetOutputInfoReply>>
    {
        let cookie = self.randr_get_output_info(output, config_timestamp);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetOutputInfoReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_list_output_properties<'this>(
        &'this mut self,
        output: types::Output,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::ListOutputPropertiesReply>>
    {
        let span = tracing::info_span!(
            "randr_list_output_properties",
            output = ?output,
        );
        let request = types::randr::ListOutputPropertiesRequest { output };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_list_output_properties_immediate<'this>(
        &'this mut self,
        output: types::Output,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::randr::ListOutputPropertiesReply>,
    > {
        let cookie = self.randr_list_output_properties(output);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::ListOutputPropertiesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_query_output_property<'this>(
        &'this mut self,
        output: types::Output,
        property: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::QueryOutputPropertyReply>>
    {
        let span = tracing::info_span!(
            "randr_query_output_property",
            output = ?output,
            property = ?property,
        );
        let request = types::randr::QueryOutputPropertyRequest { output, property };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_query_output_property_immediate<'this>(
        &'this mut self,
        output: types::Output,
        property: types::Atom,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::randr::QueryOutputPropertyReply>,
    > {
        let cookie = self.randr_query_output_property(output, property);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::QueryOutputPropertyReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_output_property<'this>(
        &'this mut self,
        output: types::Output,
        property: types::Atom,
        pending: types::Bool,
        range: types::Bool,
        values: impl AsRef<[types::Int32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_configure_output_property",
            output = ?output,
            property = ?property,
            pending = ?pending,
            range = ?range,
        );
        let request = types::randr::ConfigureOutputPropertyRequest {
            output,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_output_property_checked<'this>(
        &'this mut self,
        output: types::Output,
        property: types::Atom,
        pending: types::Bool,
        range: types::Bool,
        values: impl AsRef<[types::Int32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_configure_output_property(output, property, pending, range, values);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_change_output_property<'this>(
        &'this mut self,
        output: types::Output,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        mode: types::PropMode,
        num_units: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_change_output_property",
            output = ?output,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            mode = ?mode,
            num_units = ?num_units,
        );
        let request = types::randr::ChangeOutputPropertyRequest {
            output,
            property,
            type_,
            format,
            mode,
            num_units,
            data: Cow::Borrowed(data.bytes()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_change_output_property_checked<'this>(
        &'this mut self,
        output: types::Output,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        mode: types::PropMode,
        num_units: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self
            .randr_change_output_property(output, property, type_, format, mode, num_units, data);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_property<'this>(
        &'this mut self,
        output: types::Output,
        property: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_delete_output_property",
            output = ?output,
            property = ?property,
        );
        let request = types::randr::DeleteOutputPropertyRequest { output, property };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_property_checked<'this>(
        &'this mut self,
        output: types::Output,
        property: types::Atom,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_delete_output_property(output, property);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_property<'this>(
        &'this mut self,
        output: types::Output,
        property: types::Atom,
        type_: impl Into<types::GetPropertyType>,
        long_offset: types::Card32,
        long_length: types::Card32,
        delete: types::Bool,
        pending: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetOutputPropertyReply>> {
        let span = tracing::info_span!(
            "randr_get_output_property",
            output = ?output,
            property = ?property,
            long_offset = ?long_offset,
            long_length = ?long_length,
            delete = ?delete,
            pending = ?pending,
        );
        let request = types::randr::GetOutputPropertyRequest {
            output,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
            delete,
            pending,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_property_immediate<'this>(
        &'this mut self,
        output: types::Output,
        property: types::Atom,
        type_: impl Into<types::GetPropertyType>,
        long_offset: types::Card32,
        long_length: types::Card32,
        delete: types::Bool,
        pending: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetOutputPropertyReply>>
    {
        let cookie = self.randr_get_output_property(
            output,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetOutputPropertyReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_create_mode<'this>(
        &'this mut self,
        window: types::xproto::Window,
        mode_info: types::randr::ModeInfo,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::CreateModeReply>> {
        let span = tracing::info_span!(
            "randr_create_mode",
            window = ?window,
            mode_info = ?mode_info,
        );
        let request = types::randr::CreateModeRequest {
            window,
            mode_info,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_create_mode_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        mode_info: types::randr::ModeInfo,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::CreateModeReply>> {
        let cookie = self.randr_create_mode(window, mode_info, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::CreateModeReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_destroy_mode<'this>(
        &'this mut self,
        mode: types::Mode,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_destroy_mode",
            mode = ?mode,
        );
        let request = types::randr::DestroyModeRequest { mode };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_destroy_mode_checked<'this>(
        &'this mut self,
        mode: types::Mode,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_destroy_mode(mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_add_output_mode<'this>(
        &'this mut self,
        output: types::Output,
        mode: types::Mode,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_add_output_mode",
            output = ?output,
            mode = ?mode,
        );
        let request = types::randr::AddOutputModeRequest { output, mode };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_add_output_mode_checked<'this>(
        &'this mut self,
        output: types::Output,
        mode: types::Mode,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_add_output_mode(output, mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_mode<'this>(
        &'this mut self,
        output: types::Output,
        mode: types::Mode,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_delete_output_mode",
            output = ?output,
            mode = ?mode,
        );
        let request = types::randr::DeleteOutputModeRequest { output, mode };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_output_mode_checked<'this>(
        &'this mut self,
        output: types::Output,
        mode: types::Mode,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_delete_output_mode(output, mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_info<'this>(
        &'this mut self,
        crtc: types::Crtc,
        config_timestamp: types::Timestamp,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetCrtcInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_info",
            crtc = ?crtc,
            config_timestamp = ?config_timestamp,
        );
        let request = types::randr::GetCrtcInfoRequest {
            crtc,
            config_timestamp,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_info_immediate<'this>(
        &'this mut self,
        crtc: types::Crtc,
        config_timestamp: types::Timestamp,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcInfoReply>>
    {
        let cookie = self.randr_get_crtc_info(crtc, config_timestamp);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcInfoReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_config<'this>(
        &'this mut self,
        crtc: types::Crtc,
        timestamp: types::Timestamp,
        config_timestamp: types::Timestamp,
        x: types::Int16,
        y: types::Int16,
        mode: types::Mode,
        rotation: impl Into<types::Rotation>,
        outputs: impl AsRef<[types::Output]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::SetCrtcConfigReply>> {
        let span = tracing::info_span!(
            "randr_set_crtc_config",
            crtc = ?crtc,
            timestamp = ?timestamp,
            config_timestamp = ?config_timestamp,
            x = ?x,
            y = ?y,
            mode = ?mode,
        );
        let request = types::randr::SetCrtcConfigRequest {
            crtc,
            timestamp,
            config_timestamp,
            x,
            y,
            mode,
            rotation: Into::<u32>::into(rotation.into()) as _,
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_config_immediate<'this>(
        &'this mut self,
        crtc: types::Crtc,
        timestamp: types::Timestamp,
        config_timestamp: types::Timestamp,
        x: types::Int16,
        y: types::Int16,
        mode: types::Mode,
        rotation: impl Into<types::Rotation>,
        outputs: impl AsRef<[types::Output]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::SetCrtcConfigReply>>
    {
        let cookie = self.randr_set_crtc_config(
            crtc,
            timestamp,
            config_timestamp,
            x,
            y,
            mode,
            rotation,
            outputs,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::SetCrtcConfigReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_size<'this>(
        &'this mut self,
        crtc: types::Crtc,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetCrtcGammaSizeReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_gamma_size",
            crtc = ?crtc,
        );
        let request = types::randr::GetCrtcGammaSizeRequest { crtc };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_size_immediate<'this>(
        &'this mut self,
        crtc: types::Crtc,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcGammaSizeReply>>
    {
        let cookie = self.randr_get_crtc_gamma_size(crtc);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcGammaSizeReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma<'this>(
        &'this mut self,
        crtc: types::Crtc,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetCrtcGammaReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_gamma",
            crtc = ?crtc,
        );
        let request = types::randr::GetCrtcGammaRequest { crtc };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_gamma_immediate<'this>(
        &'this mut self,
        crtc: types::Crtc,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcGammaReply>>
    {
        let cookie = self.randr_get_crtc_gamma(crtc);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcGammaReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_gamma<'this>(
        &'this mut self,
        crtc: types::Crtc,
        red: impl AsRef<[types::Card16]>,
        green: impl AsRef<[types::Card16]>,
        blue: impl AsRef<[types::Card16]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_set_crtc_gamma",
            crtc = ?crtc,
        );
        let request = types::randr::SetCrtcGammaRequest {
            crtc,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_gamma_checked<'this>(
        &'this mut self,
        crtc: types::Crtc,
        red: impl AsRef<[types::Card16]>,
        green: impl AsRef<[types::Card16]>,
        blue: impl AsRef<[types::Card16]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_set_crtc_gamma(crtc, red, green, blue);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_current<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetScreenResourcesCurrentReply>>
    {
        let span = tracing::info_span!(
            "randr_get_screen_resources_current",
            window = ?window,
        );
        let request = types::randr::GetScreenResourcesCurrentRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_screen_resources_current_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::randr::GetScreenResourcesCurrentReply>,
    > {
        let cookie = self.randr_get_screen_resources_current(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::randr::GetScreenResourcesCurrentReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_transform<'this>(
        &'this mut self,
        crtc: types::Crtc,
        transform: types::render::Transform,
        filter_name: impl AsRef<[types::Char]>,
        filter_params: impl AsRef<[types::Fixed]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_set_crtc_transform",
            crtc = ?crtc,
            transform = ?transform,
        );
        let request = types::randr::SetCrtcTransformRequest {
            crtc,
            transform,
            filter_name: Cow::Borrowed(filter_name.as_ref()),
            filter_params: Cow::Borrowed(filter_params.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_crtc_transform_checked<'this>(
        &'this mut self,
        crtc: types::Crtc,
        transform: types::render::Transform,
        filter_name: impl AsRef<[types::Char]>,
        filter_params: impl AsRef<[types::Fixed]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_set_crtc_transform(crtc, transform, filter_name, filter_params);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_transform<'this>(
        &'this mut self,
        crtc: types::Crtc,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetCrtcTransformReply>> {
        let span = tracing::info_span!(
            "randr_get_crtc_transform",
            crtc = ?crtc,
        );
        let request = types::randr::GetCrtcTransformRequest { crtc };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_crtc_transform_immediate<'this>(
        &'this mut self,
        crtc: types::Crtc,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcTransformReply>>
    {
        let cookie = self.randr_get_crtc_transform(crtc);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetCrtcTransformReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_panning<'this>(
        &'this mut self,
        crtc: types::Crtc,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetPanningReply>> {
        let span = tracing::info_span!(
            "randr_get_panning",
            crtc = ?crtc,
        );
        let request = types::randr::GetPanningRequest { crtc };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_panning_immediate<'this>(
        &'this mut self,
        crtc: types::Crtc,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetPanningReply>> {
        let cookie = self.randr_get_panning(crtc);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetPanningReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_panning<'this>(
        &'this mut self,
        crtc: types::Crtc,
        timestamp: types::Timestamp,
        left: types::Card16,
        top: types::Card16,
        width: types::Card16,
        height: types::Card16,
        track_left: types::Card16,
        track_top: types::Card16,
        track_width: types::Card16,
        track_height: types::Card16,
        border_left: types::Int16,
        border_top: types::Int16,
        border_right: types::Int16,
        border_bottom: types::Int16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::SetPanningReply>> {
        let span = tracing::info_span!(
            "randr_set_panning",
            crtc = ?crtc,
            timestamp = ?timestamp,
            left = ?left,
            top = ?top,
            width = ?width,
            height = ?height,
            track_left = ?track_left,
            track_top = ?track_top,
            track_width = ?track_width,
            track_height = ?track_height,
            border_left = ?border_left,
            border_top = ?border_top,
            border_right = ?border_right,
            border_bottom = ?border_bottom,
        );
        let request = types::randr::SetPanningRequest {
            crtc,
            timestamp,
            left,
            top,
            width,
            height,
            track_left,
            track_top,
            track_width,
            track_height,
            border_left,
            border_top,
            border_right,
            border_bottom,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_panning_immediate<'this>(
        &'this mut self,
        crtc: types::Crtc,
        timestamp: types::Timestamp,
        left: types::Card16,
        top: types::Card16,
        width: types::Card16,
        height: types::Card16,
        track_left: types::Card16,
        track_top: types::Card16,
        track_width: types::Card16,
        track_height: types::Card16,
        border_left: types::Int16,
        border_top: types::Int16,
        border_right: types::Int16,
        border_bottom: types::Int16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::SetPanningReply>> {
        let cookie = self.randr_set_panning(
            crtc,
            timestamp,
            left,
            top,
            width,
            height,
            track_left,
            track_top,
            track_width,
            track_height,
            border_left,
            border_top,
            border_right,
            border_bottom,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::SetPanningReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_output_primary<'this>(
        &'this mut self,
        window: types::xproto::Window,
        output: types::Output,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_set_output_primary",
            window = ?window,
            output = ?output,
        );
        let request = types::randr::SetOutputPrimaryRequest { window, output };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_output_primary_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        output: types::Output,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_set_output_primary(window, output);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_primary<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetOutputPrimaryReply>> {
        let span = tracing::info_span!(
            "randr_get_output_primary",
            window = ?window,
        );
        let request = types::randr::GetOutputPrimaryRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_output_primary_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetOutputPrimaryReply>>
    {
        let cookie = self.randr_get_output_primary(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetOutputPrimaryReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_providers<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetProvidersReply>> {
        let span = tracing::info_span!(
            "randr_get_providers",
            window = ?window,
        );
        let request = types::randr::GetProvidersRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_providers_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetProvidersReply>>
    {
        let cookie = self.randr_get_providers(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetProvidersReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_info<'this>(
        &'this mut self,
        provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetProviderInfoReply>> {
        let span = tracing::info_span!(
            "randr_get_provider_info",
            provider = ?provider,
            config_timestamp = ?config_timestamp,
        );
        let request = types::randr::GetProviderInfoRequest {
            provider,
            config_timestamp,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_info_immediate<'this>(
        &'this mut self,
        provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetProviderInfoReply>>
    {
        let cookie = self.randr_get_provider_info(provider, config_timestamp);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetProviderInfoReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_offload_sink<'this>(
        &'this mut self,
        provider: types::Provider,
        sink_provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_set_provider_offload_sink",
            provider = ?provider,
            sink_provider = ?sink_provider,
            config_timestamp = ?config_timestamp,
        );
        let request = types::randr::SetProviderOffloadSinkRequest {
            provider,
            sink_provider,
            config_timestamp,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_offload_sink_checked<'this>(
        &'this mut self,
        provider: types::Provider,
        sink_provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie =
            self.randr_set_provider_offload_sink(provider, sink_provider, config_timestamp);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_output_source<'this>(
        &'this mut self,
        provider: types::Provider,
        source_provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_set_provider_output_source",
            provider = ?provider,
            source_provider = ?source_provider,
            config_timestamp = ?config_timestamp,
        );
        let request = types::randr::SetProviderOutputSourceRequest {
            provider,
            source_provider,
            config_timestamp,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_provider_output_source_checked<'this>(
        &'this mut self,
        provider: types::Provider,
        source_provider: types::Provider,
        config_timestamp: types::Timestamp,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie =
            self.randr_set_provider_output_source(provider, source_provider, config_timestamp);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_list_provider_properties<'this>(
        &'this mut self,
        provider: types::Provider,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::ListProviderPropertiesReply>>
    {
        let span = tracing::info_span!(
            "randr_list_provider_properties",
            provider = ?provider,
        );
        let request = types::randr::ListProviderPropertiesRequest { provider };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_list_provider_properties_immediate<'this>(
        &'this mut self,
        provider: types::Provider,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::randr::ListProviderPropertiesReply>,
    > {
        let cookie = self.randr_list_provider_properties(provider);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::randr::ListProviderPropertiesReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_query_provider_property<'this>(
        &'this mut self,
        provider: types::Provider,
        property: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::QueryProviderPropertyReply>>
    {
        let span = tracing::info_span!(
            "randr_query_provider_property",
            provider = ?provider,
            property = ?property,
        );
        let request = types::randr::QueryProviderPropertyRequest { provider, property };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_query_provider_property_immediate<'this>(
        &'this mut self,
        provider: types::Provider,
        property: types::Atom,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::randr::QueryProviderPropertyReply>,
    > {
        let cookie = self.randr_query_provider_property(provider, property);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::randr::QueryProviderPropertyReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_provider_property<'this>(
        &'this mut self,
        provider: types::Provider,
        property: types::Atom,
        pending: types::Bool,
        range: types::Bool,
        values: impl AsRef<[types::Int32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_configure_provider_property",
            provider = ?provider,
            property = ?property,
            pending = ?pending,
            range = ?range,
        );
        let request = types::randr::ConfigureProviderPropertyRequest {
            provider,
            property,
            pending,
            range,
            values: Cow::Borrowed(values.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_configure_provider_property_checked<'this>(
        &'this mut self,
        provider: types::Provider,
        property: types::Atom,
        pending: types::Bool,
        range: types::Bool,
        values: impl AsRef<[types::Int32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie =
            self.randr_configure_provider_property(provider, property, pending, range, values);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_change_provider_property<'this>(
        &'this mut self,
        provider: types::Provider,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        mode: types::Card8,
        num_items: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_change_provider_property",
            provider = ?provider,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            mode = ?mode,
            num_items = ?num_items,
        );
        let request = types::randr::ChangeProviderPropertyRequest {
            provider,
            property,
            type_,
            format,
            mode,
            num_items,
            data: Cow::Borrowed(data.bytes()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_change_provider_property_checked<'this>(
        &'this mut self,
        provider: types::Provider,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        mode: types::Card8,
        num_items: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_change_provider_property(
            provider, property, type_, format, mode, num_items, data,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_provider_property<'this>(
        &'this mut self,
        provider: types::Provider,
        property: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_delete_provider_property",
            provider = ?provider,
            property = ?property,
        );
        let request = types::randr::DeleteProviderPropertyRequest { provider, property };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_provider_property_checked<'this>(
        &'this mut self,
        provider: types::Provider,
        property: types::Atom,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_delete_provider_property(provider, property);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_property<'this>(
        &'this mut self,
        provider: types::Provider,
        property: types::Atom,
        type_: types::Atom,
        long_offset: types::Card32,
        long_length: types::Card32,
        delete: types::Bool,
        pending: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetProviderPropertyReply>>
    {
        let span = tracing::info_span!(
            "randr_get_provider_property",
            provider = ?provider,
            property = ?property,
            type_ = ?type_,
            long_offset = ?long_offset,
            long_length = ?long_length,
            delete = ?delete,
            pending = ?pending,
        );
        let request = types::randr::GetProviderPropertyRequest {
            provider,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_provider_property_immediate<'this>(
        &'this mut self,
        provider: types::Provider,
        property: types::Atom,
        type_: types::Atom,
        long_offset: types::Card32,
        long_length: types::Card32,
        delete: types::Bool,
        pending: types::Bool,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::randr::GetProviderPropertyReply>,
    > {
        let cookie = self.randr_get_provider_property(
            provider,
            property,
            type_,
            long_offset,
            long_length,
            delete,
            pending,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetProviderPropertyReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_monitors<'this>(
        &'this mut self,
        window: types::xproto::Window,
        get_active: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::GetMonitorsReply>> {
        let span = tracing::info_span!(
            "randr_get_monitors",
            window = ?window,
            get_active = ?get_active,
        );
        let request = types::randr::GetMonitorsRequest { window, get_active };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_get_monitors_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        get_active: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::GetMonitorsReply>>
    {
        let cookie = self.randr_get_monitors(window, get_active);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::GetMonitorsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_monitor<'this>(
        &'this mut self,
        window: types::xproto::Window,
        monitorinfo: types::MonitorInfo,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_set_monitor",
            window = ?window,
            monitorinfo = ?monitorinfo,
        );
        let request = types::randr::SetMonitorRequest {
            window,
            monitorinfo,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_set_monitor_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        monitorinfo: types::MonitorInfo,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_set_monitor(window, monitorinfo);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_monitor<'this>(
        &'this mut self,
        window: types::xproto::Window,
        name: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_delete_monitor",
            window = ?window,
            name = ?name,
        );
        let request = types::randr::DeleteMonitorRequest { window, name };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_delete_monitor_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        name: types::Atom,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_delete_monitor(window, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_create_lease<'this>(
        &'this mut self,
        window: types::xproto::Window,
        lid: types::Lease,
        crtcs: impl AsRef<[types::Crtc]>,
        outputs: impl AsRef<[types::Output]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::randr::CreateLeaseReply>> {
        let span = tracing::info_span!(
            "randr_create_lease",
            window = ?window,
            lid = ?lid,
        );
        let request = types::randr::CreateLeaseRequest {
            window,
            lid,
            crtcs: Cow::Borrowed(crtcs.as_ref()),
            outputs: Cow::Borrowed(outputs.as_ref()),
        };
        self.send_reply_fd_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_create_lease_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        lid: types::Lease,
        crtcs: impl AsRef<[types::Crtc]>,
        outputs: impl AsRef<[types::Output]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::randr::CreateLeaseReply>>
    {
        let cookie = self.randr_create_lease(window, lid, crtcs, outputs);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::randr::CreateLeaseReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_free_lease<'this>(
        &'this mut self,
        lid: types::Lease,
        terminate: types::Byte,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "randr_free_lease",
            lid = ?lid,
            terminate = ?terminate,
        );
        let request = types::randr::FreeLeaseRequest { lid, terminate };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "randr")]
    fn randr_free_lease_checked<'this>(
        &'this mut self,
        lid: types::Lease,
        terminate: types::Byte,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.randr_free_lease(lid, terminate);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "record")]
    fn record_query_version<'this>(
        &'this mut self,
        major_version: types::Card16,
        minor_version: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::record::QueryVersionReply>> {
        let span = tracing::info_span!(
            "record_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::record::QueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_query_version_immediate<'this>(
        &'this mut self,
        major_version: types::Card16,
        minor_version: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::record::QueryVersionReply>>
    {
        let cookie = self.record_query_version(major_version, minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::record::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_create_context<'this>(
        &'this mut self,
        context: types::record::Context,
        element_header: types::ElementHeader,
        client_specs: impl AsRef<[types::ClientSpec]>,
        ranges: impl AsRef<[types::Range]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "record_create_context",
            context = ?context,
            element_header = ?element_header,
        );
        let request = types::record::CreateContextRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_create_context_checked<'this>(
        &'this mut self,
        context: types::record::Context,
        element_header: types::ElementHeader,
        client_specs: impl AsRef<[types::ClientSpec]>,
        ranges: impl AsRef<[types::Range]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.record_create_context(context, element_header, client_specs, ranges);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_register_clients<'this>(
        &'this mut self,
        context: types::record::Context,
        element_header: types::ElementHeader,
        client_specs: impl AsRef<[types::ClientSpec]>,
        ranges: impl AsRef<[types::Range]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "record_register_clients",
            context = ?context,
            element_header = ?element_header,
        );
        let request = types::record::RegisterClientsRequest {
            context,
            element_header,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
            ranges: Cow::Borrowed(ranges.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_register_clients_checked<'this>(
        &'this mut self,
        context: types::record::Context,
        element_header: types::ElementHeader,
        client_specs: impl AsRef<[types::ClientSpec]>,
        ranges: impl AsRef<[types::Range]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.record_register_clients(context, element_header, client_specs, ranges);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_unregister_clients<'this>(
        &'this mut self,
        context: types::record::Context,
        client_specs: impl AsRef<[types::ClientSpec]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "record_unregister_clients",
            context = ?context,
        );
        let request = types::record::UnregisterClientsRequest {
            context,
            client_specs: Cow::Borrowed(client_specs.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_unregister_clients_checked<'this>(
        &'this mut self,
        context: types::record::Context,
        client_specs: impl AsRef<[types::ClientSpec]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.record_unregister_clients(context, client_specs);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_get_context<'this>(
        &'this mut self,
        context: types::record::Context,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::record::GetContextReply>> {
        let span = tracing::info_span!(
            "record_get_context",
            context = ?context,
        );
        let request = types::record::GetContextRequest { context };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_get_context_immediate<'this>(
        &'this mut self,
        context: types::record::Context,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::record::GetContextReply>>
    {
        let cookie = self.record_get_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::record::GetContextReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_enable_context<'this>(
        &'this mut self,
        context: types::record::Context,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::record::EnableContextReply>> {
        let span = tracing::info_span!(
            "record_enable_context",
            context = ?context,
        );
        let request = types::record::EnableContextRequest { context };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_enable_context_immediate<'this>(
        &'this mut self,
        context: types::record::Context,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::record::EnableContextReply>>
    {
        let cookie = self.record_enable_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::record::EnableContextReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_disable_context<'this>(
        &'this mut self,
        context: types::record::Context,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "record_disable_context",
            context = ?context,
        );
        let request = types::record::DisableContextRequest { context };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_disable_context_checked<'this>(
        &'this mut self,
        context: types::record::Context,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.record_disable_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_free_context<'this>(
        &'this mut self,
        context: types::record::Context,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "record_free_context",
            context = ?context,
        );
        let request = types::record::FreeContextRequest { context };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "record")]
    fn record_free_context_checked<'this>(
        &'this mut self,
        context: types::record::Context,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.record_free_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "render")]
    fn render_query_version<'this>(
        &'this mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::render::QueryVersionReply>> {
        let span = tracing::info_span!(
            "render_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::render::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_query_version_immediate<'this>(
        &'this mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::render::QueryVersionReply>>
    {
        let cookie = self.render_query_version(client_major_version, client_minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::render::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_formats<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::render::QueryPictFormatsReply>> {
        let span = tracing::info_span!("render_query_pict_formats",);
        let request = types::render::QueryPictFormatsRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_formats_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::render::QueryPictFormatsReply>>
    {
        let cookie = self.render_query_pict_formats();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::render::QueryPictFormatsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_index_values<'this>(
        &'this mut self,
        format: types::Pictformat,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::render::QueryPictIndexValuesReply>>
    {
        let span = tracing::info_span!(
            "render_query_pict_index_values",
            format = ?format,
        );
        let request = types::render::QueryPictIndexValuesRequest { format };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_query_pict_index_values_immediate<'this>(
        &'this mut self,
        format: types::Pictformat,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::render::QueryPictIndexValuesReply>,
    > {
        let cookie = self.render_query_pict_index_values(format);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::render::QueryPictIndexValuesReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_picture<'this>(
        &'this mut self,
        pid: types::Picture,
        drawable: types::xproto::Drawable,
        format: types::Pictformat,
        value_list: impl Borrow<types::render::CreatePictureAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_create_picture",
            pid = ?pid,
            drawable = ?drawable,
            format = ?format,
        );
        let request = types::render::CreatePictureRequest {
            pid,
            drawable,
            format,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_picture_checked<'this>(
        &'this mut self,
        pid: types::Picture,
        drawable: types::xproto::Drawable,
        format: types::Pictformat,
        value_list: impl Borrow<types::render::CreatePictureAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_create_picture(pid, drawable, format, value_list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_change_picture<'this>(
        &'this mut self,
        picture: types::Picture,
        value_list: impl Borrow<types::render::ChangePictureAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_change_picture",
            picture = ?picture,
        );
        let request = types::render::ChangePictureRequest {
            picture,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_change_picture_checked<'this>(
        &'this mut self,
        picture: types::Picture,
        value_list: impl Borrow<types::render::ChangePictureAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_change_picture(picture, value_list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_clip_rectangles<'this>(
        &'this mut self,
        picture: types::Picture,
        clip_x_origin: types::Int16,
        clip_y_origin: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_set_picture_clip_rectangles",
            picture = ?picture,
            clip_x_origin = ?clip_x_origin,
            clip_y_origin = ?clip_y_origin,
        );
        let request = types::render::SetPictureClipRectanglesRequest {
            picture,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_clip_rectangles_checked<'this>(
        &'this mut self,
        picture: types::Picture,
        clip_x_origin: types::Int16,
        clip_y_origin: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_set_picture_clip_rectangles(
            picture,
            clip_x_origin,
            clip_y_origin,
            rectangles,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_free_picture<'this>(
        &'this mut self,
        picture: types::Picture,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_free_picture",
            picture = ?picture,
        );
        let request = types::render::FreePictureRequest { picture };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_free_picture_checked<'this>(
        &'this mut self,
        picture: types::Picture,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_free_picture(picture);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_composite<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        mask: impl Into<types::Picture>,
        dst: types::Picture,
        src_x: types::Int16,
        src_y: types::Int16,
        mask_x: types::Int16,
        mask_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_composite",
            op = ?op,
            src = ?src,
            dst = ?dst,
            src_x = ?src_x,
            src_y = ?src_y,
            mask_x = ?mask_x,
            mask_y = ?mask_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
        );
        let request = types::render::CompositeRequest {
            op,
            src,
            mask: Into::<u32>::into(mask.into()) as _,
            dst,
            src_x,
            src_y,
            mask_x,
            mask_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_composite_checked<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        mask: impl Into<types::Picture>,
        dst: types::Picture,
        src_x: types::Int16,
        src_y: types::Int16,
        mask_x: types::Int16,
        mask_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_composite(
            op, src, mask, dst, src_x, src_y, mask_x, mask_y, dst_x, dst_y, width, height,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_trapezoids<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        traps: impl AsRef<[types::Trapezoid]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_trapezoids",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::TrapezoidsRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_trapezoids_checked<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        traps: impl AsRef<[types::Trapezoid]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_trapezoids(op, src, dst, mask_format, src_x, src_y, traps);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_triangles<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        triangles: impl AsRef<[types::Triangle]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_triangles",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::TrianglesRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            triangles: Cow::Borrowed(triangles.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_triangles_checked<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        triangles: impl AsRef<[types::Triangle]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_triangles(op, src, dst, mask_format, src_x, src_y, triangles);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_tri_strip<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        points: impl AsRef<[types::Pointfix]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_tri_strip",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::TriStripRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_tri_strip_checked<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        points: impl AsRef<[types::Pointfix]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_tri_strip(op, src, dst, mask_format, src_x, src_y, points);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_tri_fan<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        points: impl AsRef<[types::Pointfix]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_tri_fan",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::TriFanRequest {
            op,
            src,
            dst,
            mask_format,
            src_x,
            src_y,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_tri_fan_checked<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        src_x: types::Int16,
        src_y: types::Int16,
        points: impl AsRef<[types::Pointfix]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_tri_fan(op, src, dst, mask_format, src_x, src_y, points);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_glyph_set<'this>(
        &'this mut self,
        gsid: types::Glyphset,
        format: types::Pictformat,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_create_glyph_set",
            gsid = ?gsid,
            format = ?format,
        );
        let request = types::render::CreateGlyphSetRequest { gsid, format };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_glyph_set_checked<'this>(
        &'this mut self,
        gsid: types::Glyphset,
        format: types::Pictformat,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_create_glyph_set(gsid, format);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_reference_glyph_set<'this>(
        &'this mut self,
        gsid: types::Glyphset,
        existing: types::Glyphset,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_reference_glyph_set",
            gsid = ?gsid,
            existing = ?existing,
        );
        let request = types::render::ReferenceGlyphSetRequest { gsid, existing };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_reference_glyph_set_checked<'this>(
        &'this mut self,
        gsid: types::Glyphset,
        existing: types::Glyphset,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_reference_glyph_set(gsid, existing);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_free_glyph_set<'this>(
        &'this mut self,
        glyphset: types::Glyphset,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_free_glyph_set",
            glyphset = ?glyphset,
        );
        let request = types::render::FreeGlyphSetRequest { glyphset };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_free_glyph_set_checked<'this>(
        &'this mut self,
        glyphset: types::Glyphset,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_free_glyph_set(glyphset);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_add_glyphs<'this>(
        &'this mut self,
        glyphset: types::Glyphset,
        glyphids: impl AsRef<[types::Card32]>,
        glyphs: impl AsRef<[types::Glyphinfo]>,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_add_glyphs",
            glyphset = ?glyphset,
        );
        let request = types::render::AddGlyphsRequest {
            glyphset,
            glyphids: Cow::Borrowed(glyphids.as_ref()),
            glyphs: Cow::Borrowed(glyphs.as_ref()),
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_add_glyphs_checked<'this>(
        &'this mut self,
        glyphset: types::Glyphset,
        glyphids: impl AsRef<[types::Card32]>,
        glyphs: impl AsRef<[types::Glyphinfo]>,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_add_glyphs(glyphset, glyphids, glyphs, data);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_free_glyphs<'this>(
        &'this mut self,
        glyphset: types::Glyphset,
        glyphs: impl AsRef<[types::Glyph]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_free_glyphs",
            glyphset = ?glyphset,
        );
        let request = types::render::FreeGlyphsRequest {
            glyphset,
            glyphs: Cow::Borrowed(glyphs.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_free_glyphs_checked<'this>(
        &'this mut self,
        glyphset: types::Glyphset,
        glyphs: impl AsRef<[types::Glyph]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_free_glyphs(glyphset, glyphs);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs8<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_composite_glyphs8",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::CompositeGlyphs8Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs8_checked<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_composite_glyphs8(
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs16<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_composite_glyphs16",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::CompositeGlyphs16Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs16_checked<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_composite_glyphs16(
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs32<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_composite_glyphs32",
            op = ?op,
            src = ?src,
            dst = ?dst,
            mask_format = ?mask_format,
            glyphset = ?glyphset,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::render::CompositeGlyphs32Request {
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds: Cow::Borrowed(glyphcmds.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_composite_glyphs32_checked<'this>(
        &'this mut self,
        op: types::PictOp,
        src: types::Picture,
        dst: types::Picture,
        mask_format: types::Pictformat,
        glyphset: types::Glyphset,
        src_x: types::Int16,
        src_y: types::Int16,
        glyphcmds: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_composite_glyphs32(
            op,
            src,
            dst,
            mask_format,
            glyphset,
            src_x,
            src_y,
            glyphcmds,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_fill_rectangles<'this>(
        &'this mut self,
        op: types::PictOp,
        dst: types::Picture,
        color: types::Color,
        rects: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_fill_rectangles",
            op = ?op,
            dst = ?dst,
            color = ?color,
        );
        let request = types::render::FillRectanglesRequest {
            op,
            dst,
            color,
            rects: Cow::Borrowed(rects.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_fill_rectangles_checked<'this>(
        &'this mut self,
        op: types::PictOp,
        dst: types::Picture,
        color: types::Color,
        rects: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_fill_rectangles(op, dst, color, rects);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_cursor<'this>(
        &'this mut self,
        cid: types::xproto::Cursor,
        source: types::Picture,
        x: types::Card16,
        y: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_create_cursor",
            cid = ?cid,
            source = ?source,
            x = ?x,
            y = ?y,
        );
        let request = types::render::CreateCursorRequest { cid, source, x, y };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_cursor_checked<'this>(
        &'this mut self,
        cid: types::xproto::Cursor,
        source: types::Picture,
        x: types::Card16,
        y: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_create_cursor(cid, source, x, y);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_transform<'this>(
        &'this mut self,
        picture: types::Picture,
        transform: types::render::Transform,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_set_picture_transform",
            picture = ?picture,
            transform = ?transform,
        );
        let request = types::render::SetPictureTransformRequest { picture, transform };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_transform_checked<'this>(
        &'this mut self,
        picture: types::Picture,
        transform: types::render::Transform,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_set_picture_transform(picture, transform);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_query_filters<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::render::QueryFiltersReply>> {
        let span = tracing::info_span!(
            "render_query_filters",
            drawable = ?drawable,
        );
        let request = types::render::QueryFiltersRequest { drawable };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_query_filters_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::render::QueryFiltersReply>>
    {
        let cookie = self.render_query_filters(drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::render::QueryFiltersReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_filter<'this>(
        &'this mut self,
        picture: types::Picture,
        filter: impl AsRef<[types::Char]>,
        values: impl AsRef<[types::Fixed]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_set_picture_filter",
            picture = ?picture,
        );
        let request = types::render::SetPictureFilterRequest {
            picture,
            filter: Cow::Borrowed(filter.as_ref()),
            values: Cow::Borrowed(values.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_set_picture_filter_checked<'this>(
        &'this mut self,
        picture: types::Picture,
        filter: impl AsRef<[types::Char]>,
        values: impl AsRef<[types::Fixed]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_set_picture_filter(picture, filter, values);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_anim_cursor<'this>(
        &'this mut self,
        cid: types::xproto::Cursor,
        cursors: impl AsRef<[types::Animcursorelt]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_create_anim_cursor",
            cid = ?cid,
        );
        let request = types::render::CreateAnimCursorRequest {
            cid,
            cursors: Cow::Borrowed(cursors.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_anim_cursor_checked<'this>(
        &'this mut self,
        cid: types::xproto::Cursor,
        cursors: impl AsRef<[types::Animcursorelt]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_create_anim_cursor(cid, cursors);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_add_traps<'this>(
        &'this mut self,
        picture: types::Picture,
        x_off: types::Int16,
        y_off: types::Int16,
        traps: impl AsRef<[types::Trap]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_add_traps",
            picture = ?picture,
            x_off = ?x_off,
            y_off = ?y_off,
        );
        let request = types::render::AddTrapsRequest {
            picture,
            x_off,
            y_off,
            traps: Cow::Borrowed(traps.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_add_traps_checked<'this>(
        &'this mut self,
        picture: types::Picture,
        x_off: types::Int16,
        y_off: types::Int16,
        traps: impl AsRef<[types::Trap]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_add_traps(picture, x_off, y_off, traps);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_solid_fill<'this>(
        &'this mut self,
        picture: types::Picture,
        color: types::Color,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_create_solid_fill",
            picture = ?picture,
            color = ?color,
        );
        let request = types::render::CreateSolidFillRequest { picture, color };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_solid_fill_checked<'this>(
        &'this mut self,
        picture: types::Picture,
        color: types::Color,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_create_solid_fill(picture, color);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_linear_gradient<'this>(
        &'this mut self,
        picture: types::Picture,
        p1: types::Pointfix,
        p2: types::Pointfix,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_create_linear_gradient",
            picture = ?picture,
            p1 = ?p1,
            p2 = ?p2,
        );
        let request = types::render::CreateLinearGradientRequest {
            picture,
            p1,
            p2,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_linear_gradient_checked<'this>(
        &'this mut self,
        picture: types::Picture,
        p1: types::Pointfix,
        p2: types::Pointfix,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_create_linear_gradient(picture, p1, p2, stops, colors);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_radial_gradient<'this>(
        &'this mut self,
        picture: types::Picture,
        inner: types::Pointfix,
        outer: types::Pointfix,
        inner_radius: types::Fixed,
        outer_radius: types::Fixed,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_create_radial_gradient",
            picture = ?picture,
            inner = ?inner,
            outer = ?outer,
            inner_radius = ?inner_radius,
            outer_radius = ?outer_radius,
        );
        let request = types::render::CreateRadialGradientRequest {
            picture,
            inner,
            outer,
            inner_radius,
            outer_radius,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_radial_gradient_checked<'this>(
        &'this mut self,
        picture: types::Picture,
        inner: types::Pointfix,
        outer: types::Pointfix,
        inner_radius: types::Fixed,
        outer_radius: types::Fixed,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_create_radial_gradient(
            picture,
            inner,
            outer,
            inner_radius,
            outer_radius,
            stops,
            colors,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_conical_gradient<'this>(
        &'this mut self,
        picture: types::Picture,
        center: types::Pointfix,
        angle: types::Fixed,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "render_create_conical_gradient",
            picture = ?picture,
            center = ?center,
            angle = ?angle,
        );
        let request = types::render::CreateConicalGradientRequest {
            picture,
            center,
            angle,
            stops: Cow::Borrowed(stops.as_ref()),
            colors: Cow::Borrowed(colors.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "render")]
    fn render_create_conical_gradient_checked<'this>(
        &'this mut self,
        picture: types::Picture,
        center: types::Pointfix,
        angle: types::Fixed,
        stops: impl AsRef<[types::Fixed]>,
        colors: impl AsRef<[types::Color]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.render_create_conical_gradient(picture, center, angle, stops, colors);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "res")]
    fn res_query_version<'this>(
        &'this mut self,
        client_major: types::Card8,
        client_minor: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::res::QueryVersionReply>> {
        let span = tracing::info_span!(
            "res_query_version",
            client_major = ?client_major,
            client_minor = ?client_minor,
        );
        let request = types::res::QueryVersionRequest {
            client_major,
            client_minor,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "res")]
    fn res_query_version_immediate<'this>(
        &'this mut self,
        client_major: types::Card8,
        client_minor: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::res::QueryVersionReply>> {
        let cookie = self.res_query_version(client_major, client_minor);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "res")]
    fn res_query_clients<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::res::QueryClientsReply>> {
        let span = tracing::info_span!("res_query_clients",);
        let request = types::res::QueryClientsRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "res")]
    fn res_query_clients_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::res::QueryClientsReply>> {
        let cookie = self.res_query_clients();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryClientsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "res")]
    fn res_query_client_resources<'this>(
        &'this mut self,
        xid: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::res::QueryClientResourcesReply>>
    {
        let span = tracing::info_span!(
            "res_query_client_resources",
            xid = ?xid,
        );
        let request = types::res::QueryClientResourcesRequest { xid };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "res")]
    fn res_query_client_resources_immediate<'this>(
        &'this mut self,
        xid: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::res::QueryClientResourcesReply>>
    {
        let cookie = self.res_query_client_resources(xid);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryClientResourcesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "res")]
    fn res_query_client_pixmap_bytes<'this>(
        &'this mut self,
        xid: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::res::QueryClientPixmapBytesReply>>
    {
        let span = tracing::info_span!(
            "res_query_client_pixmap_bytes",
            xid = ?xid,
        );
        let request = types::res::QueryClientPixmapBytesRequest { xid };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "res")]
    fn res_query_client_pixmap_bytes_immediate<'this>(
        &'this mut self,
        xid: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::res::QueryClientPixmapBytesReply>,
    > {
        let cookie = self.res_query_client_pixmap_bytes(xid);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryClientPixmapBytesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "res")]
    fn res_query_client_ids<'this>(
        &'this mut self,
        specs: impl AsRef<[types::ClientIdSpec]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::res::QueryClientIdsReply>> {
        let span = tracing::info_span!("res_query_client_ids",);
        let request = types::res::QueryClientIdsRequest {
            specs: Cow::Borrowed(specs.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "res")]
    fn res_query_client_ids_immediate<'this>(
        &'this mut self,
        specs: impl AsRef<[types::ClientIdSpec]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::res::QueryClientIdsReply>>
    {
        let cookie = self.res_query_client_ids(specs);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryClientIdsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "res")]
    fn res_query_resource_bytes<'this>(
        &'this mut self,
        client: types::Card32,
        specs: impl AsRef<[types::ResourceIdSpec]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::res::QueryResourceBytesReply>> {
        let span = tracing::info_span!(
            "res_query_resource_bytes",
            client = ?client,
        );
        let request = types::res::QueryResourceBytesRequest {
            client,
            specs: Cow::Borrowed(specs.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "res")]
    fn res_query_resource_bytes_immediate<'this>(
        &'this mut self,
        client: types::Card32,
        specs: impl AsRef<[types::ResourceIdSpec]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::res::QueryResourceBytesReply>>
    {
        let cookie = self.res_query_resource_bytes(client, specs);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::res::QueryResourceBytesReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "screensaver")]
    fn screensaver_query_version<'this>(
        &'this mut self,
        client_major_version: types::Card8,
        client_minor_version: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::screensaver::QueryVersionReply>>
    {
        let span = tracing::info_span!(
            "screensaver_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::screensaver::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_version_immediate<'this>(
        &'this mut self,
        client_major_version: types::Card8,
        client_minor_version: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::screensaver::QueryVersionReply>>
    {
        let cookie = self.screensaver_query_version(client_major_version, client_minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::screensaver::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_info<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::screensaver::QueryInfoReply>> {
        let span = tracing::info_span!(
            "screensaver_query_info",
            drawable = ?drawable,
        );
        let request = types::screensaver::QueryInfoRequest { drawable };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_query_info_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::screensaver::QueryInfoReply>>
    {
        let cookie = self.screensaver_query_info(drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::screensaver::QueryInfoReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_select_input<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        event_mask: impl Into<types::screensaver::Event>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "screensaver_select_input",
            drawable = ?drawable,
        );
        let request = types::screensaver::SelectInputRequest {
            drawable,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_select_input_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        event_mask: impl Into<types::screensaver::Event>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.screensaver_select_input(drawable, event_mask);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_set_attributes<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        border_width: types::Card16,
        class: types::WindowClass,
        depth: types::Card8,
        visual: types::Visualid,
        value_list: impl Borrow<types::screensaver::SetAttributesAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "screensaver_set_attributes",
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            border_width = ?border_width,
            class = ?class,
            depth = ?depth,
            visual = ?visual,
        );
        let request = types::screensaver::SetAttributesRequest {
            drawable,
            x,
            y,
            width,
            height,
            border_width,
            class,
            depth,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_set_attributes_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        border_width: types::Card16,
        class: types::WindowClass,
        depth: types::Card8,
        visual: types::Visualid,
        value_list: impl Borrow<types::screensaver::SetAttributesAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.screensaver_set_attributes(
            drawable,
            x,
            y,
            width,
            height,
            border_width,
            class,
            depth,
            visual,
            value_list,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_unset_attributes<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "screensaver_unset_attributes",
            drawable = ?drawable,
        );
        let request = types::screensaver::UnsetAttributesRequest { drawable };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_unset_attributes_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.screensaver_unset_attributes(drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_suspend<'this>(
        &'this mut self,
        suspend: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "screensaver_suspend",
            suspend = ?suspend,
        );
        let request = types::screensaver::SuspendRequest { suspend };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "screensaver")]
    fn screensaver_suspend_checked<'this>(
        &'this mut self,
        suspend: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.screensaver_suspend(suspend);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "shape")]
    fn shape_query_version<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::shape::QueryVersionReply>> {
        let span = tracing::info_span!("shape_query_version",);
        let request = types::shape::QueryVersionRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_query_version_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::shape::QueryVersionReply>>
    {
        let cookie = self.shape_query_version();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::shape::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_rectangles<'this>(
        &'this mut self,
        operation: types::SO,
        destination_kind: types::SK,
        ordering: types::ClipOrdering,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "shape_rectangles",
            operation = ?operation,
            destination_kind = ?destination_kind,
            ordering = ?ordering,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let request = types::shape::RectanglesRequest {
            operation,
            destination_kind,
            ordering,
            destination_window,
            x_offset,
            y_offset,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_rectangles_checked<'this>(
        &'this mut self,
        operation: types::SO,
        destination_kind: types::SK,
        ordering: types::ClipOrdering,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.shape_rectangles(
            operation,
            destination_kind,
            ordering,
            destination_window,
            x_offset,
            y_offset,
            rectangles,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_mask<'this>(
        &'this mut self,
        operation: types::SO,
        destination_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        source_bitmap: impl Into<types::xproto::Pixmap>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "shape_mask",
            operation = ?operation,
            destination_kind = ?destination_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let request = types::shape::MaskRequest {
            operation,
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
            source_bitmap: Into::<u32>::into(source_bitmap.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_mask_checked<'this>(
        &'this mut self,
        operation: types::SO,
        destination_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        source_bitmap: impl Into<types::xproto::Pixmap>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.shape_mask(
            operation,
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
            source_bitmap,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_combine<'this>(
        &'this mut self,
        operation: types::SO,
        destination_kind: types::SK,
        source_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        source_window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "shape_combine",
            operation = ?operation,
            destination_kind = ?destination_kind,
            source_kind = ?source_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
            source_window = ?source_window,
        );
        let request = types::shape::CombineRequest {
            operation,
            destination_kind,
            source_kind,
            destination_window,
            x_offset,
            y_offset,
            source_window,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_combine_checked<'this>(
        &'this mut self,
        operation: types::SO,
        destination_kind: types::SK,
        source_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
        source_window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.shape_combine(
            operation,
            destination_kind,
            source_kind,
            destination_window,
            x_offset,
            y_offset,
            source_window,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_offset<'this>(
        &'this mut self,
        destination_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "shape_offset",
            destination_kind = ?destination_kind,
            destination_window = ?destination_window,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let request = types::shape::OffsetRequest {
            destination_kind,
            destination_window,
            x_offset,
            y_offset,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_offset_checked<'this>(
        &'this mut self,
        destination_kind: types::SK,
        destination_window: types::xproto::Window,
        x_offset: types::Int16,
        y_offset: types::Int16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.shape_offset(destination_kind, destination_window, x_offset, y_offset);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_query_extents<'this>(
        &'this mut self,
        destination_window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::shape::QueryExtentsReply>> {
        let span = tracing::info_span!(
            "shape_query_extents",
            destination_window = ?destination_window,
        );
        let request = types::shape::QueryExtentsRequest { destination_window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_query_extents_immediate<'this>(
        &'this mut self,
        destination_window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::shape::QueryExtentsReply>>
    {
        let cookie = self.shape_query_extents(destination_window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::shape::QueryExtentsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_select_input<'this>(
        &'this mut self,
        destination_window: types::xproto::Window,
        enable: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "shape_select_input",
            destination_window = ?destination_window,
            enable = ?enable,
        );
        let request = types::shape::SelectInputRequest {
            destination_window,
            enable,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_select_input_checked<'this>(
        &'this mut self,
        destination_window: types::xproto::Window,
        enable: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.shape_select_input(destination_window, enable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_input_selected<'this>(
        &'this mut self,
        destination_window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::shape::InputSelectedReply>> {
        let span = tracing::info_span!(
            "shape_input_selected",
            destination_window = ?destination_window,
        );
        let request = types::shape::InputSelectedRequest { destination_window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_input_selected_immediate<'this>(
        &'this mut self,
        destination_window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::shape::InputSelectedReply>>
    {
        let cookie = self.shape_input_selected(destination_window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::shape::InputSelectedReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_get_rectangles<'this>(
        &'this mut self,
        window: types::xproto::Window,
        source_kind: types::SK,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::shape::GetRectanglesReply>> {
        let span = tracing::info_span!(
            "shape_get_rectangles",
            window = ?window,
            source_kind = ?source_kind,
        );
        let request = types::shape::GetRectanglesRequest {
            window,
            source_kind,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "shape")]
    fn shape_get_rectangles_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        source_kind: types::SK,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::shape::GetRectanglesReply>>
    {
        let cookie = self.shape_get_rectangles(window, source_kind);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::shape::GetRectanglesReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "shm")]
    fn shm_query_version<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::shm::QueryVersionReply>> {
        let span = tracing::info_span!("shm_query_version",);
        let request = types::shm::QueryVersionRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_query_version_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::shm::QueryVersionReply>> {
        let cookie = self.shm_query_version();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::shm::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_attach<'this>(
        &'this mut self,
        shmseg: types::Seg,
        shmid: types::Card32,
        read_only: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "shm_attach",
            shmseg = ?shmseg,
            shmid = ?shmid,
            read_only = ?read_only,
        );
        let request = types::shm::AttachRequest {
            shmseg,
            shmid,
            read_only,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_attach_checked<'this>(
        &'this mut self,
        shmseg: types::Seg,
        shmid: types::Card32,
        read_only: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.shm_attach(shmseg, shmid, read_only);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_detach<'this>(
        &'this mut self,
        shmseg: types::Seg,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "shm_detach",
            shmseg = ?shmseg,
        );
        let request = types::shm::DetachRequest { shmseg };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_detach_checked<'this>(
        &'this mut self,
        shmseg: types::Seg,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.shm_detach(shmseg);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_put_image<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        total_width: types::Card16,
        total_height: types::Card16,
        src_x: types::Card16,
        src_y: types::Card16,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        depth: types::Card8,
        format: types::Card8,
        send_event: types::Bool,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "shm_put_image",
            drawable = ?drawable,
            gc = ?gc,
            total_width = ?total_width,
            total_height = ?total_height,
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            depth = ?depth,
            format = ?format,
            send_event = ?send_event,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let request = types::shm::PutImageRequest {
            drawable,
            gc,
            total_width,
            total_height,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            depth,
            format,
            send_event,
            shmseg,
            offset,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_put_image_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        total_width: types::Card16,
        total_height: types::Card16,
        src_x: types::Card16,
        src_y: types::Card16,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        depth: types::Card8,
        format: types::Card8,
        send_event: types::Bool,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.shm_put_image(
            drawable,
            gc,
            total_width,
            total_height,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            depth,
            format,
            send_event,
            shmseg,
            offset,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_get_image<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        plane_mask: types::Card32,
        format: types::Card8,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::shm::GetImageReply>> {
        let span = tracing::info_span!(
            "shm_get_image",
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            plane_mask = ?plane_mask,
            format = ?format,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let request = types::shm::GetImageRequest {
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
            format,
            shmseg,
            offset,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_get_image_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        plane_mask: types::Card32,
        format: types::Card8,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::shm::GetImageReply>> {
        let cookie = self.shm_get_image(
            drawable, x, y, width, height, plane_mask, format, shmseg, offset,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::shm::GetImageReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_create_pixmap<'this>(
        &'this mut self,
        pid: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
        depth: types::Card8,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "shm_create_pixmap",
            pid = ?pid,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
            depth = ?depth,
            shmseg = ?shmseg,
            offset = ?offset,
        );
        let request = types::shm::CreatePixmapRequest {
            pid,
            drawable,
            width,
            height,
            depth,
            shmseg,
            offset,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_create_pixmap_checked<'this>(
        &'this mut self,
        pid: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
        depth: types::Card8,
        shmseg: types::Seg,
        offset: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.shm_create_pixmap(pid, drawable, width, height, depth, shmseg, offset);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_attach_fd<'this>(
        &'this mut self,
        shmseg: types::Seg,
        shm_fd: types::Fd,
        read_only: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "shm_attach_fd",
            shmseg = ?shmseg,
            shm_fd = ?shm_fd,
            read_only = ?read_only,
        );
        let request = types::shm::AttachFdRequest {
            shmseg,
            shm_fd,
            read_only,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_attach_fd_checked<'this>(
        &'this mut self,
        shmseg: types::Seg,
        shm_fd: types::Fd,
        read_only: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.shm_attach_fd(shmseg, shm_fd, read_only);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_create_segment<'this>(
        &'this mut self,
        shmseg: types::Seg,
        size: types::Card32,
        read_only: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::shm::CreateSegmentReply>> {
        let span = tracing::info_span!(
            "shm_create_segment",
            shmseg = ?shmseg,
            size = ?size,
            read_only = ?read_only,
        );
        let request = types::shm::CreateSegmentRequest {
            shmseg,
            size,
            read_only,
        };
        self.send_reply_fd_request(request).instrument(span)
    }
    #[cfg(feature = "shm")]
    fn shm_create_segment_immediate<'this>(
        &'this mut self,
        shmseg: types::Seg,
        size: types::Card32,
        read_only: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::shm::CreateSegmentReply>>
    {
        let cookie = self.shm_create_segment(shmseg, size, read_only);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::shm::CreateSegmentReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "sync")]
    fn sync_initialize<'this>(
        &'this mut self,
        desired_major_version: types::Card8,
        desired_minor_version: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::sync::InitializeReply>> {
        let span = tracing::info_span!(
            "sync_initialize",
            desired_major_version = ?desired_major_version,
            desired_minor_version = ?desired_minor_version,
        );
        let request = types::sync::InitializeRequest {
            desired_major_version,
            desired_minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_initialize_immediate<'this>(
        &'this mut self,
        desired_major_version: types::Card8,
        desired_minor_version: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::sync::InitializeReply>> {
        let cookie = self.sync_initialize(desired_major_version, desired_minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::sync::InitializeReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_list_system_counters<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::sync::ListSystemCountersReply>> {
        let span = tracing::info_span!("sync_list_system_counters",);
        let request = types::sync::ListSystemCountersRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_list_system_counters_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::sync::ListSystemCountersReply>>
    {
        let cookie = self.sync_list_system_counters();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::sync::ListSystemCountersReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_create_counter<'this>(
        &'this mut self,
        id: types::Counter,
        initial_value: types::sync::Int64,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_create_counter",
            id = ?id,
            initial_value = ?initial_value,
        );
        let request = types::sync::CreateCounterRequest { id, initial_value };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_create_counter_checked<'this>(
        &'this mut self,
        id: types::Counter,
        initial_value: types::sync::Int64,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_create_counter(id, initial_value);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_counter<'this>(
        &'this mut self,
        counter: types::Counter,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_destroy_counter",
            counter = ?counter,
        );
        let request = types::sync::DestroyCounterRequest { counter };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_counter_checked<'this>(
        &'this mut self,
        counter: types::Counter,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_destroy_counter(counter);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_query_counter<'this>(
        &'this mut self,
        counter: types::Counter,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::sync::QueryCounterReply>> {
        let span = tracing::info_span!(
            "sync_query_counter",
            counter = ?counter,
        );
        let request = types::sync::QueryCounterRequest { counter };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_query_counter_immediate<'this>(
        &'this mut self,
        counter: types::Counter,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::sync::QueryCounterReply>>
    {
        let cookie = self.sync_query_counter(counter);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::sync::QueryCounterReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_await<'this>(
        &'this mut self,
        wait_list: impl AsRef<[types::Waitcondition]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("sync_await",);
        let request = types::sync::AwaitRequest {
            wait_list: Cow::Borrowed(wait_list.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_await_checked<'this>(
        &'this mut self,
        wait_list: impl AsRef<[types::Waitcondition]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_await(wait_list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_change_counter<'this>(
        &'this mut self,
        counter: types::Counter,
        amount: types::sync::Int64,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_change_counter",
            counter = ?counter,
            amount = ?amount,
        );
        let request = types::sync::ChangeCounterRequest { counter, amount };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_change_counter_checked<'this>(
        &'this mut self,
        counter: types::Counter,
        amount: types::sync::Int64,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_change_counter(counter, amount);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_set_counter<'this>(
        &'this mut self,
        counter: types::Counter,
        value: types::sync::Int64,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_set_counter",
            counter = ?counter,
            value = ?value,
        );
        let request = types::sync::SetCounterRequest { counter, value };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_set_counter_checked<'this>(
        &'this mut self,
        counter: types::Counter,
        value: types::sync::Int64,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_set_counter(counter, value);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_create_alarm<'this>(
        &'this mut self,
        id: types::Alarm,
        value_list: impl Borrow<types::sync::CreateAlarmAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_create_alarm",
            id = ?id,
        );
        let request = types::sync::CreateAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_create_alarm_checked<'this>(
        &'this mut self,
        id: types::Alarm,
        value_list: impl Borrow<types::sync::CreateAlarmAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_create_alarm(id, value_list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_change_alarm<'this>(
        &'this mut self,
        id: types::Alarm,
        value_list: impl Borrow<types::sync::ChangeAlarmAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_change_alarm",
            id = ?id,
        );
        let request = types::sync::ChangeAlarmRequest {
            id,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_change_alarm_checked<'this>(
        &'this mut self,
        id: types::Alarm,
        value_list: impl Borrow<types::sync::ChangeAlarmAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_change_alarm(id, value_list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_alarm<'this>(
        &'this mut self,
        alarm: types::Alarm,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_destroy_alarm",
            alarm = ?alarm,
        );
        let request = types::sync::DestroyAlarmRequest { alarm };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_alarm_checked<'this>(
        &'this mut self,
        alarm: types::Alarm,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_destroy_alarm(alarm);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_query_alarm<'this>(
        &'this mut self,
        alarm: types::Alarm,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::sync::QueryAlarmReply>> {
        let span = tracing::info_span!(
            "sync_query_alarm",
            alarm = ?alarm,
        );
        let request = types::sync::QueryAlarmRequest { alarm };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_query_alarm_immediate<'this>(
        &'this mut self,
        alarm: types::Alarm,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::sync::QueryAlarmReply>> {
        let cookie = self.sync_query_alarm(alarm);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::sync::QueryAlarmReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_set_priority<'this>(
        &'this mut self,
        id: types::Card32,
        priority: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_set_priority",
            id = ?id,
            priority = ?priority,
        );
        let request = types::sync::SetPriorityRequest { id, priority };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_set_priority_checked<'this>(
        &'this mut self,
        id: types::Card32,
        priority: types::Int32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_set_priority(id, priority);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_get_priority<'this>(
        &'this mut self,
        id: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::sync::GetPriorityReply>> {
        let span = tracing::info_span!(
            "sync_get_priority",
            id = ?id,
        );
        let request = types::sync::GetPriorityRequest { id };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_get_priority_immediate<'this>(
        &'this mut self,
        id: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::sync::GetPriorityReply>> {
        let cookie = self.sync_get_priority(id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::sync::GetPriorityReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_create_fence<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        fence: types::Fence,
        initially_triggered: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_create_fence",
            drawable = ?drawable,
            fence = ?fence,
            initially_triggered = ?initially_triggered,
        );
        let request = types::sync::CreateFenceRequest {
            drawable,
            fence,
            initially_triggered,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_create_fence_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        fence: types::Fence,
        initially_triggered: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_create_fence(drawable, fence, initially_triggered);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_trigger_fence<'this>(
        &'this mut self,
        fence: types::Fence,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_trigger_fence",
            fence = ?fence,
        );
        let request = types::sync::TriggerFenceRequest { fence };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_trigger_fence_checked<'this>(
        &'this mut self,
        fence: types::Fence,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_trigger_fence(fence);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_reset_fence<'this>(
        &'this mut self,
        fence: types::Fence,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_reset_fence",
            fence = ?fence,
        );
        let request = types::sync::ResetFenceRequest { fence };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_reset_fence_checked<'this>(
        &'this mut self,
        fence: types::Fence,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_reset_fence(fence);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_fence<'this>(
        &'this mut self,
        fence: types::Fence,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "sync_destroy_fence",
            fence = ?fence,
        );
        let request = types::sync::DestroyFenceRequest { fence };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_destroy_fence_checked<'this>(
        &'this mut self,
        fence: types::Fence,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_destroy_fence(fence);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_query_fence<'this>(
        &'this mut self,
        fence: types::Fence,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::sync::QueryFenceReply>> {
        let span = tracing::info_span!(
            "sync_query_fence",
            fence = ?fence,
        );
        let request = types::sync::QueryFenceRequest { fence };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_query_fence_immediate<'this>(
        &'this mut self,
        fence: types::Fence,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::sync::QueryFenceReply>> {
        let cookie = self.sync_query_fence(fence);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::sync::QueryFenceReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_await_fence<'this>(
        &'this mut self,
        fence_list: impl AsRef<[types::Fence]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("sync_await_fence",);
        let request = types::sync::AwaitFenceRequest {
            fence_list: Cow::Borrowed(fence_list.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "sync")]
    fn sync_await_fence_checked<'this>(
        &'this mut self,
        fence_list: impl AsRef<[types::Fence]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.sync_await_fence(fence_list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    fn xc_misc_get_version<'this>(
        &'this mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xc_misc::GetVersionReply>> {
        let span = tracing::info_span!(
            "xc_misc_get_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::xc_misc::GetVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn xc_misc_get_version_immediate<'this>(
        &'this mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xc_misc::GetVersionReply>>
    {
        let cookie = self.xc_misc_get_version(client_major_version, client_minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xc_misc::GetVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    fn xc_misc_get_xid_range<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xc_misc::GetXIDRangeReply>> {
        let span = tracing::info_span!("xc_misc_get_xid_range",);
        let request = types::xc_misc::GetXIDRangeRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn xc_misc_get_xid_range_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xc_misc::GetXIDRangeReply>>
    {
        let cookie = self.xc_misc_get_xid_range();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xc_misc::GetXIDRangeReply> =
            cookie.into();
        res.instrument(span)
    }
    fn xc_misc_get_xid_list<'this>(
        &'this mut self,
        count: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xc_misc::GetXIDListReply>> {
        let span = tracing::info_span!(
            "xc_misc_get_xid_list",
            count = ?count,
        );
        let request = types::xc_misc::GetXIDListRequest { count };
        self.send_reply_request(request).instrument(span)
    }
    fn xc_misc_get_xid_list_immediate<'this>(
        &'this mut self,
        count: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xc_misc::GetXIDListReply>>
    {
        let cookie = self.xc_misc_get_xid_list(count);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xc_misc::GetXIDListReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xevie")]
    fn xevie_query_version<'this>(
        &'this mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xevie::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xevie_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::xevie::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xevie")]
    fn xevie_query_version_immediate<'this>(
        &'this mut self,
        client_major_version: types::Card16,
        client_minor_version: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xevie::QueryVersionReply>>
    {
        let cookie = self.xevie_query_version(client_major_version, client_minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xevie::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xevie")]
    fn xevie_start<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xevie::StartReply>> {
        let span = tracing::info_span!(
            "xevie_start",
            screen = ?screen,
        );
        let request = types::xevie::StartRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xevie")]
    fn xevie_start_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xevie::StartReply>> {
        let cookie = self.xevie_start(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xevie::StartReply> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xevie")]
    fn xevie_end<'this>(
        &'this mut self,
        cmap: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xevie::EndReply>> {
        let span = tracing::info_span!(
            "xevie_end",
            cmap = ?cmap,
        );
        let request = types::xevie::EndRequest { cmap };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xevie")]
    fn xevie_end_immediate<'this>(
        &'this mut self,
        cmap: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xevie::EndReply>> {
        let cookie = self.xevie_end(cmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xevie::EndReply> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xevie")]
    fn xevie_send<'this>(
        &'this mut self,
        event: types::xevie::Event,
        data_type: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xevie::SendReply>> {
        let span = tracing::info_span!(
            "xevie_send",
            event = ?event,
            data_type = ?data_type,
        );
        let request = types::xevie::SendRequest { event, data_type };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xevie")]
    fn xevie_send_immediate<'this>(
        &'this mut self,
        event: types::xevie::Event,
        data_type: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xevie::SendReply>> {
        let cookie = self.xevie_send(event, data_type);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xevie::SendReply> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xevie")]
    fn xevie_select_input<'this>(
        &'this mut self,
        event_mask: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xevie::SelectInputReply>> {
        let span = tracing::info_span!(
            "xevie_select_input",
            event_mask = ?event_mask,
        );
        let request = types::xevie::SelectInputRequest { event_mask };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xevie")]
    fn xevie_select_input_immediate<'this>(
        &'this mut self,
        event_mask: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xevie::SelectInputReply>>
    {
        let cookie = self.xevie_select_input(event_mask);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xevie::SelectInputReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_version<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86dri::QueryVersionReply>> {
        let span = tracing::info_span!("xf86dri_query_version",);
        let request = types::xf86dri::QueryVersionRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_version_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86dri::QueryVersionReply>>
    {
        let cookie = self.xf86dri_query_version();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_direct_rendering_capable<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<
        futures::SendRequest<'this, Self, types::xf86dri::QueryDirectRenderingCapableReply>,
    > {
        let span = tracing::info_span!(
            "xf86dri_query_direct_rendering_capable",
            screen = ?screen,
        );
        let request = types::xf86dri::QueryDirectRenderingCapableRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_query_direct_rendering_capable_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xf86dri::QueryDirectRenderingCapableReply>,
    > {
        let cookie = self.xf86dri_query_direct_rendering_capable(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xf86dri::QueryDirectRenderingCapableReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_open_connection<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86dri::OpenConnectionReply>> {
        let span = tracing::info_span!(
            "xf86dri_open_connection",
            screen = ?screen,
        );
        let request = types::xf86dri::OpenConnectionRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_open_connection_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86dri::OpenConnectionReply>>
    {
        let cookie = self.xf86dri_open_connection(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::OpenConnectionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_close_connection<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86dri_close_connection",
            screen = ?screen,
        );
        let request = types::xf86dri::CloseConnectionRequest { screen };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_close_connection_checked<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86dri_close_connection(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_client_driver_name<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86dri::GetClientDriverNameReply>>
    {
        let span = tracing::info_span!(
            "xf86dri_get_client_driver_name",
            screen = ?screen,
        );
        let request = types::xf86dri::GetClientDriverNameRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_client_driver_name_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xf86dri::GetClientDriverNameReply>,
    > {
        let cookie = self.xf86dri_get_client_driver_name(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xf86dri::GetClientDriverNameReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_context<'this>(
        &'this mut self,
        screen: types::Card32,
        visual: types::Card32,
        context: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86dri::CreateContextReply>> {
        let span = tracing::info_span!(
            "xf86dri_create_context",
            screen = ?screen,
            visual = ?visual,
            context = ?context,
        );
        let request = types::xf86dri::CreateContextRequest {
            screen,
            visual,
            context,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_context_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
        visual: types::Card32,
        context: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86dri::CreateContextReply>>
    {
        let cookie = self.xf86dri_create_context(screen, visual, context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::CreateContextReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_context<'this>(
        &'this mut self,
        screen: types::Card32,
        context: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86dri_destroy_context",
            screen = ?screen,
            context = ?context,
        );
        let request = types::xf86dri::DestroyContextRequest { screen, context };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_context_checked<'this>(
        &'this mut self,
        screen: types::Card32,
        context: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86dri_destroy_context(screen, context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_drawable<'this>(
        &'this mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86dri::CreateDrawableReply>> {
        let span = tracing::info_span!(
            "xf86dri_create_drawable",
            screen = ?screen,
            drawable = ?drawable,
        );
        let request = types::xf86dri::CreateDrawableRequest { screen, drawable };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_create_drawable_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86dri::CreateDrawableReply>>
    {
        let cookie = self.xf86dri_create_drawable(screen, drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::CreateDrawableReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_drawable<'this>(
        &'this mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86dri_destroy_drawable",
            screen = ?screen,
            drawable = ?drawable,
        );
        let request = types::xf86dri::DestroyDrawableRequest { screen, drawable };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_destroy_drawable_checked<'this>(
        &'this mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86dri_destroy_drawable(screen, drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_drawable_info<'this>(
        &'this mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86dri::GetDrawableInfoReply>> {
        let span = tracing::info_span!(
            "xf86dri_get_drawable_info",
            screen = ?screen,
            drawable = ?drawable,
        );
        let request = types::xf86dri::GetDrawableInfoRequest { screen, drawable };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_drawable_info_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
        drawable: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86dri::GetDrawableInfoReply>>
    {
        let cookie = self.xf86dri_get_drawable_info(screen, drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::GetDrawableInfoReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_device_info<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86dri::GetDeviceInfoReply>> {
        let span = tracing::info_span!(
            "xf86dri_get_device_info",
            screen = ?screen,
        );
        let request = types::xf86dri::GetDeviceInfoRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_get_device_info_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86dri::GetDeviceInfoReply>>
    {
        let cookie = self.xf86dri_get_device_info(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::GetDeviceInfoReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_auth_connection<'this>(
        &'this mut self,
        screen: types::Card32,
        magic: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86dri::AuthConnectionReply>> {
        let span = tracing::info_span!(
            "xf86dri_auth_connection",
            screen = ?screen,
            magic = ?magic,
        );
        let request = types::xf86dri::AuthConnectionRequest { screen, magic };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86dri")]
    fn xf86dri_auth_connection_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
        magic: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86dri::AuthConnectionReply>>
    {
        let cookie = self.xf86dri_auth_connection(screen, magic);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86dri::AuthConnectionReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_query_version<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86vidmode::QueryVersionReply>>
    {
        let span = tracing::info_span!("xf86vidmode_query_version",);
        let request = types::xf86vidmode::QueryVersionRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_query_version_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86vidmode::QueryVersionReply>>
    {
        let cookie = self.xf86vidmode_query_version();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_mode_line<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86vidmode::GetModeLineReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_mode_line",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetModeLineRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_mode_line_immediate<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetModeLineReply>>
    {
        let cookie = self.xf86vidmode_get_mode_line(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetModeLineReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_mod_mode_line<'this>(
        &'this mut self,
        screen: types::Card32,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86vidmode_mod_mode_line",
            screen = ?screen,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let request = types::xf86vidmode::ModModeLineRequest {
            screen,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_mod_mode_line_checked<'this>(
        &'this mut self,
        screen: types::Card32,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86vidmode_mod_mode_line(
            screen, hdisplay, hsyncstart, hsyncend, htotal, hskew, vdisplay, vsyncstart, vsyncend,
            vtotal, flags, private,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_mode<'this>(
        &'this mut self,
        screen: types::Card16,
        zoom: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86vidmode_switch_mode",
            screen = ?screen,
            zoom = ?zoom,
        );
        let request = types::xf86vidmode::SwitchModeRequest { screen, zoom };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_mode_checked<'this>(
        &'this mut self,
        screen: types::Card16,
        zoom: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86vidmode_switch_mode(screen, zoom);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_monitor<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86vidmode::GetMonitorReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_monitor",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetMonitorRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_monitor_immediate<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetMonitorReply>>
    {
        let cookie = self.xf86vidmode_get_monitor(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetMonitorReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_lock_mode_switch<'this>(
        &'this mut self,
        screen: types::Card16,
        lock: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86vidmode_lock_mode_switch",
            screen = ?screen,
            lock = ?lock,
        );
        let request = types::xf86vidmode::LockModeSwitchRequest { screen, lock };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_lock_mode_switch_checked<'this>(
        &'this mut self,
        screen: types::Card16,
        lock: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86vidmode_lock_mode_switch(screen, lock);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_all_mode_lines<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86vidmode::GetAllModeLinesReply>>
    {
        let span = tracing::info_span!(
            "xf86vidmode_get_all_mode_lines",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetAllModeLinesRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_all_mode_lines_immediate<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetAllModeLinesReply>,
    > {
        let cookie = self.xf86vidmode_get_all_mode_lines(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xf86vidmode::GetAllModeLinesReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_add_mode_line<'this>(
        &'this mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        after_dotclock: types::Dotclock,
        after_hdisplay: types::Card16,
        after_hsyncstart: types::Card16,
        after_hsyncend: types::Card16,
        after_htotal: types::Card16,
        after_hskew: types::Card16,
        after_vdisplay: types::Card16,
        after_vsyncstart: types::Card16,
        after_vsyncend: types::Card16,
        after_vtotal: types::Card16,
        after_flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86vidmode_add_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
            after_dotclock = ?after_dotclock,
            after_hdisplay = ?after_hdisplay,
            after_hsyncstart = ?after_hsyncstart,
            after_hsyncend = ?after_hsyncend,
            after_htotal = ?after_htotal,
            after_hskew = ?after_hskew,
            after_vdisplay = ?after_vdisplay,
            after_vsyncstart = ?after_vsyncstart,
            after_vsyncend = ?after_vsyncend,
            after_vtotal = ?after_vtotal,
        );
        let request = types::xf86vidmode::AddModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            after_dotclock,
            after_hdisplay,
            after_hsyncstart,
            after_hsyncend,
            after_htotal,
            after_hskew,
            after_vdisplay,
            after_vsyncstart,
            after_vsyncend,
            after_vtotal,
            after_flags: Into::<u32>::into(after_flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_add_mode_line_checked<'this>(
        &'this mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        after_dotclock: types::Dotclock,
        after_hdisplay: types::Card16,
        after_hsyncstart: types::Card16,
        after_hsyncend: types::Card16,
        after_htotal: types::Card16,
        after_hskew: types::Card16,
        after_vdisplay: types::Card16,
        after_vsyncstart: types::Card16,
        after_vsyncend: types::Card16,
        after_vtotal: types::Card16,
        after_flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86vidmode_add_mode_line(
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags,
            after_dotclock,
            after_hdisplay,
            after_hsyncstart,
            after_hsyncend,
            after_htotal,
            after_hskew,
            after_vdisplay,
            after_vsyncstart,
            after_vsyncend,
            after_vtotal,
            after_flags,
            private,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_delete_mode_line<'this>(
        &'this mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86vidmode_delete_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let request = types::xf86vidmode::DeleteModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_delete_mode_line_checked<'this>(
        &'this mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86vidmode_delete_mode_line(
            screen, dotclock, hdisplay, hsyncstart, hsyncend, htotal, hskew, vdisplay, vsyncstart,
            vsyncend, vtotal, flags, private,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_validate_mode_line<'this>(
        &'this mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86vidmode::ValidateModeLineReply>>
    {
        let span = tracing::info_span!(
            "xf86vidmode_validate_mode_line",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let request = types::xf86vidmode::ValidateModeLineRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_validate_mode_line_immediate<'this>(
        &'this mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xf86vidmode::ValidateModeLineReply>,
    > {
        let cookie = self.xf86vidmode_validate_mode_line(
            screen, dotclock, hdisplay, hsyncstart, hsyncend, htotal, hskew, vdisplay, vsyncstart,
            vsyncend, vtotal, flags, private,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xf86vidmode::ValidateModeLineReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_to_mode<'this>(
        &'this mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86vidmode_switch_to_mode",
            screen = ?screen,
            dotclock = ?dotclock,
            hdisplay = ?hdisplay,
            hsyncstart = ?hsyncstart,
            hsyncend = ?hsyncend,
            htotal = ?htotal,
            hskew = ?hskew,
            vdisplay = ?vdisplay,
            vsyncstart = ?vsyncstart,
            vsyncend = ?vsyncend,
            vtotal = ?vtotal,
        );
        let request = types::xf86vidmode::SwitchToModeRequest {
            screen,
            dotclock,
            hdisplay,
            hsyncstart,
            hsyncend,
            htotal,
            hskew,
            vdisplay,
            vsyncstart,
            vsyncend,
            vtotal,
            flags: Into::<u32>::into(flags.into()) as _,
            private: Cow::Borrowed(private.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_switch_to_mode_checked<'this>(
        &'this mut self,
        screen: types::Card32,
        dotclock: types::Dotclock,
        hdisplay: types::Card16,
        hsyncstart: types::Card16,
        hsyncend: types::Card16,
        htotal: types::Card16,
        hskew: types::Card16,
        vdisplay: types::Card16,
        vsyncstart: types::Card16,
        vsyncend: types::Card16,
        vtotal: types::Card16,
        flags: impl Into<types::xf86vidmode::ModeFlag>,
        private: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86vidmode_switch_to_mode(
            screen, dotclock, hdisplay, hsyncstart, hsyncend, htotal, hskew, vdisplay, vsyncstart,
            vsyncend, vtotal, flags, private,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_view_port<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86vidmode::GetViewPortReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_view_port",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetViewPortRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_view_port_immediate<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetViewPortReply>>
    {
        let cookie = self.xf86vidmode_get_view_port(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetViewPortReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_view_port<'this>(
        &'this mut self,
        screen: types::Card16,
        x: types::Card32,
        y: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_view_port",
            screen = ?screen,
            x = ?x,
            y = ?y,
        );
        let request = types::xf86vidmode::SetViewPortRequest { screen, x, y };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_view_port_checked<'this>(
        &'this mut self,
        screen: types::Card16,
        x: types::Card32,
        y: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86vidmode_set_view_port(screen, x, y);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_dot_clocks<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86vidmode::GetDotClocksReply>>
    {
        let span = tracing::info_span!(
            "xf86vidmode_get_dot_clocks",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetDotClocksRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_dot_clocks_immediate<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetDotClocksReply>>
    {
        let cookie = self.xf86vidmode_get_dot_clocks(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetDotClocksReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_client_version<'this>(
        &'this mut self,
        major: types::Card16,
        minor: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_client_version",
            major = ?major,
            minor = ?minor,
        );
        let request = types::xf86vidmode::SetClientVersionRequest { major, minor };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_client_version_checked<'this>(
        &'this mut self,
        major: types::Card16,
        minor: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86vidmode_set_client_version(major, minor);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma<'this>(
        &'this mut self,
        screen: types::Card16,
        red: types::Card32,
        green: types::Card32,
        blue: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_gamma",
            screen = ?screen,
            red = ?red,
            green = ?green,
            blue = ?blue,
        );
        let request = types::xf86vidmode::SetGammaRequest {
            screen,
            red,
            green,
            blue,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_checked<'this>(
        &'this mut self,
        screen: types::Card16,
        red: types::Card32,
        green: types::Card32,
        blue: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86vidmode_set_gamma(screen, red, green, blue);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86vidmode::GetGammaReply>> {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetGammaRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_immediate<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetGammaReply>>
    {
        let cookie = self.xf86vidmode_get_gamma(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetGammaReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp<'this>(
        &'this mut self,
        screen: types::Card16,
        size: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86vidmode::GetGammaRampReply>>
    {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma_ramp",
            screen = ?screen,
            size = ?size,
        );
        let request = types::xf86vidmode::GetGammaRampRequest { screen, size };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_immediate<'this>(
        &'this mut self,
        screen: types::Card16,
        size: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetGammaRampReply>>
    {
        let cookie = self.xf86vidmode_get_gamma_ramp(screen, size);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetGammaRampReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_ramp<'this>(
        &'this mut self,
        screen: types::Card16,
        size: types::Card16,
        red: impl AsRef<[types::Card16]>,
        green: impl AsRef<[types::Card16]>,
        blue: impl AsRef<[types::Card16]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xf86vidmode_set_gamma_ramp",
            screen = ?screen,
            size = ?size,
        );
        let request = types::xf86vidmode::SetGammaRampRequest {
            screen,
            size,
            red: Cow::Borrowed(red.as_ref()),
            green: Cow::Borrowed(green.as_ref()),
            blue: Cow::Borrowed(blue.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_set_gamma_ramp_checked<'this>(
        &'this mut self,
        screen: types::Card16,
        size: types::Card16,
        red: impl AsRef<[types::Card16]>,
        green: impl AsRef<[types::Card16]>,
        blue: impl AsRef<[types::Card16]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xf86vidmode_set_gamma_ramp(screen, size, red, green, blue);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_size<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86vidmode::GetGammaRampSizeReply>>
    {
        let span = tracing::info_span!(
            "xf86vidmode_get_gamma_ramp_size",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetGammaRampSizeRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_gamma_ramp_size_immediate<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetGammaRampSizeReply>,
    > {
        let cookie = self.xf86vidmode_get_gamma_ramp_size(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xf86vidmode::GetGammaRampSizeReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_permissions<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xf86vidmode::GetPermissionsReply>>
    {
        let span = tracing::info_span!(
            "xf86vidmode_get_permissions",
            screen = ?screen,
        );
        let request = types::xf86vidmode::GetPermissionsRequest { screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xf86vidmode")]
    fn xf86vidmode_get_permissions_immediate<'this>(
        &'this mut self,
        screen: types::Card16,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetPermissionsReply>,
    > {
        let cookie = self.xf86vidmode_get_permissions(screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xf86vidmode::GetPermissionsReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xfixes")]
    fn xfixes_query_version<'this>(
        &'this mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xfixes::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xfixes_query_version",
            client_major_version = ?client_major_version,
            client_minor_version = ?client_minor_version,
        );
        let request = types::xfixes::QueryVersionRequest {
            client_major_version,
            client_minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_query_version_immediate<'this>(
        &'this mut self,
        client_major_version: types::Card32,
        client_minor_version: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xfixes::QueryVersionReply>>
    {
        let cookie = self.xfixes_query_version(client_major_version, client_minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xfixes::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_save_set<'this>(
        &'this mut self,
        mode: types::SaveSetMode,
        target: types::SaveSetTarget,
        map: types::SaveSetMapping,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_change_save_set",
            mode = ?mode,
            target = ?target,
            map = ?map,
            window = ?window,
        );
        let request = types::xfixes::ChangeSaveSetRequest {
            mode,
            target,
            map,
            window,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_save_set_checked<'this>(
        &'this mut self,
        mode: types::SaveSetMode,
        target: types::SaveSetTarget,
        map: types::SaveSetMapping,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_change_save_set(mode, target, map, window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_selection_input<'this>(
        &'this mut self,
        window: types::xproto::Window,
        selection: types::Atom,
        event_mask: impl Into<types::SelectionEventMask>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_select_selection_input",
            window = ?window,
            selection = ?selection,
        );
        let request = types::xfixes::SelectSelectionInputRequest {
            window,
            selection,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_selection_input_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        selection: types::Atom,
        event_mask: impl Into<types::SelectionEventMask>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_select_selection_input(window, selection, event_mask);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_cursor_input<'this>(
        &'this mut self,
        window: types::xproto::Window,
        event_mask: impl Into<types::CursorNotifyMask>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_select_cursor_input",
            window = ?window,
        );
        let request = types::xfixes::SelectCursorInputRequest {
            window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_select_cursor_input_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        event_mask: impl Into<types::CursorNotifyMask>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_select_cursor_input(window, event_mask);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xfixes::GetCursorImageReply>> {
        let span = tracing::info_span!("xfixes_get_cursor_image",);
        let request = types::xfixes::GetCursorImageRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xfixes::GetCursorImageReply>>
    {
        let cookie = self.xfixes_get_cursor_image();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xfixes::GetCursorImageReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region<'this>(
        &'this mut self,
        region: types::Region,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_create_region",
            region = ?region,
        );
        let request = types::xfixes::CreateRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_checked<'this>(
        &'this mut self,
        region: types::Region,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_create_region(region, rectangles);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_bitmap<'this>(
        &'this mut self,
        region: types::Region,
        bitmap: types::xproto::Pixmap,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_bitmap",
            region = ?region,
            bitmap = ?bitmap,
        );
        let request = types::xfixes::CreateRegionFromBitmapRequest { region, bitmap };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_bitmap_checked<'this>(
        &'this mut self,
        region: types::Region,
        bitmap: types::xproto::Pixmap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_create_region_from_bitmap(region, bitmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_window<'this>(
        &'this mut self,
        region: types::Region,
        window: types::xproto::Window,
        kind: types::SK,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_window",
            region = ?region,
            window = ?window,
            kind = ?kind,
        );
        let request = types::xfixes::CreateRegionFromWindowRequest {
            region,
            window,
            kind,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_window_checked<'this>(
        &'this mut self,
        region: types::Region,
        window: types::xproto::Window,
        kind: types::SK,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_create_region_from_window(region, window, kind);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_gc<'this>(
        &'this mut self,
        region: types::Region,
        gc: types::Gcontext,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_gc",
            region = ?region,
            gc = ?gc,
        );
        let request = types::xfixes::CreateRegionFromGCRequest { region, gc };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_gc_checked<'this>(
        &'this mut self,
        region: types::Region,
        gc: types::Gcontext,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_create_region_from_gc(region, gc);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_picture<'this>(
        &'this mut self,
        region: types::Region,
        picture: types::Picture,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_create_region_from_picture",
            region = ?region,
            picture = ?picture,
        );
        let request = types::xfixes::CreateRegionFromPictureRequest { region, picture };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_region_from_picture_checked<'this>(
        &'this mut self,
        region: types::Region,
        picture: types::Picture,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_create_region_from_picture(region, picture);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_destroy_region<'this>(
        &'this mut self,
        region: types::Region,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_destroy_region",
            region = ?region,
        );
        let request = types::xfixes::DestroyRegionRequest { region };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_destroy_region_checked<'this>(
        &'this mut self,
        region: types::Region,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_destroy_region(region);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_region<'this>(
        &'this mut self,
        region: types::Region,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_set_region",
            region = ?region,
        );
        let request = types::xfixes::SetRegionRequest {
            region,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_region_checked<'this>(
        &'this mut self,
        region: types::Region,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_set_region(region, rectangles);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_copy_region<'this>(
        &'this mut self,
        source: types::Region,
        destination: types::Region,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_copy_region",
            source = ?source,
            destination = ?destination,
        );
        let request = types::xfixes::CopyRegionRequest {
            source,
            destination,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_copy_region_checked<'this>(
        &'this mut self,
        source: types::Region,
        destination: types::Region,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_copy_region(source, destination);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_union_region<'this>(
        &'this mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_union_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let request = types::xfixes::UnionRegionRequest {
            source1,
            source2,
            destination,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_union_region_checked<'this>(
        &'this mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_union_region(source1, source2, destination);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_intersect_region<'this>(
        &'this mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_intersect_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let request = types::xfixes::IntersectRegionRequest {
            source1,
            source2,
            destination,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_intersect_region_checked<'this>(
        &'this mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_intersect_region(source1, source2, destination);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_subtract_region<'this>(
        &'this mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_subtract_region",
            source1 = ?source1,
            source2 = ?source2,
            destination = ?destination,
        );
        let request = types::xfixes::SubtractRegionRequest {
            source1,
            source2,
            destination,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_subtract_region_checked<'this>(
        &'this mut self,
        source1: types::Region,
        source2: types::Region,
        destination: types::Region,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_subtract_region(source1, source2, destination);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_invert_region<'this>(
        &'this mut self,
        source: types::Region,
        bounds: types::Rectangle,
        destination: types::Region,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_invert_region",
            source = ?source,
            bounds = ?bounds,
            destination = ?destination,
        );
        let request = types::xfixes::InvertRegionRequest {
            source,
            bounds,
            destination,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_invert_region_checked<'this>(
        &'this mut self,
        source: types::Region,
        bounds: types::Rectangle,
        destination: types::Region,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_invert_region(source, bounds, destination);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_translate_region<'this>(
        &'this mut self,
        region: types::Region,
        dx: types::Int16,
        dy: types::Int16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_translate_region",
            region = ?region,
            dx = ?dx,
            dy = ?dy,
        );
        let request = types::xfixes::TranslateRegionRequest { region, dx, dy };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_translate_region_checked<'this>(
        &'this mut self,
        region: types::Region,
        dx: types::Int16,
        dy: types::Int16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_translate_region(region, dx, dy);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_region_extents<'this>(
        &'this mut self,
        source: types::Region,
        destination: types::Region,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_region_extents",
            source = ?source,
            destination = ?destination,
        );
        let request = types::xfixes::RegionExtentsRequest {
            source,
            destination,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_region_extents_checked<'this>(
        &'this mut self,
        source: types::Region,
        destination: types::Region,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_region_extents(source, destination);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_fetch_region<'this>(
        &'this mut self,
        region: types::Region,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xfixes::FetchRegionReply>> {
        let span = tracing::info_span!(
            "xfixes_fetch_region",
            region = ?region,
        );
        let request = types::xfixes::FetchRegionRequest { region };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_fetch_region_immediate<'this>(
        &'this mut self,
        region: types::Region,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xfixes::FetchRegionReply>>
    {
        let cookie = self.xfixes_fetch_region(region);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xfixes::FetchRegionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_gc_clip_region<'this>(
        &'this mut self,
        gc: types::Gcontext,
        region: impl Into<types::Region>,
        x_origin: types::Int16,
        y_origin: types::Int16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_set_gc_clip_region",
            gc = ?gc,
            x_origin = ?x_origin,
            y_origin = ?y_origin,
        );
        let request = types::xfixes::SetGCClipRegionRequest {
            gc,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_gc_clip_region_checked<'this>(
        &'this mut self,
        gc: types::Gcontext,
        region: impl Into<types::Region>,
        x_origin: types::Int16,
        y_origin: types::Int16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_set_gc_clip_region(gc, region, x_origin, y_origin);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_window_shape_region<'this>(
        &'this mut self,
        dest: types::xproto::Window,
        dest_kind: types::SK,
        x_offset: types::Int16,
        y_offset: types::Int16,
        region: impl Into<types::Region>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_set_window_shape_region",
            dest = ?dest,
            dest_kind = ?dest_kind,
            x_offset = ?x_offset,
            y_offset = ?y_offset,
        );
        let request = types::xfixes::SetWindowShapeRegionRequest {
            dest,
            dest_kind,
            x_offset,
            y_offset,
            region: Into::<u32>::into(region.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_window_shape_region_checked<'this>(
        &'this mut self,
        dest: types::xproto::Window,
        dest_kind: types::SK,
        x_offset: types::Int16,
        y_offset: types::Int16,
        region: impl Into<types::Region>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie =
            self.xfixes_set_window_shape_region(dest, dest_kind, x_offset, y_offset, region);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_picture_clip_region<'this>(
        &'this mut self,
        picture: types::Picture,
        region: impl Into<types::Region>,
        x_origin: types::Int16,
        y_origin: types::Int16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_set_picture_clip_region",
            picture = ?picture,
            x_origin = ?x_origin,
            y_origin = ?y_origin,
        );
        let request = types::xfixes::SetPictureClipRegionRequest {
            picture,
            region: Into::<u32>::into(region.into()) as _,
            x_origin,
            y_origin,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_picture_clip_region_checked<'this>(
        &'this mut self,
        picture: types::Picture,
        region: impl Into<types::Region>,
        x_origin: types::Int16,
        y_origin: types::Int16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_set_picture_clip_region(picture, region, x_origin, y_origin);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_cursor_name<'this>(
        &'this mut self,
        cursor: types::xproto::Cursor,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_set_cursor_name",
            cursor = ?cursor,
        );
        let request = types::xfixes::SetCursorNameRequest {
            cursor,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_set_cursor_name_checked<'this>(
        &'this mut self,
        cursor: types::xproto::Cursor,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_set_cursor_name(cursor, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_name<'this>(
        &'this mut self,
        cursor: types::xproto::Cursor,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xfixes::GetCursorNameReply>> {
        let span = tracing::info_span!(
            "xfixes_get_cursor_name",
            cursor = ?cursor,
        );
        let request = types::xfixes::GetCursorNameRequest { cursor };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_name_immediate<'this>(
        &'this mut self,
        cursor: types::xproto::Cursor,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xfixes::GetCursorNameReply>>
    {
        let cookie = self.xfixes_get_cursor_name(cursor);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xfixes::GetCursorNameReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_and_name<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xfixes::GetCursorImageAndNameReply>>
    {
        let span = tracing::info_span!("xfixes_get_cursor_image_and_name",);
        let request = types::xfixes::GetCursorImageAndNameRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_get_cursor_image_and_name_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xfixes::GetCursorImageAndNameReply>,
    > {
        let cookie = self.xfixes_get_cursor_image_and_name();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xfixes::GetCursorImageAndNameReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor<'this>(
        &'this mut self,
        source: types::xproto::Cursor,
        destination: types::xproto::Cursor,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_change_cursor",
            source = ?source,
            destination = ?destination,
        );
        let request = types::xfixes::ChangeCursorRequest {
            source,
            destination,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_checked<'this>(
        &'this mut self,
        source: types::xproto::Cursor,
        destination: types::xproto::Cursor,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_change_cursor(source, destination);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_by_name<'this>(
        &'this mut self,
        src: types::xproto::Cursor,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_change_cursor_by_name",
            src = ?src,
        );
        let request = types::xfixes::ChangeCursorByNameRequest {
            src,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_change_cursor_by_name_checked<'this>(
        &'this mut self,
        src: types::xproto::Cursor,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_change_cursor_by_name(src, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_expand_region<'this>(
        &'this mut self,
        source: types::Region,
        destination: types::Region,
        left: types::Card16,
        right: types::Card16,
        top: types::Card16,
        bottom: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_expand_region",
            source = ?source,
            destination = ?destination,
            left = ?left,
            right = ?right,
            top = ?top,
            bottom = ?bottom,
        );
        let request = types::xfixes::ExpandRegionRequest {
            source,
            destination,
            left,
            right,
            top,
            bottom,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_expand_region_checked<'this>(
        &'this mut self,
        source: types::Region,
        destination: types::Region,
        left: types::Card16,
        right: types::Card16,
        top: types::Card16,
        bottom: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_expand_region(source, destination, left, right, top, bottom);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_hide_cursor<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_hide_cursor",
            window = ?window,
        );
        let request = types::xfixes::HideCursorRequest { window };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_hide_cursor_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_hide_cursor(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_show_cursor<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_show_cursor",
            window = ?window,
        );
        let request = types::xfixes::ShowCursorRequest { window };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_show_cursor_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_show_cursor(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_pointer_barrier<'this>(
        &'this mut self,
        barrier: types::Barrier,
        window: types::xproto::Window,
        x1: types::Card16,
        y1: types::Card16,
        x2: types::Card16,
        y2: types::Card16,
        directions: impl Into<types::BarrierDirections>,
        devices: impl AsRef<[types::Card16]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_create_pointer_barrier",
            barrier = ?barrier,
            window = ?window,
            x1 = ?x1,
            y1 = ?y1,
            x2 = ?x2,
            y2 = ?y2,
        );
        let request = types::xfixes::CreatePointerBarrierRequest {
            barrier,
            window,
            x1,
            y1,
            x2,
            y2,
            directions: Into::<u32>::into(directions.into()) as _,
            devices: Cow::Borrowed(devices.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_create_pointer_barrier_checked<'this>(
        &'this mut self,
        barrier: types::Barrier,
        window: types::xproto::Window,
        x1: types::Card16,
        y1: types::Card16,
        x2: types::Card16,
        y2: types::Card16,
        directions: impl Into<types::BarrierDirections>,
        devices: impl AsRef<[types::Card16]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self
            .xfixes_create_pointer_barrier(barrier, window, x1, y1, x2, y2, directions, devices);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_delete_pointer_barrier<'this>(
        &'this mut self,
        barrier: types::Barrier,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xfixes_delete_pointer_barrier",
            barrier = ?barrier,
        );
        let request = types::xfixes::DeletePointerBarrierRequest { barrier };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xfixes")]
    fn xfixes_delete_pointer_barrier_checked<'this>(
        &'this mut self,
        barrier: types::Barrier,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xfixes_delete_pointer_barrier(barrier);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xinerama")]
    fn xinerama_query_version<'this>(
        &'this mut self,
        major: types::Card8,
        minor: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinerama::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xinerama_query_version",
            major = ?major,
            minor = ?minor,
        );
        let request = types::xinerama::QueryVersionRequest { major, minor };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_version_immediate<'this>(
        &'this mut self,
        major: types::Card8,
        minor: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinerama::QueryVersionReply>>
    {
        let cookie = self.xinerama_query_version(major, minor);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_state<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinerama::GetStateReply>> {
        let span = tracing::info_span!(
            "xinerama_get_state",
            window = ?window,
        );
        let request = types::xinerama::GetStateRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_state_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinerama::GetStateReply>>
    {
        let cookie = self.xinerama_get_state(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::GetStateReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_count<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinerama::GetScreenCountReply>> {
        let span = tracing::info_span!(
            "xinerama_get_screen_count",
            window = ?window,
        );
        let request = types::xinerama::GetScreenCountRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_count_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinerama::GetScreenCountReply>>
    {
        let cookie = self.xinerama_get_screen_count(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::GetScreenCountReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_size<'this>(
        &'this mut self,
        window: types::xproto::Window,
        screen: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinerama::GetScreenSizeReply>> {
        let span = tracing::info_span!(
            "xinerama_get_screen_size",
            window = ?window,
            screen = ?screen,
        );
        let request = types::xinerama::GetScreenSizeRequest { window, screen };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_get_screen_size_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        screen: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinerama::GetScreenSizeReply>>
    {
        let cookie = self.xinerama_get_screen_size(window, screen);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::GetScreenSizeReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_is_active<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinerama::IsActiveReply>> {
        let span = tracing::info_span!("xinerama_is_active",);
        let request = types::xinerama::IsActiveRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_is_active_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinerama::IsActiveReply>>
    {
        let cookie = self.xinerama_is_active();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::IsActiveReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_screens<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinerama::QueryScreensReply>> {
        let span = tracing::info_span!("xinerama_query_screens",);
        let request = types::xinerama::QueryScreensRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinerama")]
    fn xinerama_query_screens_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinerama::QueryScreensReply>>
    {
        let cookie = self.xinerama_query_screens();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinerama::QueryScreensReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xinput")]
    fn xinput_get_extension_version<'this>(
        &'this mut self,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::GetExtensionVersionReply>>
    {
        let span = tracing::info_span!("xinput_get_extension_version",);
        let request = types::xinput::GetExtensionVersionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_extension_version_immediate<'this>(
        &'this mut self,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::GetExtensionVersionReply>,
    > {
        let cookie = self.xinput_get_extension_version(name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetExtensionVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_input_devices<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::ListInputDevicesReply>> {
        let span = tracing::info_span!("xinput_list_input_devices",);
        let request = types::xinput::ListInputDevicesRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_input_devices_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::ListInputDevicesReply>>
    {
        let cookie = self.xinput_list_input_devices();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::ListInputDevicesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_open_device<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::OpenDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_open_device",
            device_id = ?device_id,
        );
        let request = types::xinput::OpenDeviceRequest { device_id };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_open_device_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::OpenDeviceReply>>
    {
        let cookie = self.xinput_open_device(device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::OpenDeviceReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_close_device<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_close_device",
            device_id = ?device_id,
        );
        let request = types::xinput::CloseDeviceRequest { device_id };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_close_device_checked<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_close_device(device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_mode<'this>(
        &'this mut self,
        device_id: types::Card8,
        mode: types::ValuatorMode,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::SetDeviceModeReply>> {
        let span = tracing::info_span!(
            "xinput_set_device_mode",
            device_id = ?device_id,
            mode = ?mode,
        );
        let request = types::xinput::SetDeviceModeRequest { device_id, mode };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_mode_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
        mode: types::ValuatorMode,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceModeReply>>
    {
        let cookie = self.xinput_set_device_mode(device_id, mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceModeReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_select_extension_event<'this>(
        &'this mut self,
        window: types::xproto::Window,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_select_extension_event",
            window = ?window,
        );
        let request = types::xinput::SelectExtensionEventRequest {
            window,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_select_extension_event_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_select_extension_event(window, classes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_selected_extension_events<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<
        futures::SendRequest<'this, Self, types::xinput::GetSelectedExtensionEventsReply>,
    > {
        let span = tracing::info_span!(
            "xinput_get_selected_extension_events",
            window = ?window,
        );
        let request = types::xinput::GetSelectedExtensionEventsRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_selected_extension_events_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::GetSelectedExtensionEventsReply>,
    > {
        let cookie = self.xinput_get_selected_extension_events(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xinput::GetSelectedExtensionEventsReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_dont_propagate_list<'this>(
        &'this mut self,
        window: types::xproto::Window,
        mode: types::PropagateMode,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_change_device_dont_propagate_list",
            window = ?window,
            mode = ?mode,
        );
        let request = types::xinput::ChangeDeviceDontPropagateListRequest {
            window,
            mode,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_dont_propagate_list_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        mode: types::PropagateMode,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_change_device_dont_propagate_list(window, mode, classes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_dont_propagate_list<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<
        futures::SendRequest<'this, Self, types::xinput::GetDeviceDontPropagateListReply>,
    > {
        let span = tracing::info_span!(
            "xinput_get_device_dont_propagate_list",
            window = ?window,
        );
        let request = types::xinput::GetDeviceDontPropagateListRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_dont_propagate_list_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceDontPropagateListReply>,
    > {
        let cookie = self.xinput_get_device_dont_propagate_list(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xinput::GetDeviceDontPropagateListReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_motion_events<'this>(
        &'this mut self,
        start: types::Timestamp,
        stop: impl Into<types::Time>,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::GetDeviceMotionEventsReply>>
    {
        let span = tracing::info_span!(
            "xinput_get_device_motion_events",
            start = ?start,
            device_id = ?device_id,
        );
        let request = types::xinput::GetDeviceMotionEventsRequest {
            start,
            stop: Into::<u32>::into(stop.into()) as _,
            device_id,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_motion_events_immediate<'this>(
        &'this mut self,
        start: types::Timestamp,
        stop: impl Into<types::Time>,
        device_id: types::Card8,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceMotionEventsReply>,
    > {
        let cookie = self.xinput_get_device_motion_events(start, stop, device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xinput::GetDeviceMotionEventsReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_keyboard_device<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::ChangeKeyboardDeviceReply>>
    {
        let span = tracing::info_span!(
            "xinput_change_keyboard_device",
            device_id = ?device_id,
        );
        let request = types::xinput::ChangeKeyboardDeviceRequest { device_id };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_keyboard_device_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::ChangeKeyboardDeviceReply>,
    > {
        let cookie = self.xinput_change_keyboard_device(device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xinput::ChangeKeyboardDeviceReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_pointer_device<'this>(
        &'this mut self,
        x_axis: types::Card8,
        y_axis: types::Card8,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::ChangePointerDeviceReply>>
    {
        let span = tracing::info_span!(
            "xinput_change_pointer_device",
            x_axis = ?x_axis,
            y_axis = ?y_axis,
            device_id = ?device_id,
        );
        let request = types::xinput::ChangePointerDeviceRequest {
            x_axis,
            y_axis,
            device_id,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_pointer_device_immediate<'this>(
        &'this mut self,
        x_axis: types::Card8,
        y_axis: types::Card8,
        device_id: types::Card8,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::ChangePointerDeviceReply>,
    > {
        let cookie = self.xinput_change_pointer_device(x_axis, y_axis, device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::ChangePointerDeviceReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        time: impl Into<types::Time>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        owner_events: types::Bool,
        device_id: types::Card8,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::GrabDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_grab_device",
            grab_window = ?grab_window,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
            device_id = ?device_id,
        );
        let request = types::xinput::GrabDeviceRequest {
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            device_id,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_immediate<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        time: impl Into<types::Time>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        owner_events: types::Bool,
        device_id: types::Card8,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::GrabDeviceReply>>
    {
        let cookie = self.xinput_grab_device(
            grab_window,
            time,
            this_device_mode,
            other_device_mode,
            owner_events,
            device_id,
            classes,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GrabDeviceReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_ungrab_device",
            device_id = ?device_id,
        );
        let request = types::xinput::UngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            device_id,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_checked<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
        device_id: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_ungrab_device(time, device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_key<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        grabbed_device: types::Card8,
        key: impl Into<types::Grab>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        owner_events: types::Bool,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_grab_device_key",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
        );
        let request = types::xinput::GrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            grabbed_device,
            key: Into::<u32>::into(key.into()) as _,
            this_device_mode,
            other_device_mode,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_key_checked<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        grabbed_device: types::Card8,
        key: impl Into<types::Grab>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        owner_events: types::Bool,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_grab_device_key(
            grab_window,
            modifiers,
            modifier_device,
            grabbed_device,
            key,
            this_device_mode,
            other_device_mode,
            owner_events,
            classes,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_key<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        key: impl Into<types::Grab>,
        grabbed_device: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_ungrab_device_key",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
        );
        let request = types::xinput::UngrabDeviceKeyRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            grabbed_device,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_key_checked<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        key: impl Into<types::Grab>,
        grabbed_device: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_ungrab_device_key(
            grab_window,
            modifiers,
            modifier_device,
            key,
            grabbed_device,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_button<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        grabbed_device: types::Card8,
        modifier_device: impl Into<types::ModifierDevice>,
        modifiers: impl Into<types::ModMask>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        button: impl Into<types::Grab>,
        owner_events: types::Bool,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_grab_device_button",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
            this_device_mode = ?this_device_mode,
            other_device_mode = ?other_device_mode,
            owner_events = ?owner_events,
        );
        let request = types::xinput::GrabDeviceButtonRequest {
            grab_window,
            grabbed_device,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            this_device_mode,
            other_device_mode,
            button: Into::<u32>::into(button.into()) as _,
            owner_events,
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_grab_device_button_checked<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        grabbed_device: types::Card8,
        modifier_device: impl Into<types::ModifierDevice>,
        modifiers: impl Into<types::ModMask>,
        this_device_mode: types::GrabMode,
        other_device_mode: types::GrabMode,
        button: impl Into<types::Grab>,
        owner_events: types::Bool,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_grab_device_button(
            grab_window,
            grabbed_device,
            modifier_device,
            modifiers,
            this_device_mode,
            other_device_mode,
            button,
            owner_events,
            classes,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_button<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        button: impl Into<types::Grab>,
        grabbed_device: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_ungrab_device_button",
            grab_window = ?grab_window,
            grabbed_device = ?grabbed_device,
        );
        let request = types::xinput::UngrabDeviceButtonRequest {
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            modifier_device: Into::<u32>::into(modifier_device.into()) as _,
            button: Into::<u32>::into(button.into()) as _,
            grabbed_device,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_ungrab_device_button_checked<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        modifier_device: impl Into<types::ModifierDevice>,
        button: impl Into<types::Grab>,
        grabbed_device: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_ungrab_device_button(
            grab_window,
            modifiers,
            modifier_device,
            button,
            grabbed_device,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_allow_device_events<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
        mode: types::DeviceInputMode,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_allow_device_events",
            mode = ?mode,
            device_id = ?device_id,
        );
        let request = types::xinput::AllowDeviceEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            mode,
            device_id,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_allow_device_events_checked<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
        mode: types::DeviceInputMode,
        device_id: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_allow_device_events(time, mode, device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_focus<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::GetDeviceFocusReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_focus",
            device_id = ?device_id,
        );
        let request = types::xinput::GetDeviceFocusRequest { device_id };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_focus_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceFocusReply>>
    {
        let cookie = self.xinput_get_device_focus(device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceFocusReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_focus<'this>(
        &'this mut self,
        focus: impl Into<types::InputFocus>,
        time: impl Into<types::Time>,
        revert_to: types::InputFocus,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_set_device_focus",
            revert_to = ?revert_to,
            device_id = ?device_id,
        );
        let request = types::xinput::SetDeviceFocusRequest {
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            revert_to,
            device_id,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_focus_checked<'this>(
        &'this mut self,
        focus: impl Into<types::InputFocus>,
        time: impl Into<types::Time>,
        revert_to: types::InputFocus,
        device_id: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_set_device_focus(focus, time, revert_to, device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_feedback_control<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::GetFeedbackControlReply>>
    {
        let span = tracing::info_span!(
            "xinput_get_feedback_control",
            device_id = ?device_id,
        );
        let request = types::xinput::GetFeedbackControlRequest { device_id };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_feedback_control_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::GetFeedbackControlReply>,
    > {
        let cookie = self.xinput_get_feedback_control(device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetFeedbackControlReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_feedback_control<'this>(
        &'this mut self,
        mask: impl Into<types::ChangeFeedbackControlMask>,
        device_id: types::Card8,
        feedback_id: types::Card8,
        feedback: types::FeedbackCtl,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_change_feedback_control",
            device_id = ?device_id,
            feedback_id = ?feedback_id,
            feedback = ?feedback,
        );
        let request = types::xinput::ChangeFeedbackControlRequest {
            mask: Into::<u32>::into(mask.into()) as _,
            device_id,
            feedback_id,
            feedback,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_feedback_control_checked<'this>(
        &'this mut self,
        mask: impl Into<types::ChangeFeedbackControlMask>,
        device_id: types::Card8,
        feedback_id: types::Card8,
        feedback: types::FeedbackCtl,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_change_feedback_control(mask, device_id, feedback_id, feedback);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_key_mapping<'this>(
        &'this mut self,
        device_id: types::Card8,
        first_keycode: types::KeyCode,
        count: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::GetDeviceKeyMappingReply>>
    {
        let span = tracing::info_span!(
            "xinput_get_device_key_mapping",
            device_id = ?device_id,
            first_keycode = ?first_keycode,
            count = ?count,
        );
        let request = types::xinput::GetDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            count,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_key_mapping_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
        first_keycode: types::KeyCode,
        count: types::Card8,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceKeyMappingReply>,
    > {
        let cookie = self.xinput_get_device_key_mapping(device_id, first_keycode, count);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceKeyMappingReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_key_mapping<'this>(
        &'this mut self,
        device_id: types::Card8,
        first_keycode: types::KeyCode,
        keysyms_per_keycode: types::Card8,
        keycode_count: types::Card8,
        keysyms: impl AsRef<[types::Keysym]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_change_device_key_mapping",
            device_id = ?device_id,
            first_keycode = ?first_keycode,
            keysyms_per_keycode = ?keysyms_per_keycode,
            keycode_count = ?keycode_count,
        );
        let request = types::xinput::ChangeDeviceKeyMappingRequest {
            device_id,
            first_keycode,
            keysyms_per_keycode,
            keycode_count,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_key_mapping_checked<'this>(
        &'this mut self,
        device_id: types::Card8,
        first_keycode: types::KeyCode,
        keysyms_per_keycode: types::Card8,
        keycode_count: types::Card8,
        keysyms: impl AsRef<[types::Keysym]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_change_device_key_mapping(
            device_id,
            first_keycode,
            keysyms_per_keycode,
            keycode_count,
            keysyms,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_modifier_mapping<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::GetDeviceModifierMappingReply>>
    {
        let span = tracing::info_span!(
            "xinput_get_device_modifier_mapping",
            device_id = ?device_id,
        );
        let request = types::xinput::GetDeviceModifierMappingRequest { device_id };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_modifier_mapping_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceModifierMappingReply>,
    > {
        let cookie = self.xinput_get_device_modifier_mapping(device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xinput::GetDeviceModifierMappingReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_modifier_mapping<'this>(
        &'this mut self,
        device_id: types::Card8,
        keymaps: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::SetDeviceModifierMappingReply>>
    {
        let span = tracing::info_span!(
            "xinput_set_device_modifier_mapping",
            device_id = ?device_id,
        );
        let request = types::xinput::SetDeviceModifierMappingRequest {
            device_id,
            keymaps: Cow::Borrowed(keymaps.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_modifier_mapping_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
        keymaps: impl AsRef<[types::Card8]>,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceModifierMappingReply>,
    > {
        let cookie = self.xinput_set_device_modifier_mapping(device_id, keymaps);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xinput::SetDeviceModifierMappingReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_button_mapping<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::GetDeviceButtonMappingReply>>
    {
        let span = tracing::info_span!(
            "xinput_get_device_button_mapping",
            device_id = ?device_id,
        );
        let request = types::xinput::GetDeviceButtonMappingRequest { device_id };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_button_mapping_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceButtonMappingReply>,
    > {
        let cookie = self.xinput_get_device_button_mapping(device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xinput::GetDeviceButtonMappingReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_button_mapping<'this>(
        &'this mut self,
        device_id: types::Card8,
        map: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::SetDeviceButtonMappingReply>>
    {
        let span = tracing::info_span!(
            "xinput_set_device_button_mapping",
            device_id = ?device_id,
        );
        let request = types::xinput::SetDeviceButtonMappingRequest {
            device_id,
            map: Cow::Borrowed(map.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_button_mapping_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
        map: impl AsRef<[types::Card8]>,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceButtonMappingReply>,
    > {
        let cookie = self.xinput_set_device_button_mapping(device_id, map);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xinput::SetDeviceButtonMappingReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_query_device_state<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::QueryDeviceStateReply>> {
        let span = tracing::info_span!(
            "xinput_query_device_state",
            device_id = ?device_id,
        );
        let request = types::xinput::QueryDeviceStateRequest { device_id };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_query_device_state_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::QueryDeviceStateReply>>
    {
        let cookie = self.xinput_query_device_state(device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::QueryDeviceStateReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_device_bell<'this>(
        &'this mut self,
        device_id: types::Card8,
        feedback_id: types::Card8,
        feedback_class: types::Card8,
        percent: types::Int8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_device_bell",
            device_id = ?device_id,
            feedback_id = ?feedback_id,
            feedback_class = ?feedback_class,
            percent = ?percent,
        );
        let request = types::xinput::DeviceBellRequest {
            device_id,
            feedback_id,
            feedback_class,
            percent,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_device_bell_checked<'this>(
        &'this mut self,
        device_id: types::Card8,
        feedback_id: types::Card8,
        feedback_class: types::Card8,
        percent: types::Int8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_device_bell(device_id, feedback_id, feedback_class, percent);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_valuators<'this>(
        &'this mut self,
        device_id: types::Card8,
        first_valuator: types::Card8,
        valuators: impl AsRef<[types::Int32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::SetDeviceValuatorsReply>>
    {
        let span = tracing::info_span!(
            "xinput_set_device_valuators",
            device_id = ?device_id,
            first_valuator = ?first_valuator,
        );
        let request = types::xinput::SetDeviceValuatorsRequest {
            device_id,
            first_valuator,
            valuators: Cow::Borrowed(valuators.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_set_device_valuators_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
        first_valuator: types::Card8,
        valuators: impl AsRef<[types::Int32]>,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceValuatorsReply>,
    > {
        let cookie = self.xinput_set_device_valuators(device_id, first_valuator, valuators);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::SetDeviceValuatorsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_control<'this>(
        &'this mut self,
        control_id: types::DeviceControl,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::GetDeviceControlReply>> {
        let span = tracing::info_span!(
            "xinput_get_device_control",
            control_id = ?control_id,
            device_id = ?device_id,
        );
        let request = types::xinput::GetDeviceControlRequest {
            control_id,
            device_id,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_control_immediate<'this>(
        &'this mut self,
        control_id: types::DeviceControl,
        device_id: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceControlReply>>
    {
        let cookie = self.xinput_get_device_control(control_id, device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDeviceControlReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_control<'this>(
        &'this mut self,
        control_id: types::DeviceControl,
        device_id: types::Card8,
        control: types::DeviceCtl,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::ChangeDeviceControlReply>>
    {
        let span = tracing::info_span!(
            "xinput_change_device_control",
            control_id = ?control_id,
            device_id = ?device_id,
            control = ?control,
        );
        let request = types::xinput::ChangeDeviceControlRequest {
            control_id,
            device_id,
            control,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_control_immediate<'this>(
        &'this mut self,
        control_id: types::DeviceControl,
        device_id: types::Card8,
        control: types::DeviceCtl,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::ChangeDeviceControlReply>,
    > {
        let cookie = self.xinput_change_device_control(control_id, device_id, control);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::ChangeDeviceControlReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_device_properties<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::ListDevicePropertiesReply>>
    {
        let span = tracing::info_span!(
            "xinput_list_device_properties",
            device_id = ?device_id,
        );
        let request = types::xinput::ListDevicePropertiesRequest { device_id };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_list_device_properties_immediate<'this>(
        &'this mut self,
        device_id: types::Card8,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::ListDevicePropertiesReply>,
    > {
        let cookie = self.xinput_list_device_properties(device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xinput::ListDevicePropertiesReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_property<'this>(
        &'this mut self,
        property: types::Atom,
        type_: types::Atom,
        device_id: types::Card8,
        mode: types::PropMode,
        num_items: types::Card32,
        items: impl Borrow<types::xinput::ChangeDevicePropertyAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_change_device_property",
            property = ?property,
            type_ = ?type_,
            device_id = ?device_id,
            mode = ?mode,
            num_items = ?num_items,
        );
        let request = types::xinput::ChangeDevicePropertyRequest {
            property,
            type_,
            device_id,
            mode,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_change_device_property_checked<'this>(
        &'this mut self,
        property: types::Atom,
        type_: types::Atom,
        device_id: types::Card8,
        mode: types::PropMode,
        num_items: types::Card32,
        items: impl Borrow<types::xinput::ChangeDevicePropertyAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie =
            self.xinput_change_device_property(property, type_, device_id, mode, num_items, items);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_delete_device_property<'this>(
        &'this mut self,
        property: types::Atom,
        device_id: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_delete_device_property",
            property = ?property,
            device_id = ?device_id,
        );
        let request = types::xinput::DeleteDevicePropertyRequest {
            property,
            device_id,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_delete_device_property_checked<'this>(
        &'this mut self,
        property: types::Atom,
        device_id: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_delete_device_property(property, device_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_property<'this>(
        &'this mut self,
        property: types::Atom,
        type_: types::Atom,
        offset: types::Card32,
        len: types::Card32,
        device_id: types::Card8,
        delete: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::GetDevicePropertyReply>>
    {
        let span = tracing::info_span!(
            "xinput_get_device_property",
            property = ?property,
            type_ = ?type_,
            offset = ?offset,
            len = ?len,
            device_id = ?device_id,
            delete = ?delete,
        );
        let request = types::xinput::GetDevicePropertyRequest {
            property,
            type_,
            offset,
            len,
            device_id,
            delete,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_get_device_property_immediate<'this>(
        &'this mut self,
        property: types::Atom,
        type_: types::Atom,
        offset: types::Card32,
        len: types::Card32,
        device_id: types::Card8,
        delete: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::GetDevicePropertyReply>>
    {
        let cookie =
            self.xinput_get_device_property(property, type_, offset, len, device_id, delete);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::GetDevicePropertyReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_pointer<'this>(
        &'this mut self,
        window: types::xproto::Window,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::XIQueryPointerReply>> {
        let span = tracing::info_span!(
            "xinput_xi_query_pointer",
            window = ?window,
        );
        let request = types::xinput::XIQueryPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_pointer_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryPointerReply>>
    {
        let cookie = self.xinput_xi_query_pointer(window, deviceid);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryPointerReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_warp_pointer<'this>(
        &'this mut self,
        src_win: types::xproto::Window,
        dst_win: types::xproto::Window,
        src_x: types::Fp1616,
        src_y: types::Fp1616,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Fp1616,
        dst_y: types::Fp1616,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_xi_warp_pointer",
            src_win = ?src_win,
            dst_win = ?dst_win,
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
        );
        let request = types::xinput::XIWarpPointerRequest {
            src_win,
            dst_win,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_warp_pointer_checked<'this>(
        &'this mut self,
        src_win: types::xproto::Window,
        dst_win: types::xproto::Window,
        src_x: types::Fp1616,
        src_y: types::Fp1616,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Fp1616,
        dst_y: types::Fp1616,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_xi_warp_pointer(
            src_win, dst_win, src_x, src_y, src_width, src_height, dst_x, dst_y, deviceid,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_cursor<'this>(
        &'this mut self,
        window: types::xproto::Window,
        cursor: types::xproto::Cursor,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_xi_change_cursor",
            window = ?window,
            cursor = ?cursor,
        );
        let request = types::xinput::XIChangeCursorRequest {
            window,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_cursor_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        cursor: types::xproto::Cursor,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_xi_change_cursor(window, cursor, deviceid);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_hierarchy<'this>(
        &'this mut self,
        changes: impl AsRef<[types::HierarchyChange]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("xinput_xi_change_hierarchy",);
        let request = types::xinput::XIChangeHierarchyRequest {
            changes: Cow::Borrowed(changes.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_hierarchy_checked<'this>(
        &'this mut self,
        changes: impl AsRef<[types::HierarchyChange]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_xi_change_hierarchy(changes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_client_pointer<'this>(
        &'this mut self,
        window: types::xproto::Window,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_xi_set_client_pointer",
            window = ?window,
        );
        let request = types::xinput::XISetClientPointerRequest {
            window,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_client_pointer_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_xi_set_client_pointer(window, deviceid);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_client_pointer<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::XIGetClientPointerReply>>
    {
        let span = tracing::info_span!(
            "xinput_xi_get_client_pointer",
            window = ?window,
        );
        let request = types::xinput::XIGetClientPointerRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_client_pointer_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::XIGetClientPointerReply>,
    > {
        let cookie = self.xinput_xi_get_client_pointer(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIGetClientPointerReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_select_events<'this>(
        &'this mut self,
        window: types::xproto::Window,
        masks: impl AsRef<[types::xinput::EventMask]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_xi_select_events",
            window = ?window,
        );
        let request = types::xinput::XISelectEventsRequest {
            window,
            masks: Cow::Borrowed(masks.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_select_events_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        masks: impl AsRef<[types::xinput::EventMask]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_xi_select_events(window, masks);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_version<'this>(
        &'this mut self,
        major_version: types::Card16,
        minor_version: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::XIQueryVersionReply>> {
        let span = tracing::info_span!(
            "xinput_xi_query_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::xinput::XIQueryVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_version_immediate<'this>(
        &'this mut self,
        major_version: types::Card16,
        minor_version: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryVersionReply>>
    {
        let cookie = self.xinput_xi_query_version(major_version, minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_device<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::XIQueryDeviceReply>> {
        let span = tracing::info_span!("xinput_xi_query_device",);
        let request = types::xinput::XIQueryDeviceRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_query_device_immediate<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryDeviceReply>>
    {
        let cookie = self.xinput_xi_query_device(deviceid);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIQueryDeviceReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_focus<'this>(
        &'this mut self,
        window: types::xproto::Window,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_xi_set_focus",
            window = ?window,
        );
        let request = types::xinput::XISetFocusRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_set_focus_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_xi_set_focus(window, time, deviceid);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_focus<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::XIGetFocusReply>> {
        let span = tracing::info_span!("xinput_xi_get_focus",);
        let request = types::xinput::XIGetFocusRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_focus_immediate<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::XIGetFocusReply>>
    {
        let cookie = self.xinput_xi_get_focus(deviceid);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIGetFocusReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_grab_device<'this>(
        &'this mut self,
        window: types::xproto::Window,
        time: impl Into<types::Time>,
        cursor: types::xproto::Cursor,
        deviceid: impl Into<types::Device>,
        mode: types::GrabMode,
        paired_device_mode: types::GrabMode,
        owner_events: types::GrabOwner,
        mask: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::XIGrabDeviceReply>> {
        let span = tracing::info_span!(
            "xinput_xi_grab_device",
            window = ?window,
            cursor = ?cursor,
            mode = ?mode,
            paired_device_mode = ?paired_device_mode,
            owner_events = ?owner_events,
        );
        let request = types::xinput::XIGrabDeviceRequest {
            window,
            time: Into::<u32>::into(time.into()) as _,
            cursor,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_grab_device_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        time: impl Into<types::Time>,
        cursor: types::xproto::Cursor,
        deviceid: impl Into<types::Device>,
        mode: types::GrabMode,
        paired_device_mode: types::GrabMode,
        owner_events: types::GrabOwner,
        mask: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::XIGrabDeviceReply>>
    {
        let cookie = self.xinput_xi_grab_device(
            window,
            time,
            cursor,
            deviceid,
            mode,
            paired_device_mode,
            owner_events,
            mask,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIGrabDeviceReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_ungrab_device<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("xinput_xi_ungrab_device",);
        let request = types::xinput::XIUngrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_ungrab_device_checked<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_xi_ungrab_device(time, deviceid);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_allow_events<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
        event_mode: types::EventMode,
        touchid: types::Card32,
        grab_window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_xi_allow_events",
            event_mode = ?event_mode,
            touchid = ?touchid,
            grab_window = ?grab_window,
        );
        let request = types::xinput::XIAllowEventsRequest {
            time: Into::<u32>::into(time.into()) as _,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            event_mode,
            touchid,
            grab_window,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_allow_events_checked<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
        deviceid: impl Into<types::Device>,
        event_mode: types::EventMode,
        touchid: types::Card32,
        grab_window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_xi_allow_events(time, deviceid, event_mode, touchid, grab_window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_grab_device<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
        grab_window: types::xproto::Window,
        cursor: types::xproto::Cursor,
        detail: types::Card32,
        deviceid: impl Into<types::Device>,
        grab_type: types::GrabType,
        grab_mode: types::GrabMode22,
        paired_device_mode: types::GrabMode,
        owner_events: types::GrabOwner,
        mask: impl AsRef<[types::Card32]>,
        modifiers: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::XIPassiveGrabDeviceReply>>
    {
        let span = tracing::info_span!(
            "xinput_xi_passive_grab_device",
            grab_window = ?grab_window,
            cursor = ?cursor,
            detail = ?detail,
            grab_type = ?grab_type,
            grab_mode = ?grab_mode,
            paired_device_mode = ?paired_device_mode,
            owner_events = ?owner_events,
        );
        let request = types::xinput::XIPassiveGrabDeviceRequest {
            time: Into::<u32>::into(time.into()) as _,
            grab_window,
            cursor,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            grab_mode,
            paired_device_mode,
            owner_events,
            mask: Cow::Borrowed(mask.as_ref()),
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_grab_device_immediate<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
        grab_window: types::xproto::Window,
        cursor: types::xproto::Cursor,
        detail: types::Card32,
        deviceid: impl Into<types::Device>,
        grab_type: types::GrabType,
        grab_mode: types::GrabMode22,
        paired_device_mode: types::GrabMode,
        owner_events: types::GrabOwner,
        mask: impl AsRef<[types::Card32]>,
        modifiers: impl AsRef<[types::Card32]>,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::XIPassiveGrabDeviceReply>,
    > {
        let cookie = self.xinput_xi_passive_grab_device(
            time,
            grab_window,
            cursor,
            detail,
            deviceid,
            grab_type,
            grab_mode,
            paired_device_mode,
            owner_events,
            mask,
            modifiers,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIPassiveGrabDeviceReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_ungrab_device<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        detail: types::Card32,
        deviceid: impl Into<types::Device>,
        grab_type: types::GrabType,
        modifiers: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_xi_passive_ungrab_device",
            grab_window = ?grab_window,
            detail = ?detail,
            grab_type = ?grab_type,
        );
        let request = types::xinput::XIPassiveUngrabDeviceRequest {
            grab_window,
            detail,
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            grab_type,
            modifiers: Cow::Borrowed(modifiers.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_passive_ungrab_device_checked<'this>(
        &'this mut self,
        grab_window: types::xproto::Window,
        detail: types::Card32,
        deviceid: impl Into<types::Device>,
        grab_type: types::GrabType,
        modifiers: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_xi_passive_ungrab_device(
            grab_window,
            detail,
            deviceid,
            grab_type,
            modifiers,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_list_properties<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::XIListPropertiesReply>> {
        let span = tracing::info_span!("xinput_xi_list_properties",);
        let request = types::xinput::XIListPropertiesRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_list_properties_immediate<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::XIListPropertiesReply>>
    {
        let cookie = self.xinput_xi_list_properties(deviceid);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIListPropertiesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_property<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
        mode: types::PropMode,
        property: types::Atom,
        type_: types::Atom,
        num_items: types::Card32,
        items: impl Borrow<types::xinput::XIChangePropertyAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_xi_change_property",
            mode = ?mode,
            property = ?property,
            type_ = ?type_,
            num_items = ?num_items,
        );
        let request = types::xinput::XIChangePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            mode,
            property,
            type_,
            num_items,
            items: Cow::Borrowed(items.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_change_property_checked<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
        mode: types::PropMode,
        property: types::Atom,
        type_: types::Atom,
        num_items: types::Card32,
        items: impl Borrow<types::xinput::XIChangePropertyAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie =
            self.xinput_xi_change_property(deviceid, mode, property, type_, num_items, items);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_delete_property<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
        property: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_xi_delete_property",
            property = ?property,
        );
        let request = types::xinput::XIDeletePropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            property,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_delete_property_checked<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
        property: types::Atom,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_xi_delete_property(deviceid, property);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_property<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
        delete: types::Bool,
        property: types::Atom,
        type_: types::Atom,
        offset: types::Card32,
        len: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::XIGetPropertyReply>> {
        let span = tracing::info_span!(
            "xinput_xi_get_property",
            delete = ?delete,
            property = ?property,
            type_ = ?type_,
            offset = ?offset,
            len = ?len,
        );
        let request = types::xinput::XIGetPropertyRequest {
            deviceid: Into::<u32>::into(deviceid.into()) as _,
            delete,
            property,
            type_,
            offset,
            len,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_property_immediate<'this>(
        &'this mut self,
        deviceid: impl Into<types::Device>,
        delete: types::Bool,
        property: types::Atom,
        type_: types::Atom,
        offset: types::Card32,
        len: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xinput::XIGetPropertyReply>>
    {
        let cookie = self.xinput_xi_get_property(deviceid, delete, property, type_, offset, len);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIGetPropertyReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_selected_events<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xinput::XIGetSelectedEventsReply>>
    {
        let span = tracing::info_span!(
            "xinput_xi_get_selected_events",
            window = ?window,
        );
        let request = types::xinput::XIGetSelectedEventsRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_get_selected_events_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xinput::XIGetSelectedEventsReply>,
    > {
        let cookie = self.xinput_xi_get_selected_events(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xinput::XIGetSelectedEventsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_barrier_release_pointer<'this>(
        &'this mut self,
        barriers: impl AsRef<[types::BarrierReleasePointerInfo]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("xinput_xi_barrier_release_pointer",);
        let request = types::xinput::XIBarrierReleasePointerRequest {
            barriers: Cow::Borrowed(barriers.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_xi_barrier_release_pointer_checked<'this>(
        &'this mut self,
        barriers: impl AsRef<[types::BarrierReleasePointerInfo]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xinput_xi_barrier_release_pointer(barriers);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_send_extension_event<'this>(
        &'this mut self,
        destination: types::xproto::Window,
        device_id: types::Card8,
        propagate: types::Bool,
        events: impl AsRef<[types::EventForSend]>,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xinput_send_extension_event",
            destination = ?destination,
            device_id = ?device_id,
            propagate = ?propagate,
        );
        let request = types::xinput::SendExtensionEventRequest {
            destination,
            device_id,
            propagate,
            events: Cow::Borrowed(events.as_ref()),
            classes: Cow::Borrowed(classes.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xinput")]
    fn xinput_send_extension_event_checked<'this>(
        &'this mut self,
        destination: types::xproto::Window,
        device_id: types::Card8,
        propagate: types::Bool,
        events: impl AsRef<[types::EventForSend]>,
        classes: impl AsRef<[types::EventClass]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie =
            self.xinput_send_extension_event(destination, device_id, propagate, events, classes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xkb")]
    fn xkb_use_extension<'this>(
        &'this mut self,
        wanted_major: types::Card16,
        wanted_minor: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::UseExtensionReply>> {
        let span = tracing::info_span!(
            "xkb_use_extension",
            wanted_major = ?wanted_major,
            wanted_minor = ?wanted_minor,
        );
        let request = types::xkb::UseExtensionRequest {
            wanted_major,
            wanted_minor,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_use_extension_immediate<'this>(
        &'this mut self,
        wanted_major: types::Card16,
        wanted_minor: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::UseExtensionReply>> {
        let cookie = self.xkb_use_extension(wanted_major, wanted_minor);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::UseExtensionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_select_events<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        clear: impl Into<types::xkb::EventType>,
        select_all: impl Into<types::xkb::EventType>,
        affect_map: impl Into<types::MapPart>,
        map: impl Into<types::MapPart>,
        details: impl Borrow<types::xkb::SelectEventsAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xkb_select_events",
            device_spec = ?device_spec,
        );
        let request = types::xkb::SelectEventsRequest {
            device_spec,
            clear: Into::<u32>::into(clear.into()) as _,
            select_all: Into::<u32>::into(select_all.into()) as _,
            affect_map: Into::<u32>::into(affect_map.into()) as _,
            map: Into::<u32>::into(map.into()) as _,
            details: Cow::Borrowed(details.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_select_events_checked<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        clear: impl Into<types::xkb::EventType>,
        select_all: impl Into<types::xkb::EventType>,
        affect_map: impl Into<types::MapPart>,
        map: impl Into<types::MapPart>,
        details: impl Borrow<types::xkb::SelectEventsAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie =
            self.xkb_select_events(device_spec, clear, select_all, affect_map, map, details);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_bell<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        bell_class: types::BellClassSpec,
        bell_id: types::IDSpec,
        percent: types::Int8,
        force_sound: types::Bool,
        event_only: types::Bool,
        pitch: types::Int16,
        duration: types::Int16,
        name: types::Atom,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xkb_bell",
            device_spec = ?device_spec,
            bell_class = ?bell_class,
            bell_id = ?bell_id,
            percent = ?percent,
            force_sound = ?force_sound,
            event_only = ?event_only,
            pitch = ?pitch,
            duration = ?duration,
            name = ?name,
            window = ?window,
        );
        let request = types::xkb::BellRequest {
            device_spec,
            bell_class,
            bell_id,
            percent,
            force_sound,
            event_only,
            pitch,
            duration,
            name,
            window,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_bell_checked<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        bell_class: types::BellClassSpec,
        bell_id: types::IDSpec,
        percent: types::Int8,
        force_sound: types::Bool,
        event_only: types::Bool,
        pitch: types::Int16,
        duration: types::Int16,
        name: types::Atom,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xkb_bell(
            device_spec,
            bell_class,
            bell_id,
            percent,
            force_sound,
            event_only,
            pitch,
            duration,
            name,
            window,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_state<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::GetStateReply>> {
        let span = tracing::info_span!(
            "xkb_get_state",
            device_spec = ?device_spec,
        );
        let request = types::xkb::GetStateRequest { device_spec };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_state_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::GetStateReply>> {
        let cookie = self.xkb_get_state(device_spec);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetStateReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_latch_lock_state<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        affect_mod_locks: impl Into<types::ModMask>,
        mod_locks: impl Into<types::ModMask>,
        lock_group: types::Bool,
        group_lock: types::Group,
        affect_mod_latches: impl Into<types::ModMask>,
        latch_group: types::Bool,
        group_latch: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xkb_latch_lock_state",
            device_spec = ?device_spec,
            lock_group = ?lock_group,
            group_lock = ?group_lock,
            latch_group = ?latch_group,
            group_latch = ?group_latch,
        );
        let request = types::xkb::LatchLockStateRequest {
            device_spec,
            affect_mod_locks: Into::<u32>::into(affect_mod_locks.into()) as _,
            mod_locks: Into::<u32>::into(mod_locks.into()) as _,
            lock_group,
            group_lock,
            affect_mod_latches: Into::<u32>::into(affect_mod_latches.into()) as _,
            latch_group,
            group_latch,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_latch_lock_state_checked<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        affect_mod_locks: impl Into<types::ModMask>,
        mod_locks: impl Into<types::ModMask>,
        lock_group: types::Bool,
        group_lock: types::Group,
        affect_mod_latches: impl Into<types::ModMask>,
        latch_group: types::Bool,
        group_latch: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xkb_latch_lock_state(
            device_spec,
            affect_mod_locks,
            mod_locks,
            lock_group,
            group_lock,
            affect_mod_latches,
            latch_group,
            group_latch,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_controls<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::GetControlsReply>> {
        let span = tracing::info_span!(
            "xkb_get_controls",
            device_spec = ?device_spec,
        );
        let request = types::xkb::GetControlsRequest { device_spec };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_controls_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::GetControlsReply>> {
        let cookie = self.xkb_get_controls(device_spec);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetControlsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_controls<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        affect_internal_real_mods: impl Into<types::ModMask>,
        internal_real_mods: impl Into<types::ModMask>,
        affect_ignore_lock_real_mods: impl Into<types::ModMask>,
        ignore_lock_real_mods: impl Into<types::ModMask>,
        affect_internal_virtual_mods: impl Into<types::VMod>,
        internal_virtual_mods: impl Into<types::VMod>,
        affect_ignore_lock_virtual_mods: impl Into<types::VMod>,
        ignore_lock_virtual_mods: impl Into<types::VMod>,
        mouse_keys_dflt_btn: types::Card8,
        groups_wrap: types::Card8,
        access_x_options: impl Into<types::AXOption>,
        affect_enabled_controls: impl Into<types::BoolCtrl>,
        enabled_controls: impl Into<types::BoolCtrl>,
        change_controls: impl Into<types::Control>,
        repeat_delay: types::Card16,
        repeat_interval: types::Card16,
        slow_keys_delay: types::Card16,
        debounce_delay: types::Card16,
        mouse_keys_delay: types::Card16,
        mouse_keys_interval: types::Card16,
        mouse_keys_time_to_max: types::Card16,
        mouse_keys_max_speed: types::Card16,
        mouse_keys_curve: types::Int16,
        access_x_timeout: types::Card16,
        access_x_timeout_mask: impl Into<types::BoolCtrl>,
        access_x_timeout_values: impl Into<types::BoolCtrl>,
        access_x_timeout_options_mask: impl Into<types::AXOption>,
        access_x_timeout_options_values: impl Into<types::AXOption>,
        per_key_repeat: impl Borrow<[types::Card8; 32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xkb_set_controls",
            device_spec = ?device_spec,
            mouse_keys_dflt_btn = ?mouse_keys_dflt_btn,
            groups_wrap = ?groups_wrap,
            repeat_delay = ?repeat_delay,
            repeat_interval = ?repeat_interval,
            slow_keys_delay = ?slow_keys_delay,
            debounce_delay = ?debounce_delay,
            mouse_keys_delay = ?mouse_keys_delay,
            mouse_keys_interval = ?mouse_keys_interval,
            mouse_keys_time_to_max = ?mouse_keys_time_to_max,
            mouse_keys_max_speed = ?mouse_keys_max_speed,
            mouse_keys_curve = ?mouse_keys_curve,
            access_x_timeout = ?access_x_timeout,
        );
        let request = types::xkb::SetControlsRequest {
            device_spec,
            affect_internal_real_mods: Into::<u32>::into(affect_internal_real_mods.into()) as _,
            internal_real_mods: Into::<u32>::into(internal_real_mods.into()) as _,
            affect_ignore_lock_real_mods: Into::<u32>::into(affect_ignore_lock_real_mods.into())
                as _,
            ignore_lock_real_mods: Into::<u32>::into(ignore_lock_real_mods.into()) as _,
            affect_internal_virtual_mods: Into::<u32>::into(affect_internal_virtual_mods.into())
                as _,
            internal_virtual_mods: Into::<u32>::into(internal_virtual_mods.into()) as _,
            affect_ignore_lock_virtual_mods: Into::<u32>::into(
                affect_ignore_lock_virtual_mods.into(),
            ) as _,
            ignore_lock_virtual_mods: Into::<u32>::into(ignore_lock_virtual_mods.into()) as _,
            mouse_keys_dflt_btn,
            groups_wrap,
            access_x_options: Into::<u32>::into(access_x_options.into()) as _,
            affect_enabled_controls: Into::<u32>::into(affect_enabled_controls.into()) as _,
            enabled_controls: Into::<u32>::into(enabled_controls.into()) as _,
            change_controls: Into::<u32>::into(change_controls.into()) as _,
            repeat_delay,
            repeat_interval,
            slow_keys_delay,
            debounce_delay,
            mouse_keys_delay,
            mouse_keys_interval,
            mouse_keys_time_to_max,
            mouse_keys_max_speed,
            mouse_keys_curve,
            access_x_timeout,
            access_x_timeout_mask: Into::<u32>::into(access_x_timeout_mask.into()) as _,
            access_x_timeout_values: Into::<u32>::into(access_x_timeout_values.into()) as _,
            access_x_timeout_options_mask: Into::<u32>::into(access_x_timeout_options_mask.into())
                as _,
            access_x_timeout_options_values: Into::<u32>::into(
                access_x_timeout_options_values.into(),
            ) as _,
            per_key_repeat: Cow::Borrowed(per_key_repeat.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_controls_checked<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        affect_internal_real_mods: impl Into<types::ModMask>,
        internal_real_mods: impl Into<types::ModMask>,
        affect_ignore_lock_real_mods: impl Into<types::ModMask>,
        ignore_lock_real_mods: impl Into<types::ModMask>,
        affect_internal_virtual_mods: impl Into<types::VMod>,
        internal_virtual_mods: impl Into<types::VMod>,
        affect_ignore_lock_virtual_mods: impl Into<types::VMod>,
        ignore_lock_virtual_mods: impl Into<types::VMod>,
        mouse_keys_dflt_btn: types::Card8,
        groups_wrap: types::Card8,
        access_x_options: impl Into<types::AXOption>,
        affect_enabled_controls: impl Into<types::BoolCtrl>,
        enabled_controls: impl Into<types::BoolCtrl>,
        change_controls: impl Into<types::Control>,
        repeat_delay: types::Card16,
        repeat_interval: types::Card16,
        slow_keys_delay: types::Card16,
        debounce_delay: types::Card16,
        mouse_keys_delay: types::Card16,
        mouse_keys_interval: types::Card16,
        mouse_keys_time_to_max: types::Card16,
        mouse_keys_max_speed: types::Card16,
        mouse_keys_curve: types::Int16,
        access_x_timeout: types::Card16,
        access_x_timeout_mask: impl Into<types::BoolCtrl>,
        access_x_timeout_values: impl Into<types::BoolCtrl>,
        access_x_timeout_options_mask: impl Into<types::AXOption>,
        access_x_timeout_options_values: impl Into<types::AXOption>,
        per_key_repeat: impl Borrow<[types::Card8; 32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xkb_set_controls(
            device_spec,
            affect_internal_real_mods,
            internal_real_mods,
            affect_ignore_lock_real_mods,
            ignore_lock_real_mods,
            affect_internal_virtual_mods,
            internal_virtual_mods,
            affect_ignore_lock_virtual_mods,
            ignore_lock_virtual_mods,
            mouse_keys_dflt_btn,
            groups_wrap,
            access_x_options,
            affect_enabled_controls,
            enabled_controls,
            change_controls,
            repeat_delay,
            repeat_interval,
            slow_keys_delay,
            debounce_delay,
            mouse_keys_delay,
            mouse_keys_interval,
            mouse_keys_time_to_max,
            mouse_keys_max_speed,
            mouse_keys_curve,
            access_x_timeout,
            access_x_timeout_mask,
            access_x_timeout_values,
            access_x_timeout_options_mask,
            access_x_timeout_options_values,
            per_key_repeat,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_map<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        full: impl Into<types::MapPart>,
        partial: impl Into<types::MapPart>,
        first_type: types::Card8,
        n_types: types::Card8,
        first_key_sym: types::Keycode,
        n_key_syms: types::Card8,
        first_key_action: types::Keycode,
        n_key_actions: types::Card8,
        first_key_behavior: types::Keycode,
        n_key_behaviors: types::Card8,
        virtual_mods: impl Into<types::VMod>,
        first_key_explicit: types::Keycode,
        n_key_explicit: types::Card8,
        first_mod_map_key: types::Keycode,
        n_mod_map_keys: types::Card8,
        first_v_mod_map_key: types::Keycode,
        n_v_mod_map_keys: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::GetMapReply>> {
        let span = tracing::info_span!(
            "xkb_get_map",
            device_spec = ?device_spec,
            first_type = ?first_type,
            n_types = ?n_types,
            first_key_sym = ?first_key_sym,
            n_key_syms = ?n_key_syms,
            first_key_action = ?first_key_action,
            n_key_actions = ?n_key_actions,
            first_key_behavior = ?first_key_behavior,
            n_key_behaviors = ?n_key_behaviors,
            first_key_explicit = ?first_key_explicit,
            n_key_explicit = ?n_key_explicit,
            first_mod_map_key = ?first_mod_map_key,
            n_mod_map_keys = ?n_mod_map_keys,
            first_v_mod_map_key = ?first_v_mod_map_key,
            n_v_mod_map_keys = ?n_v_mod_map_keys,
        );
        let request = types::xkb::GetMapRequest {
            device_spec,
            full: Into::<u32>::into(full.into()) as _,
            partial: Into::<u32>::into(partial.into()) as _,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            first_key_action,
            n_key_actions,
            first_key_behavior,
            n_key_behaviors,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_key_explicit,
            n_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_map_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        full: impl Into<types::MapPart>,
        partial: impl Into<types::MapPart>,
        first_type: types::Card8,
        n_types: types::Card8,
        first_key_sym: types::Keycode,
        n_key_syms: types::Card8,
        first_key_action: types::Keycode,
        n_key_actions: types::Card8,
        first_key_behavior: types::Keycode,
        n_key_behaviors: types::Card8,
        virtual_mods: impl Into<types::VMod>,
        first_key_explicit: types::Keycode,
        n_key_explicit: types::Card8,
        first_mod_map_key: types::Keycode,
        n_mod_map_keys: types::Card8,
        first_v_mod_map_key: types::Keycode,
        n_v_mod_map_keys: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::GetMapReply>> {
        let cookie = self.xkb_get_map(
            device_spec,
            full,
            partial,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            first_key_action,
            n_key_actions,
            first_key_behavior,
            n_key_behaviors,
            virtual_mods,
            first_key_explicit,
            n_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetMapReply> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_map<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        flags: impl Into<types::SetMapFlags>,
        min_key_code: types::Keycode,
        max_key_code: types::Keycode,
        first_type: types::Card8,
        n_types: types::Card8,
        first_key_sym: types::Keycode,
        n_key_syms: types::Card8,
        total_syms: types::Card16,
        first_key_action: types::Keycode,
        n_key_actions: types::Card8,
        total_actions: types::Card16,
        first_key_behavior: types::Keycode,
        n_key_behaviors: types::Card8,
        total_key_behaviors: types::Card8,
        first_key_explicit: types::Keycode,
        n_key_explicit: types::Card8,
        total_key_explicit: types::Card8,
        first_mod_map_key: types::Keycode,
        n_mod_map_keys: types::Card8,
        total_mod_map_keys: types::Card8,
        first_v_mod_map_key: types::Keycode,
        n_v_mod_map_keys: types::Card8,
        total_v_mod_map_keys: types::Card8,
        virtual_mods: impl Into<types::VMod>,
        values: impl Borrow<types::xkb::SetMapAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xkb_set_map",
            device_spec = ?device_spec,
            min_key_code = ?min_key_code,
            max_key_code = ?max_key_code,
            first_type = ?first_type,
            n_types = ?n_types,
            first_key_sym = ?first_key_sym,
            n_key_syms = ?n_key_syms,
            total_syms = ?total_syms,
            first_key_action = ?first_key_action,
            n_key_actions = ?n_key_actions,
            total_actions = ?total_actions,
            first_key_behavior = ?first_key_behavior,
            n_key_behaviors = ?n_key_behaviors,
            total_key_behaviors = ?total_key_behaviors,
            first_key_explicit = ?first_key_explicit,
            n_key_explicit = ?n_key_explicit,
            total_key_explicit = ?total_key_explicit,
            first_mod_map_key = ?first_mod_map_key,
            n_mod_map_keys = ?n_mod_map_keys,
            total_mod_map_keys = ?total_mod_map_keys,
            first_v_mod_map_key = ?first_v_mod_map_key,
            n_v_mod_map_keys = ?n_v_mod_map_keys,
            total_v_mod_map_keys = ?total_v_mod_map_keys,
        );
        let request = types::xkb::SetMapRequest {
            device_spec,
            flags: Into::<u32>::into(flags.into()) as _,
            min_key_code,
            max_key_code,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            total_syms,
            first_key_action,
            n_key_actions,
            total_actions,
            first_key_behavior,
            n_key_behaviors,
            total_key_behaviors,
            first_key_explicit,
            n_key_explicit,
            total_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            total_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
            total_v_mod_map_keys,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            values: Cow::Borrowed(values.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_map_checked<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        flags: impl Into<types::SetMapFlags>,
        min_key_code: types::Keycode,
        max_key_code: types::Keycode,
        first_type: types::Card8,
        n_types: types::Card8,
        first_key_sym: types::Keycode,
        n_key_syms: types::Card8,
        total_syms: types::Card16,
        first_key_action: types::Keycode,
        n_key_actions: types::Card8,
        total_actions: types::Card16,
        first_key_behavior: types::Keycode,
        n_key_behaviors: types::Card8,
        total_key_behaviors: types::Card8,
        first_key_explicit: types::Keycode,
        n_key_explicit: types::Card8,
        total_key_explicit: types::Card8,
        first_mod_map_key: types::Keycode,
        n_mod_map_keys: types::Card8,
        total_mod_map_keys: types::Card8,
        first_v_mod_map_key: types::Keycode,
        n_v_mod_map_keys: types::Card8,
        total_v_mod_map_keys: types::Card8,
        virtual_mods: impl Into<types::VMod>,
        values: impl Borrow<types::xkb::SetMapAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xkb_set_map(
            device_spec,
            flags,
            min_key_code,
            max_key_code,
            first_type,
            n_types,
            first_key_sym,
            n_key_syms,
            total_syms,
            first_key_action,
            n_key_actions,
            total_actions,
            first_key_behavior,
            n_key_behaviors,
            total_key_behaviors,
            first_key_explicit,
            n_key_explicit,
            total_key_explicit,
            first_mod_map_key,
            n_mod_map_keys,
            total_mod_map_keys,
            first_v_mod_map_key,
            n_v_mod_map_keys,
            total_v_mod_map_keys,
            virtual_mods,
            values,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_compat_map<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        groups: impl Into<types::SetOfGroup>,
        get_all_si: types::Bool,
        first_si: types::Card16,
        n_si: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::GetCompatMapReply>> {
        let span = tracing::info_span!(
            "xkb_get_compat_map",
            device_spec = ?device_spec,
            get_all_si = ?get_all_si,
            first_si = ?first_si,
            n_si = ?n_si,
        );
        let request = types::xkb::GetCompatMapRequest {
            device_spec,
            groups: Into::<u32>::into(groups.into()) as _,
            get_all_si,
            first_si,
            n_si,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_compat_map_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        groups: impl Into<types::SetOfGroup>,
        get_all_si: types::Bool,
        first_si: types::Card16,
        n_si: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::GetCompatMapReply>> {
        let cookie = self.xkb_get_compat_map(device_spec, groups, get_all_si, first_si, n_si);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetCompatMapReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_compat_map<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        recompute_actions: types::Bool,
        truncate_si: types::Bool,
        groups: impl Into<types::SetOfGroup>,
        first_si: types::Card16,
        si: impl AsRef<[types::SymInterpret]>,
        group_maps: impl AsRef<[types::ModDef]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xkb_set_compat_map",
            device_spec = ?device_spec,
            recompute_actions = ?recompute_actions,
            truncate_si = ?truncate_si,
            first_si = ?first_si,
        );
        let request = types::xkb::SetCompatMapRequest {
            device_spec,
            recompute_actions,
            truncate_si,
            groups: Into::<u32>::into(groups.into()) as _,
            first_si,
            si: Cow::Borrowed(si.as_ref()),
            group_maps: Cow::Borrowed(group_maps.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_compat_map_checked<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        recompute_actions: types::Bool,
        truncate_si: types::Bool,
        groups: impl Into<types::SetOfGroup>,
        first_si: types::Card16,
        si: impl AsRef<[types::SymInterpret]>,
        group_maps: impl AsRef<[types::ModDef]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xkb_set_compat_map(
            device_spec,
            recompute_actions,
            truncate_si,
            groups,
            first_si,
            si,
            group_maps,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_state<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::GetIndicatorStateReply>> {
        let span = tracing::info_span!(
            "xkb_get_indicator_state",
            device_spec = ?device_spec,
        );
        let request = types::xkb::GetIndicatorStateRequest { device_spec };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_state_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::GetIndicatorStateReply>>
    {
        let cookie = self.xkb_get_indicator_state(device_spec);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetIndicatorStateReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_map<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        which: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::GetIndicatorMapReply>> {
        let span = tracing::info_span!(
            "xkb_get_indicator_map",
            device_spec = ?device_spec,
            which = ?which,
        );
        let request = types::xkb::GetIndicatorMapRequest { device_spec, which };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_indicator_map_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        which: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::GetIndicatorMapReply>>
    {
        let cookie = self.xkb_get_indicator_map(device_spec, which);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetIndicatorMapReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_indicator_map<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        which: types::Card32,
        maps: impl AsRef<[types::IndicatorMap]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xkb_set_indicator_map",
            device_spec = ?device_spec,
            which = ?which,
        );
        let request = types::xkb::SetIndicatorMapRequest {
            device_spec,
            which,
            maps: Cow::Borrowed(maps.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_indicator_map_checked<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        which: types::Card32,
        maps: impl AsRef<[types::IndicatorMap]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xkb_set_indicator_map(device_spec, which, maps);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_named_indicator<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
        indicator: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::GetNamedIndicatorReply>> {
        let span = tracing::info_span!(
            "xkb_get_named_indicator",
            device_spec = ?device_spec,
            led_class = ?led_class,
            indicator = ?indicator,
        );
        let request = types::xkb::GetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_named_indicator_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
        indicator: types::Atom,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::GetNamedIndicatorReply>>
    {
        let cookie = self.xkb_get_named_indicator(device_spec, led_class, led_id, indicator);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetNamedIndicatorReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_named_indicator<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
        indicator: types::Atom,
        set_state: types::Bool,
        on: types::Bool,
        set_map: types::Bool,
        create_map: types::Bool,
        map_flags: impl Into<types::IMFlag>,
        map_which_groups: impl Into<types::IMGroupsWhich>,
        map_groups: impl Into<types::SetOfGroups>,
        map_which_mods: impl Into<types::IMModsWhich>,
        map_real_mods: impl Into<types::ModMask>,
        map_vmods: impl Into<types::VMod>,
        map_ctrls: impl Into<types::BoolCtrl>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xkb_set_named_indicator",
            device_spec = ?device_spec,
            led_class = ?led_class,
            indicator = ?indicator,
            set_state = ?set_state,
            on = ?on,
            set_map = ?set_map,
            create_map = ?create_map,
        );
        let request = types::xkb::SetNamedIndicatorRequest {
            device_spec,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
            indicator,
            set_state,
            on,
            set_map,
            create_map,
            map_flags: Into::<u32>::into(map_flags.into()) as _,
            map_which_groups: Into::<u32>::into(map_which_groups.into()) as _,
            map_groups: Into::<u32>::into(map_groups.into()) as _,
            map_which_mods: Into::<u32>::into(map_which_mods.into()) as _,
            map_real_mods: Into::<u32>::into(map_real_mods.into()) as _,
            map_vmods: Into::<u32>::into(map_vmods.into()) as _,
            map_ctrls: Into::<u32>::into(map_ctrls.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_named_indicator_checked<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
        indicator: types::Atom,
        set_state: types::Bool,
        on: types::Bool,
        set_map: types::Bool,
        create_map: types::Bool,
        map_flags: impl Into<types::IMFlag>,
        map_which_groups: impl Into<types::IMGroupsWhich>,
        map_groups: impl Into<types::SetOfGroups>,
        map_which_mods: impl Into<types::IMModsWhich>,
        map_real_mods: impl Into<types::ModMask>,
        map_vmods: impl Into<types::VMod>,
        map_ctrls: impl Into<types::BoolCtrl>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xkb_set_named_indicator(
            device_spec,
            led_class,
            led_id,
            indicator,
            set_state,
            on,
            set_map,
            create_map,
            map_flags,
            map_which_groups,
            map_groups,
            map_which_mods,
            map_real_mods,
            map_vmods,
            map_ctrls,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_names<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        which: impl Into<types::NameDetail>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::GetNamesReply>> {
        let span = tracing::info_span!(
            "xkb_get_names",
            device_spec = ?device_spec,
        );
        let request = types::xkb::GetNamesRequest {
            device_spec,
            which: Into::<u32>::into(which.into()) as _,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_names_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        which: impl Into<types::NameDetail>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::GetNamesReply>> {
        let cookie = self.xkb_get_names(device_spec, which);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetNamesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_names<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        virtual_mods: impl Into<types::VMod>,
        first_type: types::Card8,
        n_types: types::Card8,
        first_kt_levelt: types::Card8,
        n_kt_levels: types::Card8,
        indicators: types::Card32,
        group_names: impl Into<types::SetOfGroup>,
        n_radio_groups: types::Card8,
        first_key: types::Keycode,
        n_keys: types::Card8,
        n_key_aliases: types::Card8,
        total_kt_level_names: types::Card16,
        values: impl Borrow<types::xkb::SetNamesAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xkb_set_names",
            device_spec = ?device_spec,
            first_type = ?first_type,
            n_types = ?n_types,
            first_kt_levelt = ?first_kt_levelt,
            n_kt_levels = ?n_kt_levels,
            indicators = ?indicators,
            n_radio_groups = ?n_radio_groups,
            first_key = ?first_key,
            n_keys = ?n_keys,
            n_key_aliases = ?n_key_aliases,
            total_kt_level_names = ?total_kt_level_names,
        );
        let request = types::xkb::SetNamesRequest {
            device_spec,
            virtual_mods: Into::<u32>::into(virtual_mods.into()) as _,
            first_type,
            n_types,
            first_kt_levelt,
            n_kt_levels,
            indicators,
            group_names: Into::<u32>::into(group_names.into()) as _,
            n_radio_groups,
            first_key,
            n_keys,
            n_key_aliases,
            total_kt_level_names,
            values: Cow::Borrowed(values.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_names_checked<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        virtual_mods: impl Into<types::VMod>,
        first_type: types::Card8,
        n_types: types::Card8,
        first_kt_levelt: types::Card8,
        n_kt_levels: types::Card8,
        indicators: types::Card32,
        group_names: impl Into<types::SetOfGroup>,
        n_radio_groups: types::Card8,
        first_key: types::Keycode,
        n_keys: types::Card8,
        n_key_aliases: types::Card8,
        total_kt_level_names: types::Card16,
        values: impl Borrow<types::xkb::SetNamesAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xkb_set_names(
            device_spec,
            virtual_mods,
            first_type,
            n_types,
            first_kt_levelt,
            n_kt_levels,
            indicators,
            group_names,
            n_radio_groups,
            first_key,
            n_keys,
            n_key_aliases,
            total_kt_level_names,
            values,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_per_client_flags<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        change: impl Into<types::PerClientFlag>,
        value: impl Into<types::PerClientFlag>,
        ctrls_to_change: impl Into<types::BoolCtrl>,
        auto_ctrls: impl Into<types::BoolCtrl>,
        auto_ctrls_values: impl Into<types::BoolCtrl>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::PerClientFlagsReply>> {
        let span = tracing::info_span!(
            "xkb_per_client_flags",
            device_spec = ?device_spec,
        );
        let request = types::xkb::PerClientFlagsRequest {
            device_spec,
            change: Into::<u32>::into(change.into()) as _,
            value: Into::<u32>::into(value.into()) as _,
            ctrls_to_change: Into::<u32>::into(ctrls_to_change.into()) as _,
            auto_ctrls: Into::<u32>::into(auto_ctrls.into()) as _,
            auto_ctrls_values: Into::<u32>::into(auto_ctrls_values.into()) as _,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_per_client_flags_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        change: impl Into<types::PerClientFlag>,
        value: impl Into<types::PerClientFlag>,
        ctrls_to_change: impl Into<types::BoolCtrl>,
        auto_ctrls: impl Into<types::BoolCtrl>,
        auto_ctrls_values: impl Into<types::BoolCtrl>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::PerClientFlagsReply>>
    {
        let cookie = self.xkb_per_client_flags(
            device_spec,
            change,
            value,
            ctrls_to_change,
            auto_ctrls,
            auto_ctrls_values,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::PerClientFlagsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_list_components<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        max_names: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::ListComponentsReply>> {
        let span = tracing::info_span!(
            "xkb_list_components",
            device_spec = ?device_spec,
            max_names = ?max_names,
        );
        let request = types::xkb::ListComponentsRequest {
            device_spec,
            max_names,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_list_components_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        max_names: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::ListComponentsReply>>
    {
        let cookie = self.xkb_list_components(device_spec, max_names);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::ListComponentsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_kbd_by_name<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        need: impl Into<types::GBNDetail>,
        want: impl Into<types::GBNDetail>,
        load: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::GetKbdByNameReply>> {
        let span = tracing::info_span!(
            "xkb_get_kbd_by_name",
            device_spec = ?device_spec,
            load = ?load,
        );
        let request = types::xkb::GetKbdByNameRequest {
            device_spec,
            need: Into::<u32>::into(need.into()) as _,
            want: Into::<u32>::into(want.into()) as _,
            load,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_kbd_by_name_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        need: impl Into<types::GBNDetail>,
        want: impl Into<types::GBNDetail>,
        load: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::GetKbdByNameReply>> {
        let cookie = self.xkb_get_kbd_by_name(device_spec, need, want, load);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetKbdByNameReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_device_info<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        wanted: impl Into<types::XIFeature>,
        all_buttons: types::Bool,
        first_button: types::Card8,
        n_buttons: types::Card8,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::GetDeviceInfoReply>> {
        let span = tracing::info_span!(
            "xkb_get_device_info",
            device_spec = ?device_spec,
            all_buttons = ?all_buttons,
            first_button = ?first_button,
            n_buttons = ?n_buttons,
            led_class = ?led_class,
        );
        let request = types::xkb::GetDeviceInfoRequest {
            device_spec,
            wanted: Into::<u32>::into(wanted.into()) as _,
            all_buttons,
            first_button,
            n_buttons,
            led_class,
            led_id: Into::<u32>::into(led_id.into()) as _,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_get_device_info_immediate<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        wanted: impl Into<types::XIFeature>,
        all_buttons: types::Bool,
        first_button: types::Card8,
        n_buttons: types::Card8,
        led_class: types::LedClass,
        led_id: impl Into<types::ID>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::GetDeviceInfoReply>>
    {
        let cookie = self.xkb_get_device_info(
            device_spec,
            wanted,
            all_buttons,
            first_button,
            n_buttons,
            led_class,
            led_id,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::GetDeviceInfoReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_device_info<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        first_btn: types::Card8,
        change: impl Into<types::XIFeature>,
        btn_actions: impl AsRef<[types::Action]>,
        leds: impl AsRef<[types::DeviceLedInfo]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xkb_set_device_info",
            device_spec = ?device_spec,
            first_btn = ?first_btn,
        );
        let request = types::xkb::SetDeviceInfoRequest {
            device_spec,
            first_btn,
            change: Into::<u32>::into(change.into()) as _,
            btn_actions: Cow::Borrowed(btn_actions.as_ref()),
            leds: Cow::Borrowed(leds.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_device_info_checked<'this>(
        &'this mut self,
        device_spec: types::DeviceSpec,
        first_btn: types::Card8,
        change: impl Into<types::XIFeature>,
        btn_actions: impl AsRef<[types::Action]>,
        leds: impl AsRef<[types::DeviceLedInfo]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xkb_set_device_info(device_spec, first_btn, change, btn_actions, leds);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_debugging_flags<'this>(
        &'this mut self,
        affect_flags: types::Card32,
        flags: types::Card32,
        affect_ctrls: types::Card32,
        ctrls: types::Card32,
        message: impl AsRef<[types::xkb::String8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xkb::SetDebuggingFlagsReply>> {
        let span = tracing::info_span!(
            "xkb_set_debugging_flags",
            affect_flags = ?affect_flags,
            flags = ?flags,
            affect_ctrls = ?affect_ctrls,
            ctrls = ?ctrls,
        );
        let request = types::xkb::SetDebuggingFlagsRequest {
            affect_flags,
            flags,
            affect_ctrls,
            ctrls,
            message: Cow::Borrowed(message.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xkb")]
    fn xkb_set_debugging_flags_immediate<'this>(
        &'this mut self,
        affect_flags: types::Card32,
        flags: types::Card32,
        affect_ctrls: types::Card32,
        ctrls: types::Card32,
        message: impl AsRef<[types::xkb::String8]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xkb::SetDebuggingFlagsReply>>
    {
        let cookie =
            self.xkb_set_debugging_flags(affect_flags, flags, affect_ctrls, ctrls, message);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xkb::SetDebuggingFlagsReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xprint")]
    fn xprint_print_query_version<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintQueryVersionReply>>
    {
        let span = tracing::info_span!("xprint_print_query_version",);
        let request = types::xprint::PrintQueryVersionRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_version_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xprint::PrintQueryVersionReply>>
    {
        let cookie = self.xprint_print_query_version();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintQueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_printer_list<'this>(
        &'this mut self,
        printer_name: impl AsRef<[types::xprint::String8]>,
        locale: impl AsRef<[types::xprint::String8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintGetPrinterListReply>>
    {
        let span = tracing::info_span!("xprint_print_get_printer_list",);
        let request = types::xprint::PrintGetPrinterListRequest {
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_printer_list_immediate<'this>(
        &'this mut self,
        printer_name: impl AsRef<[types::xprint::String8]>,
        locale: impl AsRef<[types::xprint::String8]>,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetPrinterListReply>,
    > {
        let cookie = self.xprint_print_get_printer_list(printer_name, locale);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetPrinterListReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_rehash_printer_list<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("xprint_print_rehash_printer_list",);
        let request = types::xprint::PrintRehashPrinterListRequest {};
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_rehash_printer_list_checked<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_rehash_printer_list();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_create_context<'this>(
        &'this mut self,
        context_id: types::Card32,
        printer_name: impl AsRef<[types::xprint::String8]>,
        locale: impl AsRef<[types::xprint::String8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_create_context",
            context_id = ?context_id,
        );
        let request = types::xprint::CreateContextRequest {
            context_id,
            printer_name: Cow::Borrowed(printer_name.as_ref()),
            locale: Cow::Borrowed(locale.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_create_context_checked<'this>(
        &'this mut self,
        context_id: types::Card32,
        printer_name: impl AsRef<[types::xprint::String8]>,
        locale: impl AsRef<[types::xprint::String8]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_create_context(context_id, printer_name, locale);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_context<'this>(
        &'this mut self,
        context: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_print_set_context",
            context = ?context,
        );
        let request = types::xprint::PrintSetContextRequest { context };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_context_checked<'this>(
        &'this mut self,
        context: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_set_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_context<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintGetContextReply>> {
        let span = tracing::info_span!("xprint_print_get_context",);
        let request = types::xprint::PrintGetContextRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_context_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetContextReply>>
    {
        let cookie = self.xprint_print_get_context();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetContextReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_destroy_context<'this>(
        &'this mut self,
        context: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_print_destroy_context",
            context = ?context,
        );
        let request = types::xprint::PrintDestroyContextRequest { context };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_destroy_context_checked<'this>(
        &'this mut self,
        context: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_destroy_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_screen_of_context<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintGetScreenOfContextReply>>
    {
        let span = tracing::info_span!("xprint_print_get_screen_of_context",);
        let request = types::xprint::PrintGetScreenOfContextRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_screen_of_context_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetScreenOfContextReply>,
    > {
        let cookie = self.xprint_print_get_screen_of_context();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xprint::PrintGetScreenOfContextReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_job<'this>(
        &'this mut self,
        output_mode: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_print_start_job",
            output_mode = ?output_mode,
        );
        let request = types::xprint::PrintStartJobRequest { output_mode };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_job_checked<'this>(
        &'this mut self,
        output_mode: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_start_job(output_mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_job<'this>(
        &'this mut self,
        cancel: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_print_end_job",
            cancel = ?cancel,
        );
        let request = types::xprint::PrintEndJobRequest { cancel };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_job_checked<'this>(
        &'this mut self,
        cancel: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_end_job(cancel);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_doc<'this>(
        &'this mut self,
        driver_mode: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_print_start_doc",
            driver_mode = ?driver_mode,
        );
        let request = types::xprint::PrintStartDocRequest { driver_mode };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_doc_checked<'this>(
        &'this mut self,
        driver_mode: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_start_doc(driver_mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_doc<'this>(
        &'this mut self,
        cancel: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_print_end_doc",
            cancel = ?cancel,
        );
        let request = types::xprint::PrintEndDocRequest { cancel };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_doc_checked<'this>(
        &'this mut self,
        cancel: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_end_doc(cancel);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_put_document_data<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        data: impl AsRef<[types::Byte]>,
        doc_format: impl AsRef<[types::xprint::String8]>,
        options: impl AsRef<[types::xprint::String8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_print_put_document_data",
            drawable = ?drawable,
        );
        let request = types::xprint::PrintPutDocumentDataRequest {
            drawable,
            data: Cow::Borrowed(data.as_ref()),
            doc_format: Cow::Borrowed(doc_format.as_ref()),
            options: Cow::Borrowed(options.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_put_document_data_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        data: impl AsRef<[types::Byte]>,
        doc_format: impl AsRef<[types::xprint::String8]>,
        options: impl AsRef<[types::xprint::String8]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_put_document_data(drawable, data, doc_format, options);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_document_data<'this>(
        &'this mut self,
        context: types::Pcontext,
        max_bytes: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintGetDocumentDataReply>>
    {
        let span = tracing::info_span!(
            "xprint_print_get_document_data",
            context = ?context,
            max_bytes = ?max_bytes,
        );
        let request = types::xprint::PrintGetDocumentDataRequest { context, max_bytes };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_document_data_immediate<'this>(
        &'this mut self,
        context: types::Pcontext,
        max_bytes: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetDocumentDataReply>,
    > {
        let cookie = self.xprint_print_get_document_data(context, max_bytes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xprint::PrintGetDocumentDataReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_page<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_print_start_page",
            window = ?window,
        );
        let request = types::xprint::PrintStartPageRequest { window };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_start_page_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_start_page(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_page<'this>(
        &'this mut self,
        cancel: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_print_end_page",
            cancel = ?cancel,
        );
        let request = types::xprint::PrintEndPageRequest { cancel };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_end_page_checked<'this>(
        &'this mut self,
        cancel: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_end_page(cancel);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_select_input<'this>(
        &'this mut self,
        context: types::Pcontext,
        event_mask: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_print_select_input",
            context = ?context,
            event_mask = ?event_mask,
        );
        let request = types::xprint::PrintSelectInputRequest {
            context,
            event_mask,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_select_input_checked<'this>(
        &'this mut self,
        context: types::Pcontext,
        event_mask: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_select_input(context, event_mask);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_input_selected<'this>(
        &'this mut self,
        context: types::Pcontext,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintInputSelectedReply>>
    {
        let span = tracing::info_span!(
            "xprint_print_input_selected",
            context = ?context,
        );
        let request = types::xprint::PrintInputSelectedRequest { context };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_input_selected_immediate<'this>(
        &'this mut self,
        context: types::Pcontext,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xprint::PrintInputSelectedReply>,
    > {
        let cookie = self.xprint_print_input_selected(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintInputSelectedReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_attributes<'this>(
        &'this mut self,
        context: types::Pcontext,
        pool: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintGetAttributesReply>>
    {
        let span = tracing::info_span!(
            "xprint_print_get_attributes",
            context = ?context,
            pool = ?pool,
        );
        let request = types::xprint::PrintGetAttributesRequest { context, pool };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_attributes_immediate<'this>(
        &'this mut self,
        context: types::Pcontext,
        pool: types::Card8,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetAttributesReply>,
    > {
        let cookie = self.xprint_print_get_attributes(context, pool);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetAttributesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_one_attributes<'this>(
        &'this mut self,
        context: types::Pcontext,
        pool: types::Card8,
        name: impl AsRef<[types::xprint::String8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintGetOneAttributesReply>>
    {
        let span = tracing::info_span!(
            "xprint_print_get_one_attributes",
            context = ?context,
            pool = ?pool,
        );
        let request = types::xprint::PrintGetOneAttributesRequest {
            context,
            pool,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_one_attributes_immediate<'this>(
        &'this mut self,
        context: types::Pcontext,
        pool: types::Card8,
        name: impl AsRef<[types::xprint::String8]>,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetOneAttributesReply>,
    > {
        let cookie = self.xprint_print_get_one_attributes(context, pool, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xprint::PrintGetOneAttributesReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_attributes<'this>(
        &'this mut self,
        context: types::Pcontext,
        string_len: types::Card32,
        pool: types::Card8,
        rule: types::Card8,
        attributes: impl AsRef<[types::xprint::String8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xprint_print_set_attributes",
            context = ?context,
            string_len = ?string_len,
            pool = ?pool,
            rule = ?rule,
        );
        let request = types::xprint::PrintSetAttributesRequest {
            context,
            string_len,
            pool,
            rule,
            attributes: Cow::Borrowed(attributes.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_attributes_checked<'this>(
        &'this mut self,
        context: types::Pcontext,
        string_len: types::Card32,
        pool: types::Card8,
        rule: types::Card8,
        attributes: impl AsRef<[types::xprint::String8]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xprint_print_set_attributes(context, string_len, pool, rule, attributes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_page_dimensions<'this>(
        &'this mut self,
        context: types::Pcontext,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintGetPageDimensionsReply>>
    {
        let span = tracing::info_span!(
            "xprint_print_get_page_dimensions",
            context = ?context,
        );
        let request = types::xprint::PrintGetPageDimensionsRequest { context };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_page_dimensions_immediate<'this>(
        &'this mut self,
        context: types::Pcontext,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetPageDimensionsReply>,
    > {
        let cookie = self.xprint_print_get_page_dimensions(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xprint::PrintGetPageDimensionsReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_screens<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintQueryScreensReply>>
    {
        let span = tracing::info_span!("xprint_print_query_screens",);
        let request = types::xprint::PrintQueryScreensRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_query_screens_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xprint::PrintQueryScreensReply>>
    {
        let cookie = self.xprint_print_query_screens();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xprint::PrintQueryScreensReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_image_resolution<'this>(
        &'this mut self,
        context: types::Pcontext,
        image_resolution: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintSetImageResolutionReply>>
    {
        let span = tracing::info_span!(
            "xprint_print_set_image_resolution",
            context = ?context,
            image_resolution = ?image_resolution,
        );
        let request = types::xprint::PrintSetImageResolutionRequest {
            context,
            image_resolution,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_set_image_resolution_immediate<'this>(
        &'this mut self,
        context: types::Pcontext,
        image_resolution: types::Card16,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xprint::PrintSetImageResolutionReply>,
    > {
        let cookie = self.xprint_print_set_image_resolution(context, image_resolution);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xprint::PrintSetImageResolutionReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_image_resolution<'this>(
        &'this mut self,
        context: types::Pcontext,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xprint::PrintGetImageResolutionReply>>
    {
        let span = tracing::info_span!(
            "xprint_print_get_image_resolution",
            context = ?context,
        );
        let request = types::xprint::PrintGetImageResolutionRequest { context };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xprint")]
    fn xprint_print_get_image_resolution_immediate<'this>(
        &'this mut self,
        context: types::Pcontext,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xprint::PrintGetImageResolutionReply>,
    > {
        let cookie = self.xprint_print_get_image_resolution(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xprint::PrintGetImageResolutionReply,
        > = cookie.into();
        res.instrument(span)
    }

    fn create_window<'this>(
        &'this mut self,
        depth: types::Card8,
        wid: types::xproto::Window,
        parent: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        border_width: types::Card16,
        class: types::WindowClass,
        visual: types::Visualid,
        value_list: impl Borrow<types::xproto::CreateWindowAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "create_window",
            depth = ?depth,
            wid = ?wid,
            parent = ?parent,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            border_width = ?border_width,
            class = ?class,
            visual = ?visual,
        );
        let request = types::xproto::CreateWindowRequest {
            depth,
            wid,
            parent,
            x,
            y,
            width,
            height,
            border_width,
            class,
            visual,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn create_window_checked<'this>(
        &'this mut self,
        depth: types::Card8,
        wid: types::xproto::Window,
        parent: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        border_width: types::Card16,
        class: types::WindowClass,
        visual: types::Visualid,
        value_list: impl Borrow<types::xproto::CreateWindowAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.create_window(
            depth,
            wid,
            parent,
            x,
            y,
            width,
            height,
            border_width,
            class,
            visual,
            value_list,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn change_window_attributes<'this>(
        &'this mut self,
        window: types::xproto::Window,
        value_list: impl Borrow<types::xproto::ChangeWindowAttributesAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "change_window_attributes",
            window = ?window,
        );
        let request = types::xproto::ChangeWindowAttributesRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn change_window_attributes_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        value_list: impl Borrow<types::xproto::ChangeWindowAttributesAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.change_window_attributes(window, value_list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn get_window_attributes<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetWindowAttributesReply>>
    {
        let span = tracing::info_span!(
            "get_window_attributes",
            window = ?window,
        );
        let request = types::xproto::GetWindowAttributesRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    fn get_window_attributes_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xproto::GetWindowAttributesReply>,
    > {
        let cookie = self.get_window_attributes(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetWindowAttributesReply> =
            cookie.into();
        res.instrument(span)
    }
    fn destroy_window<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "destroy_window",
            window = ?window,
        );
        let request = types::xproto::DestroyWindowRequest { window };
        self.send_void_request(request).instrument(span)
    }
    fn destroy_window_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.destroy_window(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn destroy_subwindows<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "destroy_subwindows",
            window = ?window,
        );
        let request = types::xproto::DestroySubwindowsRequest { window };
        self.send_void_request(request).instrument(span)
    }
    fn destroy_subwindows_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.destroy_subwindows(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn change_save_set<'this>(
        &'this mut self,
        mode: types::SetMode,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "change_save_set",
            mode = ?mode,
            window = ?window,
        );
        let request = types::xproto::ChangeSaveSetRequest { mode, window };
        self.send_void_request(request).instrument(span)
    }
    fn change_save_set_checked<'this>(
        &'this mut self,
        mode: types::SetMode,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.change_save_set(mode, window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn reparent_window<'this>(
        &'this mut self,
        window: types::xproto::Window,
        parent: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "reparent_window",
            window = ?window,
            parent = ?parent,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::ReparentWindowRequest {
            window,
            parent,
            x,
            y,
        };
        self.send_void_request(request).instrument(span)
    }
    fn reparent_window_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        parent: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.reparent_window(window, parent, x, y);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn map_window<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "map_window",
            window = ?window,
        );
        let request = types::xproto::MapWindowRequest { window };
        self.send_void_request(request).instrument(span)
    }
    fn map_window_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.map_window(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn map_subwindows<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "map_subwindows",
            window = ?window,
        );
        let request = types::xproto::MapSubwindowsRequest { window };
        self.send_void_request(request).instrument(span)
    }
    fn map_subwindows_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.map_subwindows(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn unmap_window<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "unmap_window",
            window = ?window,
        );
        let request = types::xproto::UnmapWindowRequest { window };
        self.send_void_request(request).instrument(span)
    }
    fn unmap_window_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.unmap_window(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn unmap_subwindows<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "unmap_subwindows",
            window = ?window,
        );
        let request = types::xproto::UnmapSubwindowsRequest { window };
        self.send_void_request(request).instrument(span)
    }
    fn unmap_subwindows_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.unmap_subwindows(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn configure_window<'this>(
        &'this mut self,
        window: types::xproto::Window,
        value_list: impl Borrow<types::xproto::ConfigureWindowAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "configure_window",
            window = ?window,
        );
        let request = types::xproto::ConfigureWindowRequest {
            window,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn configure_window_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        value_list: impl Borrow<types::xproto::ConfigureWindowAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.configure_window(window, value_list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn circulate_window<'this>(
        &'this mut self,
        direction: types::Circulate,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "circulate_window",
            direction = ?direction,
            window = ?window,
        );
        let request = types::xproto::CirculateWindowRequest { direction, window };
        self.send_void_request(request).instrument(span)
    }
    fn circulate_window_checked<'this>(
        &'this mut self,
        direction: types::Circulate,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.circulate_window(direction, window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn get_geometry<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetGeometryReply>> {
        let span = tracing::info_span!(
            "get_geometry",
            drawable = ?drawable,
        );
        let request = types::xproto::GetGeometryRequest { drawable };
        self.send_reply_request(request).instrument(span)
    }
    fn get_geometry_immediate<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GetGeometryReply>>
    {
        let cookie = self.get_geometry(drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetGeometryReply> =
            cookie.into();
        res.instrument(span)
    }
    fn query_tree<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::QueryTreeReply>> {
        let span = tracing::info_span!(
            "query_tree",
            window = ?window,
        );
        let request = types::xproto::QueryTreeRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    fn query_tree_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::QueryTreeReply>> {
        let cookie = self.query_tree(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryTreeReply> =
            cookie.into();
        res.instrument(span)
    }
    fn intern_atom<'this>(
        &'this mut self,
        only_if_exists: types::Bool,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::InternAtomReply>> {
        let span = tracing::info_span!(
            "intern_atom",
            only_if_exists = ?only_if_exists,
        );
        let request = types::xproto::InternAtomRequest {
            only_if_exists,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    fn intern_atom_immediate<'this>(
        &'this mut self,
        only_if_exists: types::Bool,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::InternAtomReply>>
    {
        let cookie = self.intern_atom(only_if_exists, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::InternAtomReply> =
            cookie.into();
        res.instrument(span)
    }
    fn get_atom_name<'this>(
        &'this mut self,
        atom: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetAtomNameReply>> {
        let span = tracing::info_span!(
            "get_atom_name",
            atom = ?atom,
        );
        let request = types::xproto::GetAtomNameRequest { atom };
        self.send_reply_request(request).instrument(span)
    }
    fn get_atom_name_immediate<'this>(
        &'this mut self,
        atom: types::Atom,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GetAtomNameReply>>
    {
        let cookie = self.get_atom_name(atom);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetAtomNameReply> =
            cookie.into();
        res.instrument(span)
    }
    fn change_property<'this>(
        &'this mut self,
        mode: types::PropMode,
        window: types::xproto::Window,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        data_len: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "change_property",
            mode = ?mode,
            window = ?window,
            property = ?property,
            type_ = ?type_,
            format = ?format,
            data_len = ?data_len,
        );
        let request = types::xproto::ChangePropertyRequest {
            mode,
            window,
            property,
            type_,
            format,
            data_len,
            data: Cow::Borrowed(data.bytes()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn change_property_checked<'this>(
        &'this mut self,
        mode: types::PropMode,
        window: types::xproto::Window,
        property: types::Atom,
        type_: types::Atom,
        format: types::Card8,
        data_len: types::Card32,
        data: &(impl crate::Void + ?Sized),
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.change_property(mode, window, property, type_, format, data_len, data);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn delete_property<'this>(
        &'this mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "delete_property",
            window = ?window,
            property = ?property,
        );
        let request = types::xproto::DeletePropertyRequest { window, property };
        self.send_void_request(request).instrument(span)
    }
    fn delete_property_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.delete_property(window, property);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn get_property<'this>(
        &'this mut self,
        delete: types::Bool,
        window: types::xproto::Window,
        property: types::Atom,
        type_: impl Into<types::GetPropertyType>,
        long_offset: types::Card32,
        long_length: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetPropertyReply>> {
        let span = tracing::info_span!(
            "get_property",
            delete = ?delete,
            window = ?window,
            property = ?property,
            long_offset = ?long_offset,
            long_length = ?long_length,
        );
        let request = types::xproto::GetPropertyRequest {
            delete,
            window,
            property,
            type_: Into::<u32>::into(type_.into()) as _,
            long_offset,
            long_length,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn get_property_immediate<'this>(
        &'this mut self,
        delete: types::Bool,
        window: types::xproto::Window,
        property: types::Atom,
        type_: impl Into<types::GetPropertyType>,
        long_offset: types::Card32,
        long_length: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GetPropertyReply>>
    {
        let cookie = self.get_property(delete, window, property, type_, long_offset, long_length);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetPropertyReply> =
            cookie.into();
        res.instrument(span)
    }
    fn list_properties<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::ListPropertiesReply>> {
        let span = tracing::info_span!(
            "list_properties",
            window = ?window,
        );
        let request = types::xproto::ListPropertiesRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    fn list_properties_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::ListPropertiesReply>>
    {
        let cookie = self.list_properties(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::ListPropertiesReply> =
            cookie.into();
        res.instrument(span)
    }
    fn set_selection_owner<'this>(
        &'this mut self,
        owner: impl Into<types::xproto::Window>,
        selection: types::Atom,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "set_selection_owner",
            selection = ?selection,
        );
        let request = types::xproto::SetSelectionOwnerRequest {
            owner: Into::<u32>::into(owner.into()) as _,
            selection,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn set_selection_owner_checked<'this>(
        &'this mut self,
        owner: impl Into<types::xproto::Window>,
        selection: types::Atom,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.set_selection_owner(owner, selection, time);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn get_selection_owner<'this>(
        &'this mut self,
        selection: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetSelectionOwnerReply>>
    {
        let span = tracing::info_span!(
            "get_selection_owner",
            selection = ?selection,
        );
        let request = types::xproto::GetSelectionOwnerRequest { selection };
        self.send_reply_request(request).instrument(span)
    }
    fn get_selection_owner_immediate<'this>(
        &'this mut self,
        selection: types::Atom,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GetSelectionOwnerReply>>
    {
        let cookie = self.get_selection_owner(selection);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetSelectionOwnerReply> =
            cookie.into();
        res.instrument(span)
    }
    fn convert_selection<'this>(
        &'this mut self,
        requestor: types::xproto::Window,
        selection: types::Atom,
        target: types::Atom,
        property: impl Into<types::Atom>,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "convert_selection",
            requestor = ?requestor,
            selection = ?selection,
            target = ?target,
        );
        let request = types::xproto::ConvertSelectionRequest {
            requestor,
            selection,
            target,
            property: Into::<u32>::into(property.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn convert_selection_checked<'this>(
        &'this mut self,
        requestor: types::xproto::Window,
        selection: types::Atom,
        target: types::Atom,
        property: impl Into<types::Atom>,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.convert_selection(requestor, selection, target, property, time);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn send_event<'this>(
        &'this mut self,
        propagate: types::Bool,
        destination: impl Into<types::SendEventDest>,
        event_mask: impl Into<types::xproto::EventMask>,
        event: impl Borrow<[types::Char; 32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "send_event",
            propagate = ?propagate,
        );
        let request = types::xproto::SendEventRequest {
            propagate,
            destination: Into::<u32>::into(destination.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            event: Cow::Borrowed(event.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn send_event_checked<'this>(
        &'this mut self,
        propagate: types::Bool,
        destination: impl Into<types::SendEventDest>,
        event_mask: impl Into<types::xproto::EventMask>,
        event: impl Borrow<[types::Char; 32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.send_event(propagate, destination, event_mask, event);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn grab_pointer<'this>(
        &'this mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        event_mask: impl Into<types::xproto::EventMask>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
        confine_to: impl Into<types::xproto::Window>,
        cursor: impl Into<types::xproto::Cursor>,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GrabPointerReply>> {
        let span = tracing::info_span!(
            "grab_pointer",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let request = types::xproto::GrabPointerRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn grab_pointer_immediate<'this>(
        &'this mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        event_mask: impl Into<types::xproto::EventMask>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
        confine_to: impl Into<types::xproto::Window>,
        cursor: impl Into<types::xproto::Cursor>,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GrabPointerReply>>
    {
        let cookie = self.grab_pointer(
            owner_events,
            grab_window,
            event_mask,
            pointer_mode,
            keyboard_mode,
            confine_to,
            cursor,
            time,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GrabPointerReply> =
            cookie.into();
        res.instrument(span)
    }
    fn ungrab_pointer<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("ungrab_pointer",);
        let request = types::xproto::UngrabPointerRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn ungrab_pointer_checked<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.ungrab_pointer(time);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn grab_button<'this>(
        &'this mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        event_mask: impl Into<types::xproto::EventMask>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
        confine_to: impl Into<types::xproto::Window>,
        cursor: impl Into<types::xproto::Cursor>,
        button: types::ButtonIndex,
        modifiers: impl Into<types::ModMask>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "grab_button",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
            button = ?button,
        );
        let request = types::xproto::GrabButtonRequest {
            owner_events,
            grab_window,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
            pointer_mode,
            keyboard_mode,
            confine_to: Into::<u32>::into(confine_to.into()) as _,
            cursor: Into::<u32>::into(cursor.into()) as _,
            button,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn grab_button_checked<'this>(
        &'this mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        event_mask: impl Into<types::xproto::EventMask>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
        confine_to: impl Into<types::xproto::Window>,
        cursor: impl Into<types::xproto::Cursor>,
        button: types::ButtonIndex,
        modifiers: impl Into<types::ModMask>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.grab_button(
            owner_events,
            grab_window,
            event_mask,
            pointer_mode,
            keyboard_mode,
            confine_to,
            cursor,
            button,
            modifiers,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn ungrab_button<'this>(
        &'this mut self,
        button: types::ButtonIndex,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "ungrab_button",
            button = ?button,
            grab_window = ?grab_window,
        );
        let request = types::xproto::UngrabButtonRequest {
            button,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn ungrab_button_checked<'this>(
        &'this mut self,
        button: types::ButtonIndex,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.ungrab_button(button, grab_window, modifiers);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn change_active_pointer_grab<'this>(
        &'this mut self,
        cursor: impl Into<types::xproto::Cursor>,
        time: impl Into<types::Time>,
        event_mask: impl Into<types::xproto::EventMask>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("change_active_pointer_grab",);
        let request = types::xproto::ChangeActivePointerGrabRequest {
            cursor: Into::<u32>::into(cursor.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
            event_mask: Into::<u32>::into(event_mask.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn change_active_pointer_grab_checked<'this>(
        &'this mut self,
        cursor: impl Into<types::xproto::Cursor>,
        time: impl Into<types::Time>,
        event_mask: impl Into<types::xproto::EventMask>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.change_active_pointer_grab(cursor, time, event_mask);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn grab_keyboard<'this>(
        &'this mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        time: impl Into<types::Time>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GrabKeyboardReply>> {
        let span = tracing::info_span!(
            "grab_keyboard",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let request = types::xproto::GrabKeyboardRequest {
            owner_events,
            grab_window,
            time: Into::<u32>::into(time.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn grab_keyboard_immediate<'this>(
        &'this mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        time: impl Into<types::Time>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GrabKeyboardReply>>
    {
        let cookie =
            self.grab_keyboard(owner_events, grab_window, time, pointer_mode, keyboard_mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GrabKeyboardReply> =
            cookie.into();
        res.instrument(span)
    }
    fn ungrab_keyboard<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("ungrab_keyboard",);
        let request = types::xproto::UngrabKeyboardRequest {
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn ungrab_keyboard_checked<'this>(
        &'this mut self,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.ungrab_keyboard(time);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn grab_key<'this>(
        &'this mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        key: impl Into<types::Grab>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "grab_key",
            owner_events = ?owner_events,
            grab_window = ?grab_window,
            pointer_mode = ?pointer_mode,
            keyboard_mode = ?keyboard_mode,
        );
        let request = types::xproto::GrabKeyRequest {
            owner_events,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
            key: Into::<u32>::into(key.into()) as _,
            pointer_mode,
            keyboard_mode,
        };
        self.send_void_request(request).instrument(span)
    }
    fn grab_key_checked<'this>(
        &'this mut self,
        owner_events: types::Bool,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
        key: impl Into<types::Grab>,
        pointer_mode: types::GrabMode,
        keyboard_mode: types::GrabMode,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.grab_key(
            owner_events,
            grab_window,
            modifiers,
            key,
            pointer_mode,
            keyboard_mode,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn ungrab_key<'this>(
        &'this mut self,
        key: impl Into<types::Grab>,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "ungrab_key",
            grab_window = ?grab_window,
        );
        let request = types::xproto::UngrabKeyRequest {
            key: Into::<u32>::into(key.into()) as _,
            grab_window,
            modifiers: Into::<u32>::into(modifiers.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn ungrab_key_checked<'this>(
        &'this mut self,
        key: impl Into<types::Grab>,
        grab_window: types::xproto::Window,
        modifiers: impl Into<types::ModMask>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.ungrab_key(key, grab_window, modifiers);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn allow_events<'this>(
        &'this mut self,
        mode: types::Allow,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "allow_events",
            mode = ?mode,
        );
        let request = types::xproto::AllowEventsRequest {
            mode,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn allow_events_checked<'this>(
        &'this mut self,
        mode: types::Allow,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.allow_events(mode, time);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn grab_server<'this>(&'this mut self) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("grab_server",);
        let request = types::xproto::GrabServerRequest {};
        self.send_void_request(request).instrument(span)
    }
    fn grab_server_checked<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.grab_server();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn ungrab_server<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("ungrab_server",);
        let request = types::xproto::UngrabServerRequest {};
        self.send_void_request(request).instrument(span)
    }
    fn ungrab_server_checked<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.ungrab_server();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn query_pointer<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::QueryPointerReply>> {
        let span = tracing::info_span!(
            "query_pointer",
            window = ?window,
        );
        let request = types::xproto::QueryPointerRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    fn query_pointer_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::QueryPointerReply>>
    {
        let cookie = self.query_pointer(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryPointerReply> =
            cookie.into();
        res.instrument(span)
    }
    fn get_motion_events<'this>(
        &'this mut self,
        window: types::xproto::Window,
        start: impl Into<types::Time>,
        stop: impl Into<types::Time>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetMotionEventsReply>> {
        let span = tracing::info_span!(
            "get_motion_events",
            window = ?window,
        );
        let request = types::xproto::GetMotionEventsRequest {
            window,
            start: Into::<u32>::into(start.into()) as _,
            stop: Into::<u32>::into(stop.into()) as _,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn get_motion_events_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        start: impl Into<types::Time>,
        stop: impl Into<types::Time>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GetMotionEventsReply>>
    {
        let cookie = self.get_motion_events(window, start, stop);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetMotionEventsReply> =
            cookie.into();
        res.instrument(span)
    }
    fn translate_coordinates<'this>(
        &'this mut self,
        src_window: types::xproto::Window,
        dst_window: types::xproto::Window,
        src_x: types::Int16,
        src_y: types::Int16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::TranslateCoordinatesReply>>
    {
        let span = tracing::info_span!(
            "translate_coordinates",
            src_window = ?src_window,
            dst_window = ?dst_window,
            src_x = ?src_x,
            src_y = ?src_y,
        );
        let request = types::xproto::TranslateCoordinatesRequest {
            src_window,
            dst_window,
            src_x,
            src_y,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn translate_coordinates_immediate<'this>(
        &'this mut self,
        src_window: types::xproto::Window,
        dst_window: types::xproto::Window,
        src_x: types::Int16,
        src_y: types::Int16,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xproto::TranslateCoordinatesReply>,
    > {
        let cookie = self.translate_coordinates(src_window, dst_window, src_x, src_y);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xproto::TranslateCoordinatesReply,
        > = cookie.into();
        res.instrument(span)
    }
    fn warp_pointer<'this>(
        &'this mut self,
        src_window: impl Into<types::xproto::Window>,
        dst_window: impl Into<types::xproto::Window>,
        src_x: types::Int16,
        src_y: types::Int16,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "warp_pointer",
            src_x = ?src_x,
            src_y = ?src_y,
            src_width = ?src_width,
            src_height = ?src_height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
        );
        let request = types::xproto::WarpPointerRequest {
            src_window: Into::<u32>::into(src_window.into()) as _,
            dst_window: Into::<u32>::into(dst_window.into()) as _,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
        };
        self.send_void_request(request).instrument(span)
    }
    fn warp_pointer_checked<'this>(
        &'this mut self,
        src_window: impl Into<types::xproto::Window>,
        dst_window: impl Into<types::xproto::Window>,
        src_x: types::Int16,
        src_y: types::Int16,
        src_width: types::Card16,
        src_height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.warp_pointer(
            src_window, dst_window, src_x, src_y, src_width, src_height, dst_x, dst_y,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn set_input_focus<'this>(
        &'this mut self,
        revert_to: types::InputFocus,
        focus: impl Into<types::InputFocus>,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "set_input_focus",
            revert_to = ?revert_to,
        );
        let request = types::xproto::SetInputFocusRequest {
            revert_to,
            focus: Into::<u32>::into(focus.into()) as _,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn set_input_focus_checked<'this>(
        &'this mut self,
        revert_to: types::InputFocus,
        focus: impl Into<types::InputFocus>,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.set_input_focus(revert_to, focus, time);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn get_input_focus<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetInputFocusReply>> {
        let span = tracing::info_span!("get_input_focus",);
        let request = types::xproto::GetInputFocusRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn get_input_focus_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GetInputFocusReply>>
    {
        let cookie = self.get_input_focus();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetInputFocusReply> =
            cookie.into();
        res.instrument(span)
    }
    fn query_keymap<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::QueryKeymapReply>> {
        let span = tracing::info_span!("query_keymap",);
        let request = types::xproto::QueryKeymapRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn query_keymap_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::QueryKeymapReply>>
    {
        let cookie = self.query_keymap();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryKeymapReply> =
            cookie.into();
        res.instrument(span)
    }
    fn open_font<'this>(
        &'this mut self,
        fid: types::Font,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "open_font",
            fid = ?fid,
        );
        let request = types::xproto::OpenFontRequest {
            fid,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn open_font_checked<'this>(
        &'this mut self,
        fid: types::Font,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.open_font(fid, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn close_font<'this>(
        &'this mut self,
        font: types::Font,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "close_font",
            font = ?font,
        );
        let request = types::xproto::CloseFontRequest { font };
        self.send_void_request(request).instrument(span)
    }
    fn close_font_checked<'this>(
        &'this mut self,
        font: types::Font,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.close_font(font);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn query_font<'this>(
        &'this mut self,
        font: types::Fontable,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::QueryFontReply>> {
        let span = tracing::info_span!(
            "query_font",
            font = ?font,
        );
        let request = types::xproto::QueryFontRequest { font };
        self.send_reply_request(request).instrument(span)
    }
    fn query_font_immediate<'this>(
        &'this mut self,
        font: types::Fontable,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::QueryFontReply>> {
        let cookie = self.query_font(font);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryFontReply> =
            cookie.into();
        res.instrument(span)
    }
    fn query_text_extents<'this>(
        &'this mut self,
        font: types::Fontable,
        string: impl AsRef<[types::Char2b]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::QueryTextExtentsReply>> {
        let span = tracing::info_span!(
            "query_text_extents",
            font = ?font,
        );
        let request = types::xproto::QueryTextExtentsRequest {
            font,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    fn query_text_extents_immediate<'this>(
        &'this mut self,
        font: types::Fontable,
        string: impl AsRef<[types::Char2b]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::QueryTextExtentsReply>>
    {
        let cookie = self.query_text_extents(font, string);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryTextExtentsReply> =
            cookie.into();
        res.instrument(span)
    }
    fn list_fonts<'this>(
        &'this mut self,
        max_names: types::Card16,
        pattern: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::ListFontsReply>> {
        let span = tracing::info_span!(
            "list_fonts",
            max_names = ?max_names,
        );
        let request = types::xproto::ListFontsRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    fn list_fonts_immediate<'this>(
        &'this mut self,
        max_names: types::Card16,
        pattern: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::ListFontsReply>> {
        let cookie = self.list_fonts(max_names, pattern);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::ListFontsReply> =
            cookie.into();
        res.instrument(span)
    }
    fn list_fonts_with_info<'this>(
        &'this mut self,
        max_names: types::Card16,
        pattern: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::ListFontsWithInfoReply>>
    {
        let span = tracing::info_span!(
            "list_fonts_with_info",
            max_names = ?max_names,
        );
        let request = types::xproto::ListFontsWithInfoRequest {
            max_names,
            pattern: Cow::Borrowed(pattern.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    fn list_fonts_with_info_immediate<'this>(
        &'this mut self,
        max_names: types::Card16,
        pattern: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::ListFontsWithInfoReply>>
    {
        let cookie = self.list_fonts_with_info(max_names, pattern);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::ListFontsWithInfoReply> =
            cookie.into();
        res.instrument(span)
    }
    fn set_font_path<'this>(
        &'this mut self,
        font: impl AsRef<[types::Str]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("set_font_path",);
        let request = types::xproto::SetFontPathRequest {
            font: Cow::Borrowed(font.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn set_font_path_checked<'this>(
        &'this mut self,
        font: impl AsRef<[types::Str]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.set_font_path(font);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn get_font_path<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetFontPathReply>> {
        let span = tracing::info_span!("get_font_path",);
        let request = types::xproto::GetFontPathRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn get_font_path_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GetFontPathReply>>
    {
        let cookie = self.get_font_path();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetFontPathReply> =
            cookie.into();
        res.instrument(span)
    }
    fn create_pixmap<'this>(
        &'this mut self,
        depth: types::Card8,
        pid: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "create_pixmap",
            depth = ?depth,
            pid = ?pid,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
        );
        let request = types::xproto::CreatePixmapRequest {
            depth,
            pid,
            drawable,
            width,
            height,
        };
        self.send_void_request(request).instrument(span)
    }
    fn create_pixmap_checked<'this>(
        &'this mut self,
        depth: types::Card8,
        pid: types::xproto::Pixmap,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.create_pixmap(depth, pid, drawable, width, height);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn free_pixmap<'this>(
        &'this mut self,
        pixmap: types::xproto::Pixmap,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "free_pixmap",
            pixmap = ?pixmap,
        );
        let request = types::xproto::FreePixmapRequest { pixmap };
        self.send_void_request(request).instrument(span)
    }
    fn free_pixmap_checked<'this>(
        &'this mut self,
        pixmap: types::xproto::Pixmap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.free_pixmap(pixmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn create_gc<'this>(
        &'this mut self,
        cid: types::Gcontext,
        drawable: types::xproto::Drawable,
        value_list: impl Borrow<types::xproto::CreateGCAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "create_gc",
            cid = ?cid,
            drawable = ?drawable,
        );
        let request = types::xproto::CreateGCRequest {
            cid,
            drawable,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn create_gc_checked<'this>(
        &'this mut self,
        cid: types::Gcontext,
        drawable: types::xproto::Drawable,
        value_list: impl Borrow<types::xproto::CreateGCAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.create_gc(cid, drawable, value_list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn change_gc<'this>(
        &'this mut self,
        gc: types::Gcontext,
        value_list: impl Borrow<types::xproto::ChangeGCAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "change_gc",
            gc = ?gc,
        );
        let request = types::xproto::ChangeGCRequest {
            gc,
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn change_gc_checked<'this>(
        &'this mut self,
        gc: types::Gcontext,
        value_list: impl Borrow<types::xproto::ChangeGCAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.change_gc(gc, value_list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn copy_gc<'this>(
        &'this mut self,
        src_gc: types::Gcontext,
        dst_gc: types::Gcontext,
        value_mask: impl Into<types::xproto::GC>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "copy_gc",
            src_gc = ?src_gc,
            dst_gc = ?dst_gc,
        );
        let request = types::xproto::CopyGCRequest {
            src_gc,
            dst_gc,
            value_mask: Into::<u32>::into(value_mask.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn copy_gc_checked<'this>(
        &'this mut self,
        src_gc: types::Gcontext,
        dst_gc: types::Gcontext,
        value_mask: impl Into<types::xproto::GC>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.copy_gc(src_gc, dst_gc, value_mask);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn set_dashes<'this>(
        &'this mut self,
        gc: types::Gcontext,
        dash_offset: types::Card16,
        dashes: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "set_dashes",
            gc = ?gc,
            dash_offset = ?dash_offset,
        );
        let request = types::xproto::SetDashesRequest {
            gc,
            dash_offset,
            dashes: Cow::Borrowed(dashes.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn set_dashes_checked<'this>(
        &'this mut self,
        gc: types::Gcontext,
        dash_offset: types::Card16,
        dashes: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.set_dashes(gc, dash_offset, dashes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn set_clip_rectangles<'this>(
        &'this mut self,
        ordering: types::ClipOrdering,
        gc: types::Gcontext,
        clip_x_origin: types::Int16,
        clip_y_origin: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "set_clip_rectangles",
            ordering = ?ordering,
            gc = ?gc,
            clip_x_origin = ?clip_x_origin,
            clip_y_origin = ?clip_y_origin,
        );
        let request = types::xproto::SetClipRectanglesRequest {
            ordering,
            gc,
            clip_x_origin,
            clip_y_origin,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn set_clip_rectangles_checked<'this>(
        &'this mut self,
        ordering: types::ClipOrdering,
        gc: types::Gcontext,
        clip_x_origin: types::Int16,
        clip_y_origin: types::Int16,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie =
            self.set_clip_rectangles(ordering, gc, clip_x_origin, clip_y_origin, rectangles);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn free_gc<'this>(
        &'this mut self,
        gc: types::Gcontext,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "free_gc",
            gc = ?gc,
        );
        let request = types::xproto::FreeGCRequest { gc };
        self.send_void_request(request).instrument(span)
    }
    fn free_gc_checked<'this>(
        &'this mut self,
        gc: types::Gcontext,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.free_gc(gc);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn clear_area<'this>(
        &'this mut self,
        exposures: types::Bool,
        window: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "clear_area",
            exposures = ?exposures,
            window = ?window,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
        );
        let request = types::xproto::ClearAreaRequest {
            exposures,
            window,
            x,
            y,
            width,
            height,
        };
        self.send_void_request(request).instrument(span)
    }
    fn clear_area_checked<'this>(
        &'this mut self,
        exposures: types::Bool,
        window: types::xproto::Window,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.clear_area(exposures, window, x, y, width, height);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn copy_area<'this>(
        &'this mut self,
        src_drawable: types::xproto::Drawable,
        dst_drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        src_x: types::Int16,
        src_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "copy_area",
            src_drawable = ?src_drawable,
            dst_drawable = ?dst_drawable,
            gc = ?gc,
            src_x = ?src_x,
            src_y = ?src_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
        );
        let request = types::xproto::CopyAreaRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
        };
        self.send_void_request(request).instrument(span)
    }
    fn copy_area_checked<'this>(
        &'this mut self,
        src_drawable: types::xproto::Drawable,
        dst_drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        src_x: types::Int16,
        src_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.copy_area(
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn copy_plane<'this>(
        &'this mut self,
        src_drawable: types::xproto::Drawable,
        dst_drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        src_x: types::Int16,
        src_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        bit_plane: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "copy_plane",
            src_drawable = ?src_drawable,
            dst_drawable = ?dst_drawable,
            gc = ?gc,
            src_x = ?src_x,
            src_y = ?src_y,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            width = ?width,
            height = ?height,
            bit_plane = ?bit_plane,
        );
        let request = types::xproto::CopyPlaneRequest {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
            bit_plane,
        };
        self.send_void_request(request).instrument(span)
    }
    fn copy_plane_checked<'this>(
        &'this mut self,
        src_drawable: types::xproto::Drawable,
        dst_drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        src_x: types::Int16,
        src_y: types::Int16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        bit_plane: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.copy_plane(
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
            bit_plane,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn poly_point<'this>(
        &'this mut self,
        coordinate_mode: types::CoordMode,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        points: impl AsRef<[types::Point]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "poly_point",
            coordinate_mode = ?coordinate_mode,
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyPointRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn poly_point_checked<'this>(
        &'this mut self,
        coordinate_mode: types::CoordMode,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        points: impl AsRef<[types::Point]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.poly_point(coordinate_mode, drawable, gc, points);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn poly_line<'this>(
        &'this mut self,
        coordinate_mode: types::CoordMode,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        points: impl AsRef<[types::Point]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "poly_line",
            coordinate_mode = ?coordinate_mode,
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyLineRequest {
            coordinate_mode,
            drawable,
            gc,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn poly_line_checked<'this>(
        &'this mut self,
        coordinate_mode: types::CoordMode,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        points: impl AsRef<[types::Point]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.poly_line(coordinate_mode, drawable, gc, points);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn poly_segment<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        segments: impl AsRef<[types::Segment]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "poly_segment",
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolySegmentRequest {
            drawable,
            gc,
            segments: Cow::Borrowed(segments.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn poly_segment_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        segments: impl AsRef<[types::Segment]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.poly_segment(drawable, gc, segments);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn poly_rectangle<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "poly_rectangle",
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn poly_rectangle_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.poly_rectangle(drawable, gc, rectangles);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn poly_arc<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        arcs: impl AsRef<[types::Arc]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "poly_arc",
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn poly_arc_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        arcs: impl AsRef<[types::Arc]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.poly_arc(drawable, gc, arcs);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn fill_poly<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        shape: types::PolyShape,
        coordinate_mode: types::CoordMode,
        points: impl AsRef<[types::Point]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "fill_poly",
            drawable = ?drawable,
            gc = ?gc,
            shape = ?shape,
            coordinate_mode = ?coordinate_mode,
        );
        let request = types::xproto::FillPolyRequest {
            drawable,
            gc,
            shape,
            coordinate_mode,
            points: Cow::Borrowed(points.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn fill_poly_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        shape: types::PolyShape,
        coordinate_mode: types::CoordMode,
        points: impl AsRef<[types::Point]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.fill_poly(drawable, gc, shape, coordinate_mode, points);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn poly_fill_rectangle<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "poly_fill_rectangle",
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyFillRectangleRequest {
            drawable,
            gc,
            rectangles: Cow::Borrowed(rectangles.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn poly_fill_rectangle_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        rectangles: impl AsRef<[types::Rectangle]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.poly_fill_rectangle(drawable, gc, rectangles);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn poly_fill_arc<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        arcs: impl AsRef<[types::Arc]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "poly_fill_arc",
            drawable = ?drawable,
            gc = ?gc,
        );
        let request = types::xproto::PolyFillArcRequest {
            drawable,
            gc,
            arcs: Cow::Borrowed(arcs.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn poly_fill_arc_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        arcs: impl AsRef<[types::Arc]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.poly_fill_arc(drawable, gc, arcs);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn put_image<'this>(
        &'this mut self,
        format: types::ImageFormat,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        width: types::Card16,
        height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        left_pad: types::Card8,
        depth: types::Card8,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "put_image",
            format = ?format,
            drawable = ?drawable,
            gc = ?gc,
            width = ?width,
            height = ?height,
            dst_x = ?dst_x,
            dst_y = ?dst_y,
            left_pad = ?left_pad,
            depth = ?depth,
        );
        let request = types::xproto::PutImageRequest {
            format,
            drawable,
            gc,
            width,
            height,
            dst_x,
            dst_y,
            left_pad,
            depth,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn put_image_checked<'this>(
        &'this mut self,
        format: types::ImageFormat,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        width: types::Card16,
        height: types::Card16,
        dst_x: types::Int16,
        dst_y: types::Int16,
        left_pad: types::Card8,
        depth: types::Card8,
        data: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.put_image(
            format, drawable, gc, width, height, dst_x, dst_y, left_pad, depth, data,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn get_image<'this>(
        &'this mut self,
        format: types::ImageFormat,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        plane_mask: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetImageReply>> {
        let span = tracing::info_span!(
            "get_image",
            format = ?format,
            drawable = ?drawable,
            x = ?x,
            y = ?y,
            width = ?width,
            height = ?height,
            plane_mask = ?plane_mask,
        );
        let request = types::xproto::GetImageRequest {
            format,
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn get_image_immediate<'this>(
        &'this mut self,
        format: types::ImageFormat,
        drawable: types::xproto::Drawable,
        x: types::Int16,
        y: types::Int16,
        width: types::Card16,
        height: types::Card16,
        plane_mask: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GetImageReply>> {
        let cookie = self.get_image(format, drawable, x, y, width, height, plane_mask);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetImageReply> =
            cookie.into();
        res.instrument(span)
    }
    fn poly_text8<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        items: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "poly_text8",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::PolyText8Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn poly_text8_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        items: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.poly_text8(drawable, gc, x, y, items);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn poly_text16<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        items: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "poly_text16",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::PolyText16Request {
            drawable,
            gc,
            x,
            y,
            items: Cow::Borrowed(items.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn poly_text16_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        items: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.poly_text16(drawable, gc, x, y, items);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn image_text8<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        string: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "image_text8",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::ImageText8Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn image_text8_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        string: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.image_text8(drawable, gc, x, y, string);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn image_text16<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        string: impl AsRef<[types::Char2b]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "image_text16",
            drawable = ?drawable,
            gc = ?gc,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::ImageText16Request {
            drawable,
            gc,
            x,
            y,
            string: Cow::Borrowed(string.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn image_text16_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        x: types::Int16,
        y: types::Int16,
        string: impl AsRef<[types::Char2b]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.image_text16(drawable, gc, x, y, string);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn create_colormap<'this>(
        &'this mut self,
        alloc: types::ColormapAlloc,
        mid: types::Colormap,
        window: types::xproto::Window,
        visual: types::Visualid,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "create_colormap",
            alloc = ?alloc,
            mid = ?mid,
            window = ?window,
            visual = ?visual,
        );
        let request = types::xproto::CreateColormapRequest {
            alloc,
            mid,
            window,
            visual,
        };
        self.send_void_request(request).instrument(span)
    }
    fn create_colormap_checked<'this>(
        &'this mut self,
        alloc: types::ColormapAlloc,
        mid: types::Colormap,
        window: types::xproto::Window,
        visual: types::Visualid,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.create_colormap(alloc, mid, window, visual);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn free_colormap<'this>(
        &'this mut self,
        cmap: types::Colormap,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "free_colormap",
            cmap = ?cmap,
        );
        let request = types::xproto::FreeColormapRequest { cmap };
        self.send_void_request(request).instrument(span)
    }
    fn free_colormap_checked<'this>(
        &'this mut self,
        cmap: types::Colormap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.free_colormap(cmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn copy_colormap_and_free<'this>(
        &'this mut self,
        mid: types::Colormap,
        src_cmap: types::Colormap,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "copy_colormap_and_free",
            mid = ?mid,
            src_cmap = ?src_cmap,
        );
        let request = types::xproto::CopyColormapAndFreeRequest { mid, src_cmap };
        self.send_void_request(request).instrument(span)
    }
    fn copy_colormap_and_free_checked<'this>(
        &'this mut self,
        mid: types::Colormap,
        src_cmap: types::Colormap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.copy_colormap_and_free(mid, src_cmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn install_colormap<'this>(
        &'this mut self,
        cmap: types::Colormap,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "install_colormap",
            cmap = ?cmap,
        );
        let request = types::xproto::InstallColormapRequest { cmap };
        self.send_void_request(request).instrument(span)
    }
    fn install_colormap_checked<'this>(
        &'this mut self,
        cmap: types::Colormap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.install_colormap(cmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn uninstall_colormap<'this>(
        &'this mut self,
        cmap: types::Colormap,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "uninstall_colormap",
            cmap = ?cmap,
        );
        let request = types::xproto::UninstallColormapRequest { cmap };
        self.send_void_request(request).instrument(span)
    }
    fn uninstall_colormap_checked<'this>(
        &'this mut self,
        cmap: types::Colormap,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.uninstall_colormap(cmap);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn list_installed_colormaps<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::ListInstalledColormapsReply>>
    {
        let span = tracing::info_span!(
            "list_installed_colormaps",
            window = ?window,
        );
        let request = types::xproto::ListInstalledColormapsRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    fn list_installed_colormaps_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xproto::ListInstalledColormapsReply>,
    > {
        let cookie = self.list_installed_colormaps(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xproto::ListInstalledColormapsReply,
        > = cookie.into();
        res.instrument(span)
    }
    fn alloc_color<'this>(
        &'this mut self,
        cmap: types::Colormap,
        red: types::Card16,
        green: types::Card16,
        blue: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::AllocColorReply>> {
        let span = tracing::info_span!(
            "alloc_color",
            cmap = ?cmap,
            red = ?red,
            green = ?green,
            blue = ?blue,
        );
        let request = types::xproto::AllocColorRequest {
            cmap,
            red,
            green,
            blue,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn alloc_color_immediate<'this>(
        &'this mut self,
        cmap: types::Colormap,
        red: types::Card16,
        green: types::Card16,
        blue: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorReply>>
    {
        let cookie = self.alloc_color(cmap, red, green, blue);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorReply> =
            cookie.into();
        res.instrument(span)
    }
    fn alloc_named_color<'this>(
        &'this mut self,
        cmap: types::Colormap,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::AllocNamedColorReply>> {
        let span = tracing::info_span!(
            "alloc_named_color",
            cmap = ?cmap,
        );
        let request = types::xproto::AllocNamedColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    fn alloc_named_color_immediate<'this>(
        &'this mut self,
        cmap: types::Colormap,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::AllocNamedColorReply>>
    {
        let cookie = self.alloc_named_color(cmap, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::AllocNamedColorReply> =
            cookie.into();
        res.instrument(span)
    }
    fn alloc_color_cells<'this>(
        &'this mut self,
        contiguous: types::Bool,
        cmap: types::Colormap,
        colors: types::Card16,
        planes: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::AllocColorCellsReply>> {
        let span = tracing::info_span!(
            "alloc_color_cells",
            contiguous = ?contiguous,
            cmap = ?cmap,
            colors = ?colors,
            planes = ?planes,
        );
        let request = types::xproto::AllocColorCellsRequest {
            contiguous,
            cmap,
            colors,
            planes,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn alloc_color_cells_immediate<'this>(
        &'this mut self,
        contiguous: types::Bool,
        cmap: types::Colormap,
        colors: types::Card16,
        planes: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorCellsReply>>
    {
        let cookie = self.alloc_color_cells(contiguous, cmap, colors, planes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorCellsReply> =
            cookie.into();
        res.instrument(span)
    }
    fn alloc_color_planes<'this>(
        &'this mut self,
        contiguous: types::Bool,
        cmap: types::Colormap,
        colors: types::Card16,
        reds: types::Card16,
        greens: types::Card16,
        blues: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::AllocColorPlanesReply>> {
        let span = tracing::info_span!(
            "alloc_color_planes",
            contiguous = ?contiguous,
            cmap = ?cmap,
            colors = ?colors,
            reds = ?reds,
            greens = ?greens,
            blues = ?blues,
        );
        let request = types::xproto::AllocColorPlanesRequest {
            contiguous,
            cmap,
            colors,
            reds,
            greens,
            blues,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn alloc_color_planes_immediate<'this>(
        &'this mut self,
        contiguous: types::Bool,
        cmap: types::Colormap,
        colors: types::Card16,
        reds: types::Card16,
        greens: types::Card16,
        blues: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorPlanesReply>>
    {
        let cookie = self.alloc_color_planes(contiguous, cmap, colors, reds, greens, blues);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::AllocColorPlanesReply> =
            cookie.into();
        res.instrument(span)
    }
    fn free_colors<'this>(
        &'this mut self,
        cmap: types::Colormap,
        plane_mask: types::Card32,
        pixels: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "free_colors",
            cmap = ?cmap,
            plane_mask = ?plane_mask,
        );
        let request = types::xproto::FreeColorsRequest {
            cmap,
            plane_mask,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn free_colors_checked<'this>(
        &'this mut self,
        cmap: types::Colormap,
        plane_mask: types::Card32,
        pixels: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.free_colors(cmap, plane_mask, pixels);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn store_colors<'this>(
        &'this mut self,
        cmap: types::Colormap,
        items: impl AsRef<[types::Coloritem]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "store_colors",
            cmap = ?cmap,
        );
        let request = types::xproto::StoreColorsRequest {
            cmap,
            items: Cow::Borrowed(items.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn store_colors_checked<'this>(
        &'this mut self,
        cmap: types::Colormap,
        items: impl AsRef<[types::Coloritem]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.store_colors(cmap, items);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn store_named_color<'this>(
        &'this mut self,
        flags: impl Into<types::ColorFlag>,
        cmap: types::Colormap,
        pixel: types::Card32,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "store_named_color",
            cmap = ?cmap,
            pixel = ?pixel,
        );
        let request = types::xproto::StoreNamedColorRequest {
            flags: Into::<u32>::into(flags.into()) as _,
            cmap,
            pixel,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn store_named_color_checked<'this>(
        &'this mut self,
        flags: impl Into<types::ColorFlag>,
        cmap: types::Colormap,
        pixel: types::Card32,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.store_named_color(flags, cmap, pixel, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn query_colors<'this>(
        &'this mut self,
        cmap: types::Colormap,
        pixels: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::QueryColorsReply>> {
        let span = tracing::info_span!(
            "query_colors",
            cmap = ?cmap,
        );
        let request = types::xproto::QueryColorsRequest {
            cmap,
            pixels: Cow::Borrowed(pixels.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    fn query_colors_immediate<'this>(
        &'this mut self,
        cmap: types::Colormap,
        pixels: impl AsRef<[types::Card32]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::QueryColorsReply>>
    {
        let cookie = self.query_colors(cmap, pixels);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryColorsReply> =
            cookie.into();
        res.instrument(span)
    }
    fn lookup_color<'this>(
        &'this mut self,
        cmap: types::Colormap,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::LookupColorReply>> {
        let span = tracing::info_span!(
            "lookup_color",
            cmap = ?cmap,
        );
        let request = types::xproto::LookupColorRequest {
            cmap,
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    fn lookup_color_immediate<'this>(
        &'this mut self,
        cmap: types::Colormap,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::LookupColorReply>>
    {
        let cookie = self.lookup_color(cmap, name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::LookupColorReply> =
            cookie.into();
        res.instrument(span)
    }
    fn create_cursor<'this>(
        &'this mut self,
        cid: types::xproto::Cursor,
        source: types::xproto::Pixmap,
        mask: impl Into<types::xproto::Pixmap>,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
        x: types::Card16,
        y: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "create_cursor",
            cid = ?cid,
            source = ?source,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
            x = ?x,
            y = ?y,
        );
        let request = types::xproto::CreateCursorRequest {
            cid,
            source,
            mask: Into::<u32>::into(mask.into()) as _,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
            x,
            y,
        };
        self.send_void_request(request).instrument(span)
    }
    fn create_cursor_checked<'this>(
        &'this mut self,
        cid: types::xproto::Cursor,
        source: types::xproto::Pixmap,
        mask: impl Into<types::xproto::Pixmap>,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
        x: types::Card16,
        y: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.create_cursor(
            cid, source, mask, fore_red, fore_green, fore_blue, back_red, back_green, back_blue, x,
            y,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn create_glyph_cursor<'this>(
        &'this mut self,
        cid: types::xproto::Cursor,
        source_font: types::Font,
        mask_font: impl Into<types::Font>,
        source_char: types::Card16,
        mask_char: types::Card16,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "create_glyph_cursor",
            cid = ?cid,
            source_font = ?source_font,
            source_char = ?source_char,
            mask_char = ?mask_char,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
        );
        let request = types::xproto::CreateGlyphCursorRequest {
            cid,
            source_font,
            mask_font: Into::<u32>::into(mask_font.into()) as _,
            source_char,
            mask_char,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        self.send_void_request(request).instrument(span)
    }
    fn create_glyph_cursor_checked<'this>(
        &'this mut self,
        cid: types::xproto::Cursor,
        source_font: types::Font,
        mask_font: impl Into<types::Font>,
        source_char: types::Card16,
        mask_char: types::Card16,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.create_glyph_cursor(
            cid,
            source_font,
            mask_font,
            source_char,
            mask_char,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn free_cursor<'this>(
        &'this mut self,
        cursor: types::xproto::Cursor,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "free_cursor",
            cursor = ?cursor,
        );
        let request = types::xproto::FreeCursorRequest { cursor };
        self.send_void_request(request).instrument(span)
    }
    fn free_cursor_checked<'this>(
        &'this mut self,
        cursor: types::xproto::Cursor,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.free_cursor(cursor);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn recolor_cursor<'this>(
        &'this mut self,
        cursor: types::xproto::Cursor,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "recolor_cursor",
            cursor = ?cursor,
            fore_red = ?fore_red,
            fore_green = ?fore_green,
            fore_blue = ?fore_blue,
            back_red = ?back_red,
            back_green = ?back_green,
            back_blue = ?back_blue,
        );
        let request = types::xproto::RecolorCursorRequest {
            cursor,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        };
        self.send_void_request(request).instrument(span)
    }
    fn recolor_cursor_checked<'this>(
        &'this mut self,
        cursor: types::xproto::Cursor,
        fore_red: types::Card16,
        fore_green: types::Card16,
        fore_blue: types::Card16,
        back_red: types::Card16,
        back_green: types::Card16,
        back_blue: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.recolor_cursor(
            cursor, fore_red, fore_green, fore_blue, back_red, back_green, back_blue,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn query_best_size<'this>(
        &'this mut self,
        class: types::QueryShapeOf,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::QueryBestSizeReply>> {
        let span = tracing::info_span!(
            "query_best_size",
            class = ?class,
            drawable = ?drawable,
            width = ?width,
            height = ?height,
        );
        let request = types::xproto::QueryBestSizeRequest {
            class,
            drawable,
            width,
            height,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn query_best_size_immediate<'this>(
        &'this mut self,
        class: types::QueryShapeOf,
        drawable: types::xproto::Drawable,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::QueryBestSizeReply>>
    {
        let cookie = self.query_best_size(class, drawable, width, height);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryBestSizeReply> =
            cookie.into();
        res.instrument(span)
    }
    fn query_extension<'this>(
        &'this mut self,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::QueryExtensionReply>> {
        let span = tracing::info_span!("query_extension",);
        let request = types::xproto::QueryExtensionRequest {
            name: Cow::Borrowed(name.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    fn query_extension_immediate<'this>(
        &'this mut self,
        name: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::QueryExtensionReply>>
    {
        let cookie = self.query_extension(name);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::QueryExtensionReply> =
            cookie.into();
        res.instrument(span)
    }
    fn list_extensions<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::ListExtensionsReply>> {
        let span = tracing::info_span!("list_extensions",);
        let request = types::xproto::ListExtensionsRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn list_extensions_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::ListExtensionsReply>>
    {
        let cookie = self.list_extensions();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::ListExtensionsReply> =
            cookie.into();
        res.instrument(span)
    }
    fn change_keyboard_mapping<'this>(
        &'this mut self,
        keycode_count: types::Card8,
        first_keycode: types::Keycode,
        keysyms_per_keycode: types::Card8,
        keysyms: impl AsRef<[types::Keysym]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "change_keyboard_mapping",
            keycode_count = ?keycode_count,
            first_keycode = ?first_keycode,
            keysyms_per_keycode = ?keysyms_per_keycode,
        );
        let request = types::xproto::ChangeKeyboardMappingRequest {
            keycode_count,
            first_keycode,
            keysyms_per_keycode,
            keysyms: Cow::Borrowed(keysyms.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn change_keyboard_mapping_checked<'this>(
        &'this mut self,
        keycode_count: types::Card8,
        first_keycode: types::Keycode,
        keysyms_per_keycode: types::Card8,
        keysyms: impl AsRef<[types::Keysym]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.change_keyboard_mapping(
            keycode_count,
            first_keycode,
            keysyms_per_keycode,
            keysyms,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn get_keyboard_mapping<'this>(
        &'this mut self,
        first_keycode: types::Keycode,
        count: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetKeyboardMappingReply>>
    {
        let span = tracing::info_span!(
            "get_keyboard_mapping",
            first_keycode = ?first_keycode,
            count = ?count,
        );
        let request = types::xproto::GetKeyboardMappingRequest {
            first_keycode,
            count,
        };
        self.send_reply_request(request).instrument(span)
    }
    fn get_keyboard_mapping_immediate<'this>(
        &'this mut self,
        first_keycode: types::Keycode,
        count: types::Card8,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xproto::GetKeyboardMappingReply>,
    > {
        let cookie = self.get_keyboard_mapping(first_keycode, count);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetKeyboardMappingReply> =
            cookie.into();
        res.instrument(span)
    }
    fn change_keyboard_control<'this>(
        &'this mut self,
        value_list: impl Borrow<types::xproto::ChangeKeyboardControlAux>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("change_keyboard_control",);
        let request = types::xproto::ChangeKeyboardControlRequest {
            value_list: Cow::Borrowed(value_list.borrow()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn change_keyboard_control_checked<'this>(
        &'this mut self,
        value_list: impl Borrow<types::xproto::ChangeKeyboardControlAux>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.change_keyboard_control(value_list);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn get_keyboard_control<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetKeyboardControlReply>>
    {
        let span = tracing::info_span!("get_keyboard_control",);
        let request = types::xproto::GetKeyboardControlRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn get_keyboard_control_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xproto::GetKeyboardControlReply>,
    > {
        let cookie = self.get_keyboard_control();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetKeyboardControlReply> =
            cookie.into();
        res.instrument(span)
    }
    fn bell<'this>(
        &'this mut self,
        percent: types::Int8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "bell",
            percent = ?percent,
        );
        let request = types::xproto::BellRequest { percent };
        self.send_void_request(request).instrument(span)
    }
    fn bell_checked<'this>(
        &'this mut self,
        percent: types::Int8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.bell(percent);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn change_pointer_control<'this>(
        &'this mut self,
        acceleration_numerator: types::Int16,
        acceleration_denominator: types::Int16,
        threshold: types::Int16,
        do_acceleration: types::Bool,
        do_threshold: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "change_pointer_control",
            acceleration_numerator = ?acceleration_numerator,
            acceleration_denominator = ?acceleration_denominator,
            threshold = ?threshold,
            do_acceleration = ?do_acceleration,
            do_threshold = ?do_threshold,
        );
        let request = types::xproto::ChangePointerControlRequest {
            acceleration_numerator,
            acceleration_denominator,
            threshold,
            do_acceleration,
            do_threshold,
        };
        self.send_void_request(request).instrument(span)
    }
    fn change_pointer_control_checked<'this>(
        &'this mut self,
        acceleration_numerator: types::Int16,
        acceleration_denominator: types::Int16,
        threshold: types::Int16,
        do_acceleration: types::Bool,
        do_threshold: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.change_pointer_control(
            acceleration_numerator,
            acceleration_denominator,
            threshold,
            do_acceleration,
            do_threshold,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn get_pointer_control<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetPointerControlReply>>
    {
        let span = tracing::info_span!("get_pointer_control",);
        let request = types::xproto::GetPointerControlRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn get_pointer_control_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GetPointerControlReply>>
    {
        let cookie = self.get_pointer_control();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetPointerControlReply> =
            cookie.into();
        res.instrument(span)
    }
    fn set_screen_saver<'this>(
        &'this mut self,
        timeout: types::Int16,
        interval: types::Int16,
        prefer_blanking: types::Blanking,
        allow_exposures: types::Exposures,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "set_screen_saver",
            timeout = ?timeout,
            interval = ?interval,
            prefer_blanking = ?prefer_blanking,
            allow_exposures = ?allow_exposures,
        );
        let request = types::xproto::SetScreenSaverRequest {
            timeout,
            interval,
            prefer_blanking,
            allow_exposures,
        };
        self.send_void_request(request).instrument(span)
    }
    fn set_screen_saver_checked<'this>(
        &'this mut self,
        timeout: types::Int16,
        interval: types::Int16,
        prefer_blanking: types::Blanking,
        allow_exposures: types::Exposures,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.set_screen_saver(timeout, interval, prefer_blanking, allow_exposures);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn get_screen_saver<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetScreenSaverReply>> {
        let span = tracing::info_span!("get_screen_saver",);
        let request = types::xproto::GetScreenSaverRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn get_screen_saver_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GetScreenSaverReply>>
    {
        let cookie = self.get_screen_saver();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetScreenSaverReply> =
            cookie.into();
        res.instrument(span)
    }
    fn change_hosts<'this>(
        &'this mut self,
        mode: types::HostMode,
        family: types::Family,
        address: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "change_hosts",
            mode = ?mode,
            family = ?family,
        );
        let request = types::xproto::ChangeHostsRequest {
            mode,
            family,
            address: Cow::Borrowed(address.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn change_hosts_checked<'this>(
        &'this mut self,
        mode: types::HostMode,
        family: types::Family,
        address: impl AsRef<[types::Byte]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.change_hosts(mode, family, address);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn list_hosts<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::ListHostsReply>> {
        let span = tracing::info_span!("list_hosts",);
        let request = types::xproto::ListHostsRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn list_hosts_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::ListHostsReply>> {
        let cookie = self.list_hosts();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::ListHostsReply> =
            cookie.into();
        res.instrument(span)
    }
    fn set_access_control<'this>(
        &'this mut self,
        mode: types::AccessControl,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "set_access_control",
            mode = ?mode,
        );
        let request = types::xproto::SetAccessControlRequest { mode };
        self.send_void_request(request).instrument(span)
    }
    fn set_access_control_checked<'this>(
        &'this mut self,
        mode: types::AccessControl,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.set_access_control(mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn set_close_down_mode<'this>(
        &'this mut self,
        mode: types::CloseDown,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "set_close_down_mode",
            mode = ?mode,
        );
        let request = types::xproto::SetCloseDownModeRequest { mode };
        self.send_void_request(request).instrument(span)
    }
    fn set_close_down_mode_checked<'this>(
        &'this mut self,
        mode: types::CloseDown,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.set_close_down_mode(mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn kill_client<'this>(
        &'this mut self,
        resource: impl Into<types::Kill>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("kill_client",);
        let request = types::xproto::KillClientRequest {
            resource: Into::<u32>::into(resource.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    fn kill_client_checked<'this>(
        &'this mut self,
        resource: impl Into<types::Kill>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.kill_client(resource);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn rotate_properties<'this>(
        &'this mut self,
        window: types::xproto::Window,
        delta: types::Int16,
        atoms: impl AsRef<[types::Atom]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "rotate_properties",
            window = ?window,
            delta = ?delta,
        );
        let request = types::xproto::RotatePropertiesRequest {
            window,
            delta,
            atoms: Cow::Borrowed(atoms.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    fn rotate_properties_checked<'this>(
        &'this mut self,
        window: types::xproto::Window,
        delta: types::Int16,
        atoms: impl AsRef<[types::Atom]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.rotate_properties(window, delta, atoms);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn force_screen_saver<'this>(
        &'this mut self,
        mode: types::ScreenSaver,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "force_screen_saver",
            mode = ?mode,
        );
        let request = types::xproto::ForceScreenSaverRequest { mode };
        self.send_void_request(request).instrument(span)
    }
    fn force_screen_saver_checked<'this>(
        &'this mut self,
        mode: types::ScreenSaver,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.force_screen_saver(mode);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    fn set_pointer_mapping<'this>(
        &'this mut self,
        map: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::SetPointerMappingReply>>
    {
        let span = tracing::info_span!("set_pointer_mapping",);
        let request = types::xproto::SetPointerMappingRequest {
            map: Cow::Borrowed(map.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    fn set_pointer_mapping_immediate<'this>(
        &'this mut self,
        map: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::SetPointerMappingReply>>
    {
        let cookie = self.set_pointer_mapping(map);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::SetPointerMappingReply> =
            cookie.into();
        res.instrument(span)
    }
    fn get_pointer_mapping<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetPointerMappingReply>>
    {
        let span = tracing::info_span!("get_pointer_mapping",);
        let request = types::xproto::GetPointerMappingRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn get_pointer_mapping_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xproto::GetPointerMappingReply>>
    {
        let cookie = self.get_pointer_mapping();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetPointerMappingReply> =
            cookie.into();
        res.instrument(span)
    }
    fn set_modifier_mapping<'this>(
        &'this mut self,
        keycodes: impl AsRef<[types::Keycode]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::SetModifierMappingReply>>
    {
        let span = tracing::info_span!("set_modifier_mapping",);
        let request = types::xproto::SetModifierMappingRequest {
            keycodes: Cow::Borrowed(keycodes.as_ref()),
        };
        self.send_reply_request(request).instrument(span)
    }
    fn set_modifier_mapping_immediate<'this>(
        &'this mut self,
        keycodes: impl AsRef<[types::Keycode]>,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xproto::SetModifierMappingReply>,
    > {
        let cookie = self.set_modifier_mapping(keycodes);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::SetModifierMappingReply> =
            cookie.into();
        res.instrument(span)
    }
    fn get_modifier_mapping<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xproto::GetModifierMappingReply>>
    {
        let span = tracing::info_span!("get_modifier_mapping",);
        let request = types::xproto::GetModifierMappingRequest {};
        self.send_reply_request(request).instrument(span)
    }
    fn get_modifier_mapping_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xproto::GetModifierMappingReply>,
    > {
        let cookie = self.get_modifier_mapping();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xproto::GetModifierMappingReply> =
            cookie.into();
        res.instrument(span)
    }
    fn no_operation<'this>(&'this mut self) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("no_operation",);
        let request = types::xproto::NoOperationRequest {};
        self.send_void_request(request).instrument(span)
    }
    fn no_operation_checked<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.no_operation();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xselinux")]
    fn xselinux_query_version<'this>(
        &'this mut self,
        client_major: types::Card8,
        client_minor: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::QueryVersionReply>> {
        let span = tracing::info_span!(
            "xselinux_query_version",
            client_major = ?client_major,
            client_minor = ?client_minor,
        );
        let request = types::xselinux::QueryVersionRequest {
            client_major,
            client_minor,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_query_version_immediate<'this>(
        &'this mut self,
        client_major: types::Card8,
        client_minor: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xselinux::QueryVersionReply>>
    {
        let cookie = self.xselinux_query_version(client_major, client_minor);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_create_context<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("xselinux_set_device_create_context",);
        let request = types::xselinux::SetDeviceCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_create_context_checked<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xselinux_set_device_create_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_create_context<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::GetDeviceCreateContextReply>>
    {
        let span = tracing::info_span!("xselinux_get_device_create_context",);
        let request = types::xselinux::GetDeviceCreateContextRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_create_context_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetDeviceCreateContextReply>,
    > {
        let cookie = self.xselinux_get_device_create_context();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xselinux::GetDeviceCreateContextReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_context<'this>(
        &'this mut self,
        device: types::Card32,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xselinux_set_device_context",
            device = ?device,
        );
        let request = types::xselinux::SetDeviceContextRequest {
            device,
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_device_context_checked<'this>(
        &'this mut self,
        device: types::Card32,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xselinux_set_device_context(device, context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_context<'this>(
        &'this mut self,
        device: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::GetDeviceContextReply>>
    {
        let span = tracing::info_span!(
            "xselinux_get_device_context",
            device = ?device,
        );
        let request = types::xselinux::GetDeviceContextRequest { device };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_device_context_immediate<'this>(
        &'this mut self,
        device: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetDeviceContextReply>,
    > {
        let cookie = self.xselinux_get_device_context(device);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetDeviceContextReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_window_create_context<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("xselinux_set_window_create_context",);
        let request = types::xselinux::SetWindowCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_window_create_context_checked<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xselinux_set_window_create_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_create_context<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::GetWindowCreateContextReply>>
    {
        let span = tracing::info_span!("xselinux_get_window_create_context",);
        let request = types::xselinux::GetWindowCreateContextRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_create_context_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetWindowCreateContextReply>,
    > {
        let cookie = self.xselinux_get_window_create_context();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xselinux::GetWindowCreateContextReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_context<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::GetWindowContextReply>>
    {
        let span = tracing::info_span!(
            "xselinux_get_window_context",
            window = ?window,
        );
        let request = types::xselinux::GetWindowContextRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_window_context_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetWindowContextReply>,
    > {
        let cookie = self.xselinux_get_window_context(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetWindowContextReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_create_context<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("xselinux_set_property_create_context",);
        let request = types::xselinux::SetPropertyCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_create_context_checked<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xselinux_set_property_create_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_create_context<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::SendRequest<'this, Self, types::xselinux::GetPropertyCreateContextReply>,
    > {
        let span = tracing::info_span!("xselinux_get_property_create_context",);
        let request = types::xselinux::GetPropertyCreateContextRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_create_context_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyCreateContextReply>,
    > {
        let cookie = self.xselinux_get_property_create_context();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xselinux::GetPropertyCreateContextReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_use_context<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("xselinux_set_property_use_context",);
        let request = types::xselinux::SetPropertyUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_property_use_context_checked<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xselinux_set_property_use_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_use_context<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::GetPropertyUseContextReply>>
    {
        let span = tracing::info_span!("xselinux_get_property_use_context",);
        let request = types::xselinux::GetPropertyUseContextRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_use_context_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyUseContextReply>,
    > {
        let cookie = self.xselinux_get_property_use_context();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xselinux::GetPropertyUseContextReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_context<'this>(
        &'this mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::GetPropertyContextReply>>
    {
        let span = tracing::info_span!(
            "xselinux_get_property_context",
            window = ?window,
            property = ?property,
        );
        let request = types::xselinux::GetPropertyContextRequest { window, property };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_context_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyContextReply>,
    > {
        let cookie = self.xselinux_get_property_context(window, property);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xselinux::GetPropertyContextReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_data_context<'this>(
        &'this mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::GetPropertyDataContextReply>>
    {
        let span = tracing::info_span!(
            "xselinux_get_property_data_context",
            window = ?window,
            property = ?property,
        );
        let request = types::xselinux::GetPropertyDataContextRequest { window, property };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_property_data_context_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        property: types::Atom,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetPropertyDataContextReply>,
    > {
        let cookie = self.xselinux_get_property_data_context(window, property);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xselinux::GetPropertyDataContextReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_properties<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::ListPropertiesReply>> {
        let span = tracing::info_span!(
            "xselinux_list_properties",
            window = ?window,
        );
        let request = types::xselinux::ListPropertiesRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_properties_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xselinux::ListPropertiesReply>>
    {
        let cookie = self.xselinux_list_properties(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::ListPropertiesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_create_context<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("xselinux_set_selection_create_context",);
        let request = types::xselinux::SetSelectionCreateContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_create_context_checked<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xselinux_set_selection_create_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_create_context<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::SendRequest<'this, Self, types::xselinux::GetSelectionCreateContextReply>,
    > {
        let span = tracing::info_span!("xselinux_get_selection_create_context",);
        let request = types::xselinux::GetSelectionCreateContextRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_create_context_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionCreateContextReply>,
    > {
        let cookie = self.xselinux_get_selection_create_context();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xselinux::GetSelectionCreateContextReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_use_context<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!("xselinux_set_selection_use_context",);
        let request = types::xselinux::SetSelectionUseContextRequest {
            context: Cow::Borrowed(context.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_set_selection_use_context_checked<'this>(
        &'this mut self,
        context: impl AsRef<[types::Char]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xselinux_set_selection_use_context(context);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_use_context<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::GetSelectionUseContextReply>>
    {
        let span = tracing::info_span!("xselinux_get_selection_use_context",);
        let request = types::xselinux::GetSelectionUseContextRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_use_context_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionUseContextReply>,
    > {
        let cookie = self.xselinux_get_selection_use_context();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xselinux::GetSelectionUseContextReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_context<'this>(
        &'this mut self,
        selection: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::GetSelectionContextReply>>
    {
        let span = tracing::info_span!(
            "xselinux_get_selection_context",
            selection = ?selection,
        );
        let request = types::xselinux::GetSelectionContextRequest { selection };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_context_immediate<'this>(
        &'this mut self,
        selection: types::Atom,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionContextReply>,
    > {
        let cookie = self.xselinux_get_selection_context(selection);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xselinux::GetSelectionContextReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_data_context<'this>(
        &'this mut self,
        selection: types::Atom,
    ) -> Instrumented<
        futures::SendRequest<'this, Self, types::xselinux::GetSelectionDataContextReply>,
    > {
        let span = tracing::info_span!(
            "xselinux_get_selection_data_context",
            selection = ?selection,
        );
        let request = types::xselinux::GetSelectionDataContextRequest { selection };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_selection_data_context_immediate<'this>(
        &'this mut self,
        selection: types::Atom,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetSelectionDataContextReply>,
    > {
        let cookie = self.xselinux_get_selection_data_context(selection);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<
            'this,
            Self,
            types::xselinux::GetSelectionDataContextReply,
        > = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_selections<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::ListSelectionsReply>> {
        let span = tracing::info_span!("xselinux_list_selections",);
        let request = types::xselinux::ListSelectionsRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_list_selections_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xselinux::ListSelectionsReply>>
    {
        let cookie = self.xselinux_list_selections();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::ListSelectionsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_client_context<'this>(
        &'this mut self,
        resource: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xselinux::GetClientContextReply>>
    {
        let span = tracing::info_span!(
            "xselinux_get_client_context",
            resource = ?resource,
        );
        let request = types::xselinux::GetClientContextRequest { resource };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xselinux")]
    fn xselinux_get_client_context_immediate<'this>(
        &'this mut self,
        resource: types::Card32,
    ) -> Instrumented<
        futures::CheckedSendRequest<'this, Self, types::xselinux::GetClientContextReply>,
    > {
        let cookie = self.xselinux_get_client_context(resource);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xselinux::GetClientContextReply> =
            cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xtest")]
    fn xtest_get_version<'this>(
        &'this mut self,
        major_version: types::Card8,
        minor_version: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xtest::GetVersionReply>> {
        let span = tracing::info_span!(
            "xtest_get_version",
            major_version = ?major_version,
            minor_version = ?minor_version,
        );
        let request = types::xtest::GetVersionRequest {
            major_version,
            minor_version,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xtest")]
    fn xtest_get_version_immediate<'this>(
        &'this mut self,
        major_version: types::Card8,
        minor_version: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xtest::GetVersionReply>> {
        let cookie = self.xtest_get_version(major_version, minor_version);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xtest::GetVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xtest")]
    fn xtest_compare_cursor<'this>(
        &'this mut self,
        window: types::xproto::Window,
        cursor: types::xproto::Cursor,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xtest::CompareCursorReply>> {
        let span = tracing::info_span!(
            "xtest_compare_cursor",
            window = ?window,
            cursor = ?cursor,
        );
        let request = types::xtest::CompareCursorRequest { window, cursor };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xtest")]
    fn xtest_compare_cursor_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
        cursor: types::xproto::Cursor,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xtest::CompareCursorReply>>
    {
        let cookie = self.xtest_compare_cursor(window, cursor);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xtest::CompareCursorReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xtest")]
    fn xtest_fake_input<'this>(
        &'this mut self,
        type_: types::Byte,
        detail: types::Byte,
        time: types::Card32,
        root: types::xproto::Window,
        root_x: types::Int16,
        root_y: types::Int16,
        deviceid: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xtest_fake_input",
            type_ = ?type_,
            detail = ?detail,
            time = ?time,
            root = ?root,
            root_x = ?root_x,
            root_y = ?root_y,
            deviceid = ?deviceid,
        );
        let request = types::xtest::FakeInputRequest {
            type_,
            detail,
            time,
            root,
            root_x,
            root_y,
            deviceid,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xtest")]
    fn xtest_fake_input_checked<'this>(
        &'this mut self,
        type_: types::Byte,
        detail: types::Byte,
        time: types::Card32,
        root: types::xproto::Window,
        root_x: types::Int16,
        root_y: types::Int16,
        deviceid: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xtest_fake_input(type_, detail, time, root, root_x, root_y, deviceid);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xtest")]
    fn xtest_grab_control<'this>(
        &'this mut self,
        impervious: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xtest_grab_control",
            impervious = ?impervious,
        );
        let request = types::xtest::GrabControlRequest { impervious };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xtest")]
    fn xtest_grab_control_checked<'this>(
        &'this mut self,
        impervious: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xtest_grab_control(impervious);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xv")]
    fn xv_query_extension<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xv::QueryExtensionReply>> {
        let span = tracing::info_span!("xv_query_extension",);
        let request = types::xv::QueryExtensionRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_query_extension_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xv::QueryExtensionReply>>
    {
        let cookie = self.xv_query_extension();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryExtensionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_query_adaptors<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xv::QueryAdaptorsReply>> {
        let span = tracing::info_span!(
            "xv_query_adaptors",
            window = ?window,
        );
        let request = types::xv::QueryAdaptorsRequest { window };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_query_adaptors_immediate<'this>(
        &'this mut self,
        window: types::xproto::Window,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xv::QueryAdaptorsReply>> {
        let cookie = self.xv_query_adaptors(window);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryAdaptorsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_query_encodings<'this>(
        &'this mut self,
        port: types::Port,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xv::QueryEncodingsReply>> {
        let span = tracing::info_span!(
            "xv_query_encodings",
            port = ?port,
        );
        let request = types::xv::QueryEncodingsRequest { port };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_query_encodings_immediate<'this>(
        &'this mut self,
        port: types::Port,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xv::QueryEncodingsReply>>
    {
        let cookie = self.xv_query_encodings(port);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryEncodingsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_grab_port<'this>(
        &'this mut self,
        port: types::Port,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xv::GrabPortReply>> {
        let span = tracing::info_span!(
            "xv_grab_port",
            port = ?port,
        );
        let request = types::xv::GrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_grab_port_immediate<'this>(
        &'this mut self,
        port: types::Port,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xv::GrabPortReply>> {
        let cookie = self.xv_grab_port(port, time);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xv::GrabPortReply> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_ungrab_port<'this>(
        &'this mut self,
        port: types::Port,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xv_ungrab_port",
            port = ?port,
        );
        let request = types::xv::UngrabPortRequest {
            port,
            time: Into::<u32>::into(time.into()) as _,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_ungrab_port_checked<'this>(
        &'this mut self,
        port: types::Port,
        time: impl Into<types::Time>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xv_ungrab_port(port, time);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_put_video<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xv_put_video",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let request = types::xv::PutVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_put_video_checked<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xv_put_video(
            port, drawable, gc, vid_x, vid_y, vid_w, vid_h, drw_x, drw_y, drw_w, drw_h,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_put_still<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xv_put_still",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let request = types::xv::PutStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_put_still_checked<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xv_put_still(
            port, drawable, gc, vid_x, vid_y, vid_w, vid_h, drw_x, drw_y, drw_w, drw_h,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_get_video<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xv_get_video",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let request = types::xv::GetVideoRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_get_video_checked<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xv_get_video(
            port, drawable, gc, vid_x, vid_y, vid_w, vid_h, drw_x, drw_y, drw_w, drw_h,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_get_still<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xv_get_still",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            vid_x = ?vid_x,
            vid_y = ?vid_y,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
        );
        let request = types::xv::GetStillRequest {
            port,
            drawable,
            gc,
            vid_x,
            vid_y,
            vid_w,
            vid_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_get_still_checked<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        vid_x: types::Int16,
        vid_y: types::Int16,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xv_get_still(
            port, drawable, gc, vid_x, vid_y, vid_w, vid_h, drw_x, drw_y, drw_w, drw_h,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_stop_video<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xv_stop_video",
            port = ?port,
            drawable = ?drawable,
        );
        let request = types::xv::StopVideoRequest { port, drawable };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_stop_video_checked<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xv_stop_video(port, drawable);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_select_video_notify<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        onoff: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xv_select_video_notify",
            drawable = ?drawable,
            onoff = ?onoff,
        );
        let request = types::xv::SelectVideoNotifyRequest { drawable, onoff };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_select_video_notify_checked<'this>(
        &'this mut self,
        drawable: types::xproto::Drawable,
        onoff: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xv_select_video_notify(drawable, onoff);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_select_port_notify<'this>(
        &'this mut self,
        port: types::Port,
        onoff: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xv_select_port_notify",
            port = ?port,
            onoff = ?onoff,
        );
        let request = types::xv::SelectPortNotifyRequest { port, onoff };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_select_port_notify_checked<'this>(
        &'this mut self,
        port: types::Port,
        onoff: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xv_select_port_notify(port, onoff);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_query_best_size<'this>(
        &'this mut self,
        port: types::Port,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        motion: types::Bool,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xv::QueryBestSizeReply>> {
        let span = tracing::info_span!(
            "xv_query_best_size",
            port = ?port,
            vid_w = ?vid_w,
            vid_h = ?vid_h,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            motion = ?motion,
        );
        let request = types::xv::QueryBestSizeRequest {
            port,
            vid_w,
            vid_h,
            drw_w,
            drw_h,
            motion,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_query_best_size_immediate<'this>(
        &'this mut self,
        port: types::Port,
        vid_w: types::Card16,
        vid_h: types::Card16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        motion: types::Bool,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xv::QueryBestSizeReply>> {
        let cookie = self.xv_query_best_size(port, vid_w, vid_h, drw_w, drw_h, motion);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryBestSizeReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_set_port_attribute<'this>(
        &'this mut self,
        port: types::Port,
        attribute: types::Atom,
        value: types::Int32,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xv_set_port_attribute",
            port = ?port,
            attribute = ?attribute,
            value = ?value,
        );
        let request = types::xv::SetPortAttributeRequest {
            port,
            attribute,
            value,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_set_port_attribute_checked<'this>(
        &'this mut self,
        port: types::Port,
        attribute: types::Atom,
        value: types::Int32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xv_set_port_attribute(port, attribute, value);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_get_port_attribute<'this>(
        &'this mut self,
        port: types::Port,
        attribute: types::Atom,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xv::GetPortAttributeReply>> {
        let span = tracing::info_span!(
            "xv_get_port_attribute",
            port = ?port,
            attribute = ?attribute,
        );
        let request = types::xv::GetPortAttributeRequest { port, attribute };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_get_port_attribute_immediate<'this>(
        &'this mut self,
        port: types::Port,
        attribute: types::Atom,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xv::GetPortAttributeReply>>
    {
        let cookie = self.xv_get_port_attribute(port, attribute);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xv::GetPortAttributeReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_query_port_attributes<'this>(
        &'this mut self,
        port: types::Port,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xv::QueryPortAttributesReply>> {
        let span = tracing::info_span!(
            "xv_query_port_attributes",
            port = ?port,
        );
        let request = types::xv::QueryPortAttributesRequest { port };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_query_port_attributes_immediate<'this>(
        &'this mut self,
        port: types::Port,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xv::QueryPortAttributesReply>>
    {
        let cookie = self.xv_query_port_attributes(port);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryPortAttributesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_list_image_formats<'this>(
        &'this mut self,
        port: types::Port,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xv::ListImageFormatsReply>> {
        let span = tracing::info_span!(
            "xv_list_image_formats",
            port = ?port,
        );
        let request = types::xv::ListImageFormatsRequest { port };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_list_image_formats_immediate<'this>(
        &'this mut self,
        port: types::Port,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xv::ListImageFormatsReply>>
    {
        let cookie = self.xv_list_image_formats(port);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xv::ListImageFormatsReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_query_image_attributes<'this>(
        &'this mut self,
        port: types::Port,
        id: types::Card32,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xv::QueryImageAttributesReply>> {
        let span = tracing::info_span!(
            "xv_query_image_attributes",
            port = ?port,
            id = ?id,
            width = ?width,
            height = ?height,
        );
        let request = types::xv::QueryImageAttributesRequest {
            port,
            id,
            width,
            height,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_query_image_attributes_immediate<'this>(
        &'this mut self,
        port: types::Port,
        id: types::Card32,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xv::QueryImageAttributesReply>>
    {
        let cookie = self.xv_query_image_attributes(port, id, width, height);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xv::QueryImageAttributesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_put_image<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        id: types::Card32,
        src_x: types::Int16,
        src_y: types::Int16,
        src_w: types::Card16,
        src_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        width: types::Card16,
        height: types::Card16,
        data: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xv_put_image",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            id = ?id,
            src_x = ?src_x,
            src_y = ?src_y,
            src_w = ?src_w,
            src_h = ?src_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            width = ?width,
            height = ?height,
        );
        let request = types::xv::PutImageRequest {
            port,
            drawable,
            gc,
            id,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            data: Cow::Borrowed(data.as_ref()),
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_put_image_checked<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        id: types::Card32,
        src_x: types::Int16,
        src_y: types::Int16,
        src_w: types::Card16,
        src_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        width: types::Card16,
        height: types::Card16,
        data: impl AsRef<[types::Card8]>,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xv_put_image(
            port, drawable, gc, id, src_x, src_y, src_w, src_h, drw_x, drw_y, drw_w, drw_h, width,
            height, data,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_shm_put_image<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        shmseg: types::Seg,
        id: types::Card32,
        offset: types::Card32,
        src_x: types::Int16,
        src_y: types::Int16,
        src_w: types::Card16,
        src_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        width: types::Card16,
        height: types::Card16,
        send_event: types::Card8,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xv_shm_put_image",
            port = ?port,
            drawable = ?drawable,
            gc = ?gc,
            shmseg = ?shmseg,
            id = ?id,
            offset = ?offset,
            src_x = ?src_x,
            src_y = ?src_y,
            src_w = ?src_w,
            src_h = ?src_h,
            drw_x = ?drw_x,
            drw_y = ?drw_y,
            drw_w = ?drw_w,
            drw_h = ?drw_h,
            width = ?width,
            height = ?height,
            send_event = ?send_event,
        );
        let request = types::xv::ShmPutImageRequest {
            port,
            drawable,
            gc,
            shmseg,
            id,
            offset,
            src_x,
            src_y,
            src_w,
            src_h,
            drw_x,
            drw_y,
            drw_w,
            drw_h,
            width,
            height,
            send_event,
        };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xv")]
    fn xv_shm_put_image_checked<'this>(
        &'this mut self,
        port: types::Port,
        drawable: types::xproto::Drawable,
        gc: types::Gcontext,
        shmseg: types::Seg,
        id: types::Card32,
        offset: types::Card32,
        src_x: types::Int16,
        src_y: types::Int16,
        src_w: types::Card16,
        src_h: types::Card16,
        drw_x: types::Int16,
        drw_y: types::Int16,
        drw_w: types::Card16,
        drw_h: types::Card16,
        width: types::Card16,
        height: types::Card16,
        send_event: types::Card8,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xv_shm_put_image(
            port, drawable, gc, shmseg, id, offset, src_x, src_y, src_w, src_h, drw_x, drw_y,
            drw_w, drw_h, width, height, send_event,
        );
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }

    #[cfg(feature = "xvmc")]
    fn xvmc_query_version<'this>(
        &'this mut self,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xvmc::QueryVersionReply>> {
        let span = tracing::info_span!("xvmc_query_version",);
        let request = types::xvmc::QueryVersionRequest {};
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_query_version_immediate<'this>(
        &'this mut self,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xvmc::QueryVersionReply>>
    {
        let cookie = self.xvmc_query_version();
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::QueryVersionReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_surface_types<'this>(
        &'this mut self,
        port_id: types::Port,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xvmc::ListSurfaceTypesReply>> {
        let span = tracing::info_span!(
            "xvmc_list_surface_types",
            port_id = ?port_id,
        );
        let request = types::xvmc::ListSurfaceTypesRequest { port_id };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_surface_types_immediate<'this>(
        &'this mut self,
        port_id: types::Port,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xvmc::ListSurfaceTypesReply>>
    {
        let cookie = self.xvmc_list_surface_types(port_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::ListSurfaceTypesReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_context<'this>(
        &'this mut self,
        context_id: types::xvmc::Context,
        port_id: types::Port,
        surface_id: types::Surface,
        width: types::Card16,
        height: types::Card16,
        flags: types::Card32,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xvmc::CreateContextReply>> {
        let span = tracing::info_span!(
            "xvmc_create_context",
            context_id = ?context_id,
            port_id = ?port_id,
            surface_id = ?surface_id,
            width = ?width,
            height = ?height,
            flags = ?flags,
        );
        let request = types::xvmc::CreateContextRequest {
            context_id,
            port_id,
            surface_id,
            width,
            height,
            flags,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_context_immediate<'this>(
        &'this mut self,
        context_id: types::xvmc::Context,
        port_id: types::Port,
        surface_id: types::Surface,
        width: types::Card16,
        height: types::Card16,
        flags: types::Card32,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xvmc::CreateContextReply>>
    {
        let cookie =
            self.xvmc_create_context(context_id, port_id, surface_id, width, height, flags);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::CreateContextReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_context<'this>(
        &'this mut self,
        context_id: types::xvmc::Context,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xvmc_destroy_context",
            context_id = ?context_id,
        );
        let request = types::xvmc::DestroyContextRequest { context_id };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_context_checked<'this>(
        &'this mut self,
        context_id: types::xvmc::Context,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xvmc_destroy_context(context_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_surface<'this>(
        &'this mut self,
        surface_id: types::Surface,
        context_id: types::xvmc::Context,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xvmc::CreateSurfaceReply>> {
        let span = tracing::info_span!(
            "xvmc_create_surface",
            surface_id = ?surface_id,
            context_id = ?context_id,
        );
        let request = types::xvmc::CreateSurfaceRequest {
            surface_id,
            context_id,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_surface_immediate<'this>(
        &'this mut self,
        surface_id: types::Surface,
        context_id: types::xvmc::Context,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xvmc::CreateSurfaceReply>>
    {
        let cookie = self.xvmc_create_surface(surface_id, context_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::CreateSurfaceReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_surface<'this>(
        &'this mut self,
        surface_id: types::Surface,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xvmc_destroy_surface",
            surface_id = ?surface_id,
        );
        let request = types::xvmc::DestroySurfaceRequest { surface_id };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_surface_checked<'this>(
        &'this mut self,
        surface_id: types::Surface,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xvmc_destroy_surface(surface_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_subpicture<'this>(
        &'this mut self,
        subpicture_id: types::Subpicture,
        context: types::xvmc::Context,
        xvimage_id: types::Card32,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xvmc::CreateSubpictureReply>> {
        let span = tracing::info_span!(
            "xvmc_create_subpicture",
            subpicture_id = ?subpicture_id,
            context = ?context,
            xvimage_id = ?xvimage_id,
            width = ?width,
            height = ?height,
        );
        let request = types::xvmc::CreateSubpictureRequest {
            subpicture_id,
            context,
            xvimage_id,
            width,
            height,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_create_subpicture_immediate<'this>(
        &'this mut self,
        subpicture_id: types::Subpicture,
        context: types::xvmc::Context,
        xvimage_id: types::Card32,
        width: types::Card16,
        height: types::Card16,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xvmc::CreateSubpictureReply>>
    {
        let cookie = self.xvmc_create_subpicture(subpicture_id, context, xvimage_id, width, height);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::CreateSubpictureReply> =
            cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_subpicture<'this>(
        &'this mut self,
        subpicture_id: types::Subpicture,
    ) -> Instrumented<futures::SendRequest<'this, Self, ()>> {
        let span = tracing::info_span!(
            "xvmc_destroy_subpicture",
            subpicture_id = ?subpicture_id,
        );
        let request = types::xvmc::DestroySubpictureRequest { subpicture_id };
        self.send_void_request(request).instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_destroy_subpicture_checked<'this>(
        &'this mut self,
        subpicture_id: types::Subpicture,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, ()>> {
        let cookie = self.xvmc_destroy_subpicture(subpicture_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, ()> = cookie.into();
        res.instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_subpicture_types<'this>(
        &'this mut self,
        port_id: types::Port,
        surface_id: types::Surface,
    ) -> Instrumented<futures::SendRequest<'this, Self, types::xvmc::ListSubpictureTypesReply>>
    {
        let span = tracing::info_span!(
            "xvmc_list_subpicture_types",
            port_id = ?port_id,
            surface_id = ?surface_id,
        );
        let request = types::xvmc::ListSubpictureTypesRequest {
            port_id,
            surface_id,
        };
        self.send_reply_request(request).instrument(span)
    }
    #[cfg(feature = "xvmc")]
    fn xvmc_list_subpicture_types_immediate<'this>(
        &'this mut self,
        port_id: types::Port,
        surface_id: types::Surface,
    ) -> Instrumented<futures::CheckedSendRequest<'this, Self, types::xvmc::ListSubpictureTypesReply>>
    {
        let cookie = self.xvmc_list_subpicture_types(port_id, surface_id);
        let span = cookie.span().clone();
        let cookie = cookie.into_inner();
        let res: futures::CheckedSendRequest<'this, Self, types::xvmc::ListSubpictureTypesReply> =
            cookie.into();
        res.instrument(span)
    }
}

impl<D: Display + ?Sized> DisplayFunctionsExt for D {}

#[cfg(feature = "async")]
impl<D: AsyncDisplay + ?Sized> AsyncDisplayFunctionsExt for D {}

mod __private {
    use crate::display::Display;

    pub trait Sealed {
        fn __sealed_trait_marker() {}
    }

    impl<D: Display + ?Sized> Sealed for D {}

    cfg_async! {
        use crate::display::AsyncDisplay;

        pub trait Sealed2 {
            fn __sealed_trait_marker() {}
        }

        impl<D: AsyncDisplay + ?Sized> Sealed2 for D {}
    }
}

#[allow(dead_code, unused_imports)]
mod types {
    pub(crate) type Card8 = u8;
    pub(crate) type Card16 = u16;
    pub(crate) type Card32 = u32;
    pub(crate) type Card64 = u64;
    pub(crate) type Bool = bool;
    pub(crate) type Char = u8;
    pub(crate) type Byte = u8;
    pub(crate) type Int8 = i8;
    pub(crate) type Int16 = i16;
    pub(crate) type Int32 = i32;
    pub(crate) type Float = f32;
    pub(crate) type Double = f64;
    pub(crate) type Void = u8;

    pub(crate) use crate::protocol::bigreq::{self, *};
    #[cfg(feature = "composite")]
    pub(crate) use crate::protocol::composite::{self, *};
    #[cfg(feature = "damage")]
    pub(crate) use crate::protocol::damage::{self, *};
    #[cfg(feature = "dpms")]
    pub(crate) use crate::protocol::dpms::{self, *};
    #[cfg(feature = "dri2")]
    pub(crate) use crate::protocol::dri2::{self, *};
    #[cfg(feature = "dri3")]
    pub(crate) use crate::protocol::dri3::{self, *};
    pub(crate) use crate::protocol::ge::{self, *};
    #[cfg(feature = "glx")]
    pub(crate) use crate::protocol::glx::{self, *};
    #[cfg(feature = "present")]
    pub(crate) use crate::protocol::present::{self, *};
    #[cfg(feature = "randr")]
    pub(crate) use crate::protocol::randr::{self, *};
    #[cfg(feature = "record")]
    pub(crate) use crate::protocol::record::{self, *};
    #[cfg(feature = "render")]
    pub(crate) use crate::protocol::render::{self, *};
    #[cfg(feature = "res")]
    pub(crate) use crate::protocol::res::{self, *};
    #[cfg(feature = "screensaver")]
    pub(crate) use crate::protocol::screensaver::{self, *};
    #[cfg(feature = "shape")]
    pub(crate) use crate::protocol::shape::{self, *};
    #[cfg(feature = "shm")]
    pub(crate) use crate::protocol::shm::{self, *};
    #[cfg(feature = "sync")]
    pub(crate) use crate::protocol::sync::{self, *};
    pub(crate) use crate::protocol::xc_misc::{self, *};
    #[cfg(feature = "xevie")]
    pub(crate) use crate::protocol::xevie::{self, *};
    #[cfg(feature = "xf86dri")]
    pub(crate) use crate::protocol::xf86dri::{self, *};
    #[cfg(feature = "xf86vidmode")]
    pub(crate) use crate::protocol::xf86vidmode::{self, *};
    #[cfg(feature = "xfixes")]
    pub(crate) use crate::protocol::xfixes::{self, *};
    #[cfg(feature = "xinerama")]
    pub(crate) use crate::protocol::xinerama::{self, *};
    #[cfg(feature = "xinput")]
    pub(crate) use crate::protocol::xinput::{self, *};
    #[cfg(feature = "xkb")]
    pub(crate) use crate::protocol::xkb::{self, *};
    #[cfg(feature = "xprint")]
    pub(crate) use crate::protocol::xprint::{self, *};
    pub(crate) use crate::protocol::xproto::{self, *};
    #[cfg(feature = "xselinux")]
    pub(crate) use crate::protocol::xselinux::{self, *};
    #[cfg(feature = "xtest")]
    pub(crate) use crate::protocol::xtest::{self, *};
    #[cfg(feature = "xv")]
    pub(crate) use crate::protocol::xv::{self, *};
    #[cfg(feature = "xvmc")]
    pub(crate) use crate::protocol::xvmc::{self, *};
    pub(crate) use crate::Fd;
}
